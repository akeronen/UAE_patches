diff -crB --new-file ./uae-0.8.21/config.cache ../uae_jit_cleaning/uae-0.8.21/config.cache
*** ./uae-0.8.21/config.cache	1970-01-01 02:00:00.000000000 +0200
--- ../uae_jit_cleaning/uae-0.8.21/config.cache	2021-01-10 13:14:36.778591684 +0200
***************
*** 0 ****
--- 1,154 ----
+ # This file is a shell script that caches the results of configure
+ # tests run on this system so they can be shared between configure
+ # scripts and configure runs.  It is not useful on other systems.
+ # If it contains results you don't want to keep, you may remove or edit it.
+ #
+ # By default, configure uses ./config.cache as the cache file,
+ # creating it if it does not exist already.  You can give configure
+ # the --cache-file=FILE option to use a different cache file; that is
+ # what configure does when it calls configure scripts in
+ # subdirectories, so they share the cache.
+ # Giving --cache-file=/dev/null disables caching, for debugging configure.
+ # config.status only pays attention to the cache file if you give it the
+ # --recheck option to rerun configure.
+ #
+ ac_cv_c_const=${ac_cv_c_const='yes'}
+ ac_cv_c_inline=${ac_cv_c_inline='inline'}
+ ac_cv_func_bcopy=${ac_cv_func_bcopy='yes'}
+ ac_cv_func_cfmakeraw=${ac_cv_func_cfmakeraw='yes'}
+ ac_cv_func_connect=${ac_cv_func_connect='yes'}
+ ac_cv_func_endgrent=${ac_cv_func_endgrent='yes'}
+ ac_cv_func_endpwent=${ac_cv_func_endpwent='yes'}
+ ac_cv_func_fchdir=${ac_cv_func_fchdir='yes'}
+ ac_cv_func_ftime=${ac_cv_func_ftime='yes'}
+ ac_cv_func_ftruncate=${ac_cv_func_ftruncate='yes'}
+ ac_cv_func_getcwd=${ac_cv_func_getcwd='yes'}
+ ac_cv_func_gethostbyname=${ac_cv_func_gethostbyname='yes'}
+ ac_cv_func_getmntent=${ac_cv_func_getmntent='yes'}
+ ac_cv_func_getmntinfo=${ac_cv_func_getmntinfo='no'}
+ ac_cv_func_getopt=${ac_cv_func_getopt='yes'}
+ ac_cv_func_gettimeofday=${ac_cv_func_gettimeofday='yes'}
+ ac_cv_func_isascii=${ac_cv_func_isascii='yes'}
+ ac_cv_func_isinf=${ac_cv_func_isinf='yes'}
+ ac_cv_func_isnan=${ac_cv_func_isnan='yes'}
+ ac_cv_func_lchown=${ac_cv_func_lchown='yes'}
+ ac_cv_func_listmntent=${ac_cv_func_listmntent='no'}
+ ac_cv_func_memcmp_clean=${ac_cv_func_memcmp_clean='yes'}
+ ac_cv_func_memcpy=${ac_cv_func_memcpy='yes'}
+ ac_cv_func_mkdir=${ac_cv_func_mkdir='yes'}
+ ac_cv_func_mkfifo=${ac_cv_func_mkfifo='yes'}
+ ac_cv_func_readdir_r=${ac_cv_func_readdir_r='yes'}
+ ac_cv_func_remove=${ac_cv_func_remove='yes'}
+ ac_cv_func_rmdir=${ac_cv_func_rmdir='yes'}
+ ac_cv_func_select=${ac_cv_func_select='yes'}
+ ac_cv_func_setitimer=${ac_cv_func_setitimer='yes'}
+ ac_cv_func_shmat=${ac_cv_func_shmat='yes'}
+ ac_cv_func_sigaction=${ac_cv_func_sigaction='yes'}
+ ac_cv_func_strchr=${ac_cv_func_strchr='yes'}
+ ac_cv_func_strdup=${ac_cv_func_strdup='yes'}
+ ac_cv_func_strerror=${ac_cv_func_strerror='yes'}
+ ac_cv_func_strrchr=${ac_cv_func_strrchr='yes'}
+ ac_cv_func_strstr=${ac_cv_func_strstr='yes'}
+ ac_cv_func_tcgetattr=${ac_cv_func_tcgetattr='yes'}
+ ac_cv_func_utime_null=${ac_cv_func_utime_null='yes'}
+ ac_cv_func_vfprintf=${ac_cv_func_vfprintf='yes'}
+ ac_cv_func_vprintf=${ac_cv_func_vprintf='yes'}
+ ac_cv_func_vsprintf=${ac_cv_func_vsprintf='yes'}
+ ac_cv_have_x=${ac_cv_have_x='have_x=yes 		ac_x_includes= ac_x_libraries='}
+ ac_cv_header_be_math_h=${ac_cv_header_be_math_h='no'}
+ ac_cv_header_curses_h=${ac_cv_header_curses_h='yes'}
+ ac_cv_header_cybergraphx_cybergraphics_h=${ac_cv_header_cybergraphx_cybergraphics_h='no'}
+ ac_cv_header_ddraw_h=${ac_cv_header_ddraw_h='no'}
+ ac_cv_header_devices_ahi_h=${ac_cv_header_devices_ahi_h='no'}
+ ac_cv_header_dirent_dirent_h=${ac_cv_header_dirent_dirent_h='yes'}
+ ac_cv_header_dmedia_audio_h=${ac_cv_header_dmedia_audio_h='no'}
+ ac_cv_header_fcntl_h=${ac_cv_header_fcntl_h='yes'}
+ ac_cv_header_features_h=${ac_cv_header_features_h='yes'}
+ ac_cv_header_getopt_h=${ac_cv_header_getopt_h='yes'}
+ ac_cv_header_libraries_cybergraphics_h=${ac_cv_header_libraries_cybergraphics_h='no'}
+ ac_cv_header_machine_joystick_h=${ac_cv_header_machine_joystick_h='no'}
+ ac_cv_header_machine_soundcard_h=${ac_cv_header_machine_soundcard_h='no'}
+ ac_cv_header_mntent_h=${ac_cv_header_mntent_h='yes'}
+ ac_cv_header_mnttab_h=${ac_cv_header_mnttab_h='no'}
+ ac_cv_header_ncurses_h=${ac_cv_header_ncurses_h='yes'}
+ ac_cv_header_posix_opt_h=${ac_cv_header_posix_opt_h='no'}
+ ac_cv_header_stdc=${ac_cv_header_stdc='yes'}
+ ac_cv_header_string_h=${ac_cv_header_string_h='yes'}
+ ac_cv_header_strings_h=${ac_cv_header_strings_h='yes'}
+ ac_cv_header_sun_audioio_h=${ac_cv_header_sun_audioio_h='no'}
+ ac_cv_header_sys_audioio_h=${ac_cv_header_sys_audioio_h='no'}
+ ac_cv_header_sys_filsys_h=${ac_cv_header_sys_filsys_h='no'}
+ ac_cv_header_sys_fs_s5param_h=${ac_cv_header_sys_fs_s5param_h='no'}
+ ac_cv_header_sys_fs_types_h=${ac_cv_header_sys_fs_types_h='no'}
+ ac_cv_header_sys_fstyp_h=${ac_cv_header_sys_fstyp_h='no'}
+ ac_cv_header_sys_ioctl_h=${ac_cv_header_sys_ioctl_h='yes'}
+ ac_cv_header_sys_ipc_h=${ac_cv_header_sys_ipc_h='yes'}
+ ac_cv_header_sys_mount_h=${ac_cv_header_sys_mount_h='yes'}
+ ac_cv_header_sys_param_h=${ac_cv_header_sys_param_h='yes'}
+ ac_cv_header_sys_shm_h=${ac_cv_header_sys_shm_h='yes'}
+ ac_cv_header_sys_soundcard_h=${ac_cv_header_sys_soundcard_h='yes'}
+ ac_cv_header_sys_stat_h=${ac_cv_header_sys_stat_h='yes'}
+ ac_cv_header_sys_statfs_h=${ac_cv_header_sys_statfs_h='yes'}
+ ac_cv_header_sys_statvfs_h=${ac_cv_header_sys_statvfs_h='yes'}
+ ac_cv_header_sys_termios_h=${ac_cv_header_sys_termios_h='yes'}
+ ac_cv_header_sys_time_h=${ac_cv_header_sys_time_h='yes'}
+ ac_cv_header_sys_types_h=${ac_cv_header_sys_types_h='yes'}
+ ac_cv_header_sys_utime_h=${ac_cv_header_sys_utime_h='no'}
+ ac_cv_header_sys_vfs_h=${ac_cv_header_sys_vfs_h='yes'}
+ ac_cv_header_time=${ac_cv_header_time='yes'}
+ ac_cv_header_unistd_h=${ac_cv_header_unistd_h='yes'}
+ ac_cv_header_utime_h=${ac_cv_header_utime_h='yes'}
+ ac_cv_header_values_h=${ac_cv_header_values_h='yes'}
+ ac_cv_header_windows_h=${ac_cv_header_windows_h='no'}
+ ac_cv_lib_AF_AFOpenAudioConn=${ac_cv_lib_AF_AFOpenAudioConn='no'}
+ ac_cv_lib_ICE_IceConnectionNumber=${ac_cv_lib_ICE_IceConnectionNumber='yes'}
+ ac_cv_lib_Media_s_main=${ac_cv_lib_Media_s_main='no'}
+ ac_cv_lib_NeXT_s_main=${ac_cv_lib_NeXT_s_main='no'}
+ ac_cv_lib_amiga_OpenLibrary=${ac_cv_lib_amiga_OpenLibrary='no'}
+ ac_cv_lib_audio_alOpenPort=${ac_cv_lib_audio_alOpenPort='no'}
+ ac_cv_lib_dir_opendir=${ac_cv_lib_dir_opendir='no'}
+ ac_cv_lib_dnet_dnet_ntoa=${ac_cv_lib_dnet_dnet_ntoa='no'}
+ ac_cv_lib_dnet_stub_dnet_ntoa=${ac_cv_lib_dnet_stub_dnet_ntoa='no'}
+ ac_cv_lib_gen_getmntent=${ac_cv_lib_gen_getmntent='no'}
+ ac_cv_lib_mme_waveOutGetNumDevs=${ac_cv_lib_mme_waveOutGetNumDevs='no'}
+ ac_cv_lib_moto_cos=${ac_cv_lib_moto_cos='no'}
+ ac_cv_lib_ncurses_waddch=${ac_cv_lib_ncurses_waddch='yes'}
+ ac_cv_lib_posix4_sem_init=${ac_cv_lib_posix4_sem_init='no'}
+ ac_cv_lib_rt_sem_init=${ac_cv_lib_rt_sem_init='no'}
+ ac_cv_lib_seq_getmntent=${ac_cv_lib_seq_getmntent='no'}
+ ac_cv_lib_sun_getmntent=${ac_cv_lib_sun_getmntent='no'}
+ ac_cv_lib_vga_vga_setmode=${ac_cv_lib_vga_vga_setmode='no'}
+ ac_cv_path_FILEPRG=${ac_cv_path_FILEPRG='/usr/bin/file'}
+ ac_cv_path_GTK_CONFIG=${ac_cv_path_GTK_CONFIG='no'}
+ ac_cv_path_MAKEDEPPRG=${ac_cv_path_MAKEDEPPRG='not-found'}
+ ac_cv_path_RCLPRG=${ac_cv_path_RCLPRG='not-found'}
+ ac_cv_path_SDL_CONFIG=${ac_cv_path_SDL_CONFIG='/usr/local/bin/sdl-config'}
+ ac_cv_path_WRCPRG=${ac_cv_path_WRCPRG='not-found'}
+ ac_cv_prog_CC=${ac_cv_prog_CC='gcc'}
+ ac_cv_prog_CPP=${ac_cv_prog_CPP='gcc -E'}
+ ac_cv_prog_cc_cross=${ac_cv_prog_cc_cross='no'}
+ ac_cv_prog_cc_g=${ac_cv_prog_cc_g='yes'}
+ ac_cv_prog_cc_works=${ac_cv_prog_cc_works='yes'}
+ ac_cv_prog_gcc=${ac_cv_prog_gcc='yes'}
+ ac_cv_prog_gcc_traditional=${ac_cv_prog_gcc_traditional='no'}
+ ac_cv_prog_make_make_set=${ac_cv_prog_make_make_set='yes'}
+ ac_cv_sizeof___int64=${ac_cv_sizeof___int64='0'}
+ ac_cv_sizeof_char=${ac_cv_sizeof_char='1'}
+ ac_cv_sizeof_int=${ac_cv_sizeof_int='4'}
+ ac_cv_sizeof_long=${ac_cv_sizeof_long='4'}
+ ac_cv_sizeof_long_long=${ac_cv_sizeof_long_long='8'}
+ ac_cv_sizeof_short=${ac_cv_sizeof_short='2'}
+ ac_cv_struct_st_blocks=${ac_cv_struct_st_blocks='yes'}
+ ac_cv_struct_tm=${ac_cv_struct_tm='time.h'}
+ ac_cv_type_mode_t=${ac_cv_type_mode_t='yes'}
+ ac_cv_type_off_t=${ac_cv_type_off_t='yes'}
+ ac_cv_type_pid_t=${ac_cv_type_pid_t='yes'}
+ ac_cv_type_signal=${ac_cv_type_signal='void'}
+ am_cv_cygwin32=${am_cv_cygwin32='no'}
+ am_cv_exeext=${am_cv_exeext='no'}
+ am_cv_mingw32=${am_cv_mingw32='no'}
+ fu_cv_sys_mounted_cray_listmntent=${fu_cv_sys_mounted_cray_listmntent='no'}
+ fu_cv_sys_mounted_getmntent1=${fu_cv_sys_mounted_getmntent1='yes'}
+ fu_cv_sys_stat_statvfs=${fu_cv_sys_stat_statvfs='yes'}
+ fu_cv_sys_truncating_statfs=${fu_cv_sys_truncating_statfs='no'}
+ uae_cv_prog_cc_watcom=${uae_cv_prog_cc_watcom='no'}
diff -crB --new-file ./uae-0.8.21/config.log ../uae_jit_cleaning/uae-0.8.21/config.log
*** ./uae-0.8.21/config.log	1970-01-01 02:00:00.000000000 +0200
--- ../uae_jit_cleaning/uae-0.8.21/config.log	2021-01-10 13:53:59.710591684 +0200
***************
*** 0 ****
--- 1,215 ----
+ This file contains any messages produced by compilers while
+ running configure, to aid debugging if configure makes a mistake.
+ 
+ configure:566: checking for gcc
+ configure:679: checking whether the C compiler (gcc  ) works
+ configure:695: gcc -o conftest    conftest.c  1>&5
+ configure:721: checking whether the C compiler (gcc  ) is a cross-compiler
+ configure:726: checking whether we are using GNU C
+ configure:754: checking whether gcc accepts -g
+ configure:787: checking how to run the C preprocessor
+ configure:867: checking whether make sets ${MAKE}
+ configure:896: checking for makedepend
+ configure:932: checking for file
+ configure:968: checking for wrc
+ configure:1004: checking for rcl
+ configure:1040: checking for sdl-config
+ configure:1075: checking for AIX
+ configure:1099: checking for POSIXized ISC
+ configure:1121: checking for Watcom C
+ configure:1143: checking for Cygwin32 environment
+ configure:1172: checking for Mingw32 environment
+ configure:1203: checking for executable suffix
+ configure:1247: checking for main in -lMedia_s
+ configure:1284: checking for main in -lNeXT_s
+ configure:1321: checking for cos in -lmoto
+ configure:1362: checking for OpenLibrary in -lamiga
+ configure:1403: checking for vga_setmode in -lvga
+ configure:1444: checking for AFOpenAudioConn in -lAF
+ configure:1485: checking for waveOutGetNumDevs in -lmme
+ configure:1526: checking for waddch in -lncurses
+ configure:1567: checking for sem_init in -lposix4
+ configure:1608: checking for sem_init in -lrt
+ configure:1649: checking for alOpenPort in -laudio
+ configure:1695: checking for X
+ configure:2009: checking for dnet_ntoa in -ldnet
+ configure:2050: checking for dnet_ntoa in -ldnet_stub
+ configure:2098: checking for gethostbyname
+ configure:2196: checking for connect
+ configure:2288: checking for remove
+ configure:2380: checking for shmat
+ configure:2481: checking for IceConnectionNumber in -lICE
+ configure:2531: checking for dirent.h that defines DIR
+ configure:2569: checking for opendir in -ldir
+ configure:2652: checking for ANSI C header files
+ configure:2760: checking for unistd.h
+ configure:2760: checking for fcntl.h
+ configure:2760: checking for sys/time.h
+ configure:2760: checking for sys/types.h
+ configure:2760: checking for utime.h
+ configure:2760: checking for string.h
+ configure:2760: checking for strings.h
+ configure:2760: checking for values.h
+ configure:2760: checking for ncurses.h
+ configure:2760: checking for curses.h
+ configure:2800: checking for sys/soundcard.h
+ configure:2800: checking for machine/soundcard.h
+ configure:2800: checking for sun/audioio.h
+ configure:2800: checking for sys/audioio.h
+ configure:2800: checking for getopt.h
+ configure:2800: checking for features.h
+ configure:2800: checking for sys/termios.h
+ configure:2840: checking for posix_opt.h
+ configure:2840: checking for sys/ioctl.h
+ configure:2840: checking for sys/ipc.h
+ configure:2840: checking for sys/shm.h
+ configure:2840: checking for sys/stat.h
+ configure:2840: checking for sys/utime.h
+ configure:2880: checking for windows.h
+ configure:2880: checking for ddraw.h
+ configure:2918: checking for be_math.h
+ configure:2954: checking for machine/joystick.h
+ configure:2994: checking for devices/ahi.h
+ configure:3034: checking for dmedia/audio.h
+ configure:3074: checking for libraries/cybergraphics.h
+ configure:3074: checking for cybergraphx/cybergraphics.h
+ configure:3112: checking size of char
+ configure:3151: checking size of short
+ configure:3190: checking size of int
+ configure:3229: checking size of long
+ configure:3268: checking size of long long
+ configure:3307: checking size of __int64
+ configure:3347: checking for working const
+ configure:3422: checking for inline
+ configure:3465: checking for mode_t
+ configure:3498: checking for off_t
+ configure:3531: checking for pid_t
+ configure:3564: checking for st_blocks in struct stat
+ configure:3600: checking whether time.h and sys/time.h may both be included
+ configure:3635: checking whether struct tm is in sys/time.h or time.h
+ configure:3671: checking whether gcc needs -traditional
+ configure:3717: checking for 8-bit clean memcmp
+ configure:3753: checking return type of signal handlers
+ configure:3794: checking whether utime accepts a null argument
+ configure:3841: checking for getcwd
+ configure:3841: checking for getopt
+ configure:3841: checking for strdup
+ configure:3841: checking for gettimeofday
+ configure:3841: checking for sigaction
+ configure:3841: checking for mkdir
+ configure:3841: checking for rmdir
+ configure:3896: checking for select
+ configure:3896: checking for strerror
+ configure:3896: checking for strstr
+ configure:3896: checking for isnan
+ configure:3896: checking for isinf
+ configure:3896: checking for setitimer
+ configure:3951: checking for tcgetattr
+ configure:3951: checking for cfmakeraw
+ configure:3951: checking for readdir_r
+ configure:3951: checking for vprintf
+ configure:3951: checking for vsprintf
+ configure:3951: checking for vfprintf
+ configure:4016: checking for fcntl.h
+ configure:4016: checking for sys/param.h
+ configure:4016: checking for sys/statfs.h
+ configure:4016: checking for sys/fstyp.h
+ configure:4016: checking for mnttab.h
+ configure:4016: checking for mntent.h
+ configure:4016: checking for sys/statvfs.h
+ configure:4016: checking for sys/vfs.h
+ configure:4016: checking for sys/mount.h
+ configure:4016: checking for sys/filsys.h
+ configure:4016: checking for sys/fs_types.h
+ configure:4016: checking for sys/fs/s5param.h
+ configure:4058: checking for bcopy
+ configure:4058: checking for endgrent
+ configure:4058: checking for endpwent
+ configure:4058: checking for fchdir
+ configure:4058: checking for ftime
+ configure:4058: checking for ftruncate
+ configure:4058: checking for getcwd
+ configure:4058: checking for getmntinfo
+ configure:4058: checking for gettimeofday
+ configure:4058: checking for isascii
+ configure:4058: checking for lchown
+ configure:4058: checking for listmntent
+ configure:4058: checking for memcpy
+ configure:4058: checking for mkfifo
+ configure:4058: checking for strchr
+ configure:4058: checking for strerror
+ configure:4058: checking for strrchr
+ configure:4118: checking for getmntent in -lsun
+ configure:4156: checking for getmntent in -lseq
+ configure:4194: checking for getmntent in -lgen
+ configure:4238: checking for getmntent
+ configure:4301: checking for listmntent of Cray/Unicos-9
+ configure:4345: checking for one-argument getmntent function
+ configure:4650: checking how to get filesystem space usage
+ configure:4662: checking statvfs function (SVR4)
+ configure:4983: checking for ftruncate
+ configure:5085: checking for statfs that truncates block counts
+ configure:5123: checking for AFS
+ configure:5135: checking for pOS
+ configure:5200: checking for attr_t in ncurses.h
+ configure:5209: gcc -c -g -O2  conftest.c 1>&5
+ configure:5229: checking for pthread library
+ configure:5248: gcc -o conftest -g -O2   -L. conftest.c  -lpthread 1>&5
+ In file included from /usr/include/sys/types.h:270,
+                  from configure:5238:
+ /usr/include/bits/pthreadtypes.h:123: warning: unnamed struct/union that defines no instances
+ configure:5264: checking for DirectX
+ configure:5286: gcc -o conftest -g -O2    -L. conftest.c  -lddraw 1>&5
+ configure:5276: windows.h: No such file or directory
+ configure:5277: ddraw.h: No such file or directory
+ configure: failed program was:
+ #line 5270 "configure"
+ #include "confdefs.h"
+ 
+ #include "confdefs.h"
+ #ifdef HAVE_SYS_TYPES_H
+ #include <sys/types.h>
+ #endif
+ #include <windows.h>
+ #include <ddraw.h>
+ int main() {
+ 
+ LPDIRECTDRAW lpDD;
+ IDirectDraw_CreateSurface(lpDD, 0, 0, 0);
+ 
+ ; return 0; }
+ configure:5597: checking for gtk-config
+ configure:5632: checking for GTK - version >= 0.99.7
+ configure:5805: checking whether the X11 MIT-SHM extension can be compiled in
+ configure:5835: gcc -o conftest -g -O2    -L. conftest.c    -lSM -lICE -lX11 -lXext  1>&5
+ In file included from /usr/include/sys/types.h:270,
+                  from configure:5815:
+ /usr/include/bits/pthreadtypes.h:123: warning: unnamed struct/union that defines no instances
+ configure:5855: checking which target to use
+ configure:6044: checking for GCC 2.7 or higher
+ configure:6077: checking for glibc-2.0 or higher
+ configure:6126: checking for x86 target CPU
+ configure:6148: checking for m68k target CPU
+ configure:6170: checking for ppc target CPU
+ configure:6201: checking whether assembler symbols need an underscore
+ configure:6245: gcc -c -O2 -fomit-frame-pointer  -Wall -Wno-unused -Wno-format -W -Wmissing-prototypes -Wstrict-prototypes   -DJIT -DNATMEM_OFFSET=0x50000000 -DGCCCONSTFUNC="__attribute__((const))" -mno-schedule-prologue  conftest.c 1>&5
+ configure:6240: warning: function declaration isn't a prototype
+ configure: In function `main':
+ configure:6241: warning: function declaration isn't a prototype
+ configure:6241: warning: `main' is normally a non-static function
+ configure:6267: gcc -c -O2 -fomit-frame-pointer  -Wall -Wno-unused -Wno-format -W -Wmissing-prototypes -Wstrict-prototypes   -DJIT -DNATMEM_OFFSET=0x50000000 -DGCCCONSTFUNC="__attribute__((const))" -mpreferred-stack-boundary=2  conftest.c 1>&5
+ configure:6262: warning: function declaration isn't a prototype
+ configure: In function `main':
+ configure:6263: warning: function declaration isn't a prototype
+ configure:6263: warning: `main' is normally a non-static function
+ configure:6291: gcc -c -O2 -fomit-frame-pointer  -Wall -Wno-unused -Wno-format -W -Wmissing-prototypes -Wstrict-prototypes   -DJIT -DNATMEM_OFFSET=0x50000000 -DGCCCONSTFUNC="__attribute__((const))" -mpreferred-stack-boundary=2 -fno-exceptions  conftest.c 1>&5
+ configure:6286: warning: function declaration isn't a prototype
+ configure: In function `main':
+ configure:6287: warning: function declaration isn't a prototype
+ configure:6287: warning: `main' is normally a non-static function
+ configure:6402: checking whether sys/soundcard.h or machine/soundcard.h works
+ configure:6419: gcc -c -O2 -fomit-frame-pointer  -Wall -Wno-unused -Wno-format -W -Wmissing-prototypes -Wstrict-prototypes   -DJIT -DNATMEM_OFFSET=0x50000000 -DGCCCONSTFUNC="__attribute__((const))" -mpreferred-stack-boundary=2 -fno-exceptions -DUNALIGNED_PROFITABLE -fno-strength-reduce -DREGPARAM="__attribute__((regparm(3)))" -DX86_ASSEMBLY -DOPTIMIZED_FLAGS -DUSE_ZFILE  conftest.c 1>&5
+ configure:6414: warning: function declaration isn't a prototype
+ configure: In function `main':
+ configure:6415: warning: `soundfd' might be used uninitialized in this function
+ configure:6437: checking which sound system to use
diff -crB --new-file ./uae-0.8.21/config.status ../uae_jit_cleaning/uae-0.8.21/config.status
*** ./uae-0.8.21/config.status	1970-01-01 02:00:00.000000000 +0200
--- ../uae_jit_cleaning/uae-0.8.21/config.status	2021-01-10 13:54:00.930591684 +0200
***************
*** 0 ****
--- 1,577 ----
+ #! /bin/sh
+ # Generated automatically by configure.
+ # Run this file to recreate the current configuration.
+ # This directory was configured as follows,
+ # on host osboxes:
+ #
+ # ./configure  --enable-jit
+ #
+ # Compiler output produced by configure, useful for debugging
+ # configure, is in ./config.log if it exists.
+ 
+ ac_cs_usage="Usage: ./config.status [--recheck] [--version] [--help]"
+ for ac_option
+ do
+   case "$ac_option" in
+   -recheck | --recheck | --rechec | --reche | --rech | --rec | --re | --r)
+     echo "running ${CONFIG_SHELL-/bin/sh} ./configure  --enable-jit --no-create --no-recursion"
+     exec ${CONFIG_SHELL-/bin/sh} ./configure  --enable-jit --no-create --no-recursion ;;
+   -version | --version | --versio | --versi | --vers | --ver | --ve | --v)
+     echo "./config.status generated by autoconf version 2.13"
+     exit 0 ;;
+   -help | --help | --hel | --he | --h)
+     echo "$ac_cs_usage"; exit 0 ;;
+   *) echo "$ac_cs_usage"; exit 1 ;;
+   esac
+ done
+ 
+ ac_given_srcdir=.
+ 
+ trap 'rm -fr src/Makefile Makefile src/sysconfig.h conftest*; exit 1' 1 2 15
+ 
+ # Protect against being on the right side of a sed subst in config.status.
+ sed 's/%@/@@/; s/@%/@@/; s/%g$/@g/; /@g$/s/[\\&%]/\\&/g;
+  s/@@/%@/; s/@@/@%/; s/@g$/%g/' > conftest.subs <<\CEOF
+ /^[ 	]*VPATH[ 	]*=[^:]*$/d
+ 
+ s%@SHELL@%/bin/sh%g
+ s%@CFLAGS@%-O2 -fomit-frame-pointer  -Wall -Wno-unused -Wno-format -W -Wmissing-prototypes -Wstrict-prototypes   -DJIT -DNATMEM_OFFSET=0x50000000 -DGCCCONSTFUNC="__attribute__((const))" -mpreferred-stack-boundary=2 -fno-exceptions -DUNALIGNED_PROFITABLE -fno-strength-reduce -DREGPARAM="__attribute__((regparm(3)))" -DX86_ASSEMBLY -DOPTIMIZED_FLAGS -DUSE_ZFILE%g
+ s%@CPPFLAGS@%%g
+ s%@CXXFLAGS@%%g
+ s%@FFLAGS@%%g
+ s%@DEFS@%-DHAVE_CONFIG_H%g
+ s%@LDFLAGS@% -L.%g
+ s%@LIBS@%%g
+ s%@exec_prefix@%${prefix}%g
+ s%@prefix@%/usr/local%g
+ s%@program_transform_name@%s,x,x,%g
+ s%@bindir@%${exec_prefix}/bin%g
+ s%@sbindir@%${exec_prefix}/sbin%g
+ s%@libexecdir@%${exec_prefix}/libexec%g
+ s%@datadir@%${prefix}/share%g
+ s%@sysconfdir@%${prefix}/etc%g
+ s%@sharedstatedir@%${prefix}/com%g
+ s%@localstatedir@%${prefix}/var%g
+ s%@libdir@%${exec_prefix}/lib%g
+ s%@includedir@%${prefix}/include%g
+ s%@oldincludedir@%/usr/include%g
+ s%@infodir@%${prefix}/info%g
+ s%@mandir@%${prefix}/man%g
+ s%@CC@%gcc%g
+ s%@CPP@%gcc -E%g
+ s%@SET_MAKE@%%g
+ s%@MAKEDEPPRG@%not-found%g
+ s%@FILEPRG@%/usr/bin/file%g
+ s%@WRCPRG@%not-found%g
+ s%@RCLPRG@%not-found%g
+ s%@SDL_CONFIG@%/usr/local/bin/sdl-config%g
+ s%@EXEEXT@%%g
+ s%@X_CFLAGS@%%g
+ s%@X_PRE_LIBS@% -lSM -lICE%g
+ s%@X_LIBS@%%g
+ s%@X_EXTRA_LIBS@%%g
+ s%@LIBOBJS@% fsusage.o mountlist.o%g
+ s%@GTK_CONFIG@%no%g
+ s%@GTK_CFLAGS@%%g
+ s%@GTK_LIBS@%%g
+ s%@ac_cv_c_inline@%inline%g
+ s%@NO_SCHED_CFLAGS@%-mno-schedule-prologue%g
+ s%@LIBRARIES@%  -lSM -lICE -lXext -lX11 %g
+ s%@TARGET@%x11%g
+ s%@GFXOBJS@%xwin.o nogui.o%g
+ s%@JITOBJS@%compstbl.o compemu.o compemu_support.o compemu_fpp.o cpustbl_nf.o cpufast_nf.o%g
+ s%@JIT_CFLAGS@%%g
+ s%@RESOBJS@%%g
+ s%@ASMOBJS@%md-X86.o%g
+ s%@SCSIOBJS@%scsi-none.o%g
+ s%@CPUOBJS@%cpufast.o%g
+ s%@DEBUGOBJS@%debug.o%g
+ s%@FSDBOBJS@%fsdb_unix.o%g
+ s%@MATHLIB@%-lm%g
+ s%@SHM_SUPPORT_LINKS@%1%g
+ s%@top_srcdir@%%g
+ 
+ CEOF
+ 
+ # Split the substitutions into bite-sized pieces for seds with
+ # small command number limits, like on Digital OSF/1 and HP-UX.
+ ac_max_sed_cmds=90 # Maximum number of lines to put in a sed script.
+ ac_file=1 # Number of current file.
+ ac_beg=1 # First line for current file.
+ ac_end=$ac_max_sed_cmds # Line after last line for current file.
+ ac_more_lines=:
+ ac_sed_cmds=""
+ while $ac_more_lines; do
+   if test $ac_beg -gt 1; then
+     sed "1,${ac_beg}d; ${ac_end}q" conftest.subs > conftest.s$ac_file
+   else
+     sed "${ac_end}q" conftest.subs > conftest.s$ac_file
+   fi
+   if test ! -s conftest.s$ac_file; then
+     ac_more_lines=false
+     rm -f conftest.s$ac_file
+   else
+     if test -z "$ac_sed_cmds"; then
+       ac_sed_cmds="sed -f conftest.s$ac_file"
+     else
+       ac_sed_cmds="$ac_sed_cmds | sed -f conftest.s$ac_file"
+     fi
+     ac_file=`expr $ac_file + 1`
+     ac_beg=$ac_end
+     ac_end=`expr $ac_end + $ac_max_sed_cmds`
+   fi
+ done
+ if test -z "$ac_sed_cmds"; then
+   ac_sed_cmds=cat
+ fi
+ 
+ CONFIG_FILES=${CONFIG_FILES-"src/Makefile Makefile"}
+ for ac_file in .. $CONFIG_FILES; do if test "x$ac_file" != x..; then
+   # Support "outfile[:infile[:infile...]]", defaulting infile="outfile.in".
+   case "$ac_file" in
+   *:*) ac_file_in=`echo "$ac_file"|sed 's%[^:]*:%%'`
+        ac_file=`echo "$ac_file"|sed 's%:.*%%'` ;;
+   *) ac_file_in="${ac_file}.in" ;;
+   esac
+ 
+   # Adjust a relative srcdir, top_srcdir, and INSTALL for subdirectories.
+ 
+   # Remove last slash and all that follows it.  Not all systems have dirname.
+   ac_dir=`echo $ac_file|sed 's%/[^/][^/]*$%%'`
+   if test "$ac_dir" != "$ac_file" && test "$ac_dir" != .; then
+     # The file is in a subdirectory.
+     test ! -d "$ac_dir" && mkdir "$ac_dir"
+     ac_dir_suffix="/`echo $ac_dir|sed 's%^\./%%'`"
+     # A "../" for each directory in $ac_dir_suffix.
+     ac_dots=`echo $ac_dir_suffix|sed 's%/[^/]*%../%g'`
+   else
+     ac_dir_suffix= ac_dots=
+   fi
+ 
+   case "$ac_given_srcdir" in
+   .)  srcdir=.
+       if test -z "$ac_dots"; then top_srcdir=.
+       else top_srcdir=`echo $ac_dots|sed 's%/$%%'`; fi ;;
+   /*) srcdir="$ac_given_srcdir$ac_dir_suffix"; top_srcdir="$ac_given_srcdir" ;;
+   *) # Relative path.
+     srcdir="$ac_dots$ac_given_srcdir$ac_dir_suffix"
+     top_srcdir="$ac_dots$ac_given_srcdir" ;;
+   esac
+ 
+ 
+   echo creating "$ac_file"
+   rm -f "$ac_file"
+   configure_input="Generated automatically from `echo $ac_file_in|sed 's%.*/%%'` by configure."
+   case "$ac_file" in
+   *Makefile*) ac_comsub="1i\\
+ # $configure_input" ;;
+   *) ac_comsub= ;;
+   esac
+ 
+   ac_file_inputs=`echo $ac_file_in|sed -e "s%^%$ac_given_srcdir/%" -e "s%:% $ac_given_srcdir/%g"`
+   sed -e "$ac_comsub
+ s%@configure_input@%$configure_input%g
+ s%@srcdir@%$srcdir%g
+ s%@top_srcdir@%$top_srcdir%g
+ " $ac_file_inputs | (eval "$ac_sed_cmds") > $ac_file
+ fi; done
+ rm -f conftest.s*
+ 
+ # These sed commands are passed to sed as "A NAME B NAME C VALUE D", where
+ # NAME is the cpp macro being defined and VALUE is the value it is being given.
+ #
+ # ac_d sets the value in "#define NAME VALUE" lines.
+ ac_dA='s%^\([ 	]*\)#\([ 	]*define[ 	][ 	]*\)'
+ ac_dB='\([ 	][ 	]*\)[^ 	]*%\1#\2'
+ ac_dC='\3'
+ ac_dD='%g'
+ # ac_u turns "#undef NAME" with trailing blanks into "#define NAME VALUE".
+ ac_uA='s%^\([ 	]*\)#\([ 	]*\)undef\([ 	][ 	]*\)'
+ ac_uB='\([ 	]\)%\1#\2define\3'
+ ac_uC=' '
+ ac_uD='\4%g'
+ # ac_e turns "#undef NAME" without trailing blanks into "#define NAME VALUE".
+ ac_eA='s%^\([ 	]*\)#\([ 	]*\)undef\([ 	][ 	]*\)'
+ ac_eB='$%\1#\2define\3'
+ ac_eC=' '
+ ac_eD='%g'
+ 
+ if test "${CONFIG_HEADERS+set}" != set; then
+   CONFIG_HEADERS="src/sysconfig.h"
+ fi
+ for ac_file in .. $CONFIG_HEADERS; do if test "x$ac_file" != x..; then
+   # Support "outfile[:infile[:infile...]]", defaulting infile="outfile.in".
+   case "$ac_file" in
+   *:*) ac_file_in=`echo "$ac_file"|sed 's%[^:]*:%%'`
+        ac_file=`echo "$ac_file"|sed 's%:.*%%'` ;;
+   *) ac_file_in="${ac_file}.in" ;;
+   esac
+ 
+   echo creating $ac_file
+ 
+   rm -f conftest.frag conftest.in conftest.out
+   ac_file_inputs=`echo $ac_file_in|sed -e "s%^%$ac_given_srcdir/%" -e "s%:% $ac_given_srcdir/%g"`
+   cat $ac_file_inputs > conftest.in
+ 
+   cat > conftest.frag <<CEOF
+ ${ac_dA}HAVE_DIRENT_H${ac_dB}HAVE_DIRENT_H${ac_dC}1${ac_dD}
+ ${ac_uA}HAVE_DIRENT_H${ac_uB}HAVE_DIRENT_H${ac_uC}1${ac_uD}
+ ${ac_eA}HAVE_DIRENT_H${ac_eB}HAVE_DIRENT_H${ac_eC}1${ac_eD}
+ ${ac_dA}STDC_HEADERS${ac_dB}STDC_HEADERS${ac_dC}1${ac_dD}
+ ${ac_uA}STDC_HEADERS${ac_uB}STDC_HEADERS${ac_uC}1${ac_uD}
+ ${ac_eA}STDC_HEADERS${ac_eB}STDC_HEADERS${ac_eC}1${ac_eD}
+ ${ac_dA}HAVE_UNISTD_H${ac_dB}HAVE_UNISTD_H${ac_dC}1${ac_dD}
+ ${ac_uA}HAVE_UNISTD_H${ac_uB}HAVE_UNISTD_H${ac_uC}1${ac_uD}
+ ${ac_eA}HAVE_UNISTD_H${ac_eB}HAVE_UNISTD_H${ac_eC}1${ac_eD}
+ ${ac_dA}HAVE_FCNTL_H${ac_dB}HAVE_FCNTL_H${ac_dC}1${ac_dD}
+ ${ac_uA}HAVE_FCNTL_H${ac_uB}HAVE_FCNTL_H${ac_uC}1${ac_uD}
+ ${ac_eA}HAVE_FCNTL_H${ac_eB}HAVE_FCNTL_H${ac_eC}1${ac_eD}
+ CEOF
+   sed -f conftest.frag conftest.in > conftest.out
+   rm -f conftest.in
+   mv conftest.out conftest.in
+ 
+   cat > conftest.frag <<CEOF
+ ${ac_dA}HAVE_SYS_TIME_H${ac_dB}HAVE_SYS_TIME_H${ac_dC}1${ac_dD}
+ ${ac_uA}HAVE_SYS_TIME_H${ac_uB}HAVE_SYS_TIME_H${ac_uC}1${ac_uD}
+ ${ac_eA}HAVE_SYS_TIME_H${ac_eB}HAVE_SYS_TIME_H${ac_eC}1${ac_eD}
+ ${ac_dA}HAVE_SYS_TYPES_H${ac_dB}HAVE_SYS_TYPES_H${ac_dC}1${ac_dD}
+ ${ac_uA}HAVE_SYS_TYPES_H${ac_uB}HAVE_SYS_TYPES_H${ac_uC}1${ac_uD}
+ ${ac_eA}HAVE_SYS_TYPES_H${ac_eB}HAVE_SYS_TYPES_H${ac_eC}1${ac_eD}
+ ${ac_dA}HAVE_UTIME_H${ac_dB}HAVE_UTIME_H${ac_dC}1${ac_dD}
+ ${ac_uA}HAVE_UTIME_H${ac_uB}HAVE_UTIME_H${ac_uC}1${ac_uD}
+ ${ac_eA}HAVE_UTIME_H${ac_eB}HAVE_UTIME_H${ac_eC}1${ac_eD}
+ ${ac_dA}HAVE_STRING_H${ac_dB}HAVE_STRING_H${ac_dC}1${ac_dD}
+ ${ac_uA}HAVE_STRING_H${ac_uB}HAVE_STRING_H${ac_uC}1${ac_uD}
+ ${ac_eA}HAVE_STRING_H${ac_eB}HAVE_STRING_H${ac_eC}1${ac_eD}
+ CEOF
+   sed -f conftest.frag conftest.in > conftest.out
+   rm -f conftest.in
+   mv conftest.out conftest.in
+ 
+   cat > conftest.frag <<CEOF
+ ${ac_dA}HAVE_STRINGS_H${ac_dB}HAVE_STRINGS_H${ac_dC}1${ac_dD}
+ ${ac_uA}HAVE_STRINGS_H${ac_uB}HAVE_STRINGS_H${ac_uC}1${ac_uD}
+ ${ac_eA}HAVE_STRINGS_H${ac_eB}HAVE_STRINGS_H${ac_eC}1${ac_eD}
+ ${ac_dA}HAVE_VALUES_H${ac_dB}HAVE_VALUES_H${ac_dC}1${ac_dD}
+ ${ac_uA}HAVE_VALUES_H${ac_uB}HAVE_VALUES_H${ac_uC}1${ac_uD}
+ ${ac_eA}HAVE_VALUES_H${ac_eB}HAVE_VALUES_H${ac_eC}1${ac_eD}
+ ${ac_dA}HAVE_NCURSES_H${ac_dB}HAVE_NCURSES_H${ac_dC}1${ac_dD}
+ ${ac_uA}HAVE_NCURSES_H${ac_uB}HAVE_NCURSES_H${ac_uC}1${ac_uD}
+ ${ac_eA}HAVE_NCURSES_H${ac_eB}HAVE_NCURSES_H${ac_eC}1${ac_eD}
+ ${ac_dA}HAVE_CURSES_H${ac_dB}HAVE_CURSES_H${ac_dC}1${ac_dD}
+ ${ac_uA}HAVE_CURSES_H${ac_uB}HAVE_CURSES_H${ac_uC}1${ac_uD}
+ ${ac_eA}HAVE_CURSES_H${ac_eB}HAVE_CURSES_H${ac_eC}1${ac_eD}
+ CEOF
+   sed -f conftest.frag conftest.in > conftest.out
+   rm -f conftest.in
+   mv conftest.out conftest.in
+ 
+   cat > conftest.frag <<CEOF
+ ${ac_dA}HAVE_SYS_SOUNDCARD_H${ac_dB}HAVE_SYS_SOUNDCARD_H${ac_dC}1${ac_dD}
+ ${ac_uA}HAVE_SYS_SOUNDCARD_H${ac_uB}HAVE_SYS_SOUNDCARD_H${ac_uC}1${ac_uD}
+ ${ac_eA}HAVE_SYS_SOUNDCARD_H${ac_eB}HAVE_SYS_SOUNDCARD_H${ac_eC}1${ac_eD}
+ ${ac_dA}HAVE_GETOPT_H${ac_dB}HAVE_GETOPT_H${ac_dC}1${ac_dD}
+ ${ac_uA}HAVE_GETOPT_H${ac_uB}HAVE_GETOPT_H${ac_uC}1${ac_uD}
+ ${ac_eA}HAVE_GETOPT_H${ac_eB}HAVE_GETOPT_H${ac_eC}1${ac_eD}
+ ${ac_dA}HAVE_FEATURES_H${ac_dB}HAVE_FEATURES_H${ac_dC}1${ac_dD}
+ ${ac_uA}HAVE_FEATURES_H${ac_uB}HAVE_FEATURES_H${ac_uC}1${ac_uD}
+ ${ac_eA}HAVE_FEATURES_H${ac_eB}HAVE_FEATURES_H${ac_eC}1${ac_eD}
+ ${ac_dA}HAVE_SYS_TERMIOS_H${ac_dB}HAVE_SYS_TERMIOS_H${ac_dC}1${ac_dD}
+ ${ac_uA}HAVE_SYS_TERMIOS_H${ac_uB}HAVE_SYS_TERMIOS_H${ac_uC}1${ac_uD}
+ ${ac_eA}HAVE_SYS_TERMIOS_H${ac_eB}HAVE_SYS_TERMIOS_H${ac_eC}1${ac_eD}
+ CEOF
+   sed -f conftest.frag conftest.in > conftest.out
+   rm -f conftest.in
+   mv conftest.out conftest.in
+ 
+   cat > conftest.frag <<CEOF
+ ${ac_dA}HAVE_SYS_IOCTL_H${ac_dB}HAVE_SYS_IOCTL_H${ac_dC}1${ac_dD}
+ ${ac_uA}HAVE_SYS_IOCTL_H${ac_uB}HAVE_SYS_IOCTL_H${ac_uC}1${ac_uD}
+ ${ac_eA}HAVE_SYS_IOCTL_H${ac_eB}HAVE_SYS_IOCTL_H${ac_eC}1${ac_eD}
+ ${ac_dA}HAVE_SYS_IPC_H${ac_dB}HAVE_SYS_IPC_H${ac_dC}1${ac_dD}
+ ${ac_uA}HAVE_SYS_IPC_H${ac_uB}HAVE_SYS_IPC_H${ac_uC}1${ac_uD}
+ ${ac_eA}HAVE_SYS_IPC_H${ac_eB}HAVE_SYS_IPC_H${ac_eC}1${ac_eD}
+ ${ac_dA}HAVE_SYS_SHM_H${ac_dB}HAVE_SYS_SHM_H${ac_dC}1${ac_dD}
+ ${ac_uA}HAVE_SYS_SHM_H${ac_uB}HAVE_SYS_SHM_H${ac_uC}1${ac_uD}
+ ${ac_eA}HAVE_SYS_SHM_H${ac_eB}HAVE_SYS_SHM_H${ac_eC}1${ac_eD}
+ ${ac_dA}HAVE_SYS_STAT_H${ac_dB}HAVE_SYS_STAT_H${ac_dC}1${ac_dD}
+ ${ac_uA}HAVE_SYS_STAT_H${ac_uB}HAVE_SYS_STAT_H${ac_uC}1${ac_uD}
+ ${ac_eA}HAVE_SYS_STAT_H${ac_eB}HAVE_SYS_STAT_H${ac_eC}1${ac_eD}
+ CEOF
+   sed -f conftest.frag conftest.in > conftest.out
+   rm -f conftest.in
+   mv conftest.out conftest.in
+ 
+   cat > conftest.frag <<CEOF
+ ${ac_dA}SIZEOF_CHAR${ac_dB}SIZEOF_CHAR${ac_dC}1${ac_dD}
+ ${ac_uA}SIZEOF_CHAR${ac_uB}SIZEOF_CHAR${ac_uC}1${ac_uD}
+ ${ac_eA}SIZEOF_CHAR${ac_eB}SIZEOF_CHAR${ac_eC}1${ac_eD}
+ ${ac_dA}SIZEOF_SHORT${ac_dB}SIZEOF_SHORT${ac_dC}2${ac_dD}
+ ${ac_uA}SIZEOF_SHORT${ac_uB}SIZEOF_SHORT${ac_uC}2${ac_uD}
+ ${ac_eA}SIZEOF_SHORT${ac_eB}SIZEOF_SHORT${ac_eC}2${ac_eD}
+ ${ac_dA}SIZEOF_INT${ac_dB}SIZEOF_INT${ac_dC}4${ac_dD}
+ ${ac_uA}SIZEOF_INT${ac_uB}SIZEOF_INT${ac_uC}4${ac_uD}
+ ${ac_eA}SIZEOF_INT${ac_eB}SIZEOF_INT${ac_eC}4${ac_eD}
+ ${ac_dA}SIZEOF_LONG${ac_dB}SIZEOF_LONG${ac_dC}4${ac_dD}
+ ${ac_uA}SIZEOF_LONG${ac_uB}SIZEOF_LONG${ac_uC}4${ac_uD}
+ ${ac_eA}SIZEOF_LONG${ac_eB}SIZEOF_LONG${ac_eC}4${ac_eD}
+ CEOF
+   sed -f conftest.frag conftest.in > conftest.out
+   rm -f conftest.in
+   mv conftest.out conftest.in
+ 
+   cat > conftest.frag <<CEOF
+ ${ac_dA}SIZEOF_LONG_LONG${ac_dB}SIZEOF_LONG_LONG${ac_dC}8${ac_dD}
+ ${ac_uA}SIZEOF_LONG_LONG${ac_uB}SIZEOF_LONG_LONG${ac_uC}8${ac_uD}
+ ${ac_eA}SIZEOF_LONG_LONG${ac_eB}SIZEOF_LONG_LONG${ac_eC}8${ac_eD}
+ ${ac_dA}SIZEOF___INT64${ac_dB}SIZEOF___INT64${ac_dC}0${ac_dD}
+ ${ac_uA}SIZEOF___INT64${ac_uB}SIZEOF___INT64${ac_uC}0${ac_uD}
+ ${ac_eA}SIZEOF___INT64${ac_eB}SIZEOF___INT64${ac_eC}0${ac_eD}
+ ${ac_dA}HAVE_ST_BLOCKS${ac_dB}HAVE_ST_BLOCKS${ac_dC}1${ac_dD}
+ ${ac_uA}HAVE_ST_BLOCKS${ac_uB}HAVE_ST_BLOCKS${ac_uC}1${ac_uD}
+ ${ac_eA}HAVE_ST_BLOCKS${ac_eB}HAVE_ST_BLOCKS${ac_eC}1${ac_eD}
+ ${ac_dA}TIME_WITH_SYS_TIME${ac_dB}TIME_WITH_SYS_TIME${ac_dC}1${ac_dD}
+ ${ac_uA}TIME_WITH_SYS_TIME${ac_uB}TIME_WITH_SYS_TIME${ac_uC}1${ac_uD}
+ ${ac_eA}TIME_WITH_SYS_TIME${ac_eB}TIME_WITH_SYS_TIME${ac_eC}1${ac_eD}
+ CEOF
+   sed -f conftest.frag conftest.in > conftest.out
+   rm -f conftest.in
+   mv conftest.out conftest.in
+ 
+   cat > conftest.frag <<CEOF
+ ${ac_dA}RETSIGTYPE${ac_dB}RETSIGTYPE${ac_dC}void${ac_dD}
+ ${ac_uA}RETSIGTYPE${ac_uB}RETSIGTYPE${ac_uC}void${ac_uD}
+ ${ac_eA}RETSIGTYPE${ac_eB}RETSIGTYPE${ac_eC}void${ac_eD}
+ ${ac_dA}HAVE_UTIME_NULL${ac_dB}HAVE_UTIME_NULL${ac_dC}1${ac_dD}
+ ${ac_uA}HAVE_UTIME_NULL${ac_uB}HAVE_UTIME_NULL${ac_uC}1${ac_uD}
+ ${ac_eA}HAVE_UTIME_NULL${ac_eB}HAVE_UTIME_NULL${ac_eC}1${ac_eD}
+ ${ac_dA}HAVE_GETCWD${ac_dB}HAVE_GETCWD${ac_dC}1${ac_dD}
+ ${ac_uA}HAVE_GETCWD${ac_uB}HAVE_GETCWD${ac_uC}1${ac_uD}
+ ${ac_eA}HAVE_GETCWD${ac_eB}HAVE_GETCWD${ac_eC}1${ac_eD}
+ ${ac_dA}HAVE_GETOPT${ac_dB}HAVE_GETOPT${ac_dC}1${ac_dD}
+ ${ac_uA}HAVE_GETOPT${ac_uB}HAVE_GETOPT${ac_uC}1${ac_uD}
+ ${ac_eA}HAVE_GETOPT${ac_eB}HAVE_GETOPT${ac_eC}1${ac_eD}
+ CEOF
+   sed -f conftest.frag conftest.in > conftest.out
+   rm -f conftest.in
+   mv conftest.out conftest.in
+ 
+   cat > conftest.frag <<CEOF
+ ${ac_dA}HAVE_STRDUP${ac_dB}HAVE_STRDUP${ac_dC}1${ac_dD}
+ ${ac_uA}HAVE_STRDUP${ac_uB}HAVE_STRDUP${ac_uC}1${ac_uD}
+ ${ac_eA}HAVE_STRDUP${ac_eB}HAVE_STRDUP${ac_eC}1${ac_eD}
+ ${ac_dA}HAVE_GETTIMEOFDAY${ac_dB}HAVE_GETTIMEOFDAY${ac_dC}1${ac_dD}
+ ${ac_uA}HAVE_GETTIMEOFDAY${ac_uB}HAVE_GETTIMEOFDAY${ac_uC}1${ac_uD}
+ ${ac_eA}HAVE_GETTIMEOFDAY${ac_eB}HAVE_GETTIMEOFDAY${ac_eC}1${ac_eD}
+ ${ac_dA}HAVE_SIGACTION${ac_dB}HAVE_SIGACTION${ac_dC}1${ac_dD}
+ ${ac_uA}HAVE_SIGACTION${ac_uB}HAVE_SIGACTION${ac_uC}1${ac_uD}
+ ${ac_eA}HAVE_SIGACTION${ac_eB}HAVE_SIGACTION${ac_eC}1${ac_eD}
+ ${ac_dA}HAVE_MKDIR${ac_dB}HAVE_MKDIR${ac_dC}1${ac_dD}
+ ${ac_uA}HAVE_MKDIR${ac_uB}HAVE_MKDIR${ac_uC}1${ac_uD}
+ ${ac_eA}HAVE_MKDIR${ac_eB}HAVE_MKDIR${ac_eC}1${ac_eD}
+ CEOF
+   sed -f conftest.frag conftest.in > conftest.out
+   rm -f conftest.in
+   mv conftest.out conftest.in
+ 
+   cat > conftest.frag <<CEOF
+ ${ac_dA}HAVE_RMDIR${ac_dB}HAVE_RMDIR${ac_dC}1${ac_dD}
+ ${ac_uA}HAVE_RMDIR${ac_uB}HAVE_RMDIR${ac_uC}1${ac_uD}
+ ${ac_eA}HAVE_RMDIR${ac_eB}HAVE_RMDIR${ac_eC}1${ac_eD}
+ ${ac_dA}HAVE_SELECT${ac_dB}HAVE_SELECT${ac_dC}1${ac_dD}
+ ${ac_uA}HAVE_SELECT${ac_uB}HAVE_SELECT${ac_uC}1${ac_uD}
+ ${ac_eA}HAVE_SELECT${ac_eB}HAVE_SELECT${ac_eC}1${ac_eD}
+ ${ac_dA}HAVE_STRERROR${ac_dB}HAVE_STRERROR${ac_dC}1${ac_dD}
+ ${ac_uA}HAVE_STRERROR${ac_uB}HAVE_STRERROR${ac_uC}1${ac_uD}
+ ${ac_eA}HAVE_STRERROR${ac_eB}HAVE_STRERROR${ac_eC}1${ac_eD}
+ ${ac_dA}HAVE_STRSTR${ac_dB}HAVE_STRSTR${ac_dC}1${ac_dD}
+ ${ac_uA}HAVE_STRSTR${ac_uB}HAVE_STRSTR${ac_uC}1${ac_uD}
+ ${ac_eA}HAVE_STRSTR${ac_eB}HAVE_STRSTR${ac_eC}1${ac_eD}
+ CEOF
+   sed -f conftest.frag conftest.in > conftest.out
+   rm -f conftest.in
+   mv conftest.out conftest.in
+ 
+   cat > conftest.frag <<CEOF
+ ${ac_dA}HAVE_ISNAN${ac_dB}HAVE_ISNAN${ac_dC}1${ac_dD}
+ ${ac_uA}HAVE_ISNAN${ac_uB}HAVE_ISNAN${ac_uC}1${ac_uD}
+ ${ac_eA}HAVE_ISNAN${ac_eB}HAVE_ISNAN${ac_eC}1${ac_eD}
+ ${ac_dA}HAVE_ISINF${ac_dB}HAVE_ISINF${ac_dC}1${ac_dD}
+ ${ac_uA}HAVE_ISINF${ac_uB}HAVE_ISINF${ac_uC}1${ac_uD}
+ ${ac_eA}HAVE_ISINF${ac_eB}HAVE_ISINF${ac_eC}1${ac_eD}
+ ${ac_dA}HAVE_SETITIMER${ac_dB}HAVE_SETITIMER${ac_dC}1${ac_dD}
+ ${ac_uA}HAVE_SETITIMER${ac_uB}HAVE_SETITIMER${ac_uC}1${ac_uD}
+ ${ac_eA}HAVE_SETITIMER${ac_eB}HAVE_SETITIMER${ac_eC}1${ac_eD}
+ ${ac_dA}HAVE_TCGETATTR${ac_dB}HAVE_TCGETATTR${ac_dC}1${ac_dD}
+ ${ac_uA}HAVE_TCGETATTR${ac_uB}HAVE_TCGETATTR${ac_uC}1${ac_uD}
+ ${ac_eA}HAVE_TCGETATTR${ac_eB}HAVE_TCGETATTR${ac_eC}1${ac_eD}
+ CEOF
+   sed -f conftest.frag conftest.in > conftest.out
+   rm -f conftest.in
+   mv conftest.out conftest.in
+ 
+   cat > conftest.frag <<CEOF
+ ${ac_dA}HAVE_CFMAKERAW${ac_dB}HAVE_CFMAKERAW${ac_dC}1${ac_dD}
+ ${ac_uA}HAVE_CFMAKERAW${ac_uB}HAVE_CFMAKERAW${ac_uC}1${ac_uD}
+ ${ac_eA}HAVE_CFMAKERAW${ac_eB}HAVE_CFMAKERAW${ac_eC}1${ac_eD}
+ ${ac_dA}HAVE_READDIR_R${ac_dB}HAVE_READDIR_R${ac_dC}1${ac_dD}
+ ${ac_uA}HAVE_READDIR_R${ac_uB}HAVE_READDIR_R${ac_uC}1${ac_uD}
+ ${ac_eA}HAVE_READDIR_R${ac_eB}HAVE_READDIR_R${ac_eC}1${ac_eD}
+ ${ac_dA}HAVE_VPRINTF${ac_dB}HAVE_VPRINTF${ac_dC}1${ac_dD}
+ ${ac_uA}HAVE_VPRINTF${ac_uB}HAVE_VPRINTF${ac_uC}1${ac_uD}
+ ${ac_eA}HAVE_VPRINTF${ac_eB}HAVE_VPRINTF${ac_eC}1${ac_eD}
+ ${ac_dA}HAVE_VSPRINTF${ac_dB}HAVE_VSPRINTF${ac_dC}1${ac_dD}
+ ${ac_uA}HAVE_VSPRINTF${ac_uB}HAVE_VSPRINTF${ac_uC}1${ac_uD}
+ ${ac_eA}HAVE_VSPRINTF${ac_eB}HAVE_VSPRINTF${ac_eC}1${ac_eD}
+ CEOF
+   sed -f conftest.frag conftest.in > conftest.out
+   rm -f conftest.in
+   mv conftest.out conftest.in
+ 
+   cat > conftest.frag <<CEOF
+ ${ac_dA}HAVE_VFPRINTF${ac_dB}HAVE_VFPRINTF${ac_dC}1${ac_dD}
+ ${ac_uA}HAVE_VFPRINTF${ac_uB}HAVE_VFPRINTF${ac_uC}1${ac_uD}
+ ${ac_eA}HAVE_VFPRINTF${ac_eB}HAVE_VFPRINTF${ac_eC}1${ac_eD}
+ ${ac_dA}HAVE_FCNTL_H${ac_dB}HAVE_FCNTL_H${ac_dC}1${ac_dD}
+ ${ac_uA}HAVE_FCNTL_H${ac_uB}HAVE_FCNTL_H${ac_uC}1${ac_uD}
+ ${ac_eA}HAVE_FCNTL_H${ac_eB}HAVE_FCNTL_H${ac_eC}1${ac_eD}
+ ${ac_dA}HAVE_SYS_PARAM_H${ac_dB}HAVE_SYS_PARAM_H${ac_dC}1${ac_dD}
+ ${ac_uA}HAVE_SYS_PARAM_H${ac_uB}HAVE_SYS_PARAM_H${ac_uC}1${ac_uD}
+ ${ac_eA}HAVE_SYS_PARAM_H${ac_eB}HAVE_SYS_PARAM_H${ac_eC}1${ac_eD}
+ ${ac_dA}HAVE_SYS_STATFS_H${ac_dB}HAVE_SYS_STATFS_H${ac_dC}1${ac_dD}
+ ${ac_uA}HAVE_SYS_STATFS_H${ac_uB}HAVE_SYS_STATFS_H${ac_uC}1${ac_uD}
+ ${ac_eA}HAVE_SYS_STATFS_H${ac_eB}HAVE_SYS_STATFS_H${ac_eC}1${ac_eD}
+ CEOF
+   sed -f conftest.frag conftest.in > conftest.out
+   rm -f conftest.in
+   mv conftest.out conftest.in
+ 
+   cat > conftest.frag <<CEOF
+ ${ac_dA}HAVE_MNTENT_H${ac_dB}HAVE_MNTENT_H${ac_dC}1${ac_dD}
+ ${ac_uA}HAVE_MNTENT_H${ac_uB}HAVE_MNTENT_H${ac_uC}1${ac_uD}
+ ${ac_eA}HAVE_MNTENT_H${ac_eB}HAVE_MNTENT_H${ac_eC}1${ac_eD}
+ ${ac_dA}HAVE_SYS_STATVFS_H${ac_dB}HAVE_SYS_STATVFS_H${ac_dC}1${ac_dD}
+ ${ac_uA}HAVE_SYS_STATVFS_H${ac_uB}HAVE_SYS_STATVFS_H${ac_uC}1${ac_uD}
+ ${ac_eA}HAVE_SYS_STATVFS_H${ac_eB}HAVE_SYS_STATVFS_H${ac_eC}1${ac_eD}
+ ${ac_dA}HAVE_SYS_VFS_H${ac_dB}HAVE_SYS_VFS_H${ac_dC}1${ac_dD}
+ ${ac_uA}HAVE_SYS_VFS_H${ac_uB}HAVE_SYS_VFS_H${ac_uC}1${ac_uD}
+ ${ac_eA}HAVE_SYS_VFS_H${ac_eB}HAVE_SYS_VFS_H${ac_eC}1${ac_eD}
+ ${ac_dA}HAVE_SYS_MOUNT_H${ac_dB}HAVE_SYS_MOUNT_H${ac_dC}1${ac_dD}
+ ${ac_uA}HAVE_SYS_MOUNT_H${ac_uB}HAVE_SYS_MOUNT_H${ac_uC}1${ac_uD}
+ ${ac_eA}HAVE_SYS_MOUNT_H${ac_eB}HAVE_SYS_MOUNT_H${ac_eC}1${ac_eD}
+ CEOF
+   sed -f conftest.frag conftest.in > conftest.out
+   rm -f conftest.in
+   mv conftest.out conftest.in
+ 
+   cat > conftest.frag <<CEOF
+ ${ac_dA}HAVE_BCOPY${ac_dB}HAVE_BCOPY${ac_dC}1${ac_dD}
+ ${ac_uA}HAVE_BCOPY${ac_uB}HAVE_BCOPY${ac_uC}1${ac_uD}
+ ${ac_eA}HAVE_BCOPY${ac_eB}HAVE_BCOPY${ac_eC}1${ac_eD}
+ ${ac_dA}HAVE_ENDGRENT${ac_dB}HAVE_ENDGRENT${ac_dC}1${ac_dD}
+ ${ac_uA}HAVE_ENDGRENT${ac_uB}HAVE_ENDGRENT${ac_uC}1${ac_uD}
+ ${ac_eA}HAVE_ENDGRENT${ac_eB}HAVE_ENDGRENT${ac_eC}1${ac_eD}
+ ${ac_dA}HAVE_ENDPWENT${ac_dB}HAVE_ENDPWENT${ac_dC}1${ac_dD}
+ ${ac_uA}HAVE_ENDPWENT${ac_uB}HAVE_ENDPWENT${ac_uC}1${ac_uD}
+ ${ac_eA}HAVE_ENDPWENT${ac_eB}HAVE_ENDPWENT${ac_eC}1${ac_eD}
+ ${ac_dA}HAVE_FCHDIR${ac_dB}HAVE_FCHDIR${ac_dC}1${ac_dD}
+ ${ac_uA}HAVE_FCHDIR${ac_uB}HAVE_FCHDIR${ac_uC}1${ac_uD}
+ ${ac_eA}HAVE_FCHDIR${ac_eB}HAVE_FCHDIR${ac_eC}1${ac_eD}
+ CEOF
+   sed -f conftest.frag conftest.in > conftest.out
+   rm -f conftest.in
+   mv conftest.out conftest.in
+ 
+   cat > conftest.frag <<CEOF
+ ${ac_dA}HAVE_FTIME${ac_dB}HAVE_FTIME${ac_dC}1${ac_dD}
+ ${ac_uA}HAVE_FTIME${ac_uB}HAVE_FTIME${ac_uC}1${ac_uD}
+ ${ac_eA}HAVE_FTIME${ac_eB}HAVE_FTIME${ac_eC}1${ac_eD}
+ ${ac_dA}HAVE_FTRUNCATE${ac_dB}HAVE_FTRUNCATE${ac_dC}1${ac_dD}
+ ${ac_uA}HAVE_FTRUNCATE${ac_uB}HAVE_FTRUNCATE${ac_uC}1${ac_uD}
+ ${ac_eA}HAVE_FTRUNCATE${ac_eB}HAVE_FTRUNCATE${ac_eC}1${ac_eD}
+ ${ac_dA}HAVE_GETCWD${ac_dB}HAVE_GETCWD${ac_dC}1${ac_dD}
+ ${ac_uA}HAVE_GETCWD${ac_uB}HAVE_GETCWD${ac_uC}1${ac_uD}
+ ${ac_eA}HAVE_GETCWD${ac_eB}HAVE_GETCWD${ac_eC}1${ac_eD}
+ ${ac_dA}HAVE_GETTIMEOFDAY${ac_dB}HAVE_GETTIMEOFDAY${ac_dC}1${ac_dD}
+ ${ac_uA}HAVE_GETTIMEOFDAY${ac_uB}HAVE_GETTIMEOFDAY${ac_uC}1${ac_uD}
+ ${ac_eA}HAVE_GETTIMEOFDAY${ac_eB}HAVE_GETTIMEOFDAY${ac_eC}1${ac_eD}
+ CEOF
+   sed -f conftest.frag conftest.in > conftest.out
+   rm -f conftest.in
+   mv conftest.out conftest.in
+ 
+   cat > conftest.frag <<CEOF
+ ${ac_dA}HAVE_ISASCII${ac_dB}HAVE_ISASCII${ac_dC}1${ac_dD}
+ ${ac_uA}HAVE_ISASCII${ac_uB}HAVE_ISASCII${ac_uC}1${ac_uD}
+ ${ac_eA}HAVE_ISASCII${ac_eB}HAVE_ISASCII${ac_eC}1${ac_eD}
+ ${ac_dA}HAVE_LCHOWN${ac_dB}HAVE_LCHOWN${ac_dC}1${ac_dD}
+ ${ac_uA}HAVE_LCHOWN${ac_uB}HAVE_LCHOWN${ac_uC}1${ac_uD}
+ ${ac_eA}HAVE_LCHOWN${ac_eB}HAVE_LCHOWN${ac_eC}1${ac_eD}
+ ${ac_dA}HAVE_MEMCPY${ac_dB}HAVE_MEMCPY${ac_dC}1${ac_dD}
+ ${ac_uA}HAVE_MEMCPY${ac_uB}HAVE_MEMCPY${ac_uC}1${ac_uD}
+ ${ac_eA}HAVE_MEMCPY${ac_eB}HAVE_MEMCPY${ac_eC}1${ac_eD}
+ ${ac_dA}HAVE_MKFIFO${ac_dB}HAVE_MKFIFO${ac_dC}1${ac_dD}
+ ${ac_uA}HAVE_MKFIFO${ac_uB}HAVE_MKFIFO${ac_uC}1${ac_uD}
+ ${ac_eA}HAVE_MKFIFO${ac_eB}HAVE_MKFIFO${ac_eC}1${ac_eD}
+ CEOF
+   sed -f conftest.frag conftest.in > conftest.out
+   rm -f conftest.in
+   mv conftest.out conftest.in
+ 
+   cat > conftest.frag <<CEOF
+ ${ac_dA}HAVE_STRCHR${ac_dB}HAVE_STRCHR${ac_dC}1${ac_dD}
+ ${ac_uA}HAVE_STRCHR${ac_uB}HAVE_STRCHR${ac_uC}1${ac_uD}
+ ${ac_eA}HAVE_STRCHR${ac_eB}HAVE_STRCHR${ac_eC}1${ac_eD}
+ ${ac_dA}HAVE_STRERROR${ac_dB}HAVE_STRERROR${ac_dC}1${ac_dD}
+ ${ac_uA}HAVE_STRERROR${ac_uB}HAVE_STRERROR${ac_uC}1${ac_uD}
+ ${ac_eA}HAVE_STRERROR${ac_eB}HAVE_STRERROR${ac_eC}1${ac_eD}
+ ${ac_dA}HAVE_STRRCHR${ac_dB}HAVE_STRRCHR${ac_dC}1${ac_dD}
+ ${ac_uA}HAVE_STRRCHR${ac_uB}HAVE_STRRCHR${ac_uC}1${ac_uD}
+ ${ac_eA}HAVE_STRRCHR${ac_eB}HAVE_STRRCHR${ac_eC}1${ac_eD}
+ ${ac_dA}HAVE_GETMNTENT${ac_dB}HAVE_GETMNTENT${ac_dC}1${ac_dD}
+ ${ac_uA}HAVE_GETMNTENT${ac_uB}HAVE_GETMNTENT${ac_uC}1${ac_uD}
+ ${ac_eA}HAVE_GETMNTENT${ac_eB}HAVE_GETMNTENT${ac_eC}1${ac_eD}
+ CEOF
+   sed -f conftest.frag conftest.in > conftest.out
+   rm -f conftest.in
+   mv conftest.out conftest.in
+ 
+   cat > conftest.frag <<CEOF
+ ${ac_dA}MOUNTED_GETMNTENT1${ac_dB}MOUNTED_GETMNTENT1${ac_dC}1${ac_dD}
+ ${ac_uA}MOUNTED_GETMNTENT1${ac_uB}MOUNTED_GETMNTENT1${ac_uC}1${ac_uD}
+ ${ac_eA}MOUNTED_GETMNTENT1${ac_eB}MOUNTED_GETMNTENT1${ac_eC}1${ac_eD}
+ ${ac_dA}STAT_STATVFS${ac_dB}STAT_STATVFS${ac_dC}1${ac_dD}
+ ${ac_uA}STAT_STATVFS${ac_uB}STAT_STATVFS${ac_uC}1${ac_uD}
+ ${ac_eA}STAT_STATVFS${ac_eB}STAT_STATVFS${ac_eC}1${ac_eD}
+ ${ac_dA}HAVE_FTRUNCATE${ac_dB}HAVE_FTRUNCATE${ac_dC}1${ac_dD}
+ ${ac_uA}HAVE_FTRUNCATE${ac_uB}HAVE_FTRUNCATE${ac_uC}1${ac_uD}
+ ${ac_eA}HAVE_FTRUNCATE${ac_eB}HAVE_FTRUNCATE${ac_eC}1${ac_eD}
+ s%^[ 	]*#[ 	]*undef[ 	][ 	]*[a-zA-Z_][a-zA-Z_0-9]*%/* & */%
+ CEOF
+   sed -f conftest.frag conftest.in > conftest.out
+   rm -f conftest.in
+   mv conftest.out conftest.in
+ 
+   rm -f conftest.frag conftest.h
+   echo "/* $ac_file.  Generated automatically by configure.  */" > conftest.h
+   cat conftest.in >> conftest.h
+   rm -f conftest.in
+   if cmp -s $ac_file conftest.h 2>/dev/null; then
+     echo "$ac_file is unchanged"
+     rm -f conftest.h
+   else
+     # Remove last slash and all that follows it.  Not all systems have dirname.
+       ac_dir=`echo $ac_file|sed 's%/[^/][^/]*$%%'`
+       if test "$ac_dir" != "$ac_file" && test "$ac_dir" != .; then
+       # The file is in a subdirectory.
+       test ! -d "$ac_dir" && mkdir "$ac_dir"
+     fi
+     rm -f $ac_file
+     mv conftest.h $ac_file
+   fi
+ fi; done
+ 
+ 
+ 
+ exit 0
diff -crB --new-file ./uae-0.8.21/configure ../uae_jit_cleaning/uae-0.8.21/configure
*** ./uae-0.8.21/configure	2001-12-30 16:42:54.000000000 +0200
--- ../uae_jit_cleaning/uae-0.8.21/configure	2021-01-10 13:10:29.818591684 +0200
***************
*** 32,37 ****
--- 32,39 ----
  ac_help="$ac_help
    --enable-ui             Use a user interface if possible (default on)"
  ac_help="$ac_help
+   --enable-jit            linux/X11 version: Use the JIT compiler"
+ ac_help="$ac_help
    --with-hostcc=x         Use a x as compiler for the host system"
  ac_help="$ac_help
    --with-gtk-prefix=PFX   Prefix where GTK is installed (optional)"
***************
*** 560,566 ****
  # Extract the first word of "gcc", so it can be a program name with args.
  set dummy gcc; ac_word=$2
  echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
! echo "configure:564: checking for $ac_word" >&5
  if eval "test \"`echo '$''{'ac_cv_prog_CC'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
--- 562,568 ----
  # Extract the first word of "gcc", so it can be a program name with args.
  set dummy gcc; ac_word=$2
  echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
! echo "configure:566: checking for $ac_word" >&5
  if eval "test \"`echo '$''{'ac_cv_prog_CC'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
***************
*** 590,596 ****
    # Extract the first word of "cc", so it can be a program name with args.
  set dummy cc; ac_word=$2
  echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
! echo "configure:594: checking for $ac_word" >&5
  if eval "test \"`echo '$''{'ac_cv_prog_CC'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
--- 592,598 ----
    # Extract the first word of "cc", so it can be a program name with args.
  set dummy cc; ac_word=$2
  echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
! echo "configure:596: checking for $ac_word" >&5
  if eval "test \"`echo '$''{'ac_cv_prog_CC'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
***************
*** 641,647 ****
        # Extract the first word of "cl", so it can be a program name with args.
  set dummy cl; ac_word=$2
  echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
! echo "configure:645: checking for $ac_word" >&5
  if eval "test \"`echo '$''{'ac_cv_prog_CC'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
--- 643,649 ----
        # Extract the first word of "cl", so it can be a program name with args.
  set dummy cl; ac_word=$2
  echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
! echo "configure:647: checking for $ac_word" >&5
  if eval "test \"`echo '$''{'ac_cv_prog_CC'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
***************
*** 673,679 ****
  fi
  
  echo $ac_n "checking whether the C compiler ($CC $CFLAGS $LDFLAGS) works""... $ac_c" 1>&6
! echo "configure:677: checking whether the C compiler ($CC $CFLAGS $LDFLAGS) works" >&5
  
  ac_ext=c
  # CFLAGS is not in ac_cpp because -g, -O, etc. are not valid cpp options.
--- 675,681 ----
  fi
  
  echo $ac_n "checking whether the C compiler ($CC $CFLAGS $LDFLAGS) works""... $ac_c" 1>&6
! echo "configure:679: checking whether the C compiler ($CC $CFLAGS $LDFLAGS) works" >&5
  
  ac_ext=c
  # CFLAGS is not in ac_cpp because -g, -O, etc. are not valid cpp options.
***************
*** 684,695 ****
  
  cat > conftest.$ac_ext << EOF
  
! #line 688 "configure"
  #include "confdefs.h"
  
  main(){return(0);}
  EOF
! if { (eval echo configure:693: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
    ac_cv_prog_cc_works=yes
    # If we can't run a trivial program, we are probably using a cross compiler.
    if (./conftest; exit) 2>/dev/null; then
--- 686,697 ----
  
  cat > conftest.$ac_ext << EOF
  
! #line 690 "configure"
  #include "confdefs.h"
  
  main(){return(0);}
  EOF
! if { (eval echo configure:695: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
    ac_cv_prog_cc_works=yes
    # If we can't run a trivial program, we are probably using a cross compiler.
    if (./conftest; exit) 2>/dev/null; then
***************
*** 715,726 ****
    { echo "configure: error: installation or configuration problem: C compiler cannot create executables." 1>&2; exit 1; }
  fi
  echo $ac_n "checking whether the C compiler ($CC $CFLAGS $LDFLAGS) is a cross-compiler""... $ac_c" 1>&6
! echo "configure:719: checking whether the C compiler ($CC $CFLAGS $LDFLAGS) is a cross-compiler" >&5
  echo "$ac_t""$ac_cv_prog_cc_cross" 1>&6
  cross_compiling=$ac_cv_prog_cc_cross
  
  echo $ac_n "checking whether we are using GNU C""... $ac_c" 1>&6
! echo "configure:724: checking whether we are using GNU C" >&5
  if eval "test \"`echo '$''{'ac_cv_prog_gcc'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
--- 717,728 ----
    { echo "configure: error: installation or configuration problem: C compiler cannot create executables." 1>&2; exit 1; }
  fi
  echo $ac_n "checking whether the C compiler ($CC $CFLAGS $LDFLAGS) is a cross-compiler""... $ac_c" 1>&6
! echo "configure:721: checking whether the C compiler ($CC $CFLAGS $LDFLAGS) is a cross-compiler" >&5
  echo "$ac_t""$ac_cv_prog_cc_cross" 1>&6
  cross_compiling=$ac_cv_prog_cc_cross
  
  echo $ac_n "checking whether we are using GNU C""... $ac_c" 1>&6
! echo "configure:726: checking whether we are using GNU C" >&5
  if eval "test \"`echo '$''{'ac_cv_prog_gcc'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
***************
*** 729,735 ****
    yes;
  #endif
  EOF
! if { ac_try='${CC-cc} -E conftest.c'; { (eval echo configure:733: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }; } | egrep yes >/dev/null 2>&1; then
    ac_cv_prog_gcc=yes
  else
    ac_cv_prog_gcc=no
--- 731,737 ----
    yes;
  #endif
  EOF
! if { ac_try='${CC-cc} -E conftest.c'; { (eval echo configure:735: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }; } | egrep yes >/dev/null 2>&1; then
    ac_cv_prog_gcc=yes
  else
    ac_cv_prog_gcc=no
***************
*** 748,754 ****
  ac_save_CFLAGS="$CFLAGS"
  CFLAGS=
  echo $ac_n "checking whether ${CC-cc} accepts -g""... $ac_c" 1>&6
! echo "configure:752: checking whether ${CC-cc} accepts -g" >&5
  if eval "test \"`echo '$''{'ac_cv_prog_cc_g'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
--- 750,756 ----
  ac_save_CFLAGS="$CFLAGS"
  CFLAGS=
  echo $ac_n "checking whether ${CC-cc} accepts -g""... $ac_c" 1>&6
! echo "configure:754: checking whether ${CC-cc} accepts -g" >&5
  if eval "test \"`echo '$''{'ac_cv_prog_cc_g'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
***************
*** 781,787 ****
  
  
  echo $ac_n "checking how to run the C preprocessor""... $ac_c" 1>&6
! echo "configure:785: checking how to run the C preprocessor" >&5
  # On Suns, sometimes $CPP names a directory.
  if test -n "$CPP" && test -d "$CPP"; then
    CPP=
--- 783,789 ----
  
  
  echo $ac_n "checking how to run the C preprocessor""... $ac_c" 1>&6
! echo "configure:787: checking how to run the C preprocessor" >&5
  # On Suns, sometimes $CPP names a directory.
  if test -n "$CPP" && test -d "$CPP"; then
    CPP=
***************
*** 796,808 ****
    # On the NeXT, cc -E runs the code through the compiler's parser,
    # not just through cpp.
    cat > conftest.$ac_ext <<EOF
! #line 800 "configure"
  #include "confdefs.h"
  #include <assert.h>
  Syntax Error
  EOF
  ac_try="$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out"
! { (eval echo configure:806: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
  ac_err=`grep -v '^ *+' conftest.out | grep -v "^conftest.${ac_ext}\$"`
  if test -z "$ac_err"; then
    :
--- 798,810 ----
    # On the NeXT, cc -E runs the code through the compiler's parser,
    # not just through cpp.
    cat > conftest.$ac_ext <<EOF
! #line 802 "configure"
  #include "confdefs.h"
  #include <assert.h>
  Syntax Error
  EOF
  ac_try="$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out"
! { (eval echo configure:808: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
  ac_err=`grep -v '^ *+' conftest.out | grep -v "^conftest.${ac_ext}\$"`
  if test -z "$ac_err"; then
    :
***************
*** 813,825 ****
    rm -rf conftest*
    CPP="${CC-cc} -E -traditional-cpp"
    cat > conftest.$ac_ext <<EOF
! #line 817 "configure"
  #include "confdefs.h"
  #include <assert.h>
  Syntax Error
  EOF
  ac_try="$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out"
! { (eval echo configure:823: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
  ac_err=`grep -v '^ *+' conftest.out | grep -v "^conftest.${ac_ext}\$"`
  if test -z "$ac_err"; then
    :
--- 815,827 ----
    rm -rf conftest*
    CPP="${CC-cc} -E -traditional-cpp"
    cat > conftest.$ac_ext <<EOF
! #line 819 "configure"
  #include "confdefs.h"
  #include <assert.h>
  Syntax Error
  EOF
  ac_try="$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out"
! { (eval echo configure:825: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
  ac_err=`grep -v '^ *+' conftest.out | grep -v "^conftest.${ac_ext}\$"`
  if test -z "$ac_err"; then
    :
***************
*** 830,842 ****
    rm -rf conftest*
    CPP="${CC-cc} -nologo -E"
    cat > conftest.$ac_ext <<EOF
! #line 834 "configure"
  #include "confdefs.h"
  #include <assert.h>
  Syntax Error
  EOF
  ac_try="$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out"
! { (eval echo configure:840: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
  ac_err=`grep -v '^ *+' conftest.out | grep -v "^conftest.${ac_ext}\$"`
  if test -z "$ac_err"; then
    :
--- 832,844 ----
    rm -rf conftest*
    CPP="${CC-cc} -nologo -E"
    cat > conftest.$ac_ext <<EOF
! #line 836 "configure"
  #include "confdefs.h"
  #include <assert.h>
  Syntax Error
  EOF
  ac_try="$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out"
! { (eval echo configure:842: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
  ac_err=`grep -v '^ *+' conftest.out | grep -v "^conftest.${ac_ext}\$"`
  if test -z "$ac_err"; then
    :
***************
*** 861,867 ****
  echo "$ac_t""$CPP" 1>&6
  
  echo $ac_n "checking whether ${MAKE-make} sets \${MAKE}""... $ac_c" 1>&6
! echo "configure:865: checking whether ${MAKE-make} sets \${MAKE}" >&5
  set dummy ${MAKE-make}; ac_make=`echo "$2" | sed 'y%./+-%__p_%'`
  if eval "test \"`echo '$''{'ac_cv_prog_make_${ac_make}_set'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
--- 863,869 ----
  echo "$ac_t""$CPP" 1>&6
  
  echo $ac_n "checking whether ${MAKE-make} sets \${MAKE}""... $ac_c" 1>&6
! echo "configure:867: checking whether ${MAKE-make} sets \${MAKE}" >&5
  set dummy ${MAKE-make}; ac_make=`echo "$2" | sed 'y%./+-%__p_%'`
  if eval "test \"`echo '$''{'ac_cv_prog_make_${ac_make}_set'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
***************
*** 890,896 ****
  # Extract the first word of "makedepend", so it can be a program name with args.
  set dummy makedepend; ac_word=$2
  echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
! echo "configure:894: checking for $ac_word" >&5
  if eval "test \"`echo '$''{'ac_cv_path_MAKEDEPPRG'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
--- 892,898 ----
  # Extract the first word of "makedepend", so it can be a program name with args.
  set dummy makedepend; ac_word=$2
  echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
! echo "configure:896: checking for $ac_word" >&5
  if eval "test \"`echo '$''{'ac_cv_path_MAKEDEPPRG'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
***************
*** 926,932 ****
  # Extract the first word of "file", so it can be a program name with args.
  set dummy file; ac_word=$2
  echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
! echo "configure:930: checking for $ac_word" >&5
  if eval "test \"`echo '$''{'ac_cv_path_FILEPRG'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
--- 928,934 ----
  # Extract the first word of "file", so it can be a program name with args.
  set dummy file; ac_word=$2
  echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
! echo "configure:932: checking for $ac_word" >&5
  if eval "test \"`echo '$''{'ac_cv_path_FILEPRG'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
***************
*** 962,968 ****
  # Extract the first word of "wrc", so it can be a program name with args.
  set dummy wrc; ac_word=$2
  echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
! echo "configure:966: checking for $ac_word" >&5
  if eval "test \"`echo '$''{'ac_cv_path_WRCPRG'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
--- 964,970 ----
  # Extract the first word of "wrc", so it can be a program name with args.
  set dummy wrc; ac_word=$2
  echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
! echo "configure:968: checking for $ac_word" >&5
  if eval "test \"`echo '$''{'ac_cv_path_WRCPRG'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
***************
*** 998,1004 ****
  # Extract the first word of "rcl", so it can be a program name with args.
  set dummy rcl; ac_word=$2
  echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
! echo "configure:1002: checking for $ac_word" >&5
  if eval "test \"`echo '$''{'ac_cv_path_RCLPRG'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
--- 1000,1006 ----
  # Extract the first word of "rcl", so it can be a program name with args.
  set dummy rcl; ac_word=$2
  echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
! echo "configure:1004: checking for $ac_word" >&5
  if eval "test \"`echo '$''{'ac_cv_path_RCLPRG'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
***************
*** 1034,1040 ****
  # Extract the first word of "sdl-config", so it can be a program name with args.
  set dummy sdl-config; ac_word=$2
  echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
! echo "configure:1038: checking for $ac_word" >&5
  if eval "test \"`echo '$''{'ac_cv_path_SDL_CONFIG'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
--- 1036,1042 ----
  # Extract the first word of "sdl-config", so it can be a program name with args.
  set dummy sdl-config; ac_word=$2
  echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
! echo "configure:1040: checking for $ac_word" >&5
  if eval "test \"`echo '$''{'ac_cv_path_SDL_CONFIG'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
***************
*** 1069,1077 ****
  
  
  echo $ac_n "checking for AIX""... $ac_c" 1>&6
! echo "configure:1073: checking for AIX" >&5
  cat > conftest.$ac_ext <<EOF
! #line 1075 "configure"
  #include "confdefs.h"
  #ifdef _AIX
    yes
--- 1071,1079 ----
  
  
  echo $ac_n "checking for AIX""... $ac_c" 1>&6
! echo "configure:1075: checking for AIX" >&5
  cat > conftest.$ac_ext <<EOF
! #line 1077 "configure"
  #include "confdefs.h"
  #ifdef _AIX
    yes
***************
*** 1093,1099 ****
  
  
  echo $ac_n "checking for POSIXized ISC""... $ac_c" 1>&6
! echo "configure:1097: checking for POSIXized ISC" >&5
  if test -d /etc/conf/kconfig.d &&
    grep _POSIX_VERSION /usr/include/sys/unistd.h >/dev/null 2>&1
  then
--- 1095,1101 ----
  
  
  echo $ac_n "checking for POSIXized ISC""... $ac_c" 1>&6
! echo "configure:1099: checking for POSIXized ISC" >&5
  if test -d /etc/conf/kconfig.d &&
    grep _POSIX_VERSION /usr/include/sys/unistd.h >/dev/null 2>&1
  then
***************
*** 1115,1123 ****
  
  
  echo $ac_n "checking for Watcom C""... $ac_c" 1>&6
! echo "configure:1119: checking for Watcom C" >&5
  cat > conftest.$ac_ext <<EOF
! #line 1121 "configure"
  #include "confdefs.h"
  #ifdef __WATCOMC__
    yes
--- 1117,1125 ----
  
  
  echo $ac_n "checking for Watcom C""... $ac_c" 1>&6
! echo "configure:1121: checking for Watcom C" >&5
  cat > conftest.$ac_ext <<EOF
! #line 1123 "configure"
  #include "confdefs.h"
  #ifdef __WATCOMC__
    yes
***************
*** 1137,1155 ****
  echo "$ac_t""$uae_cv_prog_cc_watcom" 1>&6
  
  echo $ac_n "checking for Cygwin32 environment""... $ac_c" 1>&6
! echo "configure:1141: checking for Cygwin32 environment" >&5
  if eval "test \"`echo '$''{'am_cv_cygwin32'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
    cat > conftest.$ac_ext <<EOF
! #line 1146 "configure"
  #include "confdefs.h"
  
  int main() {
  return __CYGWIN32__;
  ; return 0; }
  EOF
! if { (eval echo configure:1153: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
    rm -rf conftest*
    am_cv_cygwin32=yes
  else
--- 1139,1157 ----
  echo "$ac_t""$uae_cv_prog_cc_watcom" 1>&6
  
  echo $ac_n "checking for Cygwin32 environment""... $ac_c" 1>&6
! echo "configure:1143: checking for Cygwin32 environment" >&5
  if eval "test \"`echo '$''{'am_cv_cygwin32'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
    cat > conftest.$ac_ext <<EOF
! #line 1148 "configure"
  #include "confdefs.h"
  
  int main() {
  return __CYGWIN32__;
  ; return 0; }
  EOF
! if { (eval echo configure:1155: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
    rm -rf conftest*
    am_cv_cygwin32=yes
  else
***************
*** 1166,1184 ****
  CYGWIN32=
  test "$am_cv_cygwin32" = yes && CYGWIN32=yes
  echo $ac_n "checking for Mingw32 environment""... $ac_c" 1>&6
! echo "configure:1170: checking for Mingw32 environment" >&5
  if eval "test \"`echo '$''{'am_cv_mingw32'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
    cat > conftest.$ac_ext <<EOF
! #line 1175 "configure"
  #include "confdefs.h"
  
  int main() {
  return __MINGW32__;
  ; return 0; }
  EOF
! if { (eval echo configure:1182: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
    rm -rf conftest*
    am_cv_mingw32=yes
  else
--- 1168,1186 ----
  CYGWIN32=
  test "$am_cv_cygwin32" = yes && CYGWIN32=yes
  echo $ac_n "checking for Mingw32 environment""... $ac_c" 1>&6
! echo "configure:1172: checking for Mingw32 environment" >&5
  if eval "test \"`echo '$''{'am_cv_mingw32'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
    cat > conftest.$ac_ext <<EOF
! #line 1177 "configure"
  #include "confdefs.h"
  
  int main() {
  return __MINGW32__;
  ; return 0; }
  EOF
! if { (eval echo configure:1184: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
    rm -rf conftest*
    am_cv_mingw32=yes
  else
***************
*** 1197,1203 ****
  
  
  echo $ac_n "checking for executable suffix""... $ac_c" 1>&6
! echo "configure:1201: checking for executable suffix" >&5
  if eval "test \"`echo '$''{'am_cv_exeext'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
--- 1199,1205 ----
  
  
  echo $ac_n "checking for executable suffix""... $ac_c" 1>&6
! echo "configure:1203: checking for executable suffix" >&5
  if eval "test \"`echo '$''{'am_cv_exeext'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
***************
*** 1241,1247 ****
  HAVE_BEOS=no
  HAVE_POS=no
  echo $ac_n "checking for main in -lMedia_s""... $ac_c" 1>&6
! echo "configure:1245: checking for main in -lMedia_s" >&5
  ac_lib_var=`echo Media_s'_'main | sed 'y%./+-%__p_%'`
  if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
--- 1243,1249 ----
  HAVE_BEOS=no
  HAVE_POS=no
  echo $ac_n "checking for main in -lMedia_s""... $ac_c" 1>&6
! echo "configure:1247: checking for main in -lMedia_s" >&5
  ac_lib_var=`echo Media_s'_'main | sed 'y%./+-%__p_%'`
  if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
***************
*** 1249,1262 ****
    ac_save_LIBS="$LIBS"
  LIBS="-lMedia_s  $LIBS"
  cat > conftest.$ac_ext <<EOF
! #line 1253 "configure"
  #include "confdefs.h"
  
  int main() {
  main()
  ; return 0; }
  EOF
! if { (eval echo configure:1260: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
    rm -rf conftest*
    eval "ac_cv_lib_$ac_lib_var=yes"
  else
--- 1251,1264 ----
    ac_save_LIBS="$LIBS"
  LIBS="-lMedia_s  $LIBS"
  cat > conftest.$ac_ext <<EOF
! #line 1255 "configure"
  #include "confdefs.h"
  
  int main() {
  main()
  ; return 0; }
  EOF
! if { (eval echo configure:1262: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
    rm -rf conftest*
    eval "ac_cv_lib_$ac_lib_var=yes"
  else
***************
*** 1278,1284 ****
  fi
  
  echo $ac_n "checking for main in -lNeXT_s""... $ac_c" 1>&6
! echo "configure:1282: checking for main in -lNeXT_s" >&5
  ac_lib_var=`echo NeXT_s'_'main | sed 'y%./+-%__p_%'`
  if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
--- 1280,1286 ----
  fi
  
  echo $ac_n "checking for main in -lNeXT_s""... $ac_c" 1>&6
! echo "configure:1284: checking for main in -lNeXT_s" >&5
  ac_lib_var=`echo NeXT_s'_'main | sed 'y%./+-%__p_%'`
  if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
***************
*** 1286,1299 ****
    ac_save_LIBS="$LIBS"
  LIBS="-lNeXT_s  $LIBS"
  cat > conftest.$ac_ext <<EOF
! #line 1290 "configure"
  #include "confdefs.h"
  
  int main() {
  main()
  ; return 0; }
  EOF
! if { (eval echo configure:1297: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
    rm -rf conftest*
    eval "ac_cv_lib_$ac_lib_var=yes"
  else
--- 1288,1301 ----
    ac_save_LIBS="$LIBS"
  LIBS="-lNeXT_s  $LIBS"
  cat > conftest.$ac_ext <<EOF
! #line 1292 "configure"
  #include "confdefs.h"
  
  int main() {
  main()
  ; return 0; }
  EOF
! if { (eval echo configure:1299: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
    rm -rf conftest*
    eval "ac_cv_lib_$ac_lib_var=yes"
  else
***************
*** 1315,1321 ****
  fi
  
  echo $ac_n "checking for cos in -lmoto""... $ac_c" 1>&6
! echo "configure:1319: checking for cos in -lmoto" >&5
  ac_lib_var=`echo moto'_'cos | sed 'y%./+-%__p_%'`
  if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
--- 1317,1323 ----
  fi
  
  echo $ac_n "checking for cos in -lmoto""... $ac_c" 1>&6
! echo "configure:1321: checking for cos in -lmoto" >&5
  ac_lib_var=`echo moto'_'cos | sed 'y%./+-%__p_%'`
  if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
***************
*** 1323,1329 ****
    ac_save_LIBS="$LIBS"
  LIBS="-lmoto  $LIBS"
  cat > conftest.$ac_ext <<EOF
! #line 1327 "configure"
  #include "confdefs.h"
  /* Override any gcc2 internal prototype to avoid an error.  */
  /* We use char because int might match the return type of a gcc2
--- 1325,1331 ----
    ac_save_LIBS="$LIBS"
  LIBS="-lmoto  $LIBS"
  cat > conftest.$ac_ext <<EOF
! #line 1329 "configure"
  #include "confdefs.h"
  /* Override any gcc2 internal prototype to avoid an error.  */
  /* We use char because int might match the return type of a gcc2
***************
*** 1334,1340 ****
  cos()
  ; return 0; }
  EOF
! if { (eval echo configure:1338: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
    rm -rf conftest*
    eval "ac_cv_lib_$ac_lib_var=yes"
  else
--- 1336,1342 ----
  cos()
  ; return 0; }
  EOF
! if { (eval echo configure:1340: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
    rm -rf conftest*
    eval "ac_cv_lib_$ac_lib_var=yes"
  else
***************
*** 1356,1362 ****
  fi
  
  echo $ac_n "checking for OpenLibrary in -lamiga""... $ac_c" 1>&6
! echo "configure:1360: checking for OpenLibrary in -lamiga" >&5
  ac_lib_var=`echo amiga'_'OpenLibrary | sed 'y%./+-%__p_%'`
  if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
--- 1358,1364 ----
  fi
  
  echo $ac_n "checking for OpenLibrary in -lamiga""... $ac_c" 1>&6
! echo "configure:1362: checking for OpenLibrary in -lamiga" >&5
  ac_lib_var=`echo amiga'_'OpenLibrary | sed 'y%./+-%__p_%'`
  if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
***************
*** 1364,1370 ****
    ac_save_LIBS="$LIBS"
  LIBS="-lamiga  $LIBS"
  cat > conftest.$ac_ext <<EOF
! #line 1368 "configure"
  #include "confdefs.h"
  /* Override any gcc2 internal prototype to avoid an error.  */
  /* We use char because int might match the return type of a gcc2
--- 1366,1372 ----
    ac_save_LIBS="$LIBS"
  LIBS="-lamiga  $LIBS"
  cat > conftest.$ac_ext <<EOF
! #line 1370 "configure"
  #include "confdefs.h"
  /* Override any gcc2 internal prototype to avoid an error.  */
  /* We use char because int might match the return type of a gcc2
***************
*** 1375,1381 ****
  OpenLibrary()
  ; return 0; }
  EOF
! if { (eval echo configure:1379: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
    rm -rf conftest*
    eval "ac_cv_lib_$ac_lib_var=yes"
  else
--- 1377,1383 ----
  OpenLibrary()
  ; return 0; }
  EOF
! if { (eval echo configure:1381: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
    rm -rf conftest*
    eval "ac_cv_lib_$ac_lib_var=yes"
  else
***************
*** 1397,1403 ****
  fi
  
  echo $ac_n "checking for vga_setmode in -lvga""... $ac_c" 1>&6
! echo "configure:1401: checking for vga_setmode in -lvga" >&5
  ac_lib_var=`echo vga'_'vga_setmode | sed 'y%./+-%__p_%'`
  if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
--- 1399,1405 ----
  fi
  
  echo $ac_n "checking for vga_setmode in -lvga""... $ac_c" 1>&6
! echo "configure:1403: checking for vga_setmode in -lvga" >&5
  ac_lib_var=`echo vga'_'vga_setmode | sed 'y%./+-%__p_%'`
  if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
***************
*** 1405,1411 ****
    ac_save_LIBS="$LIBS"
  LIBS="-lvga  $LIBS"
  cat > conftest.$ac_ext <<EOF
! #line 1409 "configure"
  #include "confdefs.h"
  /* Override any gcc2 internal prototype to avoid an error.  */
  /* We use char because int might match the return type of a gcc2
--- 1407,1413 ----
    ac_save_LIBS="$LIBS"
  LIBS="-lvga  $LIBS"
  cat > conftest.$ac_ext <<EOF
! #line 1411 "configure"
  #include "confdefs.h"
  /* Override any gcc2 internal prototype to avoid an error.  */
  /* We use char because int might match the return type of a gcc2
***************
*** 1416,1422 ****
  vga_setmode()
  ; return 0; }
  EOF
! if { (eval echo configure:1420: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
    rm -rf conftest*
    eval "ac_cv_lib_$ac_lib_var=yes"
  else
--- 1418,1424 ----
  vga_setmode()
  ; return 0; }
  EOF
! if { (eval echo configure:1422: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
    rm -rf conftest*
    eval "ac_cv_lib_$ac_lib_var=yes"
  else
***************
*** 1438,1444 ****
  fi
  
  echo $ac_n "checking for AFOpenAudioConn in -lAF""... $ac_c" 1>&6
! echo "configure:1442: checking for AFOpenAudioConn in -lAF" >&5
  ac_lib_var=`echo AF'_'AFOpenAudioConn | sed 'y%./+-%__p_%'`
  if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
--- 1440,1446 ----
  fi
  
  echo $ac_n "checking for AFOpenAudioConn in -lAF""... $ac_c" 1>&6
! echo "configure:1444: checking for AFOpenAudioConn in -lAF" >&5
  ac_lib_var=`echo AF'_'AFOpenAudioConn | sed 'y%./+-%__p_%'`
  if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
***************
*** 1446,1452 ****
    ac_save_LIBS="$LIBS"
  LIBS="-lAF  $LIBS"
  cat > conftest.$ac_ext <<EOF
! #line 1450 "configure"
  #include "confdefs.h"
  /* Override any gcc2 internal prototype to avoid an error.  */
  /* We use char because int might match the return type of a gcc2
--- 1448,1454 ----
    ac_save_LIBS="$LIBS"
  LIBS="-lAF  $LIBS"
  cat > conftest.$ac_ext <<EOF
! #line 1452 "configure"
  #include "confdefs.h"
  /* Override any gcc2 internal prototype to avoid an error.  */
  /* We use char because int might match the return type of a gcc2
***************
*** 1457,1463 ****
  AFOpenAudioConn()
  ; return 0; }
  EOF
! if { (eval echo configure:1461: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
    rm -rf conftest*
    eval "ac_cv_lib_$ac_lib_var=yes"
  else
--- 1459,1465 ----
  AFOpenAudioConn()
  ; return 0; }
  EOF
! if { (eval echo configure:1463: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
    rm -rf conftest*
    eval "ac_cv_lib_$ac_lib_var=yes"
  else
***************
*** 1479,1485 ****
  fi
  
  echo $ac_n "checking for waveOutGetNumDevs in -lmme""... $ac_c" 1>&6
! echo "configure:1483: checking for waveOutGetNumDevs in -lmme" >&5
  ac_lib_var=`echo mme'_'waveOutGetNumDevs | sed 'y%./+-%__p_%'`
  if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
--- 1481,1487 ----
  fi
  
  echo $ac_n "checking for waveOutGetNumDevs in -lmme""... $ac_c" 1>&6
! echo "configure:1485: checking for waveOutGetNumDevs in -lmme" >&5
  ac_lib_var=`echo mme'_'waveOutGetNumDevs | sed 'y%./+-%__p_%'`
  if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
***************
*** 1487,1493 ****
    ac_save_LIBS="$LIBS"
  LIBS="-lmme  $LIBS"
  cat > conftest.$ac_ext <<EOF
! #line 1491 "configure"
  #include "confdefs.h"
  /* Override any gcc2 internal prototype to avoid an error.  */
  /* We use char because int might match the return type of a gcc2
--- 1489,1495 ----
    ac_save_LIBS="$LIBS"
  LIBS="-lmme  $LIBS"
  cat > conftest.$ac_ext <<EOF
! #line 1493 "configure"
  #include "confdefs.h"
  /* Override any gcc2 internal prototype to avoid an error.  */
  /* We use char because int might match the return type of a gcc2
***************
*** 1498,1504 ****
  waveOutGetNumDevs()
  ; return 0; }
  EOF
! if { (eval echo configure:1502: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
    rm -rf conftest*
    eval "ac_cv_lib_$ac_lib_var=yes"
  else
--- 1500,1506 ----
  waveOutGetNumDevs()
  ; return 0; }
  EOF
! if { (eval echo configure:1504: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
    rm -rf conftest*
    eval "ac_cv_lib_$ac_lib_var=yes"
  else
***************
*** 1520,1526 ****
  fi
  
  echo $ac_n "checking for waddch in -lncurses""... $ac_c" 1>&6
! echo "configure:1524: checking for waddch in -lncurses" >&5
  ac_lib_var=`echo ncurses'_'waddch | sed 'y%./+-%__p_%'`
  if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
--- 1522,1528 ----
  fi
  
  echo $ac_n "checking for waddch in -lncurses""... $ac_c" 1>&6
! echo "configure:1526: checking for waddch in -lncurses" >&5
  ac_lib_var=`echo ncurses'_'waddch | sed 'y%./+-%__p_%'`
  if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
***************
*** 1528,1534 ****
    ac_save_LIBS="$LIBS"
  LIBS="-lncurses  $LIBS"
  cat > conftest.$ac_ext <<EOF
! #line 1532 "configure"
  #include "confdefs.h"
  /* Override any gcc2 internal prototype to avoid an error.  */
  /* We use char because int might match the return type of a gcc2
--- 1530,1536 ----
    ac_save_LIBS="$LIBS"
  LIBS="-lncurses  $LIBS"
  cat > conftest.$ac_ext <<EOF
! #line 1534 "configure"
  #include "confdefs.h"
  /* Override any gcc2 internal prototype to avoid an error.  */
  /* We use char because int might match the return type of a gcc2
***************
*** 1539,1545 ****
  waddch()
  ; return 0; }
  EOF
! if { (eval echo configure:1543: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
    rm -rf conftest*
    eval "ac_cv_lib_$ac_lib_var=yes"
  else
--- 1541,1547 ----
  waddch()
  ; return 0; }
  EOF
! if { (eval echo configure:1545: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
    rm -rf conftest*
    eval "ac_cv_lib_$ac_lib_var=yes"
  else
***************
*** 1561,1567 ****
  fi
  
  echo $ac_n "checking for sem_init in -lposix4""... $ac_c" 1>&6
! echo "configure:1565: checking for sem_init in -lposix4" >&5
  ac_lib_var=`echo posix4'_'sem_init | sed 'y%./+-%__p_%'`
  if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
--- 1563,1569 ----
  fi
  
  echo $ac_n "checking for sem_init in -lposix4""... $ac_c" 1>&6
! echo "configure:1567: checking for sem_init in -lposix4" >&5
  ac_lib_var=`echo posix4'_'sem_init | sed 'y%./+-%__p_%'`
  if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
***************
*** 1569,1575 ****
    ac_save_LIBS="$LIBS"
  LIBS="-lposix4  $LIBS"
  cat > conftest.$ac_ext <<EOF
! #line 1573 "configure"
  #include "confdefs.h"
  /* Override any gcc2 internal prototype to avoid an error.  */
  /* We use char because int might match the return type of a gcc2
--- 1571,1577 ----
    ac_save_LIBS="$LIBS"
  LIBS="-lposix4  $LIBS"
  cat > conftest.$ac_ext <<EOF
! #line 1575 "configure"
  #include "confdefs.h"
  /* Override any gcc2 internal prototype to avoid an error.  */
  /* We use char because int might match the return type of a gcc2
***************
*** 1580,1586 ****
  sem_init()
  ; return 0; }
  EOF
! if { (eval echo configure:1584: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
    rm -rf conftest*
    eval "ac_cv_lib_$ac_lib_var=yes"
  else
--- 1582,1588 ----
  sem_init()
  ; return 0; }
  EOF
! if { (eval echo configure:1586: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
    rm -rf conftest*
    eval "ac_cv_lib_$ac_lib_var=yes"
  else
***************
*** 1602,1608 ****
  fi
  
  echo $ac_n "checking for sem_init in -lrt""... $ac_c" 1>&6
! echo "configure:1606: checking for sem_init in -lrt" >&5
  ac_lib_var=`echo rt'_'sem_init | sed 'y%./+-%__p_%'`
  if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
--- 1604,1610 ----
  fi
  
  echo $ac_n "checking for sem_init in -lrt""... $ac_c" 1>&6
! echo "configure:1608: checking for sem_init in -lrt" >&5
  ac_lib_var=`echo rt'_'sem_init | sed 'y%./+-%__p_%'`
  if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
***************
*** 1610,1616 ****
    ac_save_LIBS="$LIBS"
  LIBS="-lrt  $LIBS"
  cat > conftest.$ac_ext <<EOF
! #line 1614 "configure"
  #include "confdefs.h"
  /* Override any gcc2 internal prototype to avoid an error.  */
  /* We use char because int might match the return type of a gcc2
--- 1612,1618 ----
    ac_save_LIBS="$LIBS"
  LIBS="-lrt  $LIBS"
  cat > conftest.$ac_ext <<EOF
! #line 1616 "configure"
  #include "confdefs.h"
  /* Override any gcc2 internal prototype to avoid an error.  */
  /* We use char because int might match the return type of a gcc2
***************
*** 1621,1627 ****
  sem_init()
  ; return 0; }
  EOF
! if { (eval echo configure:1625: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
    rm -rf conftest*
    eval "ac_cv_lib_$ac_lib_var=yes"
  else
--- 1623,1629 ----
  sem_init()
  ; return 0; }
  EOF
! if { (eval echo configure:1627: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
    rm -rf conftest*
    eval "ac_cv_lib_$ac_lib_var=yes"
  else
***************
*** 1643,1649 ****
  fi
  
  echo $ac_n "checking for alOpenPort in -laudio""... $ac_c" 1>&6
! echo "configure:1647: checking for alOpenPort in -laudio" >&5
  ac_lib_var=`echo audio'_'alOpenPort | sed 'y%./+-%__p_%'`
  if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
--- 1645,1651 ----
  fi
  
  echo $ac_n "checking for alOpenPort in -laudio""... $ac_c" 1>&6
! echo "configure:1649: checking for alOpenPort in -laudio" >&5
  ac_lib_var=`echo audio'_'alOpenPort | sed 'y%./+-%__p_%'`
  if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
***************
*** 1651,1657 ****
    ac_save_LIBS="$LIBS"
  LIBS="-laudio  $LIBS"
  cat > conftest.$ac_ext <<EOF
! #line 1655 "configure"
  #include "confdefs.h"
  /* Override any gcc2 internal prototype to avoid an error.  */
  /* We use char because int might match the return type of a gcc2
--- 1653,1659 ----
    ac_save_LIBS="$LIBS"
  LIBS="-laudio  $LIBS"
  cat > conftest.$ac_ext <<EOF
! #line 1657 "configure"
  #include "confdefs.h"
  /* Override any gcc2 internal prototype to avoid an error.  */
  /* We use char because int might match the return type of a gcc2
***************
*** 1662,1668 ****
  alOpenPort()
  ; return 0; }
  EOF
! if { (eval echo configure:1666: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
    rm -rf conftest*
    eval "ac_cv_lib_$ac_lib_var=yes"
  else
--- 1664,1670 ----
  alOpenPort()
  ; return 0; }
  EOF
! if { (eval echo configure:1668: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
    rm -rf conftest*
    eval "ac_cv_lib_$ac_lib_var=yes"
  else
***************
*** 1689,1695 ****
  # Uses ac_ vars as temps to allow command line to override cache and checks.
  # --without-x overrides everything else, but does not touch the cache.
  echo $ac_n "checking for X""... $ac_c" 1>&6
! echo "configure:1693: checking for X" >&5
  
  # Check whether --with-x or --without-x was given.
  if test "${with_x+set}" = set; then
--- 1691,1697 ----
  # Uses ac_ vars as temps to allow command line to override cache and checks.
  # --without-x overrides everything else, but does not touch the cache.
  echo $ac_n "checking for X""... $ac_c" 1>&6
! echo "configure:1695: checking for X" >&5
  
  # Check whether --with-x or --without-x was given.
  if test "${with_x+set}" = set; then
***************
*** 1751,1762 ****
  
    # First, try using that file with no special directory specified.
  cat > conftest.$ac_ext <<EOF
! #line 1755 "configure"
  #include "confdefs.h"
  #include <$x_direct_test_include>
  EOF
  ac_try="$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out"
! { (eval echo configure:1760: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
  ac_err=`grep -v '^ *+' conftest.out | grep -v "^conftest.${ac_ext}\$"`
  if test -z "$ac_err"; then
    rm -rf conftest*
--- 1753,1764 ----
  
    # First, try using that file with no special directory specified.
  cat > conftest.$ac_ext <<EOF
! #line 1757 "configure"
  #include "confdefs.h"
  #include <$x_direct_test_include>
  EOF
  ac_try="$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out"
! { (eval echo configure:1762: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
  ac_err=`grep -v '^ *+' conftest.out | grep -v "^conftest.${ac_ext}\$"`
  if test -z "$ac_err"; then
    rm -rf conftest*
***************
*** 1825,1838 ****
    ac_save_LIBS="$LIBS"
    LIBS="-l$x_direct_test_library $LIBS"
  cat > conftest.$ac_ext <<EOF
! #line 1829 "configure"
  #include "confdefs.h"
  
  int main() {
  ${x_direct_test_function}()
  ; return 0; }
  EOF
! if { (eval echo configure:1836: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
    rm -rf conftest*
    LIBS="$ac_save_LIBS"
  # We can link X programs with no special library path.
--- 1827,1840 ----
    ac_save_LIBS="$LIBS"
    LIBS="-l$x_direct_test_library $LIBS"
  cat > conftest.$ac_ext <<EOF
! #line 1831 "configure"
  #include "confdefs.h"
  
  int main() {
  ${x_direct_test_function}()
  ; return 0; }
  EOF
! if { (eval echo configure:1838: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
    rm -rf conftest*
    LIBS="$ac_save_LIBS"
  # We can link X programs with no special library path.
***************
*** 1938,1954 ****
      case "`(uname -sr) 2>/dev/null`" in
      "SunOS 5"*)
        echo $ac_n "checking whether -R must be followed by a space""... $ac_c" 1>&6
! echo "configure:1942: checking whether -R must be followed by a space" >&5
        ac_xsave_LIBS="$LIBS"; LIBS="$LIBS -R$x_libraries"
        cat > conftest.$ac_ext <<EOF
! #line 1945 "configure"
  #include "confdefs.h"
  
  int main() {
  
  ; return 0; }
  EOF
! if { (eval echo configure:1952: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
    rm -rf conftest*
    ac_R_nospace=yes
  else
--- 1940,1956 ----
      case "`(uname -sr) 2>/dev/null`" in
      "SunOS 5"*)
        echo $ac_n "checking whether -R must be followed by a space""... $ac_c" 1>&6
! echo "configure:1944: checking whether -R must be followed by a space" >&5
        ac_xsave_LIBS="$LIBS"; LIBS="$LIBS -R$x_libraries"
        cat > conftest.$ac_ext <<EOF
! #line 1947 "configure"
  #include "confdefs.h"
  
  int main() {
  
  ; return 0; }
  EOF
! if { (eval echo configure:1954: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
    rm -rf conftest*
    ac_R_nospace=yes
  else
***************
*** 1964,1977 ****
        else
  	LIBS="$ac_xsave_LIBS -R $x_libraries"
  	cat > conftest.$ac_ext <<EOF
! #line 1968 "configure"
  #include "confdefs.h"
  
  int main() {
  
  ; return 0; }
  EOF
! if { (eval echo configure:1975: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
    rm -rf conftest*
    ac_R_space=yes
  else
--- 1966,1979 ----
        else
  	LIBS="$ac_xsave_LIBS -R $x_libraries"
  	cat > conftest.$ac_ext <<EOF
! #line 1970 "configure"
  #include "confdefs.h"
  
  int main() {
  
  ; return 0; }
  EOF
! if { (eval echo configure:1977: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
    rm -rf conftest*
    ac_R_space=yes
  else
***************
*** 2003,2009 ****
      # libraries were built with DECnet support.  And karl@cs.umb.edu says
      # the Alpha needs dnet_stub (dnet does not exist).
      echo $ac_n "checking for dnet_ntoa in -ldnet""... $ac_c" 1>&6
! echo "configure:2007: checking for dnet_ntoa in -ldnet" >&5
  ac_lib_var=`echo dnet'_'dnet_ntoa | sed 'y%./+-%__p_%'`
  if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
--- 2005,2011 ----
      # libraries were built with DECnet support.  And karl@cs.umb.edu says
      # the Alpha needs dnet_stub (dnet does not exist).
      echo $ac_n "checking for dnet_ntoa in -ldnet""... $ac_c" 1>&6
! echo "configure:2009: checking for dnet_ntoa in -ldnet" >&5
  ac_lib_var=`echo dnet'_'dnet_ntoa | sed 'y%./+-%__p_%'`
  if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
***************
*** 2011,2017 ****
    ac_save_LIBS="$LIBS"
  LIBS="-ldnet  $LIBS"
  cat > conftest.$ac_ext <<EOF
! #line 2015 "configure"
  #include "confdefs.h"
  /* Override any gcc2 internal prototype to avoid an error.  */
  /* We use char because int might match the return type of a gcc2
--- 2013,2019 ----
    ac_save_LIBS="$LIBS"
  LIBS="-ldnet  $LIBS"
  cat > conftest.$ac_ext <<EOF
! #line 2017 "configure"
  #include "confdefs.h"
  /* Override any gcc2 internal prototype to avoid an error.  */
  /* We use char because int might match the return type of a gcc2
***************
*** 2022,2028 ****
  dnet_ntoa()
  ; return 0; }
  EOF
! if { (eval echo configure:2026: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
    rm -rf conftest*
    eval "ac_cv_lib_$ac_lib_var=yes"
  else
--- 2024,2030 ----
  dnet_ntoa()
  ; return 0; }
  EOF
! if { (eval echo configure:2028: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
    rm -rf conftest*
    eval "ac_cv_lib_$ac_lib_var=yes"
  else
***************
*** 2044,2050 ****
  
      if test $ac_cv_lib_dnet_dnet_ntoa = no; then
        echo $ac_n "checking for dnet_ntoa in -ldnet_stub""... $ac_c" 1>&6
! echo "configure:2048: checking for dnet_ntoa in -ldnet_stub" >&5
  ac_lib_var=`echo dnet_stub'_'dnet_ntoa | sed 'y%./+-%__p_%'`
  if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
--- 2046,2052 ----
  
      if test $ac_cv_lib_dnet_dnet_ntoa = no; then
        echo $ac_n "checking for dnet_ntoa in -ldnet_stub""... $ac_c" 1>&6
! echo "configure:2050: checking for dnet_ntoa in -ldnet_stub" >&5
  ac_lib_var=`echo dnet_stub'_'dnet_ntoa | sed 'y%./+-%__p_%'`
  if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
***************
*** 2052,2058 ****
    ac_save_LIBS="$LIBS"
  LIBS="-ldnet_stub  $LIBS"
  cat > conftest.$ac_ext <<EOF
! #line 2056 "configure"
  #include "confdefs.h"
  /* Override any gcc2 internal prototype to avoid an error.  */
  /* We use char because int might match the return type of a gcc2
--- 2054,2060 ----
    ac_save_LIBS="$LIBS"
  LIBS="-ldnet_stub  $LIBS"
  cat > conftest.$ac_ext <<EOF
! #line 2058 "configure"
  #include "confdefs.h"
  /* Override any gcc2 internal prototype to avoid an error.  */
  /* We use char because int might match the return type of a gcc2
***************
*** 2063,2069 ****
  dnet_ntoa()
  ; return 0; }
  EOF
! if { (eval echo configure:2067: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
    rm -rf conftest*
    eval "ac_cv_lib_$ac_lib_var=yes"
  else
--- 2065,2071 ----
  dnet_ntoa()
  ; return 0; }
  EOF
! if { (eval echo configure:2069: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
    rm -rf conftest*
    eval "ac_cv_lib_$ac_lib_var=yes"
  else
***************
*** 2092,2103 ****
      # The nsl library prevents programs from opening the X display
      # on Irix 5.2, according to dickey@clark.net.
      echo $ac_n "checking for gethostbyname""... $ac_c" 1>&6
! echo "configure:2096: checking for gethostbyname" >&5
  if eval "test \"`echo '$''{'ac_cv_func_gethostbyname'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
    cat > conftest.$ac_ext <<EOF
! #line 2101 "configure"
  #include "confdefs.h"
  /* System header to define __stub macros and hopefully few prototypes,
      which can conflict with char gethostbyname(); below.  */
--- 2094,2105 ----
      # The nsl library prevents programs from opening the X display
      # on Irix 5.2, according to dickey@clark.net.
      echo $ac_n "checking for gethostbyname""... $ac_c" 1>&6
! echo "configure:2098: checking for gethostbyname" >&5
  if eval "test \"`echo '$''{'ac_cv_func_gethostbyname'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
    cat > conftest.$ac_ext <<EOF
! #line 2103 "configure"
  #include "confdefs.h"
  /* System header to define __stub macros and hopefully few prototypes,
      which can conflict with char gethostbyname(); below.  */
***************
*** 2120,2126 ****
  
  ; return 0; }
  EOF
! if { (eval echo configure:2124: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
    rm -rf conftest*
    eval "ac_cv_func_gethostbyname=yes"
  else
--- 2122,2128 ----
  
  ; return 0; }
  EOF
! if { (eval echo configure:2126: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
    rm -rf conftest*
    eval "ac_cv_func_gethostbyname=yes"
  else
***************
*** 2141,2147 ****
  
      if test $ac_cv_func_gethostbyname = no; then
        echo $ac_n "checking for gethostbyname in -lnsl""... $ac_c" 1>&6
! echo "configure:2145: checking for gethostbyname in -lnsl" >&5
  ac_lib_var=`echo nsl'_'gethostbyname | sed 'y%./+-%__p_%'`
  if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
--- 2143,2149 ----
  
      if test $ac_cv_func_gethostbyname = no; then
        echo $ac_n "checking for gethostbyname in -lnsl""... $ac_c" 1>&6
! echo "configure:2147: checking for gethostbyname in -lnsl" >&5
  ac_lib_var=`echo nsl'_'gethostbyname | sed 'y%./+-%__p_%'`
  if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
***************
*** 2149,2155 ****
    ac_save_LIBS="$LIBS"
  LIBS="-lnsl  $LIBS"
  cat > conftest.$ac_ext <<EOF
! #line 2153 "configure"
  #include "confdefs.h"
  /* Override any gcc2 internal prototype to avoid an error.  */
  /* We use char because int might match the return type of a gcc2
--- 2151,2157 ----
    ac_save_LIBS="$LIBS"
  LIBS="-lnsl  $LIBS"
  cat > conftest.$ac_ext <<EOF
! #line 2155 "configure"
  #include "confdefs.h"
  /* Override any gcc2 internal prototype to avoid an error.  */
  /* We use char because int might match the return type of a gcc2
***************
*** 2160,2166 ****
  gethostbyname()
  ; return 0; }
  EOF
! if { (eval echo configure:2164: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
    rm -rf conftest*
    eval "ac_cv_lib_$ac_lib_var=yes"
  else
--- 2162,2168 ----
  gethostbyname()
  ; return 0; }
  EOF
! if { (eval echo configure:2166: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
    rm -rf conftest*
    eval "ac_cv_lib_$ac_lib_var=yes"
  else
***************
*** 2190,2201 ****
      # -lsocket must be given before -lnsl if both are needed.
      # We assume that if connect needs -lnsl, so does gethostbyname.
      echo $ac_n "checking for connect""... $ac_c" 1>&6
! echo "configure:2194: checking for connect" >&5
  if eval "test \"`echo '$''{'ac_cv_func_connect'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
    cat > conftest.$ac_ext <<EOF
! #line 2199 "configure"
  #include "confdefs.h"
  /* System header to define __stub macros and hopefully few prototypes,
      which can conflict with char connect(); below.  */
--- 2192,2203 ----
      # -lsocket must be given before -lnsl if both are needed.
      # We assume that if connect needs -lnsl, so does gethostbyname.
      echo $ac_n "checking for connect""... $ac_c" 1>&6
! echo "configure:2196: checking for connect" >&5
  if eval "test \"`echo '$''{'ac_cv_func_connect'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
    cat > conftest.$ac_ext <<EOF
! #line 2201 "configure"
  #include "confdefs.h"
  /* System header to define __stub macros and hopefully few prototypes,
      which can conflict with char connect(); below.  */
***************
*** 2218,2224 ****
  
  ; return 0; }
  EOF
! if { (eval echo configure:2222: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
    rm -rf conftest*
    eval "ac_cv_func_connect=yes"
  else
--- 2220,2226 ----
  
  ; return 0; }
  EOF
! if { (eval echo configure:2224: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
    rm -rf conftest*
    eval "ac_cv_func_connect=yes"
  else
***************
*** 2239,2245 ****
  
      if test $ac_cv_func_connect = no; then
        echo $ac_n "checking for connect in -lsocket""... $ac_c" 1>&6
! echo "configure:2243: checking for connect in -lsocket" >&5
  ac_lib_var=`echo socket'_'connect | sed 'y%./+-%__p_%'`
  if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
--- 2241,2247 ----
  
      if test $ac_cv_func_connect = no; then
        echo $ac_n "checking for connect in -lsocket""... $ac_c" 1>&6
! echo "configure:2245: checking for connect in -lsocket" >&5
  ac_lib_var=`echo socket'_'connect | sed 'y%./+-%__p_%'`
  if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
***************
*** 2247,2253 ****
    ac_save_LIBS="$LIBS"
  LIBS="-lsocket $X_EXTRA_LIBS $LIBS"
  cat > conftest.$ac_ext <<EOF
! #line 2251 "configure"
  #include "confdefs.h"
  /* Override any gcc2 internal prototype to avoid an error.  */
  /* We use char because int might match the return type of a gcc2
--- 2249,2255 ----
    ac_save_LIBS="$LIBS"
  LIBS="-lsocket $X_EXTRA_LIBS $LIBS"
  cat > conftest.$ac_ext <<EOF
! #line 2253 "configure"
  #include "confdefs.h"
  /* Override any gcc2 internal prototype to avoid an error.  */
  /* We use char because int might match the return type of a gcc2
***************
*** 2258,2264 ****
  connect()
  ; return 0; }
  EOF
! if { (eval echo configure:2262: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
    rm -rf conftest*
    eval "ac_cv_lib_$ac_lib_var=yes"
  else
--- 2260,2266 ----
  connect()
  ; return 0; }
  EOF
! if { (eval echo configure:2264: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
    rm -rf conftest*
    eval "ac_cv_lib_$ac_lib_var=yes"
  else
***************
*** 2282,2293 ****
  
      # gomez@mi.uni-erlangen.de says -lposix is necessary on A/UX.
      echo $ac_n "checking for remove""... $ac_c" 1>&6
! echo "configure:2286: checking for remove" >&5
  if eval "test \"`echo '$''{'ac_cv_func_remove'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
    cat > conftest.$ac_ext <<EOF
! #line 2291 "configure"
  #include "confdefs.h"
  /* System header to define __stub macros and hopefully few prototypes,
      which can conflict with char remove(); below.  */
--- 2284,2295 ----
  
      # gomez@mi.uni-erlangen.de says -lposix is necessary on A/UX.
      echo $ac_n "checking for remove""... $ac_c" 1>&6
! echo "configure:2288: checking for remove" >&5
  if eval "test \"`echo '$''{'ac_cv_func_remove'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
    cat > conftest.$ac_ext <<EOF
! #line 2293 "configure"
  #include "confdefs.h"
  /* System header to define __stub macros and hopefully few prototypes,
      which can conflict with char remove(); below.  */
***************
*** 2310,2316 ****
  
  ; return 0; }
  EOF
! if { (eval echo configure:2314: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
    rm -rf conftest*
    eval "ac_cv_func_remove=yes"
  else
--- 2312,2318 ----
  
  ; return 0; }
  EOF
! if { (eval echo configure:2316: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
    rm -rf conftest*
    eval "ac_cv_func_remove=yes"
  else
***************
*** 2331,2337 ****
  
      if test $ac_cv_func_remove = no; then
        echo $ac_n "checking for remove in -lposix""... $ac_c" 1>&6
! echo "configure:2335: checking for remove in -lposix" >&5
  ac_lib_var=`echo posix'_'remove | sed 'y%./+-%__p_%'`
  if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
--- 2333,2339 ----
  
      if test $ac_cv_func_remove = no; then
        echo $ac_n "checking for remove in -lposix""... $ac_c" 1>&6
! echo "configure:2337: checking for remove in -lposix" >&5
  ac_lib_var=`echo posix'_'remove | sed 'y%./+-%__p_%'`
  if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
***************
*** 2339,2345 ****
    ac_save_LIBS="$LIBS"
  LIBS="-lposix  $LIBS"
  cat > conftest.$ac_ext <<EOF
! #line 2343 "configure"
  #include "confdefs.h"
  /* Override any gcc2 internal prototype to avoid an error.  */
  /* We use char because int might match the return type of a gcc2
--- 2341,2347 ----
    ac_save_LIBS="$LIBS"
  LIBS="-lposix  $LIBS"
  cat > conftest.$ac_ext <<EOF
! #line 2345 "configure"
  #include "confdefs.h"
  /* Override any gcc2 internal prototype to avoid an error.  */
  /* We use char because int might match the return type of a gcc2
***************
*** 2350,2356 ****
  remove()
  ; return 0; }
  EOF
! if { (eval echo configure:2354: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
    rm -rf conftest*
    eval "ac_cv_lib_$ac_lib_var=yes"
  else
--- 2352,2358 ----
  remove()
  ; return 0; }
  EOF
! if { (eval echo configure:2356: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
    rm -rf conftest*
    eval "ac_cv_lib_$ac_lib_var=yes"
  else
***************
*** 2374,2385 ****
  
      # BSDI BSD/OS 2.1 needs -lipc for XOpenDisplay.
      echo $ac_n "checking for shmat""... $ac_c" 1>&6
! echo "configure:2378: checking for shmat" >&5
  if eval "test \"`echo '$''{'ac_cv_func_shmat'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
    cat > conftest.$ac_ext <<EOF
! #line 2383 "configure"
  #include "confdefs.h"
  /* System header to define __stub macros and hopefully few prototypes,
      which can conflict with char shmat(); below.  */
--- 2376,2387 ----
  
      # BSDI BSD/OS 2.1 needs -lipc for XOpenDisplay.
      echo $ac_n "checking for shmat""... $ac_c" 1>&6
! echo "configure:2380: checking for shmat" >&5
  if eval "test \"`echo '$''{'ac_cv_func_shmat'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
    cat > conftest.$ac_ext <<EOF
! #line 2385 "configure"
  #include "confdefs.h"
  /* System header to define __stub macros and hopefully few prototypes,
      which can conflict with char shmat(); below.  */
***************
*** 2402,2408 ****
  
  ; return 0; }
  EOF
! if { (eval echo configure:2406: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
    rm -rf conftest*
    eval "ac_cv_func_shmat=yes"
  else
--- 2404,2410 ----
  
  ; return 0; }
  EOF
! if { (eval echo configure:2408: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
    rm -rf conftest*
    eval "ac_cv_func_shmat=yes"
  else
***************
*** 2423,2429 ****
  
      if test $ac_cv_func_shmat = no; then
        echo $ac_n "checking for shmat in -lipc""... $ac_c" 1>&6
! echo "configure:2427: checking for shmat in -lipc" >&5
  ac_lib_var=`echo ipc'_'shmat | sed 'y%./+-%__p_%'`
  if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
--- 2425,2431 ----
  
      if test $ac_cv_func_shmat = no; then
        echo $ac_n "checking for shmat in -lipc""... $ac_c" 1>&6
! echo "configure:2429: checking for shmat in -lipc" >&5
  ac_lib_var=`echo ipc'_'shmat | sed 'y%./+-%__p_%'`
  if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
***************
*** 2431,2437 ****
    ac_save_LIBS="$LIBS"
  LIBS="-lipc  $LIBS"
  cat > conftest.$ac_ext <<EOF
! #line 2435 "configure"
  #include "confdefs.h"
  /* Override any gcc2 internal prototype to avoid an error.  */
  /* We use char because int might match the return type of a gcc2
--- 2433,2439 ----
    ac_save_LIBS="$LIBS"
  LIBS="-lipc  $LIBS"
  cat > conftest.$ac_ext <<EOF
! #line 2437 "configure"
  #include "confdefs.h"
  /* Override any gcc2 internal prototype to avoid an error.  */
  /* We use char because int might match the return type of a gcc2
***************
*** 2442,2448 ****
  shmat()
  ; return 0; }
  EOF
! if { (eval echo configure:2446: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
    rm -rf conftest*
    eval "ac_cv_lib_$ac_lib_var=yes"
  else
--- 2444,2450 ----
  shmat()
  ; return 0; }
  EOF
! if { (eval echo configure:2448: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
    rm -rf conftest*
    eval "ac_cv_lib_$ac_lib_var=yes"
  else
***************
*** 2475,2481 ****
    # libraries we check for below, so use a different variable.
    #  --interran@uluru.Stanford.EDU, kb@cs.umb.edu.
    echo $ac_n "checking for IceConnectionNumber in -lICE""... $ac_c" 1>&6
! echo "configure:2479: checking for IceConnectionNumber in -lICE" >&5
  ac_lib_var=`echo ICE'_'IceConnectionNumber | sed 'y%./+-%__p_%'`
  if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
--- 2477,2483 ----
    # libraries we check for below, so use a different variable.
    #  --interran@uluru.Stanford.EDU, kb@cs.umb.edu.
    echo $ac_n "checking for IceConnectionNumber in -lICE""... $ac_c" 1>&6
! echo "configure:2481: checking for IceConnectionNumber in -lICE" >&5
  ac_lib_var=`echo ICE'_'IceConnectionNumber | sed 'y%./+-%__p_%'`
  if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
***************
*** 2483,2489 ****
    ac_save_LIBS="$LIBS"
  LIBS="-lICE $X_EXTRA_LIBS $LIBS"
  cat > conftest.$ac_ext <<EOF
! #line 2487 "configure"
  #include "confdefs.h"
  /* Override any gcc2 internal prototype to avoid an error.  */
  /* We use char because int might match the return type of a gcc2
--- 2485,2491 ----
    ac_save_LIBS="$LIBS"
  LIBS="-lICE $X_EXTRA_LIBS $LIBS"
  cat > conftest.$ac_ext <<EOF
! #line 2489 "configure"
  #include "confdefs.h"
  /* Override any gcc2 internal prototype to avoid an error.  */
  /* We use char because int might match the return type of a gcc2
***************
*** 2494,2500 ****
  IceConnectionNumber()
  ; return 0; }
  EOF
! if { (eval echo configure:2498: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
    rm -rf conftest*
    eval "ac_cv_lib_$ac_lib_var=yes"
  else
--- 2496,2502 ----
  IceConnectionNumber()
  ; return 0; }
  EOF
! if { (eval echo configure:2500: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
    rm -rf conftest*
    eval "ac_cv_lib_$ac_lib_var=yes"
  else
***************
*** 2525,2536 ****
  do
  ac_safe=`echo "$ac_hdr" | sed 'y%./+-%__p_%'`
  echo $ac_n "checking for $ac_hdr that defines DIR""... $ac_c" 1>&6
! echo "configure:2529: checking for $ac_hdr that defines DIR" >&5
  if eval "test \"`echo '$''{'ac_cv_header_dirent_$ac_safe'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
    cat > conftest.$ac_ext <<EOF
! #line 2534 "configure"
  #include "confdefs.h"
  #include <sys/types.h>
  #include <$ac_hdr>
--- 2527,2538 ----
  do
  ac_safe=`echo "$ac_hdr" | sed 'y%./+-%__p_%'`
  echo $ac_n "checking for $ac_hdr that defines DIR""... $ac_c" 1>&6
! echo "configure:2531: checking for $ac_hdr that defines DIR" >&5
  if eval "test \"`echo '$''{'ac_cv_header_dirent_$ac_safe'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
    cat > conftest.$ac_ext <<EOF
! #line 2536 "configure"
  #include "confdefs.h"
  #include <sys/types.h>
  #include <$ac_hdr>
***************
*** 2538,2544 ****
  DIR *dirp = 0;
  ; return 0; }
  EOF
! if { (eval echo configure:2542: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
    rm -rf conftest*
    eval "ac_cv_header_dirent_$ac_safe=yes"
  else
--- 2540,2546 ----
  DIR *dirp = 0;
  ; return 0; }
  EOF
! if { (eval echo configure:2544: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
    rm -rf conftest*
    eval "ac_cv_header_dirent_$ac_safe=yes"
  else
***************
*** 2563,2569 ****
  # Two versions of opendir et al. are in -ldir and -lx on SCO Xenix.
  if test $ac_header_dirent = dirent.h; then
  echo $ac_n "checking for opendir in -ldir""... $ac_c" 1>&6
! echo "configure:2567: checking for opendir in -ldir" >&5
  ac_lib_var=`echo dir'_'opendir | sed 'y%./+-%__p_%'`
  if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
--- 2565,2571 ----
  # Two versions of opendir et al. are in -ldir and -lx on SCO Xenix.
  if test $ac_header_dirent = dirent.h; then
  echo $ac_n "checking for opendir in -ldir""... $ac_c" 1>&6
! echo "configure:2569: checking for opendir in -ldir" >&5
  ac_lib_var=`echo dir'_'opendir | sed 'y%./+-%__p_%'`
  if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
***************
*** 2571,2577 ****
    ac_save_LIBS="$LIBS"
  LIBS="-ldir  $LIBS"
  cat > conftest.$ac_ext <<EOF
! #line 2575 "configure"
  #include "confdefs.h"
  /* Override any gcc2 internal prototype to avoid an error.  */
  /* We use char because int might match the return type of a gcc2
--- 2573,2579 ----
    ac_save_LIBS="$LIBS"
  LIBS="-ldir  $LIBS"
  cat > conftest.$ac_ext <<EOF
! #line 2577 "configure"
  #include "confdefs.h"
  /* Override any gcc2 internal prototype to avoid an error.  */
  /* We use char because int might match the return type of a gcc2
***************
*** 2582,2588 ****
  opendir()
  ; return 0; }
  EOF
! if { (eval echo configure:2586: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
    rm -rf conftest*
    eval "ac_cv_lib_$ac_lib_var=yes"
  else
--- 2584,2590 ----
  opendir()
  ; return 0; }
  EOF
! if { (eval echo configure:2588: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
    rm -rf conftest*
    eval "ac_cv_lib_$ac_lib_var=yes"
  else
***************
*** 2604,2610 ****
  
  else
  echo $ac_n "checking for opendir in -lx""... $ac_c" 1>&6
! echo "configure:2608: checking for opendir in -lx" >&5
  ac_lib_var=`echo x'_'opendir | sed 'y%./+-%__p_%'`
  if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
--- 2606,2612 ----
  
  else
  echo $ac_n "checking for opendir in -lx""... $ac_c" 1>&6
! echo "configure:2610: checking for opendir in -lx" >&5
  ac_lib_var=`echo x'_'opendir | sed 'y%./+-%__p_%'`
  if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
***************
*** 2612,2618 ****
    ac_save_LIBS="$LIBS"
  LIBS="-lx  $LIBS"
  cat > conftest.$ac_ext <<EOF
! #line 2616 "configure"
  #include "confdefs.h"
  /* Override any gcc2 internal prototype to avoid an error.  */
  /* We use char because int might match the return type of a gcc2
--- 2614,2620 ----
    ac_save_LIBS="$LIBS"
  LIBS="-lx  $LIBS"
  cat > conftest.$ac_ext <<EOF
! #line 2618 "configure"
  #include "confdefs.h"
  /* Override any gcc2 internal prototype to avoid an error.  */
  /* We use char because int might match the return type of a gcc2
***************
*** 2623,2629 ****
  opendir()
  ; return 0; }
  EOF
! if { (eval echo configure:2627: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
    rm -rf conftest*
    eval "ac_cv_lib_$ac_lib_var=yes"
  else
--- 2625,2631 ----
  opendir()
  ; return 0; }
  EOF
! if { (eval echo configure:2629: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
    rm -rf conftest*
    eval "ac_cv_lib_$ac_lib_var=yes"
  else
***************
*** 2646,2657 ****
  fi
  
  echo $ac_n "checking for ANSI C header files""... $ac_c" 1>&6
! echo "configure:2650: checking for ANSI C header files" >&5
  if eval "test \"`echo '$''{'ac_cv_header_stdc'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
    cat > conftest.$ac_ext <<EOF
! #line 2655 "configure"
  #include "confdefs.h"
  #include <stdlib.h>
  #include <stdarg.h>
--- 2648,2659 ----
  fi
  
  echo $ac_n "checking for ANSI C header files""... $ac_c" 1>&6
! echo "configure:2652: checking for ANSI C header files" >&5
  if eval "test \"`echo '$''{'ac_cv_header_stdc'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
    cat > conftest.$ac_ext <<EOF
! #line 2657 "configure"
  #include "confdefs.h"
  #include <stdlib.h>
  #include <stdarg.h>
***************
*** 2659,2665 ****
  #include <float.h>
  EOF
  ac_try="$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out"
! { (eval echo configure:2663: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
  ac_err=`grep -v '^ *+' conftest.out | grep -v "^conftest.${ac_ext}\$"`
  if test -z "$ac_err"; then
    rm -rf conftest*
--- 2661,2667 ----
  #include <float.h>
  EOF
  ac_try="$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out"
! { (eval echo configure:2665: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
  ac_err=`grep -v '^ *+' conftest.out | grep -v "^conftest.${ac_ext}\$"`
  if test -z "$ac_err"; then
    rm -rf conftest*
***************
*** 2676,2682 ****
  if test $ac_cv_header_stdc = yes; then
    # SunOS 4.x string.h does not declare mem*, contrary to ANSI.
  cat > conftest.$ac_ext <<EOF
! #line 2680 "configure"
  #include "confdefs.h"
  #include <string.h>
  EOF
--- 2678,2684 ----
  if test $ac_cv_header_stdc = yes; then
    # SunOS 4.x string.h does not declare mem*, contrary to ANSI.
  cat > conftest.$ac_ext <<EOF
! #line 2682 "configure"
  #include "confdefs.h"
  #include <string.h>
  EOF
***************
*** 2694,2700 ****
  if test $ac_cv_header_stdc = yes; then
    # ISC 2.0.2 stdlib.h does not declare free, contrary to ANSI.
  cat > conftest.$ac_ext <<EOF
! #line 2698 "configure"
  #include "confdefs.h"
  #include <stdlib.h>
  EOF
--- 2696,2702 ----
  if test $ac_cv_header_stdc = yes; then
    # ISC 2.0.2 stdlib.h does not declare free, contrary to ANSI.
  cat > conftest.$ac_ext <<EOF
! #line 2700 "configure"
  #include "confdefs.h"
  #include <stdlib.h>
  EOF
***************
*** 2715,2721 ****
    :
  else
    cat > conftest.$ac_ext <<EOF
! #line 2719 "configure"
  #include "confdefs.h"
  #include <ctype.h>
  #define ISLOWER(c) ('a' <= (c) && (c) <= 'z')
--- 2717,2723 ----
    :
  else
    cat > conftest.$ac_ext <<EOF
! #line 2721 "configure"
  #include "confdefs.h"
  #include <ctype.h>
  #define ISLOWER(c) ('a' <= (c) && (c) <= 'z')
***************
*** 2726,2732 ****
  exit (0); }
  
  EOF
! if { (eval echo configure:2730: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
  then
    :
  else
--- 2728,2734 ----
  exit (0); }
  
  EOF
! if { (eval echo configure:2732: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
  then
    :
  else
***************
*** 2754,2770 ****
  do
  ac_safe=`echo "$ac_hdr" | sed 'y%./+-%__p_%'`
  echo $ac_n "checking for $ac_hdr""... $ac_c" 1>&6
! echo "configure:2758: checking for $ac_hdr" >&5
  if eval "test \"`echo '$''{'ac_cv_header_$ac_safe'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
    cat > conftest.$ac_ext <<EOF
! #line 2763 "configure"
  #include "confdefs.h"
  #include <$ac_hdr>
  EOF
  ac_try="$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out"
! { (eval echo configure:2768: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
  ac_err=`grep -v '^ *+' conftest.out | grep -v "^conftest.${ac_ext}\$"`
  if test -z "$ac_err"; then
    rm -rf conftest*
--- 2756,2772 ----
  do
  ac_safe=`echo "$ac_hdr" | sed 'y%./+-%__p_%'`
  echo $ac_n "checking for $ac_hdr""... $ac_c" 1>&6
! echo "configure:2760: checking for $ac_hdr" >&5
  if eval "test \"`echo '$''{'ac_cv_header_$ac_safe'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
    cat > conftest.$ac_ext <<EOF
! #line 2765 "configure"
  #include "confdefs.h"
  #include <$ac_hdr>
  EOF
  ac_try="$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out"
! { (eval echo configure:2770: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
  ac_err=`grep -v '^ *+' conftest.out | grep -v "^conftest.${ac_ext}\$"`
  if test -z "$ac_err"; then
    rm -rf conftest*
***************
*** 2794,2810 ****
  do
  ac_safe=`echo "$ac_hdr" | sed 'y%./+-%__p_%'`
  echo $ac_n "checking for $ac_hdr""... $ac_c" 1>&6
! echo "configure:2798: checking for $ac_hdr" >&5
  if eval "test \"`echo '$''{'ac_cv_header_$ac_safe'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
    cat > conftest.$ac_ext <<EOF
! #line 2803 "configure"
  #include "confdefs.h"
  #include <$ac_hdr>
  EOF
  ac_try="$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out"
! { (eval echo configure:2808: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
  ac_err=`grep -v '^ *+' conftest.out | grep -v "^conftest.${ac_ext}\$"`
  if test -z "$ac_err"; then
    rm -rf conftest*
--- 2796,2812 ----
  do
  ac_safe=`echo "$ac_hdr" | sed 'y%./+-%__p_%'`
  echo $ac_n "checking for $ac_hdr""... $ac_c" 1>&6
! echo "configure:2800: checking for $ac_hdr" >&5
  if eval "test \"`echo '$''{'ac_cv_header_$ac_safe'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
    cat > conftest.$ac_ext <<EOF
! #line 2805 "configure"
  #include "confdefs.h"
  #include <$ac_hdr>
  EOF
  ac_try="$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out"
! { (eval echo configure:2810: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
  ac_err=`grep -v '^ *+' conftest.out | grep -v "^conftest.${ac_ext}\$"`
  if test -z "$ac_err"; then
    rm -rf conftest*
***************
*** 2834,2850 ****
  do
  ac_safe=`echo "$ac_hdr" | sed 'y%./+-%__p_%'`
  echo $ac_n "checking for $ac_hdr""... $ac_c" 1>&6
! echo "configure:2838: checking for $ac_hdr" >&5
  if eval "test \"`echo '$''{'ac_cv_header_$ac_safe'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
    cat > conftest.$ac_ext <<EOF
! #line 2843 "configure"
  #include "confdefs.h"
  #include <$ac_hdr>
  EOF
  ac_try="$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out"
! { (eval echo configure:2848: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
  ac_err=`grep -v '^ *+' conftest.out | grep -v "^conftest.${ac_ext}\$"`
  if test -z "$ac_err"; then
    rm -rf conftest*
--- 2836,2852 ----
  do
  ac_safe=`echo "$ac_hdr" | sed 'y%./+-%__p_%'`
  echo $ac_n "checking for $ac_hdr""... $ac_c" 1>&6
! echo "configure:2840: checking for $ac_hdr" >&5
  if eval "test \"`echo '$''{'ac_cv_header_$ac_safe'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
    cat > conftest.$ac_ext <<EOF
! #line 2845 "configure"
  #include "confdefs.h"
  #include <$ac_hdr>
  EOF
  ac_try="$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out"
! { (eval echo configure:2850: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
  ac_err=`grep -v '^ *+' conftest.out | grep -v "^conftest.${ac_ext}\$"`
  if test -z "$ac_err"; then
    rm -rf conftest*
***************
*** 2874,2890 ****
  do
  ac_safe=`echo "$ac_hdr" | sed 'y%./+-%__p_%'`
  echo $ac_n "checking for $ac_hdr""... $ac_c" 1>&6
! echo "configure:2878: checking for $ac_hdr" >&5
  if eval "test \"`echo '$''{'ac_cv_header_$ac_safe'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
    cat > conftest.$ac_ext <<EOF
! #line 2883 "configure"
  #include "confdefs.h"
  #include <$ac_hdr>
  EOF
  ac_try="$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out"
! { (eval echo configure:2888: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
  ac_err=`grep -v '^ *+' conftest.out | grep -v "^conftest.${ac_ext}\$"`
  if test -z "$ac_err"; then
    rm -rf conftest*
--- 2876,2892 ----
  do
  ac_safe=`echo "$ac_hdr" | sed 'y%./+-%__p_%'`
  echo $ac_n "checking for $ac_hdr""... $ac_c" 1>&6
! echo "configure:2880: checking for $ac_hdr" >&5
  if eval "test \"`echo '$''{'ac_cv_header_$ac_safe'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
    cat > conftest.$ac_ext <<EOF
! #line 2885 "configure"
  #include "confdefs.h"
  #include <$ac_hdr>
  EOF
  ac_try="$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out"
! { (eval echo configure:2890: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
  ac_err=`grep -v '^ *+' conftest.out | grep -v "^conftest.${ac_ext}\$"`
  if test -z "$ac_err"; then
    rm -rf conftest*
***************
*** 2912,2928 ****
  
  ac_safe=`echo "be_math.h" | sed 'y%./+-%__p_%'`
  echo $ac_n "checking for be_math.h""... $ac_c" 1>&6
! echo "configure:2916: checking for be_math.h" >&5
  if eval "test \"`echo '$''{'ac_cv_header_$ac_safe'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
    cat > conftest.$ac_ext <<EOF
! #line 2921 "configure"
  #include "confdefs.h"
  #include <be_math.h>
  EOF
  ac_try="$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out"
! { (eval echo configure:2926: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
  ac_err=`grep -v '^ *+' conftest.out | grep -v "^conftest.${ac_ext}\$"`
  if test -z "$ac_err"; then
    rm -rf conftest*
--- 2914,2930 ----
  
  ac_safe=`echo "be_math.h" | sed 'y%./+-%__p_%'`
  echo $ac_n "checking for be_math.h""... $ac_c" 1>&6
! echo "configure:2918: checking for be_math.h" >&5
  if eval "test \"`echo '$''{'ac_cv_header_$ac_safe'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
    cat > conftest.$ac_ext <<EOF
! #line 2923 "configure"
  #include "confdefs.h"
  #include <be_math.h>
  EOF
  ac_try="$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out"
! { (eval echo configure:2928: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
  ac_err=`grep -v '^ *+' conftest.out | grep -v "^conftest.${ac_ext}\$"`
  if test -z "$ac_err"; then
    rm -rf conftest*
***************
*** 2948,2964 ****
  do
  ac_safe=`echo "$ac_hdr" | sed 'y%./+-%__p_%'`
  echo $ac_n "checking for $ac_hdr""... $ac_c" 1>&6
! echo "configure:2952: checking for $ac_hdr" >&5
  if eval "test \"`echo '$''{'ac_cv_header_$ac_safe'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
    cat > conftest.$ac_ext <<EOF
! #line 2957 "configure"
  #include "confdefs.h"
  #include <$ac_hdr>
  EOF
  ac_try="$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out"
! { (eval echo configure:2962: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
  ac_err=`grep -v '^ *+' conftest.out | grep -v "^conftest.${ac_ext}\$"`
  if test -z "$ac_err"; then
    rm -rf conftest*
--- 2950,2966 ----
  do
  ac_safe=`echo "$ac_hdr" | sed 'y%./+-%__p_%'`
  echo $ac_n "checking for $ac_hdr""... $ac_c" 1>&6
! echo "configure:2954: checking for $ac_hdr" >&5
  if eval "test \"`echo '$''{'ac_cv_header_$ac_safe'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
    cat > conftest.$ac_ext <<EOF
! #line 2959 "configure"
  #include "confdefs.h"
  #include <$ac_hdr>
  EOF
  ac_try="$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out"
! { (eval echo configure:2964: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
  ac_err=`grep -v '^ *+' conftest.out | grep -v "^conftest.${ac_ext}\$"`
  if test -z "$ac_err"; then
    rm -rf conftest*
***************
*** 2988,3004 ****
  do
  ac_safe=`echo "$ac_hdr" | sed 'y%./+-%__p_%'`
  echo $ac_n "checking for $ac_hdr""... $ac_c" 1>&6
! echo "configure:2992: checking for $ac_hdr" >&5
  if eval "test \"`echo '$''{'ac_cv_header_$ac_safe'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
    cat > conftest.$ac_ext <<EOF
! #line 2997 "configure"
  #include "confdefs.h"
  #include <$ac_hdr>
  EOF
  ac_try="$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out"
! { (eval echo configure:3002: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
  ac_err=`grep -v '^ *+' conftest.out | grep -v "^conftest.${ac_ext}\$"`
  if test -z "$ac_err"; then
    rm -rf conftest*
--- 2990,3006 ----
  do
  ac_safe=`echo "$ac_hdr" | sed 'y%./+-%__p_%'`
  echo $ac_n "checking for $ac_hdr""... $ac_c" 1>&6
! echo "configure:2994: checking for $ac_hdr" >&5
  if eval "test \"`echo '$''{'ac_cv_header_$ac_safe'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
    cat > conftest.$ac_ext <<EOF
! #line 2999 "configure"
  #include "confdefs.h"
  #include <$ac_hdr>
  EOF
  ac_try="$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out"
! { (eval echo configure:3004: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
  ac_err=`grep -v '^ *+' conftest.out | grep -v "^conftest.${ac_ext}\$"`
  if test -z "$ac_err"; then
    rm -rf conftest*
***************
*** 3028,3044 ****
  do
  ac_safe=`echo "$ac_hdr" | sed 'y%./+-%__p_%'`
  echo $ac_n "checking for $ac_hdr""... $ac_c" 1>&6
! echo "configure:3032: checking for $ac_hdr" >&5
  if eval "test \"`echo '$''{'ac_cv_header_$ac_safe'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
    cat > conftest.$ac_ext <<EOF
! #line 3037 "configure"
  #include "confdefs.h"
  #include <$ac_hdr>
  EOF
  ac_try="$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out"
! { (eval echo configure:3042: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
  ac_err=`grep -v '^ *+' conftest.out | grep -v "^conftest.${ac_ext}\$"`
  if test -z "$ac_err"; then
    rm -rf conftest*
--- 3030,3046 ----
  do
  ac_safe=`echo "$ac_hdr" | sed 'y%./+-%__p_%'`
  echo $ac_n "checking for $ac_hdr""... $ac_c" 1>&6
! echo "configure:3034: checking for $ac_hdr" >&5
  if eval "test \"`echo '$''{'ac_cv_header_$ac_safe'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
    cat > conftest.$ac_ext <<EOF
! #line 3039 "configure"
  #include "confdefs.h"
  #include <$ac_hdr>
  EOF
  ac_try="$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out"
! { (eval echo configure:3044: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
  ac_err=`grep -v '^ *+' conftest.out | grep -v "^conftest.${ac_ext}\$"`
  if test -z "$ac_err"; then
    rm -rf conftest*
***************
*** 3068,3084 ****
  do
  ac_safe=`echo "$ac_hdr" | sed 'y%./+-%__p_%'`
  echo $ac_n "checking for $ac_hdr""... $ac_c" 1>&6
! echo "configure:3072: checking for $ac_hdr" >&5
  if eval "test \"`echo '$''{'ac_cv_header_$ac_safe'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
    cat > conftest.$ac_ext <<EOF
! #line 3077 "configure"
  #include "confdefs.h"
  #include <$ac_hdr>
  EOF
  ac_try="$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out"
! { (eval echo configure:3082: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
  ac_err=`grep -v '^ *+' conftest.out | grep -v "^conftest.${ac_ext}\$"`
  if test -z "$ac_err"; then
    rm -rf conftest*
--- 3070,3086 ----
  do
  ac_safe=`echo "$ac_hdr" | sed 'y%./+-%__p_%'`
  echo $ac_n "checking for $ac_hdr""... $ac_c" 1>&6
! echo "configure:3074: checking for $ac_hdr" >&5
  if eval "test \"`echo '$''{'ac_cv_header_$ac_safe'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
    cat > conftest.$ac_ext <<EOF
! #line 3079 "configure"
  #include "confdefs.h"
  #include <$ac_hdr>
  EOF
  ac_try="$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out"
! { (eval echo configure:3084: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
  ac_err=`grep -v '^ *+' conftest.out | grep -v "^conftest.${ac_ext}\$"`
  if test -z "$ac_err"; then
    rm -rf conftest*
***************
*** 3106,3112 ****
  
  
  echo $ac_n "checking size of char""... $ac_c" 1>&6
! echo "configure:3110: checking size of char" >&5
  if eval "test \"`echo '$''{'ac_cv_sizeof_char'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
--- 3108,3114 ----
  
  
  echo $ac_n "checking size of char""... $ac_c" 1>&6
! echo "configure:3112: checking size of char" >&5
  if eval "test \"`echo '$''{'ac_cv_sizeof_char'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
***************
*** 3114,3120 ****
    ac_cv_sizeof_char=1
  else
    cat > conftest.$ac_ext <<EOF
! #line 3118 "configure"
  #include "confdefs.h"
  #include <stdio.h>
  main()
--- 3116,3122 ----
    ac_cv_sizeof_char=1
  else
    cat > conftest.$ac_ext <<EOF
! #line 3120 "configure"
  #include "confdefs.h"
  #include <stdio.h>
  main()
***************
*** 3125,3131 ****
    exit(0);
  }
  EOF
! if { (eval echo configure:3129: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
  then
    ac_cv_sizeof_char=`cat conftestval`
  else
--- 3127,3133 ----
    exit(0);
  }
  EOF
! if { (eval echo configure:3131: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
  then
    ac_cv_sizeof_char=`cat conftestval`
  else
***************
*** 3145,3151 ****
  
  
  echo $ac_n "checking size of short""... $ac_c" 1>&6
! echo "configure:3149: checking size of short" >&5
  if eval "test \"`echo '$''{'ac_cv_sizeof_short'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
--- 3147,3153 ----
  
  
  echo $ac_n "checking size of short""... $ac_c" 1>&6
! echo "configure:3151: checking size of short" >&5
  if eval "test \"`echo '$''{'ac_cv_sizeof_short'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
***************
*** 3153,3159 ****
    ac_cv_sizeof_short=2
  else
    cat > conftest.$ac_ext <<EOF
! #line 3157 "configure"
  #include "confdefs.h"
  #include <stdio.h>
  main()
--- 3155,3161 ----
    ac_cv_sizeof_short=2
  else
    cat > conftest.$ac_ext <<EOF
! #line 3159 "configure"
  #include "confdefs.h"
  #include <stdio.h>
  main()
***************
*** 3164,3170 ****
    exit(0);
  }
  EOF
! if { (eval echo configure:3168: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
  then
    ac_cv_sizeof_short=`cat conftestval`
  else
--- 3166,3172 ----
    exit(0);
  }
  EOF
! if { (eval echo configure:3170: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
  then
    ac_cv_sizeof_short=`cat conftestval`
  else
***************
*** 3184,3190 ****
  
  
  echo $ac_n "checking size of int""... $ac_c" 1>&6
! echo "configure:3188: checking size of int" >&5
  if eval "test \"`echo '$''{'ac_cv_sizeof_int'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
--- 3186,3192 ----
  
  
  echo $ac_n "checking size of int""... $ac_c" 1>&6
! echo "configure:3190: checking size of int" >&5
  if eval "test \"`echo '$''{'ac_cv_sizeof_int'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
***************
*** 3192,3198 ****
    ac_cv_sizeof_int=4
  else
    cat > conftest.$ac_ext <<EOF
! #line 3196 "configure"
  #include "confdefs.h"
  #include <stdio.h>
  main()
--- 3194,3200 ----
    ac_cv_sizeof_int=4
  else
    cat > conftest.$ac_ext <<EOF
! #line 3198 "configure"
  #include "confdefs.h"
  #include <stdio.h>
  main()
***************
*** 3203,3209 ****
    exit(0);
  }
  EOF
! if { (eval echo configure:3207: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
  then
    ac_cv_sizeof_int=`cat conftestval`
  else
--- 3205,3211 ----
    exit(0);
  }
  EOF
! if { (eval echo configure:3209: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
  then
    ac_cv_sizeof_int=`cat conftestval`
  else
***************
*** 3223,3229 ****
  
  
  echo $ac_n "checking size of long""... $ac_c" 1>&6
! echo "configure:3227: checking size of long" >&5
  if eval "test \"`echo '$''{'ac_cv_sizeof_long'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
--- 3225,3231 ----
  
  
  echo $ac_n "checking size of long""... $ac_c" 1>&6
! echo "configure:3229: checking size of long" >&5
  if eval "test \"`echo '$''{'ac_cv_sizeof_long'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
***************
*** 3231,3237 ****
    ac_cv_sizeof_long=4
  else
    cat > conftest.$ac_ext <<EOF
! #line 3235 "configure"
  #include "confdefs.h"
  #include <stdio.h>
  main()
--- 3233,3239 ----
    ac_cv_sizeof_long=4
  else
    cat > conftest.$ac_ext <<EOF
! #line 3237 "configure"
  #include "confdefs.h"
  #include <stdio.h>
  main()
***************
*** 3242,3248 ****
    exit(0);
  }
  EOF
! if { (eval echo configure:3246: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
  then
    ac_cv_sizeof_long=`cat conftestval`
  else
--- 3244,3250 ----
    exit(0);
  }
  EOF
! if { (eval echo configure:3248: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
  then
    ac_cv_sizeof_long=`cat conftestval`
  else
***************
*** 3262,3268 ****
  
  
  echo $ac_n "checking size of long long""... $ac_c" 1>&6
! echo "configure:3266: checking size of long long" >&5
  if eval "test \"`echo '$''{'ac_cv_sizeof_long_long'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
--- 3264,3270 ----
  
  
  echo $ac_n "checking size of long long""... $ac_c" 1>&6
! echo "configure:3268: checking size of long long" >&5
  if eval "test \"`echo '$''{'ac_cv_sizeof_long_long'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
***************
*** 3270,3276 ****
    ac_cv_sizeof_long_long=8
  else
    cat > conftest.$ac_ext <<EOF
! #line 3274 "configure"
  #include "confdefs.h"
  #include <stdio.h>
  main()
--- 3272,3278 ----
    ac_cv_sizeof_long_long=8
  else
    cat > conftest.$ac_ext <<EOF
! #line 3276 "configure"
  #include "confdefs.h"
  #include <stdio.h>
  main()
***************
*** 3281,3287 ****
    exit(0);
  }
  EOF
! if { (eval echo configure:3285: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
  then
    ac_cv_sizeof_long_long=`cat conftestval`
  else
--- 3283,3289 ----
    exit(0);
  }
  EOF
! if { (eval echo configure:3287: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
  then
    ac_cv_sizeof_long_long=`cat conftestval`
  else
***************
*** 3301,3307 ****
  
  
  echo $ac_n "checking size of __int64""... $ac_c" 1>&6
! echo "configure:3305: checking size of __int64" >&5
  if eval "test \"`echo '$''{'ac_cv_sizeof___int64'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
--- 3303,3309 ----
  
  
  echo $ac_n "checking size of __int64""... $ac_c" 1>&6
! echo "configure:3307: checking size of __int64" >&5
  if eval "test \"`echo '$''{'ac_cv_sizeof___int64'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
***************
*** 3309,3315 ****
    ac_cv_sizeof___int64=8
  else
    cat > conftest.$ac_ext <<EOF
! #line 3313 "configure"
  #include "confdefs.h"
  #include <stdio.h>
  main()
--- 3311,3317 ----
    ac_cv_sizeof___int64=8
  else
    cat > conftest.$ac_ext <<EOF
! #line 3315 "configure"
  #include "confdefs.h"
  #include <stdio.h>
  main()
***************
*** 3320,3326 ****
    exit(0);
  }
  EOF
! if { (eval echo configure:3324: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
  then
    ac_cv_sizeof___int64=`cat conftestval`
  else
--- 3322,3328 ----
    exit(0);
  }
  EOF
! if { (eval echo configure:3326: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
  then
    ac_cv_sizeof___int64=`cat conftestval`
  else
***************
*** 3341,3352 ****
  
  
  echo $ac_n "checking for working const""... $ac_c" 1>&6
! echo "configure:3345: checking for working const" >&5
  if eval "test \"`echo '$''{'ac_cv_c_const'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
    cat > conftest.$ac_ext <<EOF
! #line 3350 "configure"
  #include "confdefs.h"
  
  int main() {
--- 3343,3354 ----
  
  
  echo $ac_n "checking for working const""... $ac_c" 1>&6
! echo "configure:3347: checking for working const" >&5
  if eval "test \"`echo '$''{'ac_cv_c_const'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
    cat > conftest.$ac_ext <<EOF
! #line 3352 "configure"
  #include "confdefs.h"
  
  int main() {
***************
*** 3395,3401 ****
  
  ; return 0; }
  EOF
! if { (eval echo configure:3399: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
    rm -rf conftest*
    ac_cv_c_const=yes
  else
--- 3397,3403 ----
  
  ; return 0; }
  EOF
! if { (eval echo configure:3401: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
    rm -rf conftest*
    ac_cv_c_const=yes
  else
***************
*** 3416,3436 ****
  fi
  
  echo $ac_n "checking for inline""... $ac_c" 1>&6
! echo "configure:3420: checking for inline" >&5
  if eval "test \"`echo '$''{'ac_cv_c_inline'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
    ac_cv_c_inline=no
  for ac_kw in inline __inline__ __inline; do
    cat > conftest.$ac_ext <<EOF
! #line 3427 "configure"
  #include "confdefs.h"
  
  int main() {
  } $ac_kw foo() {
  ; return 0; }
  EOF
! if { (eval echo configure:3434: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
    rm -rf conftest*
    ac_cv_c_inline=$ac_kw; break
  else
--- 3418,3438 ----
  fi
  
  echo $ac_n "checking for inline""... $ac_c" 1>&6
! echo "configure:3422: checking for inline" >&5
  if eval "test \"`echo '$''{'ac_cv_c_inline'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
    ac_cv_c_inline=no
  for ac_kw in inline __inline__ __inline; do
    cat > conftest.$ac_ext <<EOF
! #line 3429 "configure"
  #include "confdefs.h"
  
  int main() {
  } $ac_kw foo() {
  ; return 0; }
  EOF
! if { (eval echo configure:3436: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
    rm -rf conftest*
    ac_cv_c_inline=$ac_kw; break
  else
***************
*** 3459,3470 ****
    ac_cv_c_inline=
  fi
  echo $ac_n "checking for mode_t""... $ac_c" 1>&6
! echo "configure:3463: checking for mode_t" >&5
  if eval "test \"`echo '$''{'ac_cv_type_mode_t'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
    cat > conftest.$ac_ext <<EOF
! #line 3468 "configure"
  #include "confdefs.h"
  #include <sys/types.h>
  #if STDC_HEADERS
--- 3461,3472 ----
    ac_cv_c_inline=
  fi
  echo $ac_n "checking for mode_t""... $ac_c" 1>&6
! echo "configure:3465: checking for mode_t" >&5
  if eval "test \"`echo '$''{'ac_cv_type_mode_t'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
    cat > conftest.$ac_ext <<EOF
! #line 3470 "configure"
  #include "confdefs.h"
  #include <sys/types.h>
  #if STDC_HEADERS
***************
*** 3492,3503 ****
  fi
  
  echo $ac_n "checking for off_t""... $ac_c" 1>&6
! echo "configure:3496: checking for off_t" >&5
  if eval "test \"`echo '$''{'ac_cv_type_off_t'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
    cat > conftest.$ac_ext <<EOF
! #line 3501 "configure"
  #include "confdefs.h"
  #include <sys/types.h>
  #if STDC_HEADERS
--- 3494,3505 ----
  fi
  
  echo $ac_n "checking for off_t""... $ac_c" 1>&6
! echo "configure:3498: checking for off_t" >&5
  if eval "test \"`echo '$''{'ac_cv_type_off_t'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
    cat > conftest.$ac_ext <<EOF
! #line 3503 "configure"
  #include "confdefs.h"
  #include <sys/types.h>
  #if STDC_HEADERS
***************
*** 3525,3536 ****
  fi
  
  echo $ac_n "checking for pid_t""... $ac_c" 1>&6
! echo "configure:3529: checking for pid_t" >&5
  if eval "test \"`echo '$''{'ac_cv_type_pid_t'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
    cat > conftest.$ac_ext <<EOF
! #line 3534 "configure"
  #include "confdefs.h"
  #include <sys/types.h>
  #if STDC_HEADERS
--- 3527,3538 ----
  fi
  
  echo $ac_n "checking for pid_t""... $ac_c" 1>&6
! echo "configure:3531: checking for pid_t" >&5
  if eval "test \"`echo '$''{'ac_cv_type_pid_t'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
    cat > conftest.$ac_ext <<EOF
! #line 3536 "configure"
  #include "confdefs.h"
  #include <sys/types.h>
  #if STDC_HEADERS
***************
*** 3558,3569 ****
  fi
  
  echo $ac_n "checking for st_blocks in struct stat""... $ac_c" 1>&6
! echo "configure:3562: checking for st_blocks in struct stat" >&5
  if eval "test \"`echo '$''{'ac_cv_struct_st_blocks'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
    cat > conftest.$ac_ext <<EOF
! #line 3567 "configure"
  #include "confdefs.h"
  #include <sys/types.h>
  #include <sys/stat.h>
--- 3560,3571 ----
  fi
  
  echo $ac_n "checking for st_blocks in struct stat""... $ac_c" 1>&6
! echo "configure:3564: checking for st_blocks in struct stat" >&5
  if eval "test \"`echo '$''{'ac_cv_struct_st_blocks'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
    cat > conftest.$ac_ext <<EOF
! #line 3569 "configure"
  #include "confdefs.h"
  #include <sys/types.h>
  #include <sys/stat.h>
***************
*** 3571,3577 ****
  struct stat s; s.st_blocks;
  ; return 0; }
  EOF
! if { (eval echo configure:3575: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
    rm -rf conftest*
    ac_cv_struct_st_blocks=yes
  else
--- 3573,3579 ----
  struct stat s; s.st_blocks;
  ; return 0; }
  EOF
! if { (eval echo configure:3577: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
    rm -rf conftest*
    ac_cv_struct_st_blocks=yes
  else
***************
*** 3594,3605 ****
  fi
  
  echo $ac_n "checking whether time.h and sys/time.h may both be included""... $ac_c" 1>&6
! echo "configure:3598: checking whether time.h and sys/time.h may both be included" >&5
  if eval "test \"`echo '$''{'ac_cv_header_time'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
    cat > conftest.$ac_ext <<EOF
! #line 3603 "configure"
  #include "confdefs.h"
  #include <sys/types.h>
  #include <sys/time.h>
--- 3596,3607 ----
  fi
  
  echo $ac_n "checking whether time.h and sys/time.h may both be included""... $ac_c" 1>&6
! echo "configure:3600: checking whether time.h and sys/time.h may both be included" >&5
  if eval "test \"`echo '$''{'ac_cv_header_time'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
    cat > conftest.$ac_ext <<EOF
! #line 3605 "configure"
  #include "confdefs.h"
  #include <sys/types.h>
  #include <sys/time.h>
***************
*** 3608,3614 ****
  struct tm *tp;
  ; return 0; }
  EOF
! if { (eval echo configure:3612: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
    rm -rf conftest*
    ac_cv_header_time=yes
  else
--- 3610,3616 ----
  struct tm *tp;
  ; return 0; }
  EOF
! if { (eval echo configure:3614: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
    rm -rf conftest*
    ac_cv_header_time=yes
  else
***************
*** 3629,3640 ****
  fi
  
  echo $ac_n "checking whether struct tm is in sys/time.h or time.h""... $ac_c" 1>&6
! echo "configure:3633: checking whether struct tm is in sys/time.h or time.h" >&5
  if eval "test \"`echo '$''{'ac_cv_struct_tm'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
    cat > conftest.$ac_ext <<EOF
! #line 3638 "configure"
  #include "confdefs.h"
  #include <sys/types.h>
  #include <time.h>
--- 3631,3642 ----
  fi
  
  echo $ac_n "checking whether struct tm is in sys/time.h or time.h""... $ac_c" 1>&6
! echo "configure:3635: checking whether struct tm is in sys/time.h or time.h" >&5
  if eval "test \"`echo '$''{'ac_cv_struct_tm'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
    cat > conftest.$ac_ext <<EOF
! #line 3640 "configure"
  #include "confdefs.h"
  #include <sys/types.h>
  #include <time.h>
***************
*** 3642,3648 ****
  struct tm *tp; tp->tm_sec;
  ; return 0; }
  EOF
! if { (eval echo configure:3646: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
    rm -rf conftest*
    ac_cv_struct_tm=time.h
  else
--- 3644,3650 ----
  struct tm *tp; tp->tm_sec;
  ; return 0; }
  EOF
! if { (eval echo configure:3648: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
    rm -rf conftest*
    ac_cv_struct_tm=time.h
  else
***************
*** 3665,3677 ****
  
  if test $ac_cv_prog_gcc = yes; then
      echo $ac_n "checking whether ${CC-cc} needs -traditional""... $ac_c" 1>&6
! echo "configure:3669: checking whether ${CC-cc} needs -traditional" >&5
  if eval "test \"`echo '$''{'ac_cv_prog_gcc_traditional'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
      ac_pattern="Autoconf.*'x'"
    cat > conftest.$ac_ext <<EOF
! #line 3675 "configure"
  #include "confdefs.h"
  #include <sgtty.h>
  Autoconf TIOCGETP
--- 3667,3679 ----
  
  if test $ac_cv_prog_gcc = yes; then
      echo $ac_n "checking whether ${CC-cc} needs -traditional""... $ac_c" 1>&6
! echo "configure:3671: checking whether ${CC-cc} needs -traditional" >&5
  if eval "test \"`echo '$''{'ac_cv_prog_gcc_traditional'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
      ac_pattern="Autoconf.*'x'"
    cat > conftest.$ac_ext <<EOF
! #line 3677 "configure"
  #include "confdefs.h"
  #include <sgtty.h>
  Autoconf TIOCGETP
***************
*** 3689,3695 ****
  
    if test $ac_cv_prog_gcc_traditional = no; then
      cat > conftest.$ac_ext <<EOF
! #line 3693 "configure"
  #include "confdefs.h"
  #include <termio.h>
  Autoconf TCGETA
--- 3691,3697 ----
  
    if test $ac_cv_prog_gcc_traditional = no; then
      cat > conftest.$ac_ext <<EOF
! #line 3695 "configure"
  #include "confdefs.h"
  #include <termio.h>
  Autoconf TCGETA
***************
*** 3711,3717 ****
  fi
  
  echo $ac_n "checking for 8-bit clean memcmp""... $ac_c" 1>&6
! echo "configure:3715: checking for 8-bit clean memcmp" >&5
  if eval "test \"`echo '$''{'ac_cv_func_memcmp_clean'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
--- 3713,3719 ----
  fi
  
  echo $ac_n "checking for 8-bit clean memcmp""... $ac_c" 1>&6
! echo "configure:3717: checking for 8-bit clean memcmp" >&5
  if eval "test \"`echo '$''{'ac_cv_func_memcmp_clean'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
***************
*** 3719,3725 ****
    ac_cv_func_memcmp_clean=no
  else
    cat > conftest.$ac_ext <<EOF
! #line 3723 "configure"
  #include "confdefs.h"
  
  main()
--- 3721,3727 ----
    ac_cv_func_memcmp_clean=no
  else
    cat > conftest.$ac_ext <<EOF
! #line 3725 "configure"
  #include "confdefs.h"
  
  main()
***************
*** 3729,3735 ****
  }
  
  EOF
! if { (eval echo configure:3733: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
  then
    ac_cv_func_memcmp_clean=yes
  else
--- 3731,3737 ----
  }
  
  EOF
! if { (eval echo configure:3735: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
  then
    ac_cv_func_memcmp_clean=yes
  else
***************
*** 3747,3758 ****
  test $ac_cv_func_memcmp_clean = no && LIBOBJS="$LIBOBJS memcmp.${ac_objext}"
  
  echo $ac_n "checking return type of signal handlers""... $ac_c" 1>&6
! echo "configure:3751: checking return type of signal handlers" >&5
  if eval "test \"`echo '$''{'ac_cv_type_signal'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
    cat > conftest.$ac_ext <<EOF
! #line 3756 "configure"
  #include "confdefs.h"
  #include <sys/types.h>
  #include <signal.h>
--- 3749,3760 ----
  test $ac_cv_func_memcmp_clean = no && LIBOBJS="$LIBOBJS memcmp.${ac_objext}"
  
  echo $ac_n "checking return type of signal handlers""... $ac_c" 1>&6
! echo "configure:3753: checking return type of signal handlers" >&5
  if eval "test \"`echo '$''{'ac_cv_type_signal'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
    cat > conftest.$ac_ext <<EOF
! #line 3758 "configure"
  #include "confdefs.h"
  #include <sys/types.h>
  #include <signal.h>
***************
*** 3769,3775 ****
  int i;
  ; return 0; }
  EOF
! if { (eval echo configure:3773: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
    rm -rf conftest*
    ac_cv_type_signal=void
  else
--- 3771,3777 ----
  int i;
  ; return 0; }
  EOF
! if { (eval echo configure:3775: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
    rm -rf conftest*
    ac_cv_type_signal=void
  else
***************
*** 3788,3794 ****
  
  
  echo $ac_n "checking whether utime accepts a null argument""... $ac_c" 1>&6
! echo "configure:3792: checking whether utime accepts a null argument" >&5
  if eval "test \"`echo '$''{'ac_cv_func_utime_null'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
--- 3790,3796 ----
  
  
  echo $ac_n "checking whether utime accepts a null argument""... $ac_c" 1>&6
! echo "configure:3794: checking whether utime accepts a null argument" >&5
  if eval "test \"`echo '$''{'ac_cv_func_utime_null'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
***************
*** 3798,3804 ****
    ac_cv_func_utime_null=no
  else
    cat > conftest.$ac_ext <<EOF
! #line 3802 "configure"
  #include "confdefs.h"
  #include <sys/types.h>
  #include <sys/stat.h>
--- 3800,3806 ----
    ac_cv_func_utime_null=no
  else
    cat > conftest.$ac_ext <<EOF
! #line 3804 "configure"
  #include "confdefs.h"
  #include <sys/types.h>
  #include <sys/stat.h>
***************
*** 3809,3815 ****
  && t.st_mtime - s.st_mtime < 120));
  }
  EOF
! if { (eval echo configure:3813: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
  then
    ac_cv_func_utime_null=yes
  else
--- 3811,3817 ----
  && t.st_mtime - s.st_mtime < 120));
  }
  EOF
! if { (eval echo configure:3815: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
  then
    ac_cv_func_utime_null=yes
  else
***************
*** 3835,3846 ****
  for ac_func in getcwd getopt strdup gettimeofday sigaction mkdir rmdir
  do
  echo $ac_n "checking for $ac_func""... $ac_c" 1>&6
! echo "configure:3839: checking for $ac_func" >&5
  if eval "test \"`echo '$''{'ac_cv_func_$ac_func'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
    cat > conftest.$ac_ext <<EOF
! #line 3844 "configure"
  #include "confdefs.h"
  /* System header to define __stub macros and hopefully few prototypes,
      which can conflict with char $ac_func(); below.  */
--- 3837,3848 ----
  for ac_func in getcwd getopt strdup gettimeofday sigaction mkdir rmdir
  do
  echo $ac_n "checking for $ac_func""... $ac_c" 1>&6
! echo "configure:3841: checking for $ac_func" >&5
  if eval "test \"`echo '$''{'ac_cv_func_$ac_func'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
    cat > conftest.$ac_ext <<EOF
! #line 3846 "configure"
  #include "confdefs.h"
  /* System header to define __stub macros and hopefully few prototypes,
      which can conflict with char $ac_func(); below.  */
***************
*** 3863,3869 ****
  
  ; return 0; }
  EOF
! if { (eval echo configure:3867: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
    rm -rf conftest*
    eval "ac_cv_func_$ac_func=yes"
  else
--- 3865,3871 ----
  
  ; return 0; }
  EOF
! if { (eval echo configure:3869: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
    rm -rf conftest*
    eval "ac_cv_func_$ac_func=yes"
  else
***************
*** 3890,3901 ****
  for ac_func in select strerror strstr isnan isinf setitimer
  do
  echo $ac_n "checking for $ac_func""... $ac_c" 1>&6
! echo "configure:3894: checking for $ac_func" >&5
  if eval "test \"`echo '$''{'ac_cv_func_$ac_func'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
    cat > conftest.$ac_ext <<EOF
! #line 3899 "configure"
  #include "confdefs.h"
  /* System header to define __stub macros and hopefully few prototypes,
      which can conflict with char $ac_func(); below.  */
--- 3892,3903 ----
  for ac_func in select strerror strstr isnan isinf setitimer
  do
  echo $ac_n "checking for $ac_func""... $ac_c" 1>&6
! echo "configure:3896: checking for $ac_func" >&5
  if eval "test \"`echo '$''{'ac_cv_func_$ac_func'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
    cat > conftest.$ac_ext <<EOF
! #line 3901 "configure"
  #include "confdefs.h"
  /* System header to define __stub macros and hopefully few prototypes,
      which can conflict with char $ac_func(); below.  */
***************
*** 3918,3924 ****
  
  ; return 0; }
  EOF
! if { (eval echo configure:3922: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
    rm -rf conftest*
    eval "ac_cv_func_$ac_func=yes"
  else
--- 3920,3926 ----
  
  ; return 0; }
  EOF
! if { (eval echo configure:3924: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
    rm -rf conftest*
    eval "ac_cv_func_$ac_func=yes"
  else
***************
*** 3945,3956 ****
  for ac_func in tcgetattr cfmakeraw readdir_r vprintf vsprintf vfprintf
  do
  echo $ac_n "checking for $ac_func""... $ac_c" 1>&6
! echo "configure:3949: checking for $ac_func" >&5
  if eval "test \"`echo '$''{'ac_cv_func_$ac_func'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
    cat > conftest.$ac_ext <<EOF
! #line 3954 "configure"
  #include "confdefs.h"
  /* System header to define __stub macros and hopefully few prototypes,
      which can conflict with char $ac_func(); below.  */
--- 3947,3958 ----
  for ac_func in tcgetattr cfmakeraw readdir_r vprintf vsprintf vfprintf
  do
  echo $ac_n "checking for $ac_func""... $ac_c" 1>&6
! echo "configure:3951: checking for $ac_func" >&5
  if eval "test \"`echo '$''{'ac_cv_func_$ac_func'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
    cat > conftest.$ac_ext <<EOF
! #line 3956 "configure"
  #include "confdefs.h"
  /* System header to define __stub macros and hopefully few prototypes,
      which can conflict with char $ac_func(); below.  */
***************
*** 3973,3979 ****
  
  ; return 0; }
  EOF
! if { (eval echo configure:3977: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
    rm -rf conftest*
    eval "ac_cv_func_$ac_func=yes"
  else
--- 3975,3981 ----
  
  ; return 0; }
  EOF
! if { (eval echo configure:3979: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
    rm -rf conftest*
    eval "ac_cv_func_$ac_func=yes"
  else
***************
*** 4010,4026 ****
  do
  ac_safe=`echo "$ac_hdr" | sed 'y%./+-%__p_%'`
  echo $ac_n "checking for $ac_hdr""... $ac_c" 1>&6
! echo "configure:4014: checking for $ac_hdr" >&5
  if eval "test \"`echo '$''{'ac_cv_header_$ac_safe'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
    cat > conftest.$ac_ext <<EOF
! #line 4019 "configure"
  #include "confdefs.h"
  #include <$ac_hdr>
  EOF
  ac_try="$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out"
! { (eval echo configure:4024: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
  ac_err=`grep -v '^ *+' conftest.out | grep -v "^conftest.${ac_ext}\$"`
  if test -z "$ac_err"; then
    rm -rf conftest*
--- 4012,4028 ----
  do
  ac_safe=`echo "$ac_hdr" | sed 'y%./+-%__p_%'`
  echo $ac_n "checking for $ac_hdr""... $ac_c" 1>&6
! echo "configure:4016: checking for $ac_hdr" >&5
  if eval "test \"`echo '$''{'ac_cv_header_$ac_safe'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
    cat > conftest.$ac_ext <<EOF
! #line 4021 "configure"
  #include "confdefs.h"
  #include <$ac_hdr>
  EOF
  ac_try="$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out"
! { (eval echo configure:4026: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
  ac_err=`grep -v '^ *+' conftest.out | grep -v "^conftest.${ac_ext}\$"`
  if test -z "$ac_err"; then
    rm -rf conftest*
***************
*** 4052,4063 ****
  listmntent memcpy mkfifo strchr strerror strrchr
  do
  echo $ac_n "checking for $ac_func""... $ac_c" 1>&6
! echo "configure:4056: checking for $ac_func" >&5
  if eval "test \"`echo '$''{'ac_cv_func_$ac_func'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
    cat > conftest.$ac_ext <<EOF
! #line 4061 "configure"
  #include "confdefs.h"
  /* System header to define __stub macros and hopefully few prototypes,
      which can conflict with char $ac_func(); below.  */
--- 4054,4065 ----
  listmntent memcpy mkfifo strchr strerror strrchr
  do
  echo $ac_n "checking for $ac_func""... $ac_c" 1>&6
! echo "configure:4058: checking for $ac_func" >&5
  if eval "test \"`echo '$''{'ac_cv_func_$ac_func'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
    cat > conftest.$ac_ext <<EOF
! #line 4063 "configure"
  #include "confdefs.h"
  /* System header to define __stub macros and hopefully few prototypes,
      which can conflict with char $ac_func(); below.  */
***************
*** 4080,4086 ****
  
  ; return 0; }
  EOF
! if { (eval echo configure:4084: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
    rm -rf conftest*
    eval "ac_cv_func_$ac_func=yes"
  else
--- 4082,4088 ----
  
  ; return 0; }
  EOF
! if { (eval echo configure:4086: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
    rm -rf conftest*
    eval "ac_cv_func_$ac_func=yes"
  else
***************
*** 4112,4118 ****
  # make sure LIBS contains -lsun (on Irix4) or -lseq (on PTX).
  # getmntent is in -lsun on Irix 4, -lseq on Dynix/PTX, -lgen on Unixware.
  echo $ac_n "checking for getmntent in -lsun""... $ac_c" 1>&6
! echo "configure:4116: checking for getmntent in -lsun" >&5
  ac_lib_var=`echo sun'_'getmntent | sed 'y%./+-%__p_%'`
  if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
--- 4114,4120 ----
  # make sure LIBS contains -lsun (on Irix4) or -lseq (on PTX).
  # getmntent is in -lsun on Irix 4, -lseq on Dynix/PTX, -lgen on Unixware.
  echo $ac_n "checking for getmntent in -lsun""... $ac_c" 1>&6
! echo "configure:4118: checking for getmntent in -lsun" >&5
  ac_lib_var=`echo sun'_'getmntent | sed 'y%./+-%__p_%'`
  if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
***************
*** 4120,4126 ****
    ac_save_LIBS="$LIBS"
  LIBS="-lsun  $LIBS"
  cat > conftest.$ac_ext <<EOF
! #line 4124 "configure"
  #include "confdefs.h"
  /* Override any gcc2 internal prototype to avoid an error.  */
  /* We use char because int might match the return type of a gcc2
--- 4122,4128 ----
    ac_save_LIBS="$LIBS"
  LIBS="-lsun  $LIBS"
  cat > conftest.$ac_ext <<EOF
! #line 4126 "configure"
  #include "confdefs.h"
  /* Override any gcc2 internal prototype to avoid an error.  */
  /* We use char because int might match the return type of a gcc2
***************
*** 4131,4137 ****
  getmntent()
  ; return 0; }
  EOF
! if { (eval echo configure:4135: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
    rm -rf conftest*
    eval "ac_cv_lib_$ac_lib_var=yes"
  else
--- 4133,4139 ----
  getmntent()
  ; return 0; }
  EOF
! if { (eval echo configure:4137: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
    rm -rf conftest*
    eval "ac_cv_lib_$ac_lib_var=yes"
  else
***************
*** 4150,4156 ****
  else
    echo "$ac_t""no" 1>&6
  echo $ac_n "checking for getmntent in -lseq""... $ac_c" 1>&6
! echo "configure:4154: checking for getmntent in -lseq" >&5
  ac_lib_var=`echo seq'_'getmntent | sed 'y%./+-%__p_%'`
  if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
--- 4152,4158 ----
  else
    echo "$ac_t""no" 1>&6
  echo $ac_n "checking for getmntent in -lseq""... $ac_c" 1>&6
! echo "configure:4156: checking for getmntent in -lseq" >&5
  ac_lib_var=`echo seq'_'getmntent | sed 'y%./+-%__p_%'`
  if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
***************
*** 4158,4164 ****
    ac_save_LIBS="$LIBS"
  LIBS="-lseq  $LIBS"
  cat > conftest.$ac_ext <<EOF
! #line 4162 "configure"
  #include "confdefs.h"
  /* Override any gcc2 internal prototype to avoid an error.  */
  /* We use char because int might match the return type of a gcc2
--- 4160,4166 ----
    ac_save_LIBS="$LIBS"
  LIBS="-lseq  $LIBS"
  cat > conftest.$ac_ext <<EOF
! #line 4164 "configure"
  #include "confdefs.h"
  /* Override any gcc2 internal prototype to avoid an error.  */
  /* We use char because int might match the return type of a gcc2
***************
*** 4169,4175 ****
  getmntent()
  ; return 0; }
  EOF
! if { (eval echo configure:4173: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
    rm -rf conftest*
    eval "ac_cv_lib_$ac_lib_var=yes"
  else
--- 4171,4177 ----
  getmntent()
  ; return 0; }
  EOF
! if { (eval echo configure:4175: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
    rm -rf conftest*
    eval "ac_cv_lib_$ac_lib_var=yes"
  else
***************
*** 4188,4194 ****
  else
    echo "$ac_t""no" 1>&6
  echo $ac_n "checking for getmntent in -lgen""... $ac_c" 1>&6
! echo "configure:4192: checking for getmntent in -lgen" >&5
  ac_lib_var=`echo gen'_'getmntent | sed 'y%./+-%__p_%'`
  if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
--- 4190,4196 ----
  else
    echo "$ac_t""no" 1>&6
  echo $ac_n "checking for getmntent in -lgen""... $ac_c" 1>&6
! echo "configure:4194: checking for getmntent in -lgen" >&5
  ac_lib_var=`echo gen'_'getmntent | sed 'y%./+-%__p_%'`
  if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
***************
*** 4196,4202 ****
    ac_save_LIBS="$LIBS"
  LIBS="-lgen  $LIBS"
  cat > conftest.$ac_ext <<EOF
! #line 4200 "configure"
  #include "confdefs.h"
  /* Override any gcc2 internal prototype to avoid an error.  */
  /* We use char because int might match the return type of a gcc2
--- 4198,4204 ----
    ac_save_LIBS="$LIBS"
  LIBS="-lgen  $LIBS"
  cat > conftest.$ac_ext <<EOF
! #line 4202 "configure"
  #include "confdefs.h"
  /* Override any gcc2 internal prototype to avoid an error.  */
  /* We use char because int might match the return type of a gcc2
***************
*** 4207,4213 ****
  getmntent()
  ; return 0; }
  EOF
! if { (eval echo configure:4211: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
    rm -rf conftest*
    eval "ac_cv_lib_$ac_lib_var=yes"
  else
--- 4209,4215 ----
  getmntent()
  ; return 0; }
  EOF
! if { (eval echo configure:4213: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
    rm -rf conftest*
    eval "ac_cv_lib_$ac_lib_var=yes"
  else
***************
*** 4232,4243 ****
  fi
  
  echo $ac_n "checking for getmntent""... $ac_c" 1>&6
! echo "configure:4236: checking for getmntent" >&5
  if eval "test \"`echo '$''{'ac_cv_func_getmntent'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
    cat > conftest.$ac_ext <<EOF
! #line 4241 "configure"
  #include "confdefs.h"
  /* System header to define __stub macros and hopefully few prototypes,
      which can conflict with char getmntent(); below.  */
--- 4234,4245 ----
  fi
  
  echo $ac_n "checking for getmntent""... $ac_c" 1>&6
! echo "configure:4238: checking for getmntent" >&5
  if eval "test \"`echo '$''{'ac_cv_func_getmntent'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
    cat > conftest.$ac_ext <<EOF
! #line 4243 "configure"
  #include "confdefs.h"
  /* System header to define __stub macros and hopefully few prototypes,
      which can conflict with char getmntent(); below.  */
***************
*** 4260,4266 ****
  
  ; return 0; }
  EOF
! if { (eval echo configure:4264: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
    rm -rf conftest*
    eval "ac_cv_func_getmntent=yes"
  else
--- 4262,4268 ----
  
  ; return 0; }
  EOF
! if { (eval echo configure:4266: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
    rm -rf conftest*
    eval "ac_cv_func_getmntent=yes"
  else
***************
*** 4295,4307 ****
  if test -z "$list_mounted_fs"; then
  # Cray UNICOS 9
  echo $ac_n "checking for listmntent of Cray/Unicos-9""... $ac_c" 1>&6
! echo "configure:4299: checking for listmntent of Cray/Unicos-9" >&5
  if eval "test \"`echo '$''{'fu_cv_sys_mounted_cray_listmntent'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
    fu_cv_sys_mounted_cray_listmntent=no
  cat > conftest.$ac_ext <<EOF
! #line 4305 "configure"
  #include "confdefs.h"
  #ifdef _CRAY
  yes
--- 4297,4309 ----
  if test -z "$list_mounted_fs"; then
  # Cray UNICOS 9
  echo $ac_n "checking for listmntent of Cray/Unicos-9""... $ac_c" 1>&6
! echo "configure:4301: checking for listmntent of Cray/Unicos-9" >&5
  if eval "test \"`echo '$''{'fu_cv_sys_mounted_cray_listmntent'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
    fu_cv_sys_mounted_cray_listmntent=no
  cat > conftest.$ac_ext <<EOF
! #line 4307 "configure"
  #include "confdefs.h"
  #ifdef _CRAY
  yes
***************
*** 4339,4345 ****
  if test -z "$list_mounted_fs"; then
  # 4.3BSD, SunOS, HP-UX, Dynix, Irix
  echo $ac_n "checking for one-argument getmntent function""... $ac_c" 1>&6
! echo "configure:4343: checking for one-argument getmntent function" >&5
  if eval "test \"`echo '$''{'fu_cv_sys_mounted_getmntent1'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
--- 4341,4347 ----
  if test -z "$list_mounted_fs"; then
  # 4.3BSD, SunOS, HP-UX, Dynix, Irix
  echo $ac_n "checking for one-argument getmntent function""... $ac_c" 1>&6
! echo "configure:4345: checking for one-argument getmntent function" >&5
  if eval "test \"`echo '$''{'fu_cv_sys_mounted_getmntent1'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
***************
*** 4361,4372 ****
  if test -z "$list_mounted_fs"; then
  # SVR4
  echo $ac_n "checking for two-argument getmntent function""... $ac_c" 1>&6
! echo "configure:4365: checking for two-argument getmntent function" >&5
  if eval "test \"`echo '$''{'fu_cv_sys_mounted_getmntent2'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
    cat > conftest.$ac_ext <<EOF
! #line 4370 "configure"
  #include "confdefs.h"
  #include <sys/mnttab.h>
  EOF
--- 4363,4374 ----
  if test -z "$list_mounted_fs"; then
  # SVR4
  echo $ac_n "checking for two-argument getmntent function""... $ac_c" 1>&6
! echo "configure:4367: checking for two-argument getmntent function" >&5
  if eval "test \"`echo '$''{'fu_cv_sys_mounted_getmntent2'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
    cat > conftest.$ac_ext <<EOF
! #line 4372 "configure"
  #include "confdefs.h"
  #include <sys/mnttab.h>
  EOF
***************
*** 4401,4412 ****
  if test -z "$list_mounted_fs"; then
  # DEC Alpha running OSF/1.
  echo $ac_n "checking for getfsstat function""... $ac_c" 1>&6
! echo "configure:4405: checking for getfsstat function" >&5
  if eval "test \"`echo '$''{'fu_cv_sys_mounted_getsstat'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
    cat > conftest.$ac_ext <<EOF
! #line 4410 "configure"
  #include "confdefs.h"
  
  #include <sys/types.h>
--- 4403,4414 ----
  if test -z "$list_mounted_fs"; then
  # DEC Alpha running OSF/1.
  echo $ac_n "checking for getfsstat function""... $ac_c" 1>&6
! echo "configure:4407: checking for getfsstat function" >&5
  if eval "test \"`echo '$''{'fu_cv_sys_mounted_getsstat'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
    cat > conftest.$ac_ext <<EOF
! #line 4412 "configure"
  #include "confdefs.h"
  
  #include <sys/types.h>
***************
*** 4417,4423 ****
  int numsys = getfsstat ((struct statfs *)0, 0L, MNT_WAIT); 
  ; return 0; }
  EOF
! if { (eval echo configure:4421: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
    rm -rf conftest*
    fu_cv_sys_mounted_getsstat=yes
  else
--- 4419,4425 ----
  int numsys = getfsstat ((struct statfs *)0, 0L, MNT_WAIT); 
  ; return 0; }
  EOF
! if { (eval echo configure:4423: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
    rm -rf conftest*
    fu_cv_sys_mounted_getsstat=yes
  else
***************
*** 4442,4458 ****
  if test -z "$list_mounted_fs"; then
  # AIX.
  echo $ac_n "checking for mntctl function and struct vmount""... $ac_c" 1>&6
! echo "configure:4446: checking for mntctl function and struct vmount" >&5
  if eval "test \"`echo '$''{'fu_cv_sys_mounted_vmount'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
    cat > conftest.$ac_ext <<EOF
! #line 4451 "configure"
  #include "confdefs.h"
  #include <fshelp.h>
  EOF
  ac_try="$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out"
! { (eval echo configure:4456: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
  ac_err=`grep -v '^ *+' conftest.out | grep -v "^conftest.${ac_ext}\$"`
  if test -z "$ac_err"; then
    rm -rf conftest*
--- 4444,4460 ----
  if test -z "$list_mounted_fs"; then
  # AIX.
  echo $ac_n "checking for mntctl function and struct vmount""... $ac_c" 1>&6
! echo "configure:4448: checking for mntctl function and struct vmount" >&5
  if eval "test \"`echo '$''{'fu_cv_sys_mounted_vmount'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
    cat > conftest.$ac_ext <<EOF
! #line 4453 "configure"
  #include "confdefs.h"
  #include <fshelp.h>
  EOF
  ac_try="$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out"
! { (eval echo configure:4458: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
  ac_err=`grep -v '^ *+' conftest.out | grep -v "^conftest.${ac_ext}\$"`
  if test -z "$ac_err"; then
    rm -rf conftest*
***************
*** 4480,4491 ****
  if test -z "$list_mounted_fs"; then
  # SVR3
  echo $ac_n "checking for FIXME existence of three headers""... $ac_c" 1>&6
! echo "configure:4484: checking for FIXME existence of three headers" >&5
  if eval "test \"`echo '$''{'fu_cv_sys_mounted_fread_fstyp'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
    cat > conftest.$ac_ext <<EOF
! #line 4489 "configure"
  #include "confdefs.h"
  
  #include <sys/statfs.h>
--- 4482,4493 ----
  if test -z "$list_mounted_fs"; then
  # SVR3
  echo $ac_n "checking for FIXME existence of three headers""... $ac_c" 1>&6
! echo "configure:4486: checking for FIXME existence of three headers" >&5
  if eval "test \"`echo '$''{'fu_cv_sys_mounted_fread_fstyp'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
    cat > conftest.$ac_ext <<EOF
! #line 4491 "configure"
  #include "confdefs.h"
  
  #include <sys/statfs.h>
***************
*** 4493,4499 ****
  #include <mnttab.h>
  EOF
  ac_try="$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out"
! { (eval echo configure:4497: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
  ac_err=`grep -v '^ *+' conftest.out | grep -v "^conftest.${ac_ext}\$"`
  if test -z "$ac_err"; then
    rm -rf conftest*
--- 4495,4501 ----
  #include <mnttab.h>
  EOF
  ac_try="$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out"
! { (eval echo configure:4499: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
  ac_err=`grep -v '^ *+' conftest.out | grep -v "^conftest.${ac_ext}\$"`
  if test -z "$ac_err"; then
    rm -rf conftest*
***************
*** 4521,4527 ****
  if test -z "$list_mounted_fs"; then
  # 4.4BSD and DEC OSF/1.
  echo $ac_n "checking for getmntinfo function""... $ac_c" 1>&6
! echo "configure:4525: checking for getmntinfo function" >&5
  if eval "test \"`echo '$''{'fu_cv_sys_mounted_getmntinfo'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
--- 4523,4529 ----
  if test -z "$list_mounted_fs"; then
  # 4.4BSD and DEC OSF/1.
  echo $ac_n "checking for getmntinfo function""... $ac_c" 1>&6
! echo "configure:4527: checking for getmntinfo function" >&5
  if eval "test \"`echo '$''{'fu_cv_sys_mounted_getmntinfo'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
***************
*** 4529,4535 ****
  ok=
  if test $ac_cv_func_getmntinfo = yes; then
  cat > conftest.$ac_ext <<EOF
! #line 4533 "configure"
  #include "confdefs.h"
  #include <sys/mount.h>
  EOF
--- 4531,4537 ----
  ok=
  if test $ac_cv_func_getmntinfo = yes; then
  cat > conftest.$ac_ext <<EOF
! #line 4535 "configure"
  #include "confdefs.h"
  #include <sys/mount.h>
  EOF
***************
*** 4562,4580 ****
  if test -z "$list_mounted_fs"; then
  # Ultrix
  echo $ac_n "checking for getmnt function""... $ac_c" 1>&6
! echo "configure:4566: checking for getmnt function" >&5
  if eval "test \"`echo '$''{'fu_cv_sys_mounted_getmnt'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
    cat > conftest.$ac_ext <<EOF
! #line 4571 "configure"
  #include "confdefs.h"
  
  #include <sys/fs_types.h>
  #include <sys/mount.h>
  EOF
  ac_try="$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out"
! { (eval echo configure:4578: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
  ac_err=`grep -v '^ *+' conftest.out | grep -v "^conftest.${ac_ext}\$"`
  if test -z "$ac_err"; then
    rm -rf conftest*
--- 4564,4582 ----
  if test -z "$list_mounted_fs"; then
  # Ultrix
  echo $ac_n "checking for getmnt function""... $ac_c" 1>&6
! echo "configure:4568: checking for getmnt function" >&5
  if eval "test \"`echo '$''{'fu_cv_sys_mounted_getmnt'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
    cat > conftest.$ac_ext <<EOF
! #line 4573 "configure"
  #include "confdefs.h"
  
  #include <sys/fs_types.h>
  #include <sys/mount.h>
  EOF
  ac_try="$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out"
! { (eval echo configure:4580: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
  ac_err=`grep -v '^ *+' conftest.out | grep -v "^conftest.${ac_ext}\$"`
  if test -z "$ac_err"; then
    rm -rf conftest*
***************
*** 4602,4618 ****
  if test -z "$list_mounted_fs"; then
  # SVR2
  echo $ac_n "checking whether it is possible to resort to fread on /etc/mnttab""... $ac_c" 1>&6
! echo "configure:4606: checking whether it is possible to resort to fread on /etc/mnttab" >&5
  if eval "test \"`echo '$''{'fu_cv_sys_mounted_fread'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
    cat > conftest.$ac_ext <<EOF
! #line 4611 "configure"
  #include "confdefs.h"
  #include <mnttab.h>
  EOF
  ac_try="$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out"
! { (eval echo configure:4616: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
  ac_err=`grep -v '^ *+' conftest.out | grep -v "^conftest.${ac_ext}\$"`
  if test -z "$ac_err"; then
    rm -rf conftest*
--- 4604,4620 ----
  if test -z "$list_mounted_fs"; then
  # SVR2
  echo $ac_n "checking whether it is possible to resort to fread on /etc/mnttab""... $ac_c" 1>&6
! echo "configure:4608: checking whether it is possible to resort to fread on /etc/mnttab" >&5
  if eval "test \"`echo '$''{'fu_cv_sys_mounted_fread'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
    cat > conftest.$ac_ext <<EOF
! #line 4613 "configure"
  #include "confdefs.h"
  #include <mnttab.h>
  EOF
  ac_try="$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out"
! { (eval echo configure:4618: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
  ac_err=`grep -v '^ *+' conftest.out | grep -v "^conftest.${ac_ext}\$"`
  if test -z "$ac_err"; then
    rm -rf conftest*
***************
*** 4644,4650 ****
  fi
  
  echo "checking how to get filesystem space usage" 1>&6
! echo "configure:4648: checking how to get filesystem space usage" >&5
  space=no
  
  # Perform only the link test since it seems there are no variants of the
--- 4646,4652 ----
  fi
  
  echo "checking how to get filesystem space usage" 1>&6
! echo "configure:4650: checking how to get filesystem space usage" >&5
  space=no
  
  # Perform only the link test since it seems there are no variants of the
***************
*** 4656,4667 ****
  if test $space = no; then
  # SVR4
  echo $ac_n "checking statvfs function (SVR4)""... $ac_c" 1>&6
! echo "configure:4660: checking statvfs function (SVR4)" >&5
  if eval "test \"`echo '$''{'fu_cv_sys_stat_statvfs'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
    cat > conftest.$ac_ext <<EOF
! #line 4665 "configure"
  #include "confdefs.h"
  #include <sys/types.h>
  #include <sys/statvfs.h>
--- 4658,4669 ----
  if test $space = no; then
  # SVR4
  echo $ac_n "checking statvfs function (SVR4)""... $ac_c" 1>&6
! echo "configure:4662: checking statvfs function (SVR4)" >&5
  if eval "test \"`echo '$''{'fu_cv_sys_stat_statvfs'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
    cat > conftest.$ac_ext <<EOF
! #line 4667 "configure"
  #include "confdefs.h"
  #include <sys/types.h>
  #include <sys/statvfs.h>
***************
*** 4669,4675 ****
  struct statvfs fsd; statvfs (0, &fsd);
  ; return 0; }
  EOF
! if { (eval echo configure:4673: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
    rm -rf conftest*
    fu_cv_sys_stat_statvfs=yes
  else
--- 4671,4677 ----
  struct statvfs fsd; statvfs (0, &fsd);
  ; return 0; }
  EOF
! if { (eval echo configure:4675: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
    rm -rf conftest*
    fu_cv_sys_stat_statvfs=yes
  else
***************
*** 4694,4700 ****
  if test $space = no; then
  # DEC Alpha running OSF/1
  echo $ac_n "checking for 3-argument statfs function (DEC OSF/1)""... $ac_c" 1>&6
! echo "configure:4698: checking for 3-argument statfs function (DEC OSF/1)" >&5
  if eval "test \"`echo '$''{'fu_cv_sys_stat_statfs3_osf1'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
--- 4696,4702 ----
  if test $space = no; then
  # DEC Alpha running OSF/1
  echo $ac_n "checking for 3-argument statfs function (DEC OSF/1)""... $ac_c" 1>&6
! echo "configure:4700: checking for 3-argument statfs function (DEC OSF/1)" >&5
  if eval "test \"`echo '$''{'fu_cv_sys_stat_statfs3_osf1'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
***************
*** 4702,4708 ****
    fu_cv_sys_stat_statfs3_osf1=no
  else
    cat > conftest.$ac_ext <<EOF
! #line 4706 "configure"
  #include "confdefs.h"
  
  #include <sys/param.h>
--- 4704,4710 ----
    fu_cv_sys_stat_statfs3_osf1=no
  else
    cat > conftest.$ac_ext <<EOF
! #line 4708 "configure"
  #include "confdefs.h"
  
  #include <sys/param.h>
***************
*** 4715,4721 ****
  exit (statfs (".", &fsd, sizeof (struct statfs)));
  }
  EOF
! if { (eval echo configure:4719: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
  then
    fu_cv_sys_stat_statfs3_osf1=yes
  else
--- 4717,4723 ----
  exit (statfs (".", &fsd, sizeof (struct statfs)));
  }
  EOF
! if { (eval echo configure:4721: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
  then
    fu_cv_sys_stat_statfs3_osf1=yes
  else
***************
*** 4742,4748 ****
  if test $space = no; then
  # AIX
  echo $ac_n "checking for two-argument statfs with statfs.bsize member (AIX, 4.3BSD)""... $ac_c" 1>&6
! echo "configure:4746: checking for two-argument statfs with statfs.bsize member (AIX, 4.3BSD)" >&5
  if eval "test \"`echo '$''{'fu_cv_sys_stat_statfs2_bsize'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
--- 4744,4750 ----
  if test $space = no; then
  # AIX
  echo $ac_n "checking for two-argument statfs with statfs.bsize member (AIX, 4.3BSD)""... $ac_c" 1>&6
! echo "configure:4748: checking for two-argument statfs with statfs.bsize member (AIX, 4.3BSD)" >&5
  if eval "test \"`echo '$''{'fu_cv_sys_stat_statfs2_bsize'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
***************
*** 4750,4756 ****
    fu_cv_sys_stat_statfs2_bsize=no
  else
    cat > conftest.$ac_ext <<EOF
! #line 4754 "configure"
  #include "confdefs.h"
  
  #ifdef HAVE_SYS_PARAM_H
--- 4752,4758 ----
    fu_cv_sys_stat_statfs2_bsize=no
  else
    cat > conftest.$ac_ext <<EOF
! #line 4756 "configure"
  #include "confdefs.h"
  
  #ifdef HAVE_SYS_PARAM_H
***************
*** 4769,4775 ****
  exit (statfs (".", &fsd));
  }
  EOF
! if { (eval echo configure:4773: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
  then
    fu_cv_sys_stat_statfs2_bsize=yes
  else
--- 4771,4777 ----
  exit (statfs (".", &fsd));
  }
  EOF
! if { (eval echo configure:4775: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
  then
    fu_cv_sys_stat_statfs2_bsize=yes
  else
***************
*** 4796,4802 ****
  if test $space = no; then
  # SVR3
  echo $ac_n "checking for four-argument statfs (AIX-3.2.5, SVR3)""... $ac_c" 1>&6
! echo "configure:4800: checking for four-argument statfs (AIX-3.2.5, SVR3)" >&5
  if eval "test \"`echo '$''{'fu_cv_sys_stat_statfs4'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
--- 4798,4804 ----
  if test $space = no; then
  # SVR3
  echo $ac_n "checking for four-argument statfs (AIX-3.2.5, SVR3)""... $ac_c" 1>&6
! echo "configure:4802: checking for four-argument statfs (AIX-3.2.5, SVR3)" >&5
  if eval "test \"`echo '$''{'fu_cv_sys_stat_statfs4'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
***************
*** 4804,4810 ****
    fu_cv_sys_stat_statfs4=no
  else
    cat > conftest.$ac_ext <<EOF
! #line 4808 "configure"
  #include "confdefs.h"
  #include <sys/types.h>
  #include <sys/statfs.h>
--- 4806,4812 ----
    fu_cv_sys_stat_statfs4=no
  else
    cat > conftest.$ac_ext <<EOF
! #line 4810 "configure"
  #include "confdefs.h"
  #include <sys/types.h>
  #include <sys/statfs.h>
***************
*** 4814,4820 ****
  exit (statfs (".", &fsd, sizeof fsd, 0));
  }
  EOF
! if { (eval echo configure:4818: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
  then
    fu_cv_sys_stat_statfs4=yes
  else
--- 4816,4822 ----
  exit (statfs (".", &fsd, sizeof fsd, 0));
  }
  EOF
! if { (eval echo configure:4820: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
  then
    fu_cv_sys_stat_statfs4=yes
  else
***************
*** 4841,4847 ****
  if test $space = no; then
  # 4.4BSD and NetBSD
  echo $ac_n "checking for two-argument statfs with statfs.fsize member (4.4BSD and NetBSD)""... $ac_c" 1>&6
! echo "configure:4845: checking for two-argument statfs with statfs.fsize member (4.4BSD and NetBSD)" >&5
  if eval "test \"`echo '$''{'fu_cv_sys_stat_statfs2_fsize'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
--- 4843,4849 ----
  if test $space = no; then
  # 4.4BSD and NetBSD
  echo $ac_n "checking for two-argument statfs with statfs.fsize member (4.4BSD and NetBSD)""... $ac_c" 1>&6
! echo "configure:4847: checking for two-argument statfs with statfs.fsize member (4.4BSD and NetBSD)" >&5
  if eval "test \"`echo '$''{'fu_cv_sys_stat_statfs2_fsize'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
***************
*** 4849,4855 ****
    fu_cv_sys_stat_statfs2_fsize=no
  else
    cat > conftest.$ac_ext <<EOF
! #line 4853 "configure"
  #include "confdefs.h"
  #include <sys/types.h>
  #ifdef HAVE_SYS_PARAM_H
--- 4851,4857 ----
    fu_cv_sys_stat_statfs2_fsize=no
  else
    cat > conftest.$ac_ext <<EOF
! #line 4855 "configure"
  #include "confdefs.h"
  #include <sys/types.h>
  #ifdef HAVE_SYS_PARAM_H
***************
*** 4865,4871 ****
  exit (statfs (".", &fsd));
  }
  EOF
! if { (eval echo configure:4869: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
  then
    fu_cv_sys_stat_statfs2_fsize=yes
  else
--- 4867,4873 ----
  exit (statfs (".", &fsd));
  }
  EOF
! if { (eval echo configure:4871: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
  then
    fu_cv_sys_stat_statfs2_fsize=yes
  else
***************
*** 4892,4898 ****
  if test $space = no; then
  # Ultrix
  echo $ac_n "checking for two-argument statfs with struct fs_data (Ultrix)""... $ac_c" 1>&6
! echo "configure:4896: checking for two-argument statfs with struct fs_data (Ultrix)" >&5
  if eval "test \"`echo '$''{'fu_cv_sys_stat_fs_data'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
--- 4894,4900 ----
  if test $space = no; then
  # Ultrix
  echo $ac_n "checking for two-argument statfs with struct fs_data (Ultrix)""... $ac_c" 1>&6
! echo "configure:4898: checking for two-argument statfs with struct fs_data (Ultrix)" >&5
  if eval "test \"`echo '$''{'fu_cv_sys_stat_fs_data'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
***************
*** 4900,4906 ****
    fu_cv_sys_stat_fs_data=no
  else
    cat > conftest.$ac_ext <<EOF
! #line 4904 "configure"
  #include "confdefs.h"
  #include <sys/types.h>
  #ifdef HAVE_SYS_PARAM_H
--- 4902,4908 ----
    fu_cv_sys_stat_fs_data=no
  else
    cat > conftest.$ac_ext <<EOF
! #line 4906 "configure"
  #include "confdefs.h"
  #include <sys/types.h>
  #ifdef HAVE_SYS_PARAM_H
***************
*** 4920,4926 ****
  exit (statfs (".", &fsd) != 1);
  }
  EOF
! if { (eval echo configure:4924: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
  then
    fu_cv_sys_stat_fs_data=yes
  else
--- 4922,4928 ----
  exit (statfs (".", &fsd) != 1);
  }
  EOF
! if { (eval echo configure:4926: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
  then
    fu_cv_sys_stat_fs_data=yes
  else
***************
*** 4947,4958 ****
  if test $space = no; then
  # SVR2
  cat > conftest.$ac_ext <<EOF
! #line 4951 "configure"
  #include "confdefs.h"
  #include <sys/filsys.h>
  EOF
  ac_try="$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out"
! { (eval echo configure:4956: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
  ac_err=`grep -v '^ *+' conftest.out | grep -v "^conftest.${ac_ext}\$"`
  if test -z "$ac_err"; then
    rm -rf conftest*
--- 4949,4960 ----
  if test $space = no; then
  # SVR2
  cat > conftest.$ac_ext <<EOF
! #line 4953 "configure"
  #include "confdefs.h"
  #include <sys/filsys.h>
  EOF
  ac_try="$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out"
! { (eval echo configure:4958: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
  ac_err=`grep -v '^ *+' conftest.out | grep -v "^conftest.${ac_ext}\$"`
  if test -z "$ac_err"; then
    rm -rf conftest*
***************
*** 4977,4988 ****
  for ac_func in ftruncate
  do
  echo $ac_n "checking for $ac_func""... $ac_c" 1>&6
! echo "configure:4981: checking for $ac_func" >&5
  if eval "test \"`echo '$''{'ac_cv_func_$ac_func'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
    cat > conftest.$ac_ext <<EOF
! #line 4986 "configure"
  #include "confdefs.h"
  /* System header to define __stub macros and hopefully few prototypes,
      which can conflict with char $ac_func(); below.  */
--- 4979,4990 ----
  for ac_func in ftruncate
  do
  echo $ac_n "checking for $ac_func""... $ac_c" 1>&6
! echo "configure:4983: checking for $ac_func" >&5
  if eval "test \"`echo '$''{'ac_cv_func_$ac_func'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
    cat > conftest.$ac_ext <<EOF
! #line 4988 "configure"
  #include "confdefs.h"
  /* System header to define __stub macros and hopefully few prototypes,
      which can conflict with char $ac_func(); below.  */
***************
*** 5005,5011 ****
  
  ; return 0; }
  EOF
! if { (eval echo configure:5009: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
    rm -rf conftest*
    eval "ac_cv_func_$ac_func=yes"
  else
--- 5007,5013 ----
  
  ; return 0; }
  EOF
! if { (eval echo configure:5011: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
    rm -rf conftest*
    eval "ac_cv_func_$ac_func=yes"
  else
***************
*** 5033,5044 ****
  
  if test "$ftruncate_missing" = yes; then
  echo $ac_n "checking fcntl emulation of ftruncate""... $ac_c" 1>&6
! echo "configure:5037: checking fcntl emulation of ftruncate" >&5
  if eval "test \"`echo '$''{'fu_cv_sys_ftruncate_emulation'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
    cat > conftest.$ac_ext <<EOF
! #line 5042 "configure"
  #include "confdefs.h"
  
  #include <sys/types.h>
--- 5035,5046 ----
  
  if test "$ftruncate_missing" = yes; then
  echo $ac_n "checking fcntl emulation of ftruncate""... $ac_c" 1>&6
! echo "configure:5039: checking fcntl emulation of ftruncate" >&5
  if eval "test \"`echo '$''{'fu_cv_sys_ftruncate_emulation'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
    cat > conftest.$ac_ext <<EOF
! #line 5044 "configure"
  #include "confdefs.h"
  
  #include <sys/types.h>
***************
*** 5051,5057 ****
  
  ; return 0; }
  EOF
! if { (eval echo configure:5055: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
    rm -rf conftest*
    fu_cv_sys_ftruncate_emulation=yes
  else
--- 5053,5059 ----
  
  ; return 0; }
  EOF
! if { (eval echo configure:5057: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
    rm -rf conftest*
    fu_cv_sys_ftruncate_emulation=yes
  else
***************
*** 5079,5090 ****
  # If <sys/vfs.h> exists and struct statfs has a member named f_spare,
  # enable the work-around code in fsusage.c.
  echo $ac_n "checking for statfs that truncates block counts""... $ac_c" 1>&6
! echo "configure:5083: checking for statfs that truncates block counts" >&5
  if eval "test \"`echo '$''{'fu_cv_sys_truncating_statfs'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
    cat > conftest.$ac_ext <<EOF
! #line 5088 "configure"
  #include "confdefs.h"
  
  #if !defined(sun) && !defined(__sun)
--- 5081,5092 ----
  # If <sys/vfs.h> exists and struct statfs has a member named f_spare,
  # enable the work-around code in fsusage.c.
  echo $ac_n "checking for statfs that truncates block counts""... $ac_c" 1>&6
! echo "configure:5085: checking for statfs that truncates block counts" >&5
  if eval "test \"`echo '$''{'fu_cv_sys_truncating_statfs'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
    cat > conftest.$ac_ext <<EOF
! #line 5090 "configure"
  #include "confdefs.h"
  
  #if !defined(sun) && !defined(__sun)
***************
*** 5096,5102 ****
  struct statfs t; long c = *(t.f_spare);
  ; return 0; }
  EOF
! if { (eval echo configure:5100: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
    rm -rf conftest*
    fu_cv_sys_truncating_statfs=yes
  else
--- 5098,5104 ----
  struct statfs t; long c = *(t.f_spare);
  ; return 0; }
  EOF
! if { (eval echo configure:5102: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
    rm -rf conftest*
    fu_cv_sys_truncating_statfs=yes
  else
***************
*** 5117,5123 ****
  echo "$ac_t""$fu_cv_sys_truncating_statfs" 1>&6
  
  echo "checking for AFS" 1>&6
! echo "configure:5121: checking for AFS" >&5
  test -d /afs && cat >> confdefs.h <<\EOF
  #define AFS 1
  EOF
--- 5119,5125 ----
  echo "$ac_t""$fu_cv_sys_truncating_statfs" 1>&6
  
  echo "checking for AFS" 1>&6
! echo "configure:5123: checking for AFS" >&5
  test -d /afs && cat >> confdefs.h <<\EOF
  #define AFS 1
  EOF
***************
*** 5129,5137 ****
      HAVE_POS=yes
  else
    echo $ac_n "checking for pOS""... $ac_c" 1>&6
! echo "configure:5133: checking for pOS" >&5
    cat > conftest.$ac_ext <<EOF
! #line 5135 "configure"
  #include "confdefs.h"
  #ifdef __POS__
      yes
--- 5131,5139 ----
      HAVE_POS=yes
  else
    echo $ac_n "checking for pOS""... $ac_c" 1>&6
! echo "configure:5135: checking for pOS" >&5
    cat > conftest.$ac_ext <<EOF
! #line 5137 "configure"
  #include "confdefs.h"
  #ifdef __POS__
      yes
***************
*** 5168,5183 ****
    else
      if [ "x$ac_cv_header_ncurses_h" = "xno" ]; then
        echo $ac_n "checking for attr_t in curses.h""... $ac_c" 1>&6
! echo "configure:5172: checking for attr_t in curses.h" >&5
        cat > conftest.$ac_ext <<EOF
! #line 5174 "configure"
  #include "confdefs.h"
  #include <curses.h>
  int main() {
  { attr_t a; a = A_NORMAL; }
  ; return 0; }
  EOF
! if { (eval echo configure:5181: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
    rm -rf conftest*
    echo "$ac_t""yes" 1>&6
  else
--- 5170,5185 ----
    else
      if [ "x$ac_cv_header_ncurses_h" = "xno" ]; then
        echo $ac_n "checking for attr_t in curses.h""... $ac_c" 1>&6
! echo "configure:5174: checking for attr_t in curses.h" >&5
        cat > conftest.$ac_ext <<EOF
! #line 5176 "configure"
  #include "confdefs.h"
  #include <curses.h>
  int main() {
  { attr_t a; a = A_NORMAL; }
  ; return 0; }
  EOF
! if { (eval echo configure:5183: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
    rm -rf conftest*
    echo "$ac_t""yes" 1>&6
  else
***************
*** 5194,5209 ****
  rm -f conftest*
      else
        echo $ac_n "checking for attr_t in ncurses.h""... $ac_c" 1>&6
! echo "configure:5198: checking for attr_t in ncurses.h" >&5
        cat > conftest.$ac_ext <<EOF
! #line 5200 "configure"
  #include "confdefs.h"
  #include <ncurses.h>
  int main() {
  { attr_t a; a = A_NORMAL; }
  ; return 0; }
  EOF
! if { (eval echo configure:5207: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
    rm -rf conftest*
    echo "$ac_t""yes" 1>&6
  else
--- 5196,5211 ----
  rm -f conftest*
      else
        echo $ac_n "checking for attr_t in ncurses.h""... $ac_c" 1>&6
! echo "configure:5200: checking for attr_t in ncurses.h" >&5
        cat > conftest.$ac_ext <<EOF
! #line 5202 "configure"
  #include "confdefs.h"
  #include <ncurses.h>
  int main() {
  { attr_t a; a = A_NORMAL; }
  ; return 0; }
  EOF
! if { (eval echo configure:5209: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
    rm -rf conftest*
    echo "$ac_t""yes" 1>&6
  else
***************
*** 5223,5234 ****
  fi
  
  echo $ac_n "checking for pthread library""... $ac_c" 1>&6
! echo "configure:5227: checking for pthread library" >&5
  TMP_SAVE_CFLAGS=$CFLAGS
  TMP_SAVE_LIBS=$LIBS
  LIBS="$LIBS -lpthread"
  cat > conftest.$ac_ext <<EOF
! #line 5232 "configure"
  #include "confdefs.h"
  
  #include "confdefs.h"
--- 5225,5236 ----
  fi
  
  echo $ac_n "checking for pthread library""... $ac_c" 1>&6
! echo "configure:5229: checking for pthread library" >&5
  TMP_SAVE_CFLAGS=$CFLAGS
  TMP_SAVE_LIBS=$LIBS
  LIBS="$LIBS -lpthread"
  cat > conftest.$ac_ext <<EOF
! #line 5234 "configure"
  #include "confdefs.h"
  
  #include "confdefs.h"
***************
*** 5242,5248 ****
  
  ; return 0; }
  EOF
! if { (eval echo configure:5246: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
    rm -rf conftest*
    HAVE_PTHREAD_LIB=yes
  echo "$ac_t""yes" 1>&6
--- 5244,5250 ----
  
  ; return 0; }
  EOF
! if { (eval echo configure:5248: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
    rm -rf conftest*
    HAVE_PTHREAD_LIB=yes
  echo "$ac_t""yes" 1>&6
***************
*** 5258,5270 ****
  LIBS=$TMP_SAVE_LIBS
  
  echo $ac_n "checking for DirectX""... $ac_c" 1>&6
! echo "configure:5262: checking for DirectX" >&5
  TMP_SAVE_CFLAGS=$CFLAGS
  TMP_SAVE_LIBS=$LIBS
  CFLAGS="$CFLAGS $X_CFLAGS"
  LIBS="$LIBS -lddraw"
  cat > conftest.$ac_ext <<EOF
! #line 5268 "configure"
  #include "confdefs.h"
  
  #include "confdefs.h"
--- 5260,5272 ----
  LIBS=$TMP_SAVE_LIBS
  
  echo $ac_n "checking for DirectX""... $ac_c" 1>&6
! echo "configure:5264: checking for DirectX" >&5
  TMP_SAVE_CFLAGS=$CFLAGS
  TMP_SAVE_LIBS=$LIBS
  CFLAGS="$CFLAGS $X_CFLAGS"
  LIBS="$LIBS -lddraw"
  cat > conftest.$ac_ext <<EOF
! #line 5270 "configure"
  #include "confdefs.h"
  
  #include "confdefs.h"
***************
*** 5280,5286 ****
  
  ; return 0; }
  EOF
! if { (eval echo configure:5284: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
    rm -rf conftest*
    HAVE_DIRECTX=yes
  echo "$ac_t""yes" 1>&6
--- 5282,5288 ----
  
  ; return 0; }
  EOF
! if { (eval echo configure:5286: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
    rm -rf conftest*
    HAVE_DIRECTX=yes
  echo "$ac_t""yes" 1>&6
***************
*** 5301,5306 ****
--- 5303,5309 ----
  WANT_UI=dunno
  WANT_NCURSES_UI=no
  WANT_DGA=no
+ WANT_JIT=no
  WANT_VIDMODE=no
  
  # Check whether --enable-profiling or --disable-profiling was given.
***************
*** 5357,5362 ****
--- 5360,5371 ----
    WANT_UI=$enableval
  fi
  
+ # Check whether --enable-jit or --disable-jit was given.
+ if test "${enable_jit+set}" = set; then
+   enableval="$enable_jit"
+   WANT_JIT=$enableval
+ fi
+ 
  # Check whether --with-hostcc or --without-hostcc was given.
  if test "${with_hostcc+set}" = set; then
    withval="$with_hostcc"
***************
*** 5443,5449 ****
    TMP_SAVE_LIBS=$LIBS
    LIBS="$X_LIBS $LIBS"
    echo $ac_n "checking for XF86DGAQueryExtension in -lXxf86dga""... $ac_c" 1>&6
! echo "configure:5447: checking for XF86DGAQueryExtension in -lXxf86dga" >&5
  ac_lib_var=`echo Xxf86dga'_'XF86DGAQueryExtension | sed 'y%./+-%__p_%'`
  if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
--- 5452,5458 ----
    TMP_SAVE_LIBS=$LIBS
    LIBS="$X_LIBS $LIBS"
    echo $ac_n "checking for XF86DGAQueryExtension in -lXxf86dga""... $ac_c" 1>&6
! echo "configure:5456: checking for XF86DGAQueryExtension in -lXxf86dga" >&5
  ac_lib_var=`echo Xxf86dga'_'XF86DGAQueryExtension | sed 'y%./+-%__p_%'`
  if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
***************
*** 5451,5457 ****
    ac_save_LIBS="$LIBS"
  LIBS="-lXxf86dga  $X_PRE_LIBS -lXext -lX11 $X_EXTRA_LIBS  $LIBS"
  cat > conftest.$ac_ext <<EOF
! #line 5455 "configure"
  #include "confdefs.h"
  /* Override any gcc2 internal prototype to avoid an error.  */
  /* We use char because int might match the return type of a gcc2
--- 5460,5466 ----
    ac_save_LIBS="$LIBS"
  LIBS="-lXxf86dga  $X_PRE_LIBS -lXext -lX11 $X_EXTRA_LIBS  $LIBS"
  cat > conftest.$ac_ext <<EOF
! #line 5464 "configure"
  #include "confdefs.h"
  /* Override any gcc2 internal prototype to avoid an error.  */
  /* We use char because int might match the return type of a gcc2
***************
*** 5462,5468 ****
  XF86DGAQueryExtension()
  ; return 0; }
  EOF
! if { (eval echo configure:5466: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
    rm -rf conftest*
    eval "ac_cv_lib_$ac_lib_var=yes"
  else
--- 5471,5477 ----
  XF86DGAQueryExtension()
  ; return 0; }
  EOF
! if { (eval echo configure:5475: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
    rm -rf conftest*
    eval "ac_cv_lib_$ac_lib_var=yes"
  else
***************
*** 5495,5501 ****
    TMP_SAVE_LIBS=$LIBS
    LIBS="$X_LIBS $LIBS"
    echo $ac_n "checking for XF86VidModeQueryExtension in -lXxf86vm""... $ac_c" 1>&6
! echo "configure:5499: checking for XF86VidModeQueryExtension in -lXxf86vm" >&5
  ac_lib_var=`echo Xxf86vm'_'XF86VidModeQueryExtension | sed 'y%./+-%__p_%'`
  if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
--- 5504,5510 ----
    TMP_SAVE_LIBS=$LIBS
    LIBS="$X_LIBS $LIBS"
    echo $ac_n "checking for XF86VidModeQueryExtension in -lXxf86vm""... $ac_c" 1>&6
! echo "configure:5508: checking for XF86VidModeQueryExtension in -lXxf86vm" >&5
  ac_lib_var=`echo Xxf86vm'_'XF86VidModeQueryExtension | sed 'y%./+-%__p_%'`
  if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
***************
*** 5503,5509 ****
    ac_save_LIBS="$LIBS"
  LIBS="-lXxf86vm  $X_PRE_LIBS -lXext -lX11 $X_EXTRA_LIBS  $LIBS"
  cat > conftest.$ac_ext <<EOF
! #line 5507 "configure"
  #include "confdefs.h"
  /* Override any gcc2 internal prototype to avoid an error.  */
  /* We use char because int might match the return type of a gcc2
--- 5512,5518 ----
    ac_save_LIBS="$LIBS"
  LIBS="-lXxf86vm  $X_PRE_LIBS -lXext -lX11 $X_EXTRA_LIBS  $LIBS"
  cat > conftest.$ac_ext <<EOF
! #line 5516 "configure"
  #include "confdefs.h"
  /* Override any gcc2 internal prototype to avoid an error.  */
  /* We use char because int might match the return type of a gcc2
***************
*** 5514,5520 ****
  XF86VidModeQueryExtension()
  ; return 0; }
  EOF
! if { (eval echo configure:5518: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
    rm -rf conftest*
    eval "ac_cv_lib_$ac_lib_var=yes"
  else
--- 5523,5529 ----
  XF86VidModeQueryExtension()
  ; return 0; }
  EOF
! if { (eval echo configure:5527: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
    rm -rf conftest*
    eval "ac_cv_lib_$ac_lib_var=yes"
  else
***************
*** 5584,5590 ****
    # Extract the first word of "gtk-config", so it can be a program name with args.
  set dummy gtk-config; ac_word=$2
  echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
! echo "configure:5588: checking for $ac_word" >&5
  if eval "test \"`echo '$''{'ac_cv_path_GTK_CONFIG'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
--- 5593,5599 ----
    # Extract the first word of "gtk-config", so it can be a program name with args.
  set dummy gtk-config; ac_word=$2
  echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
! echo "configure:5597: checking for $ac_word" >&5
  if eval "test \"`echo '$''{'ac_cv_path_GTK_CONFIG'+set}'`\" = set"; then
    echo $ac_n "(cached) $ac_c" 1>&6
  else
***************
*** 5619,5625 ****
  
    min_gtk_version=0.99.7
    echo $ac_n "checking for GTK - version >= $min_gtk_version""... $ac_c" 1>&6
! echo "configure:5623: checking for GTK - version >= $min_gtk_version" >&5
    no_gtk=""
    if test "$GTK_CONFIG" = "no" ; then
      no_gtk=yes
--- 5628,5634 ----
  
    min_gtk_version=0.99.7
    echo $ac_n "checking for GTK - version >= $min_gtk_version""... $ac_c" 1>&6
! echo "configure:5632: checking for GTK - version >= $min_gtk_version" >&5
    no_gtk=""
    if test "$GTK_CONFIG" = "no" ; then
      no_gtk=yes
***************
*** 5642,5648 ****
    echo $ac_n "cross compiling; assumed OK... $ac_c"
  else
    cat > conftest.$ac_ext <<EOF
! #line 5646 "configure"
  #include "confdefs.h"
  
  #include <gtk/gtk.h>
--- 5651,5657 ----
    echo $ac_n "cross compiling; assumed OK... $ac_c"
  else
    cat > conftest.$ac_ext <<EOF
! #line 5655 "configure"
  #include "confdefs.h"
  
  #include <gtk/gtk.h>
***************
*** 5705,5711 ****
  }
  
  EOF
! if { (eval echo configure:5709: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
  then
    :
  else
--- 5714,5720 ----
  }
  
  EOF
! if { (eval echo configure:5718: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
  then
    :
  else
***************
*** 5739,5745 ****
            CFLAGS="$CFLAGS $GTK_CFLAGS"
            LIBS="$LIBS $GTK_LIBS"
            cat > conftest.$ac_ext <<EOF
! #line 5743 "configure"
  #include "confdefs.h"
  
  #include <gtk/gtk.h>
--- 5748,5754 ----
            CFLAGS="$CFLAGS $GTK_CFLAGS"
            LIBS="$LIBS $GTK_LIBS"
            cat > conftest.$ac_ext <<EOF
! #line 5752 "configure"
  #include "confdefs.h"
  
  #include <gtk/gtk.h>
***************
*** 5749,5755 ****
   return ((gtk_major_version) || (gtk_minor_version) || (gtk_micro_version)); 
  ; return 0; }
  EOF
! if { (eval echo configure:5753: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
    rm -rf conftest*
     echo "*** The test program compiled, but did not run. This usually means"
            echo "*** that the run-time linker is not finding GTK or finding the wrong"
--- 5758,5764 ----
   return ((gtk_major_version) || (gtk_minor_version) || (gtk_micro_version)); 
  ; return 0; }
  EOF
! if { (eval echo configure:5762: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
    rm -rf conftest*
     echo "*** The test program compiled, but did not run. This usually means"
            echo "*** that the run-time linker is not finding GTK or finding the wrong"
***************
*** 5792,5804 ****
  SHM_SUPPORT_LINKS=0
  if [ "x$no_x" != "xyes" -a "x$ac_cv_header_sys_ipc_h" = "xyes" -a "x$ac_cv_header_sys_shm_h" = "xyes" ]; then
    echo $ac_n "checking whether the X11 MIT-SHM extension can be compiled in""... $ac_c" 1>&6
! echo "configure:5796: checking whether the X11 MIT-SHM extension can be compiled in" >&5
    TMP_SAVE_CFLAGS=$CFLAGS
    TMP_SAVE_LIBS=$LIBS
    CFLAGS="$CFLAGS $X_CFLAGS"
    LIBS="$X_LIBS $LIBS $X_PRE_LIBS -lX11 -lXext $X_EXTRA_LIBS"
    cat > conftest.$ac_ext <<EOF
! #line 5802 "configure"
  #include "confdefs.h"
  
  #include "confdefs.h"
--- 5801,5813 ----
  SHM_SUPPORT_LINKS=0
  if [ "x$no_x" != "xyes" -a "x$ac_cv_header_sys_ipc_h" = "xyes" -a "x$ac_cv_header_sys_shm_h" = "xyes" ]; then
    echo $ac_n "checking whether the X11 MIT-SHM extension can be compiled in""... $ac_c" 1>&6
! echo "configure:5805: checking whether the X11 MIT-SHM extension can be compiled in" >&5
    TMP_SAVE_CFLAGS=$CFLAGS
    TMP_SAVE_LIBS=$LIBS
    CFLAGS="$CFLAGS $X_CFLAGS"
    LIBS="$X_LIBS $LIBS $X_PRE_LIBS -lX11 -lXext $X_EXTRA_LIBS"
    cat > conftest.$ac_ext <<EOF
! #line 5811 "configure"
  #include "confdefs.h"
  
  #include "confdefs.h"
***************
*** 5822,5828 ****
  
  ; return 0; }
  EOF
! if { (eval echo configure:5826: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
    rm -rf conftest*
    SHM_SUPPORT_LINKS=1
  echo "$ac_t""yes" 1>&6
--- 5831,5837 ----
  
  ; return 0; }
  EOF
! if { (eval echo configure:5835: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
    rm -rf conftest*
    SHM_SUPPORT_LINKS=1
  echo "$ac_t""yes" 1>&6
***************
*** 5842,5848 ****
  DEBUGOBJS="debug.o"
  
  echo $ac_n "checking which target to use""... $ac_c" 1>&6
! echo "configure:5846: checking which target to use" >&5
  
  if [ "x$WANT_SDLGFX" = "xyes" ]; then
    echo "$ac_t""SDL" 1>&6
--- 5851,5857 ----
  DEBUGOBJS="debug.o"
  
  echo $ac_n "checking which target to use""... $ac_c" 1>&6
! echo "configure:5855: checking which target to use" >&5
  
  if [ "x$WANT_SDLGFX" = "xyes" ]; then
    echo "$ac_t""SDL" 1>&6
***************
*** 5973,5986 ****
      if [ "x$no_gtk" = "xyes" ]; then
        echo "Did not find gtk+, disabling user interface"
        GTK_CFLAGS=
!       TK_LIBS=
        if [ "x$WANT_UI" = "xyes" ]; then
          NR_ERRORS=`expr $NR_ERRORS + 1`
        fi
      else
        echo "Using gtk+ GUI."
        NEED_THREAD_SUPPORT=yes
!       DDITIONAL_CFLAGS="$ADDITIONAL_CFLAGS -DUSING_GTK_GUI"
        GUIOBJS=gtkui.o
      fi
    else 
--- 5982,5995 ----
      if [ "x$no_gtk" = "xyes" ]; then
        echo "Did not find gtk+, disabling user interface"
        GTK_CFLAGS=
!       GUIOBJS=nogui.o
        if [ "x$WANT_UI" = "xyes" ]; then
          NR_ERRORS=`expr $NR_ERRORS + 1`
        fi
      else
        echo "Using gtk+ GUI."
        NEED_THREAD_SUPPORT=yes
!       ADDITIONAL_CFLAGS="$ADDITIONAL_CFLAGS -DUSING_GTK_GUI"
        GUIOBJS=gtkui.o
      fi
    else 
***************
*** 5998,6003 ****
--- 6007,6018 ----
    GUIOBJS=nogui.o
  fi
  
+ JITOBJS=""
+ if [ "x$WANT_JIT" = "xyes" ]; then
+   JITOBJS="compstbl.o compemu.o compemu_support.o compemu_fpp.o cpustbl_nf.o cpufast_nf.o"
+   ADDITIONAL_CFLAGS="$ADDITIONAL_CFLAGS -DJIT -DNATMEM_OFFSET=0x50000000"
+ fi
+ 
  GFXOBJS="$GFXOBJS $GUIOBJS"
   
  
***************
*** 6025,6033 ****
  CPUOBJS=cpuemu.o
  
  echo $ac_n "checking for GCC 2.7 or higher""... $ac_c" 1>&6
! echo "configure:6029: checking for GCC 2.7 or higher" >&5
  cat > conftest.$ac_ext <<EOF
! #line 6031 "configure"
  #include "confdefs.h"
  #if __GNUC__ - 1 > 1 || __GNUC_MINOR__ - 1 > 5
    yes
--- 6040,6048 ----
  CPUOBJS=cpuemu.o
  
  echo $ac_n "checking for GCC 2.7 or higher""... $ac_c" 1>&6
! echo "configure:6044: checking for GCC 2.7 or higher" >&5
  cat > conftest.$ac_ext <<EOF
! #line 6046 "configure"
  #include "confdefs.h"
  #if __GNUC__ - 1 > 1 || __GNUC_MINOR__ - 1 > 5
    yes
***************
*** 6058,6066 ****
  
  if [ "x$ac_cv_header_features_h" = "xyes" ]; then
    echo $ac_n "checking for glibc-2.0 or higher""... $ac_c" 1>&6
! echo "configure:6062: checking for glibc-2.0 or higher" >&5
    cat > conftest.$ac_ext <<EOF
! #line 6064 "configure"
  #include "confdefs.h"
  #include <features.h>
  #if __GLIBC__ - 1 >= 1
--- 6073,6081 ----
  
  if [ "x$ac_cv_header_features_h" = "xyes" ]; then
    echo $ac_n "checking for glibc-2.0 or higher""... $ac_c" 1>&6
! echo "configure:6077: checking for glibc-2.0 or higher" >&5
    cat > conftest.$ac_ext <<EOF
! #line 6079 "configure"
  #include "confdefs.h"
  #include <features.h>
  #if __GLIBC__ - 1 >= 1
***************
*** 6107,6115 ****
  fi
  
  echo $ac_n "checking for x86 target CPU""... $ac_c" 1>&6
! echo "configure:6111: checking for x86 target CPU" >&5
  cat > conftest.$ac_ext <<EOF
! #line 6113 "configure"
  #include "confdefs.h"
  
  #ifdef __i386__
--- 6122,6130 ----
  fi
  
  echo $ac_n "checking for x86 target CPU""... $ac_c" 1>&6
! echo "configure:6126: checking for x86 target CPU" >&5
  cat > conftest.$ac_ext <<EOF
! #line 6128 "configure"
  #include "confdefs.h"
  
  #ifdef __i386__
***************
*** 6129,6137 ****
  
  
  echo $ac_n "checking for m68k target CPU""... $ac_c" 1>&6
! echo "configure:6133: checking for m68k target CPU" >&5
  cat > conftest.$ac_ext <<EOF
! #line 6135 "configure"
  #include "confdefs.h"
  
  #ifdef __m68k__
--- 6144,6152 ----
  
  
  echo $ac_n "checking for m68k target CPU""... $ac_c" 1>&6
! echo "configure:6148: checking for m68k target CPU" >&5
  cat > conftest.$ac_ext <<EOF
! #line 6150 "configure"
  #include "confdefs.h"
  
  #ifdef __m68k__
***************
*** 6151,6159 ****
  
  
  echo $ac_n "checking for ppc target CPU""... $ac_c" 1>&6
! echo "configure:6155: checking for ppc target CPU" >&5
  cat > conftest.$ac_ext <<EOF
! #line 6157 "configure"
  #include "confdefs.h"
  
  #ifdef __powerpc__
--- 6166,6174 ----
  
  
  echo $ac_n "checking for ppc target CPU""... $ac_c" 1>&6
! echo "configure:6170: checking for ppc target CPU" >&5
  cat > conftest.$ac_ext <<EOF
! #line 6172 "configure"
  #include "confdefs.h"
  
  #ifdef __powerpc__
***************
*** 6182,6188 ****
  
  
  echo $ac_n "checking whether assembler symbols need an underscore""... $ac_c" 1>&6
! echo "configure:6186: checking whether assembler symbols need an underscore" >&5
  cat >conftest1.S << EOF
  	.text
  	.globl _symbol
--- 6197,6203 ----
  
  
  echo $ac_n "checking whether assembler symbols need an underscore""... $ac_c" 1>&6
! echo "configure:6201: checking whether assembler symbols need an underscore" >&5
  cat >conftest1.S << EOF
  	.text
  	.globl _symbol
***************
*** 6219,6232 ****
    SAVECFLAGS=$CFLAGS
    CFLAGS="$CFLAGS -mno-schedule-prologue"
    cat > conftest.$ac_ext <<EOF
! #line 6223 "configure"
  #include "confdefs.h"
  
  int main() {
  int main(){return 0;}
  ; return 0; }
  EOF
! if { (eval echo configure:6230: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
    rm -rf conftest*
    NO_SCHED_CFLAGS="-mno-schedule-prologue"
  else
--- 6234,6247 ----
    SAVECFLAGS=$CFLAGS
    CFLAGS="$CFLAGS -mno-schedule-prologue"
    cat > conftest.$ac_ext <<EOF
! #line 6238 "configure"
  #include "confdefs.h"
  
  int main() {
  int main(){return 0;}
  ; return 0; }
  EOF
! if { (eval echo configure:6245: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
    rm -rf conftest*
    NO_SCHED_CFLAGS="-mno-schedule-prologue"
  else
***************
*** 6241,6254 ****
    SAVECFLAGS=$CFLAGS
    CFLAGS="$CFLAGS -mpreferred-stack-boundary=2"
    cat > conftest.$ac_ext <<EOF
! #line 6245 "configure"
  #include "confdefs.h"
  
  int main() {
  int main(){return 0;}
  ; return 0; }
  EOF
! if { (eval echo configure:6252: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
    rm -rf conftest*
    SAVECFLAGS=$CFLAGS
  else
--- 6256,6269 ----
    SAVECFLAGS=$CFLAGS
    CFLAGS="$CFLAGS -mpreferred-stack-boundary=2"
    cat > conftest.$ac_ext <<EOF
! #line 6260 "configure"
  #include "confdefs.h"
  
  int main() {
  int main(){return 0;}
  ; return 0; }
  EOF
! if { (eval echo configure:6267: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
    rm -rf conftest*
    SAVECFLAGS=$CFLAGS
  else
***************
*** 6265,6278 ****
    CFLAGS="$CFLAGS -fno-exceptions"
    NOEXCEPTIONS=no
    cat > conftest.$ac_ext <<EOF
! #line 6269 "configure"
  #include "confdefs.h"
  
  int main() {
  int main(){return 0;}
  ; return 0; }
  EOF
! if { (eval echo configure:6276: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
    rm -rf conftest*
    NOEXCEPTIONS=yes
  else
--- 6280,6293 ----
    CFLAGS="$CFLAGS -fno-exceptions"
    NOEXCEPTIONS=no
    cat > conftest.$ac_ext <<EOF
! #line 6284 "configure"
  #include "confdefs.h"
  
  int main() {
  int main(){return 0;}
  ; return 0; }
  EOF
! if { (eval echo configure:6291: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
    rm -rf conftest*
    NOEXCEPTIONS=yes
  else
***************
*** 6383,6391 ****
  HAVE_USS_SOUND=no
  if [ "x$ac_cv_header_sys_soundcard_h" = "xyes" -o "x$ac_cv_header_machine_soundcard_h" = "xyes" ]; then
      echo $ac_n "checking whether sys/soundcard.h or machine/soundcard.h works""... $ac_c" 1>&6
! echo "configure:6387: checking whether sys/soundcard.h or machine/soundcard.h works" >&5
    cat > conftest.$ac_ext <<EOF
! #line 6389 "configure"
  #include "confdefs.h"
  
  #include "confdefs.h"
--- 6398,6406 ----
  HAVE_USS_SOUND=no
  if [ "x$ac_cv_header_sys_soundcard_h" = "xyes" -o "x$ac_cv_header_machine_soundcard_h" = "xyes" ]; then
      echo $ac_n "checking whether sys/soundcard.h or machine/soundcard.h works""... $ac_c" 1>&6
! echo "configure:6402: checking whether sys/soundcard.h or machine/soundcard.h works" >&5
    cat > conftest.$ac_ext <<EOF
! #line 6404 "configure"
  #include "confdefs.h"
  
  #include "confdefs.h"
***************
*** 6400,6406 ****
  int soundfd; ioctl (soundfd, SNDCTL_DSP_GETFMTS, 0);
  ; return 0; }
  EOF
! if { (eval echo configure:6404: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
    rm -rf conftest*
    echo "$ac_t""yes" 1>&6
  HAVE_USS_SOUND=yes
--- 6415,6421 ----
  int soundfd; ioctl (soundfd, SNDCTL_DSP_GETFMTS, 0);
  ; return 0; }
  EOF
! if { (eval echo configure:6419: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
    rm -rf conftest*
    echo "$ac_t""yes" 1>&6
  HAVE_USS_SOUND=yes
***************
*** 6418,6424 ****
  fi
  
  echo $ac_n "checking which sound system to use""... $ac_c" 1>&6
! echo "configure:6422: checking which sound system to use" >&5
  # Check whether --enable-file-sound or --disable-file-sound was given.
  if test "${enable_file_sound+set}" = set; then
    enableval="$enable_file_sound"
--- 6433,6439 ----
  fi
  
  echo $ac_n "checking which sound system to use""... $ac_c" 1>&6
! echo "configure:6437: checking which sound system to use" >&5
  # Check whether --enable-file-sound or --disable-file-sound was given.
  if test "${enable_file_sound+set}" = set; then
    enableval="$enable_file_sound"
***************
*** 6539,6551 ****
  
  if [ "x$USE_SCSI_DEVICE" = "xyes" ]; then
    echo $ac_n "checking "availability of libscg headers and lib"""... $ac_c" 1>&6
! echo "configure:6543: checking "availability of libscg headers and lib"" >&5
    OLDLIBS="$LIBS"
    OLDCFLAGS="$CFLAGS"
    CFLAGS="$CFLAGS -Isrc/include"
    LIBS="-Lsrc $LIBS -lscg -lschily"
    cat > conftest.$ac_ext <<EOF
! #line 6549 "configure"
  #include "confdefs.h"
  typedef int BOOL;
  #include "scg/scgcmd.h"
--- 6554,6566 ----
  
  if [ "x$USE_SCSI_DEVICE" = "xyes" ]; then
    echo $ac_n "checking "availability of libscg headers and lib"""... $ac_c" 1>&6
! echo "configure:6558: checking "availability of libscg headers and lib"" >&5
    OLDLIBS="$LIBS"
    OLDCFLAGS="$CFLAGS"
    CFLAGS="$CFLAGS -Isrc/include"
    LIBS="-Lsrc $LIBS -lscg -lschily"
    cat > conftest.$ac_ext <<EOF
! #line 6564 "configure"
  #include "confdefs.h"
  typedef int BOOL;
  #include "scg/scgcmd.h"
***************
*** 6555,6561 ****
  {SCSI *scgp = open_scsi ((void *)0, (void *)0, 0, 1, 1);}
  ; return 0; }
  EOF
! if { (eval echo configure:6559: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
    rm -rf conftest*
    
      echo "$ac_t""available" 1>&6
--- 6570,6576 ----
  {SCSI *scgp = open_scsi ((void *)0, (void *)0, 0, 1, 1);}
  ; return 0; }
  EOF
! if { (eval echo configure:6574: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
    rm -rf conftest*
    
      echo "$ac_t""available" 1>&6
***************
*** 6579,6594 ****
  
  if [ "x$WANT_SDL" = "xyes" ]; then
      OD_JOYSTICK=sdl-joystick.c
! else if [ "x$HAVE_MACHINE_JOYSTICK_H" = "xyes" ]; then
      cat > conftest.$ac_ext <<EOF
! #line 6585 "configure"
  #include "confdefs.h"
  #include <machine/joystick.h>
  int main() {
  { struct joystick a; }
  ; return 0; }
  EOF
! if { (eval echo configure:6592: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
    rm -rf conftest*
    OD_JOYSTICK=od-linux/joystick.c
  else
--- 6594,6609 ----
  
  if [ "x$WANT_SDL" = "xyes" ]; then
      OD_JOYSTICK=sdl-joystick.c
! else if [ "x$ac_cv_header_machine_joystick_h" = "xyes" ]; then
      cat > conftest.$ac_ext <<EOF
! #line 6600 "configure"
  #include "confdefs.h"
  #include <machine/joystick.h>
  int main() {
  { struct joystick a; }
  ; return 0; }
  EOF
! if { (eval echo configure:6607: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
    rm -rf conftest*
    OD_JOYSTICK=od-linux/joystick.c
  else
***************
*** 6616,6628 ****
  
  if [ "x$TARGET" = "xamigaos" -o "x$TARGET" = "xp_os" ]; then
      echo $ac_n "checking which CPU to use""... $ac_c" 1>&6
! echo "configure:6620: checking which CPU to use" >&5
    cpu=`cpu | cut -d' ' -f2`
    echo "$ac_t""$cpu" 1>&6
    CFLAGS="$CFLAGS -m$cpu"
  
      echo $ac_n "checking which FPU to use""... $ac_c" 1>&6
! echo "configure:6626: checking which FPU to use" >&5
    fpu=`cpu | cut -d' ' -f3 | grep '^688812$'`
    if [ "x$fpu" != "x" ]; then
          echo "$ac_t""68881" 1>&6
--- 6631,6643 ----
  
  if [ "x$TARGET" = "xamigaos" -o "x$TARGET" = "xp_os" ]; then
      echo $ac_n "checking which CPU to use""... $ac_c" 1>&6
! echo "configure:6635: checking which CPU to use" >&5
    cpu=`cpu | cut -d' ' -f2`
    echo "$ac_t""$cpu" 1>&6
    CFLAGS="$CFLAGS -m$cpu"
  
      echo $ac_n "checking which FPU to use""... $ac_c" 1>&6
! echo "configure:6641: checking which FPU to use" >&5
    fpu=`cpu | cut -d' ' -f3 | grep '^688812$'`
    if [ "x$fpu" != "x" ]; then
          echo "$ac_t""68881" 1>&6
***************
*** 6804,6809 ****
--- 6821,6828 ----
  s%@LIBRARIES@%$LIBRARIES%g
  s%@TARGET@%$TARGET%g
  s%@GFXOBJS@%$GFXOBJS%g
+ s%@JITOBJS@%$JITOBJS%g
+ s%@JIT_CFLAGS@%$JIT_CFLAGS%g
  s%@RESOBJS@%$RESOBJS%g
  s%@ASMOBJS@%$ASMOBJS%g
  s%@SCSIOBJS@%$SCSIOBJS%g
diff -crB --new-file ./uae-0.8.21/configure.in ../uae_jit_cleaning/uae-0.8.21/configure.in
*** ./uae-0.8.21/configure.in	2002-02-04 15:23:29.000000000 +0200
--- ../uae_jit_cleaning/uae-0.8.21/configure.in	2021-01-10 13:10:29.822591684 +0200
***************
*** 224,229 ****
--- 224,230 ----
  WANT_UI=dunno
  WANT_NCURSES_UI=no
  WANT_DGA=no
+ WANT_JIT=no
  WANT_VIDMODE=no
  
  AC_ARG_ENABLE(profiling,[  --enable-profiling      Build a profiling (SLOW!) version],[DO_PROFILING=$enableval],[])
***************
*** 235,240 ****
--- 236,242 ----
  AC_ARG_ENABLE(dga,[  --enable-dga            X11 version: Use the DGA extension],[WANT_DGA=$enableval],[])
  AC_ARG_ENABLE(vidmode,[  --enable-vidmode        X11 version: Use the XF86VidMode extension],[WANT_VIDMODE=$enableval],[])
  AC_ARG_ENABLE(ui,[  --enable-ui             Use a user interface if possible (default on)],[WANT_UI=$enableval],[])
+ AC_ARG_ENABLE(jit,[  --enable-jit            linux/X11 version: Use the JIT compiler],[WANT_JIT=$enableval],[])
  AC_ARG_WITH(hostcc,[  --with-hostcc=x         Use a x as compiler for the host system],[HOSTCC=$withval],[HOSTCC=$CC])
  
  dnl Some simple plausibility tests...
***************
*** 519,525 ****
      else
        echo "Using gtk+ GUI."
        NEED_THREAD_SUPPORT=yes
!       DDITIONAL_CFLAGS="$ADDITIONAL_CFLAGS -DUSING_GTK_GUI"
        GUIOBJS=gtkui.o
      fi
    else 
--- 521,527 ----
      else
        echo "Using gtk+ GUI."
        NEED_THREAD_SUPPORT=yes
!       ADDITIONAL_CFLAGS="$ADDITIONAL_CFLAGS -DUSING_GTK_GUI"
        GUIOBJS=gtkui.o
      fi
    else 
***************
*** 537,542 ****
--- 539,550 ----
    GUIOBJS=nogui.o
  fi
  
+ JITOBJS=""
+ if [[ "x$WANT_JIT" = "xyes" ]]; then
+   JITOBJS="compstbl.o compemu.o compemu_support.o compemu_fpp.o cpustbl_nf.o cpufast_nf.o"
+   ADDITIONAL_CFLAGS="$ADDITIONAL_CFLAGS -DJIT -DNATMEM_OFFSET=0x50000000"
+ fi
+ 
  GFXOBJS="$GFXOBJS $GUIOBJS"
   
  dnl Find out some things about the system 
***************
*** 1023,1028 ****
--- 1031,1037 ----
  AC_SUBST(LIBRARIES)
  AC_SUBST(TARGET)
  AC_SUBST(GFXOBJS)
+ AC_SUBST(JITOBJS)
  AC_SUBST(RESOBJS)
  AC_SUBST(ASMOBJS)
  AC_SUBST(SCSIOBJS)
diff -crB --new-file ./uae-0.8.21/docs/HOWTOBUILD.txt ../uae_jit_cleaning/uae-0.8.21/docs/HOWTOBUILD.txt
*** ./uae-0.8.21/docs/HOWTOBUILD.txt	1970-01-01 02:00:00.000000000 +0200
--- ../uae_jit_cleaning/uae-0.8.21/docs/HOWTOBUILD.txt	2021-01-10 14:15:07.030591684 +0200
***************
*** 0 ****
--- 1,20 ----
+ 1) Howto build:
+ 
+ Using old gcc 2.95.4
+ 
+ ./configure --enable-jit
+ make
+ 
+ 2) Howto run after build:
+ 
+ Create src/uae_conf.txt
+ ---------------------------------
+ cpu_type=68000
+ immediate_blits=true
+ kickstart_rom_file=path_to.rom
+ sound_output=none
+ ---------------------------------
+ 
+ cd src
+ ./uae -f ./uae_conf.txt
+ 
diff -crB --new-file ./uae-0.8.21/Makefile ../uae_jit_cleaning/uae-0.8.21/Makefile
*** ./uae-0.8.21/Makefile	1970-01-01 02:00:00.000000000 +0200
--- ../uae_jit_cleaning/uae-0.8.21/Makefile	2021-01-10 13:54:01.338591684 +0200
***************
*** 0 ****
--- 1,18 ----
+ # Generated automatically from Makefile.in by configure.
+ #
+ # Top-level Makefile for UAE
+ #
+ 
+ all:
+ 	cd src && $(MAKE)
+ 	cp src/uae .
+ 	cp src/readdisk .
+ 
+ clean:
+ 	cd src && $(MAKE) clean
+ 	rm -f uae readdisk 
+ 	
+ streifenfrei:
+ 	cd src && $(MAKE) streifenfrei
+ 	rm -f uae readdisk
+ 	rm -f config.cache config.log config.status Makefile
diff -crB --new-file ./uae-0.8.21/src/audio.c ../uae_jit_cleaning/uae-0.8.21/src/audio.c
*** ./uae-0.8.21/src/audio.c	2001-12-30 17:15:56.000000000 +0200
--- ../uae_jit_cleaning/uae-0.8.21/src/audio.c	2021-01-10 13:10:29.826591684 +0200
***************
*** 15,25 ****
  #include "options.h"
  #include "memory.h"
  #include "custom.h"
  #include "newcpu.h"
  #include "autoconf.h"
  #include "gensound.h"
  #include "sounddep/sound.h"
- #include "events.h"
  #include "audio.h"
  #include "savestate.h"
  
--- 15,25 ----
  #include "options.h"
  #include "memory.h"
  #include "custom.h"
+ #include "events.h"
  #include "newcpu.h"
  #include "autoconf.h"
  #include "gensound.h"
  #include "sounddep/sound.h"
  #include "audio.h"
  #include "savestate.h"
  
diff -crB --new-file ./uae-0.8.21/src/autoconf.c ../uae_jit_cleaning/uae-0.8.21/src/autoconf.c
*** ./uae-0.8.21/src/autoconf.c	2001-12-30 17:15:56.000000000 +0200
--- ../uae_jit_cleaning/uae-0.8.21/src/autoconf.c	2021-01-10 13:10:29.830591684 +0200
***************
*** 15,20 ****
--- 15,21 ----
  #include "uae.h"
  #include "memory.h"
  #include "custom.h"
+ #include "events.h"
  #include "newcpu.h"
  #include "compiler.h"
  #include "autoconf.h"
***************
*** 285,291 ****
      int has_retval = (trapmode[func] & TRAPFLAG_NO_RETVAL) == 0;
      int implicit_rts = (trapmode[func] & TRAPFLAG_DORET) != 0;
  
!     if (*trapstr[func] != 0 && trace_traps)
  	write_log ("TRAP: %s\n", trapstr[func]);
  
      /* For monitoring only? */
--- 286,292 ----
      int has_retval = (trapmode[func] & TRAPFLAG_NO_RETVAL) == 0;
      int implicit_rts = (trapmode[func] & TRAPFLAG_DORET) != 0;
  
!     if (trapstr[func] && *trapstr[func] != 0 && trace_traps)
  	write_log ("TRAP: %s\n", trapstr[func]);
  
      /* For monitoring only? */
diff -crB --new-file ./uae-0.8.21/src/blitter.c ../uae_jit_cleaning/uae-0.8.21/src/blitter.c
*** ./uae-0.8.21/src/blitter.c	2002-02-16 16:18:13.000000000 +0200
--- ../uae_jit_cleaning/uae-0.8.21/src/blitter.c	2021-01-10 13:10:29.830591684 +0200
***************
*** 11,20 ****
  
  #include "config.h"
  #include "options.h"
- #include "events.h"
  #include "uae.h"
  #include "memory.h"
  #include "custom.h"
  #include "newcpu.h"
  #include "blitter.h"
  #include "blit.h"
--- 11,20 ----
  
  #include "config.h"
  #include "options.h"
  #include "uae.h"
  #include "memory.h"
  #include "custom.h"
+ #include "events.h"
  #include "newcpu.h"
  #include "blitter.h"
  #include "blit.h"
diff -crB --new-file ./uae-0.8.21/src/bsdsocket.c ../uae_jit_cleaning/uae-0.8.21/src/bsdsocket.c
*** ./uae-0.8.21/src/bsdsocket.c	2000-08-26 00:29:41.000000000 +0300
--- ../uae_jit_cleaning/uae-0.8.21/src/bsdsocket.c	2021-01-10 13:10:29.834591684 +0200
***************
*** 18,23 ****
--- 18,24 ----
  #include "options.h"
  #include "memory.h"
  #include "custom.h"
+ #include "events.h"
  #include "newcpu.h"
  #include "autoconf.h"
  #include "bsdsocket.h"
diff -crB --new-file ./uae-0.8.21/src/cfgfile.c ../uae_jit_cleaning/uae-0.8.21/src/cfgfile.c
*** ./uae-0.8.21/src/cfgfile.c	2002-02-16 16:29:42.000000000 +0200
--- ../uae_jit_cleaning/uae-0.8.21/src/cfgfile.c	2021-01-10 13:10:29.838591684 +0200
***************
*** 17,23 ****
  #include "threaddep/thread.h"
  #include "uae.h"
  #include "autoconf.h"
- #include "events.h"
  #include "custom.h"
  
  /* @@@ need to get rid of this... just cut part of the manual and print that
--- 17,22 ----
***************
*** 67,76 ****
--- 66,87 ----
      {"sound_channels", "" },
      {"sound_min_buff", "" },
      {"sound_max_buff", "" },
+     {"comp_trustbyte", "How to access bytes in compiler (direct/indirect/indirectKS/afterPic" },
+     {"comp_trustword", "How to access words in compiler (direct/indirect/indirectKS/afterPic" },
+     {"comp_trustlong", "How to access longs in compiler (direct/indirect/indirectKS/afterPic" },
+     {"comp_nf", "Whether to optimize away flag generation where possible" },
+     {"comp_fpu", "Whether to provide JIT FPU emulation" },
+     {"compforcesettings", "Whether to force the JIT compiler settings" },
+     {"cachesize", "How many MB to use to buffer translated instructions"},
+     {"override_dga_address","Address from which to map the frame buffer (upper 16 bits) (DANGEROUS!)"},
+     {"avoid_cmov", "Set to yes on machines that lack the CMOV instruction" },
+     {"avoid_dga", "Set to yes if the use of DGA extension creates problems" },
+     {"avoid_vid", "Set to yes if the use of the Vidmode extension creates problems" },
      {"parallel_on_demand", "" },
      {"serial_on_demand", "" },
      {"joyport0", "" },
      {"joyport1", "" },
+     {"pci_devices", "List of PCI devices to make visible to the emulated Amiga" },
      {"kickstart_rom_file", "Kickstart ROM image, (C) Copyright Amiga, Inc." },
      {"kickstart_ext_rom_file", "Extended Kickstart ROM image, (C) Copyright Amiga, Inc." },
      {"kickstart_key_file", "Key-file for encrypted ROM images (from Cloanto's Amiga Forever)" },
***************
*** 104,109 ****
--- 115,122 ----
  static const char *stereomode3[] = { "1", "2", "3", 0 };
  static const char *interpolmode[] = { "none", "rh", "crux", 0 };
  static const char *collmode[] = { "none", "sprites", "playfields", "full", 0 };
+ static const char *compmode[] = { "direct", "indirect", "indirectKS", "afterPic", 0 };
+ static const char *flushmode[]   = { "soft", "hard", 0 };
  
  #define UNEXPANDED "$(FILE_PATH)"
  
***************
*** 185,190 ****
--- 198,223 ----
      fprintf (f, "sound_pri_time=%d\n", p->sound_pri_time);
      fprintf (f, "sound_pri_cutoff=%d\n", p->sound_pri_cutoff);
  
+     fprintf (f, "comp_trustbyte=%s\n", compmode[p->comptrustbyte]);
+     fprintf (f, "comp_trustword=%s\n", compmode[p->comptrustword]);
+     fprintf (f, "comp_trustlong=%s\n", compmode[p->comptrustlong]);
+     fprintf (f, "comp_trustnaddr=%s\n", compmode[p->comptrustnaddr]);
+     fprintf (f, "comp_nf=%s\n", p->compnf ? "true" : "false");
+     fprintf (f, "comp_constjump=%s\n", p->comp_constjump ? "true" : "false");
+     fprintf (f, "comp_oldsegv=%s\n", p->comp_oldsegv ? "true" : "false");
+     
+     fprintf (f, "comp_flushmode=%s\n", flushmode[p->comp_hardflush]);
+     fprintf (f, "compforcesettings=%s\n", p->compforcesettings ? "true" : "false");
+     fprintf (f, "compfpu=%s\n", p->compfpu ? "true" : "false");
+     fprintf (f, "comp_midopt=%s\n", p->comp_midopt ? "true" : "false");
+     fprintf (f, "comp_lowopt=%s\n", p->comp_lowopt ? "true" : "false");
+     fprintf (f, "avoid_cmov=%s\n", p->avoid_cmov ? "true" : "false" );
+     fprintf (f, "avoid_dga=%s\n", p->avoid_dga ? "true" : "false" );
+     fprintf (f, "avoid_vid=%s\n", p->avoid_vid ? "true" : "false" );
+     fprintf (f, "cachesize=%d\n", p->cachesize);
+     if (p->override_dga_address)
+ 	fprintf (f, "override_dga_address=0x%08x\n", p->override_dga_address);
+ 
      fprintf (f, "joyport0=%s\n", portmode[p->jport0]);
      fprintf (f, "joyport1=%s\n", portmode[p->jport1]);
  
***************
*** 377,382 ****
--- 410,425 ----
  	|| cfgfile_yesno (option, value, "autoconfig", &dummy)
  	|| cfgfile_yesno (option, value, "parallel_on_demand", &p->parallel_demand)
  	|| cfgfile_yesno (option, value, "serial_on_demand", &p->serial_demand)
+ 	|| cfgfile_yesno (option, value, "comp_nf", &p->compnf)
+ 	|| cfgfile_yesno (option, value, "comp_constjump", &p->comp_constjump)
+ 	|| cfgfile_yesno (option, value, "comp_oldsegv", &p->comp_oldsegv)
+ 	|| cfgfile_yesno (option, value, "compforcesettings", &p->compforcesettings)
+ 	|| cfgfile_yesno (option, value, "compfpu", &p->compfpu)
+ 	|| cfgfile_yesno (option, value, "comp_midopt", &p->comp_midopt)
+ 	|| cfgfile_yesno (option, value, "comp_lowopt", &p->comp_lowopt)
+ 	|| cfgfile_yesno (option, value, "avoid_cmov", &p->avoid_cmov)
+ 	|| cfgfile_yesno (option, value, "avoid_dga", &p->avoid_dga)
+ 	|| cfgfile_yesno (option, value, "avoid_vid", &p->avoid_vid)
  	|| cfgfile_yesno (option, value, "log_illegal_mem", &p->illegal_mem))
  	return 1;
      if (cfgfile_intval (option, value, "accuracy", &p->emul_accuracy, 1)
***************
*** 386,391 ****
--- 429,436 ----
  	|| cfgfile_intval (option, value, "sound_bits", &p->sound_bits, 1)
  	|| cfgfile_intval (option, value, "sound_pri_cutoff", &p->sound_pri_cutoff, 1)
  	|| cfgfile_intval (option, value, "sound_pri_time", &p->sound_pri_time, 1)
+ 	|| cfgfile_intval (option, value, "cachesize", &p->cachesize, 1)
+ 	|| cfgfile_intval (option, value, "override_dga_address", &p->override_dga_address, 1)
  	|| cfgfile_intval (option, value, "gfx_framerate", &p->gfx_framerate, 1)
  	|| cfgfile_intval (option, value, "gfx_width", &p->gfx_width, 1)
  	|| cfgfile_intval (option, value, "gfx_height", &p->gfx_height, 1)
***************
*** 399,404 ****
--- 444,453 ----
  	return 1;
      if (cfgfile_strval (option, value, "sound_output", &p->produce_sound, soundmode, 0)
  	|| cfgfile_strval (option, value, "sound_interpol", &p->sound_interpol, interpolmode, 0)
+ 	||cfgfile_strval (option, value, "comp_trustbyte", &p->comptrustbyte, compmode, 0)
+ 	||cfgfile_strval (option, value, "comp_trustword", &p->comptrustword, compmode, 0)
+ 	||cfgfile_strval (option, value, "comp_trustlong", &p->comptrustlong, compmode, 0)
+ 	||cfgfile_strval (option, value, "comp_trustnaddr", &p->comptrustnaddr, compmode, 0)
  	|| cfgfile_strval (option, value, "joyport0", &p->jport0, portmode, 0)
  	|| cfgfile_strval (option, value, "joyport1", &p->jport1, portmode, 0)
  	|| cfgfile_strval (option, value, "use_gui", &p->start_gui, guimode1, 1)
***************
*** 414,420 ****
  	|| cfgfile_strval (option, value, "gfx_colour_mode", &p->color_mode, colormode1, 1)
  	|| cfgfile_strval (option, value, "gfx_colour_mode", &p->color_mode, colormode2, 0)
  	|| cfgfile_strval (option, value, "gfx_color_mode", &p->color_mode, colormode1, 1)
! 	|| cfgfile_strval (option, value, "gfx_color_mode", &p->color_mode, colormode2, 0))
  	return 1;
      if (cfgfile_string (option, value, "floppy0", p->df[0], 256)
  	|| cfgfile_string (option, value, "floppy1", p->df[1], 256)
--- 463,470 ----
  	|| cfgfile_strval (option, value, "gfx_colour_mode", &p->color_mode, colormode1, 1)
  	|| cfgfile_strval (option, value, "gfx_colour_mode", &p->color_mode, colormode2, 0)
  	|| cfgfile_strval (option, value, "gfx_color_mode", &p->color_mode, colormode1, 1)
! 	|| cfgfile_strval (option, value, "gfx_color_mode", &p->color_mode, colormode2, 0)
! 	|| cfgfile_strval (option, value, "comp_flushmode", &p->comp_hardflush, flushmode, 0))
  	return 1;
      if (cfgfile_string (option, value, "floppy0", p->df[0], 256)
  	|| cfgfile_string (option, value, "floppy1", p->df[1], 256)
***************
*** 423,428 ****
--- 473,479 ----
  	|| cfgfile_string (option, value, "kickstart_rom_file", p->romfile, 256)
  	|| cfgfile_string (option, value, "kickstart_ext_rom_file", p->romextfile, 256)
  	|| cfgfile_string (option, value, "kickstart_key_file", p->keyfile, 256)
+ 	|| cfgfile_string (option, value, "pci_devices", p->pci_devices, 256)
  	|| cfgfile_string (option, value, "config_description", p->description, 256))
  	return 1;
  
diff -crB --new-file ./uae-0.8.21/src/compemu_abandoned.c ../uae_jit_cleaning/uae-0.8.21/src/compemu_abandoned.c
*** ./uae-0.8.21/src/compemu_abandoned.c	1970-01-01 02:00:00.000000000 +0200
--- ../uae_jit_cleaning/uae-0.8.21/src/compemu_abandoned.c	2021-01-10 13:10:29.838591684 +0200
***************
*** 0 ****
--- 1,244 ----
+ 
+ #if 0   /* some code that was abandoned for one reason or another, but
+ 	   might not yet be ready for complete deletion */
+ 
+ /* The jumps in the following would be a nightmare to get right with the
+    new flag handling */
+ 
+ static void readmem_new(int address, int dest, int offset, int size, int tmp)
+ {
+   int f=tmp;
+   uae_u8* branchadd;
+   uae_u8* branchadd2;
+   uae_u8* branchadd3;
+   bigstate keep, getto;   /* These are way too big for comfort! */
+   int i;
+ 
+   mov_l_rr(f,address);
+   shrl_l_ri(f,16);   /* The index into the baseaddr table */
+   mov_l_rm_indexed(f,(uae_u32)baseaddr,f,4);
+   /* f now holds either the offset, or whatever is in mem_banks */
+   test_l_ri(f,1);  /* Check for LSB */
+   keep=live;  /* Store the state for the second branch */
+   emit_byte(0x75); branchadd=target; emit_byte(0x00);  /* JNZ */
+   { /* Handling realmem situation */
+     if (isinreg(dest) && live.state[dest].size>size) {
+       tomem(dest); evict(dest);  /* So the state[dest].size will be
+ 				  * just what we loaded --- makes it
+ 				  * easier in the other branch */
+     }
+     switch(size) {
+     case 1: mov_b_rrm_indexed(dest,address,f,1); break;
+     case 2: mov_w_rrm_indexed(dest,address,f,1); bswap_16(dest); break;
+     case 4: mov_l_rrm_indexed(dest,address,f,1); bswap_32(dest); break;
+     }
+     if (live.state[dest].size>size) {
+       printf("Uh-oh, bad sd in,PC_P readmem, wanted %d\n",
+ 	     live.state[dest].size,size);
+       live.state[dest].size=size;
+     }
+     disassociate(f);
+     getto=live;  /* The state we need to get into */
+     emit_byte(0xeb); branchadd2=target; emit_byte(0x00); /* JMP */
+   }
+   if ((uae_u32)target&0x1f) 
+     target+=32-((uae_u32)target&0x1f);
+   *branchadd=(target-branchadd-1);  /* Fill in the jump length */
+   {
+     live=keep; /* Restore the pre-jump state */
+     mov_l_rR(f,f,-1+offset);  /* -1 makes up for the set LSB */
+     /* Now f holds the address of the b/w/lget function */
+     isclean(f); /* So it doesn't get pushed */
+     call_r_11(f,dest,address,4,4);
+     
+     /* OK, and now comes the part where we have to make the states the same */
+     /* First, the result might have to be moved */
+     if (live.state[dest].realreg!=getto.state[dest].realreg) {
+       raw_mov_l_rr(getto.state[dest].realreg,live.state[dest].realreg);
+       live.nat[getto.state[dest].realreg].holds=dest;
+       live.nat[live.state[dest].realreg].holds=-1;
+       live.state[dest].realreg=getto.state[dest].realreg;
+     }
+     /* That was the only live register. Now reload whatever else needs 
+        reloading */
+     for (i=0;i<N_REGS;i++) {
+       if (getto.nat[i].holds>=0 && live.nat[i].holds!=getto.nat[i].holds) {
+ 	raw_mov_l_rm(i,(uae_u32)live.state[getto.nat[i].holds].mem);
+       }
+     }
+     /* Now the state *should* be a superset of the getto state. */
+     live=getto;  /* Use the subset */
+     emit_byte(0xeb); branchadd3=target; emit_byte(0x00); /* JMP */
+   }
+   if ((uae_u32)target&0x1f) 
+     target+=32-((uae_u32)target&0x1f);
+   *branchadd2=(target-branchadd2-1);  /* Fill in the jump length */
+   *branchadd3=(target-branchadd3-1);  /* Fill in the jump length */
+ }
+ 
+ 
+ static void writemem_new(int address, int source, int offset, int size, int tmp)
+ {
+   int f=tmp;
+   uae_u8* branchadd;
+   uae_u8* branchadd2;
+   uae_u8* branchadd3;
+   bigstate keep, getto;   /* These are way too big for comfort! */
+   int i;
+ 
+   mov_l_rr(f,address);
+   shrl_l_ri(f,16);   /* The index into the baseaddr table */
+   mov_l_rm_indexed(f,(uae_u32)(baseaddr+65536+512),f,4);
+   /* f now holds either the offset, or whatever is in mem_banks */
+   test_l_ri(f,1);  /* Check for LSB */
+   keep=live;  /* Store the state for the second branch */
+   emit_byte(0x75); branchadd=target; emit_byte(0x00);  /* JNZ */
+   { /* Handling realmem situation */
+     switch(size) {
+     case 1: mov_b_mrr_indexed(address,f,1,source); break;
+     case 2: bswap_16(source); mov_w_mrr_indexed(address,f,1,source); bswap_16(source); break;
+     case 4: bswap_32(source); mov_l_mrr_indexed(address,f,1,source); bswap_32(source); break;
+     }
+     disassociate(f);
+     getto=live;  /* The state we need to get into */
+     emit_byte(0xeb); branchadd2=target; emit_byte(0x00); /* JMP */
+   }
+   if ((uae_u32)target&0x1f) 
+     target+=32-((uae_u32)target&0x1f);
+   *branchadd=(target-branchadd-1);  /* Fill in the jump length */
+   {
+     live=keep; /* Restore the pre-jump state */
+     mov_l_rR(f,f,-1+offset);  /* -1 makes up for the set LSB */
+     /* Now f holds the address of the b/w/lget function */
+     isclean(f); /* So it doesn't get pushed */
+     call_r_02(f,address,source,4,size);
+     
+     /* OK, and now comes the part where we have to make the states the same */
+     for (i=0;i<N_REGS;i++) {
+       if (getto.nat[i].holds>=0 && live.nat[i].holds!=getto.nat[i].holds) {
+ 	raw_mov_l_rm(i,(uae_u32)live.state[getto.nat[i].holds].mem);
+       }
+     }
+     /* Now the state *should* be a superset of the getto state. */
+     live=getto;  /* Use the subset */
+     emit_byte(0xeb); branchadd3=target; emit_byte(0x00); /* JMP */
+   }
+   if ((uae_u32)target&0x1f) 
+     target+=32-((uae_u32)target&0x1f);
+   *branchadd2=(target-branchadd2-1);  /* Fill in the jump length */
+   *branchadd3=(target-branchadd3-1);  /* Fill in the jump length */
+ }
+ 
+ 
+ static __inline__ void empty_stack(void)
+ {
+ }
+ 
+ static __inline__ void flags_to_stack(void) 
+ {
+   if (live.flags_on_stack==VALID)
+     return;
+   if (!live.flags_are_important) 
+     return;
+ 
+   if (live.flags_in_flags==VALID) {
+     /* Move flags from x86 flags to FLAGTMP */
+     int tmp=writereg_specific(FLAGTMP,4,0);
+     //lahf(); /* Move low byte into AH. Gets all but V */
+     //setcc(tmp,0);  /* move V into bit 0 of AL */
+     pushfl();
+     raw_pop_l(tmp);
+ 
+     unlock(tmp);
+   }
+   else
+     abort();
+   live.flags_on_stack=VALID;
+ }
+ 
+ 
+ static __inline__ void clobber_flags(void)
+ {
+   if (live.flags_in_flags==VALID && live.flags_on_stack!=VALID)
+     flags_to_stack();
+   if (live.flags_in_flags!=NADA)
+     live.flags_in_flags=TRASH;
+ }
+ 
+ static __inline__ void live_flags(void)
+ {
+   if (live.flags_on_stack!=NADA)
+     live.flags_on_stack=TRASH;
+   live.flags_in_flags=VALID;
+   live.flags_are_important=1;
+ }
+ 
+ static __inline__ void dont_care_flags(void)
+ {
+   live.flags_are_important=0;
+ }
+ 
+ static __inline__ void make_flags_live(void)
+ {
+   if (live.flags_in_flags==VALID)
+     return;
+   if (live.flags_on_stack==TRASH) {
+     printf("Want flags, got something on stack, but it is TRASH\n");
+     abort();
+   }
+   if (live.flags_on_stack==NADA) {
+     /* First time --- need to get it from memory */
+     push_m((uae_u32)&regflags.cznv);
+     pop_l(FLAGTMP);
+     live.flags_on_stack=VALID;
+   }
+   if (live.flags_on_stack==VALID) {
+ 
+     int tmp=readreg_specific(FLAGTMP,4,0);
+     /* AL is 0 (no overflow) or 1 (overflow) */
+     //raw_cmp_b_ri(tmp,-127);  /* Set overflow accordingly. Clobber all others */
+     //sahf();   /* And set the rest from AH */
+     raw_push_l(tmp);
+     popfl();
+ 
+     unlock(tmp);
+     live.flags_in_flags=VALID;
+     return;
+   }
+   printf("Huh? live.flags_in_flags=%d, live.flags_on_stack=%d, but need to make live\n",
+ 	 live.flags_in_flags,live.flags_on_stack);
+   abort();
+ }
+ 
+ /* This will swap the nreg s into the nreg d, and
+    vice versa, and adjust the state information accordingly */
+ static void swap_nregs(int s, int d)
+ {
+   int vs=live.nat[s].holds;
+   int vd=live.nat[d].holds;
+ 
+   consistent(__LINE__);
+   printf("  Swap %d and %d (%d and %d)\n",s,d,vs,vd);
+ 
+   if (s==d)
+     return;
+   if (vs>=0 && vd>=0) 
+     raw_xchg_l_rr(s,d);
+   else if (vs>=0)
+     raw_mov_l_rr(d,s);
+   else
+     raw_mov_l_rr(s,d);
+ 
+   if (vs>=0) {
+     live.state[vs].realreg=d;
+   }
+   if (vd>=0) {
+     live.state[vd].realreg=s;
+   }
+   live.nat[s].holds=vd;
+   live.nat[d].holds=vs;
+   consistent(__LINE__);
+ }
+ 
+ 
+ #endif
diff -crB --new-file ./uae-0.8.21/src/compemu_fpp.c ../uae_jit_cleaning/uae-0.8.21/src/compemu_fpp.c
*** ./uae-0.8.21/src/compemu_fpp.c	1970-01-01 02:00:00.000000000 +0200
--- ../uae_jit_cleaning/uae-0.8.21/src/compemu_fpp.c	2021-01-10 13:10:29.842591684 +0200
***************
*** 0 ****
--- 1,1555 ----
+ /*
+   * UAE - The Un*x Amiga Emulator
+   *
+   * MC68881 emulation
+   *
+   * Copyright 1996 Herman ten Brugge
+   * Adapted for JIT compilation (c) Bernd Meyer, 2000
+   */
+ 
+ #include <math.h>
+ 
+ #include "sysconfig.h"
+ #include "sysdeps.h"
+ 
+ #include "config.h"
+ #include "options.h"
+ #include "memory.h"
+ #include "custom.h"
+ #include "newcpu.h"
+ #include "ersatz.h"
+ #include "md-fpp.h"
+ #include "compemu.h"
+ 
+ #define MAKE_FPSR(r) do { fmov_rr(FP_RESULT,r); } while (0)
+ 
+ #define delay   nop() ;nop()  
+ #define delay2  nop() ;nop()   
+ 
+ uae_s32 temp_fp[3];  /* To convert between FP/integer */
+ 
+ /* return register number, or -1 for failure */
+ STATIC_INLINE int get_fp_value (uae_u32 opcode, uae_u16 extra)
+ {
+     uaecptr tmppc;
+     uae_u16 tmp;
+     int size;
+     int mode;
+     int reg;
+     double* src;
+     uae_u32 ad = 0;
+     static int sz1[8] = { 4, 4, 12, 12, 2, 8, 1, 0 };
+     static int sz2[8] = { 4, 4, 12, 12, 2, 8, 2, 0 };
+ 
+     if ((extra & 0x4000) == 0) {
+ 	return (extra >> 10) & 7;
+     }
+ 
+     mode = (opcode >> 3) & 7;
+     reg = opcode & 7;
+     size = (extra >> 10) & 7;
+     switch (mode) {
+      case 0:
+ 	switch (size) {
+ 	 case 6:
+ 	    sign_extend_8_rr(S1,reg);
+ 	    mov_l_mr((uae_u32)temp_fp,S1);
+ 	    delay2;
+ 	    fmovi_rm(FS1,(uae_u32)temp_fp);
+ 	    return FS1;
+ 	 case 4:
+ 	    sign_extend_16_rr(S1,reg);
+ 	    mov_l_mr((uae_u32)temp_fp,S1);
+ 	    delay2;
+ 	    fmovi_rm(FS1,(uae_u32)temp_fp);
+ 	    return FS1;
+ 	 case 0:
+ 	    mov_l_mr((uae_u32)temp_fp,reg);
+ 	    delay2;
+ 	    fmovi_rm(FS1,(uae_u32)temp_fp);
+ 	    return FS1;
+ 	 case 1:
+ 	    mov_l_mr((uae_u32)temp_fp,reg);
+ 	    delay2;
+ 	    fmovs_rm(FS1,(uae_u32)temp_fp);
+ 	    return FS1;
+ 	 default:
+ 	    return -1;
+ 	}
+ 	return -1; /* Should be unreachable */
+      case 1:
+ 	return -1; /* Genuine invalid instruction */
+      default:
+ 	break;
+     }
+     /* OK, we *will* have to load something from an address. Let's make
+        sure we know how to handle that, or quit early --- i.e. *before*
+        we do any postincrement/predecrement that we may regret */
+ 
+     switch (size) {
+      case 3:
+ 	return -1;
+      case 0:
+      case 1:
+      case 2:
+      case 4:
+      case 5:
+      case 6:
+ 	break; 
+      default:
+ 	return -1;
+     }
+ 
+     switch (mode) {
+      case 2:
+ 	ad=S1;  /* We will change it, anyway ;-) */
+ 	mov_l_rr(ad,reg+8);
+ 	break;
+      case 3:
+ 	ad=S1;
+ 	mov_l_rr(ad,reg+8);
+ 	lea_l_brr(reg+8,reg+8,(reg == 7?sz2[size]:sz1[size]));
+ 	break;
+      case 4:
+ 	ad=S1;
+ 	
+ 	lea_l_brr(reg+8,reg+8,-(reg == 7?sz2[size]:sz1[size]));
+ 	mov_l_rr(ad,reg+8);
+ 	break;
+      case 5:
+      {
+ 	 uae_u32 off=(uae_s32)(uae_s16)comp_get_iword((m68k_pc_offset+=2)-2);
+ 	 ad=S1;
+ 	 mov_l_rr(ad,reg+8);
+ 	 lea_l_brr(ad,ad,off);
+ 	 break;
+      }
+      case 6:
+      {
+ 	uae_u32 dp=comp_get_iword((m68k_pc_offset+=2)-2);
+ 	ad=S1;
+ 	calc_disp_ea_020(reg+8,dp,ad,S2);
+ 	break;
+      }
+      case 7:
+ 	switch (reg) {
+ 	 case 0:
+ 	 {
+ 	     uae_u32 off=(uae_s32)(uae_s16)comp_get_iword((m68k_pc_offset+=2)-2);
+ 	     ad=S1;
+ 	     mov_l_ri(ad,off);
+ 	     break;
+ 	 }
+ 	 case 1:
+ 	 {
+ 	     uae_u32 off=comp_get_ilong((m68k_pc_offset+=4)-4);
+ 	     ad=S1;
+ 	     mov_l_ri(ad,off);
+ 	     break;
+ 	 }
+ 	 case 2:
+ 	 {
+ 	     uae_u32 address=start_pc+((char *)comp_pc_p-(char *)start_pc_p)+
+ 		 m68k_pc_offset;
+ 	     uae_s32 PC16off =(uae_s32)(uae_s16)comp_get_iword((m68k_pc_offset+=2)-2);
+ 	     ad=S1;
+ 	     mov_l_ri(ad,address+PC16off);
+ 	     break;
+ 	 }
+ 	 case 3:
+ 	    return -1;
+ 	    tmppc = m68k_getpc ();
+ 	    tmp = next_iword ();
+ 	    ad = get_disp_ea_020 (tmppc, tmp);
+ 	    break;
+ 	 case 4: 
+ 	 {
+ 	     uae_u32 address=start_pc+((char *)comp_pc_p-(char *)start_pc_p)+
+ 		 m68k_pc_offset;
+ 	     ad=S1;
+ 	     mov_l_ri(ad,address);
+ 	     m68k_pc_offset+=sz2[size];
+ 	     break;
+ 	 }
+ 	 default:
+ 	    return -1;
+ 	}
+     }
+ 
+     switch (size) {
+      case 0:
+ 	readlong(ad,S2,S3);
+ 	mov_l_mr((uae_u32)temp_fp,S2);
+ 	delay2;
+ 	fmovi_rm(FS1,(uae_u32)temp_fp);
+ 	break;
+      case 1:
+ 	readlong(ad,S2,S3);
+ 	mov_l_mr((uae_u32)temp_fp,S2);
+ 	delay2;
+ 	fmovs_rm(FS1,(uae_u32)temp_fp);
+ 	break;
+      case 2:
+ 	readword(ad,S2,S3);
+ 	mov_w_mr(((uae_u32)temp_fp)+8,S2);
+ 	add_l_ri(ad,4);
+ 	readlong(ad,S2,S3);
+ 	mov_l_mr((uae_u32)(temp_fp)+4,S2);
+ 	add_l_ri(ad,4);
+ 	readlong(ad,S2,S3);
+ 	mov_l_mr((uae_u32)(temp_fp),S2);
+ 	delay2;
+ 	fmov_ext_rm(FS1,(uae_u32)(temp_fp));
+ 	break;
+      case 3:
+ 	return -1; /* Some silly "packed" stuff */
+      case 4:
+ 	readword(ad,S2,S3);
+ 	sign_extend_16_rr(S2,S2);
+ 	mov_l_mr((uae_u32)temp_fp,S2);
+ 	delay2;
+ 	fmovi_rm(FS1,(uae_u32)temp_fp);
+ 	break;
+      case 5:
+ 	readlong(ad,S2,S3);
+ 	mov_l_mr(((uae_u32)temp_fp)+4,S2);
+ 	add_l_ri(ad,4);
+ 	readlong(ad,S2,S3);
+ 	mov_l_mr((uae_u32)(temp_fp),S2);
+ 	delay2;
+ 	fmov_rm(FS1,(uae_u32)(temp_fp));
+ 	break;
+      case 6:
+ 	readbyte(ad,S2,S3);
+ 	sign_extend_8_rr(S2,S2);
+ 	mov_l_mr((uae_u32)temp_fp,S2);
+ 	delay2;
+ 	fmovi_rm(FS1,(uae_u32)temp_fp);
+ 	break;
+      default:
+ 	return -1;
+     }
+     return FS1;
+ }
+ 
+ /* return of -1 means failure, >=0 means OK */
+ STATIC_INLINE int put_fp_value (int val, uae_u32 opcode, uae_u16 extra)
+ {
+     uae_u16 tmp;
+     uaecptr tmppc;
+     int size;
+     int mode;
+     int reg;
+     uae_u32 ad;
+     static int sz1[8] = { 4, 4, 12, 12, 2, 8, 1, 0 };
+     static int sz2[8] = { 4, 4, 12, 12, 2, 8, 2, 0 };
+ 
+     if ((extra & 0x4000) == 0) {
+ 	fmov_rr((extra>>10)&7,val);
+ 	return 0;
+     }
+ 
+     mode = (opcode >> 3) & 7;
+     reg = opcode & 7;
+     size = (extra >> 10) & 7;
+     ad = -1;
+     switch (mode) {
+      case 0:
+ 	switch (size) {
+ 	 case 6:
+ 	    fmovi_mr((uae_u32)temp_fp,val);
+ 	    delay;
+ 	    mov_b_rm(reg,(uae_u32)temp_fp);
+ 	    return 0;
+ 	 case 4:
+ 	    fmovi_mr((uae_u32)temp_fp,val);
+ 	    delay;
+ 	    mov_w_rm(reg,(uae_u32)temp_fp);
+ 	    return 0;
+ 	 case 0:
+ 	    fmovi_mr((uae_u32)temp_fp,val);
+ 	    delay;
+ 	    mov_l_rm(reg,(uae_u32)temp_fp);
+ 	    return 0;
+ 	 case 1:
+ 	    fmovs_mr((uae_u32)temp_fp,val);
+ 	    delay;
+ 	    mov_l_rm(reg,(uae_u32)temp_fp);
+ 	    return 0;
+ 	 default:
+ 	    return -1;
+ 	}
+      case 1:
+ 	return -1; /* genuine invalid instruction */
+      default: break;
+     }
+ 
+     /* Let's make sure we get out *before* doing something silly if
+        we can't handle the size */
+     switch (size) {
+      case 0:
+      case 4:
+      case 5:
+      case 6:
+      case 2:
+      case 1:
+ 	break;
+      case 3:
+      default:
+ 	return -1;
+     }
+     
+     switch (mode) {
+      case 2:
+ 	ad=S1;
+ 	mov_l_rr(ad,reg+8);
+ 	break;
+      case 3:
+ 	ad=S1;
+ 	mov_l_rr(ad,reg+8);
+ 	lea_l_brr(reg+8,reg+8,(reg == 7?sz2[size]:sz1[size]));
+ 	break;
+      case 4:
+ 	ad=S1;
+ 	lea_l_brr(reg+8,reg+8,-(reg == 7?sz2[size]:sz1[size]));
+ 	mov_l_rr(ad,reg+8);
+ 	break;
+      case 5:
+      {
+ 	 uae_u32 off=(uae_s32)(uae_s16)comp_get_iword((m68k_pc_offset+=2)-2);
+ 	 ad=S1;
+ 	 mov_l_rr(ad,reg+8);
+ 	 add_l_ri(ad,off);
+ 	 break;
+      }
+      case 6:
+      {
+ 	uae_u32 dp=comp_get_iword((m68k_pc_offset+=2)-2);
+ 	ad=S1;
+ 	calc_disp_ea_020(reg+8,dp,ad,S2);
+ 	break;
+      }
+      case 7:
+ 	switch (reg) {
+ 	 case 0:
+ 	 {
+ 	     uae_u32 off=(uae_s32)(uae_s16)comp_get_iword((m68k_pc_offset+=2)-2);
+ 	     ad=S1;
+ 	     mov_l_ri(ad,off);
+ 	     break;
+ 	 }
+ 	 case 1:
+ 	 {
+ 	     uae_u32 off=comp_get_ilong((m68k_pc_offset+=4)-4);
+ 	     ad=S1;
+ 	     mov_l_ri(ad,off);
+ 	     break;
+ 	 }
+ 	 case 2:
+ 	 {
+ 	     uae_u32 address=start_pc+((char *)comp_pc_p-(char *)start_pc_p)+
+ 		 m68k_pc_offset;
+ 	     uae_s32 PC16off =(uae_s32)(uae_s16)comp_get_iword((m68k_pc_offset+=2)-2);
+ 	     ad=S1;
+ 	     mov_l_ri(ad,address+PC16off);
+ 	     break;
+ 	 }
+ 	 case 3:
+ 	    return -1;
+ 	    tmppc = m68k_getpc ();
+ 	    tmp = next_iword ();
+ 	    ad = get_disp_ea_020 (tmppc, tmp);
+ 	    break;
+ 	 case 4:
+ 	 {
+ 	     uae_u32 address=start_pc+((char *)comp_pc_p-(char *)start_pc_p)+
+ 		 m68k_pc_offset;
+ 	     ad=S1;
+ 	     mov_l_ri(ad,address);
+ 	     m68k_pc_offset+=sz2[size];
+ 	     break;
+ 	 }
+ 	 default:
+ 	    return -1;
+ 	}
+     }
+     switch (size) {
+      case 0:
+ 	fmovi_mr((uae_u32)temp_fp,val);
+ 	delay;
+ 	mov_l_rm(S2,(uae_u32)temp_fp);
+ 	writelong_clobber(ad,S2,S3);
+ 	break;
+      case 1:
+ 	fmovs_mr((uae_u32)temp_fp,val);
+ 	delay;
+ 	mov_l_rm(S2,(uae_u32)temp_fp);
+ 	writelong_clobber(ad,S2,S3);
+ 	break;
+      case 2:
+ 	fmov_ext_mr((uae_u32)temp_fp,val);
+ 	delay;
+ 	mov_w_rm(S2,(uae_u32)temp_fp+8);
+ 	writeword_clobber(ad,S2,S3);
+ 	add_l_ri(ad,4);
+ 	mov_l_rm(S2,(uae_u32)temp_fp+4);
+ 	writelong_clobber(ad,S2,S3);
+ 	add_l_ri(ad,4);
+ 	mov_l_rm(S2,(uae_u32)temp_fp);
+ 	writelong_clobber(ad,S2,S3);
+ 	break;
+      case 3: return -1; /* Packed */
+ 
+      case 4:
+ 	fmovi_mr((uae_u32)temp_fp,val);
+ 	delay;
+ 	mov_l_rm(S2,(uae_u32)temp_fp);
+ 	writeword_clobber(ad,S2,S3);
+ 	break;
+      case 5:
+ 	fmov_mr((uae_u32)temp_fp,val);
+ 	delay;
+ 	mov_l_rm(S2,(uae_u32)temp_fp+4);
+ 	writelong_clobber(ad,S2,S3);
+ 	add_l_ri(ad,4);
+ 	mov_l_rm(S2,(uae_u32)temp_fp);
+ 	writelong_clobber(ad,S2,S3);
+ 	break;
+      case 6:
+ 	fmovi_mr((uae_u32)temp_fp,val);
+ 	delay;
+ 	mov_l_rm(S2,(uae_u32)temp_fp);
+ 	writebyte(ad,S2,S3);
+ 	break;
+      default:
+ 	return -1;
+     }
+     return 0;
+ }
+ 
+ /* return -1 for failure, or register number for success */
+ STATIC_INLINE int get_fp_ad (uae_u32 opcode, uae_u32 * ad)
+ {
+     uae_u16 tmp;
+     uaecptr tmppc;
+     int mode;
+     int reg;
+     uae_s32 off;
+ 
+     mode = (opcode >> 3) & 7;
+     reg = opcode & 7;
+     switch (mode) {
+      case 0:
+      case 1:
+ 	return -1;
+      case 2:
+      case 3:
+      case 4:
+ 	mov_l_rr(S1,8+reg);
+ 	return S1;
+ 	*ad = m68k_areg (regs, reg);
+ 	break;
+      case 5:
+ 	off=(uae_s32)(uae_s16)comp_get_iword((m68k_pc_offset+=2)-2);
+ 
+ 	mov_l_rr(S1,8+reg);
+ 	add_l_ri(S1,off);
+ 	return S1;
+      case 6:
+ 	return -1;
+ 	break;
+      case 7:
+ 	switch (reg) {
+ 	 case 0:
+ 	    off=(uae_s32)(uae_s16)comp_get_iword((m68k_pc_offset+=2)-2);
+ 	    mov_l_ri(S1,off);
+ 	    return S1;
+ 	 case 1:
+ 	    off=comp_get_ilong((m68k_pc_offset+=4)-4);
+ 	    mov_l_ri(S1,off);
+ 	    return S1;
+ 	 case 2:
+ 	    return -1;
+ 	    *ad = m68k_getpc ();
+ 	    *ad += (uae_s32) (uae_s16) next_iword ();
+ 	    break;
+ 	 case 3:
+ 	    return -1;
+ 	    tmppc = m68k_getpc ();
+ 	    tmp = next_iword ();
+ 	    *ad = get_disp_ea_020 (tmppc, tmp);
+ 	    break;
+ 	 default:
+ 	    return -1;
+ 	}
+     }
+     abort();
+ }
+ 
+ void comp_fdbcc_opp (uae_u32 opcode, uae_u16 extra)
+ {
+     FAIL(1);
+     return;
+ 
+     if (!currprefs.compfpu) {
+ 	FAIL(1);
+ 	return;
+     }
+ }
+ 
+ void comp_fscc_opp (uae_u32 opcode, uae_u16 extra)
+ {
+     uae_u32 ad;
+     int cc;
+     int reg;
+ 
+     if (!currprefs.compfpu) {
+ 	FAIL(1);
+ 	return;
+     }
+ 
+ #if DEBUG_FPP
+     printf ("fscc_opp at %08lx\n", m68k_getpc ());
+     fflush (stdout);
+ #endif
+ 
+ 
+     if (extra&0x20) {  /* only cc from 00 to 1f are defined */
+ 	FAIL(1);
+ 	return;
+     }
+     if ((opcode & 0x38) != 0) { /* We can only do to integer register */
+ 	FAIL(1); 
+ 	return;
+     }
+ 
+     fflags_into_flags(S2);
+     reg=(opcode&7);
+     
+     mov_l_ri(S1,255);
+     mov_l_ri(S4,0);
+     switch(extra&0x0f) {  /* according to fpp.c, the 0x10 bit is ignored
+ 			    */
+      case 0: break;  /* set never */
+      case 1: mov_l_rr(S2,S4); 
+ 	cmov_l_rr(S4,S1,4); 
+ 	cmov_l_rr(S4,S2,10); break;
+      case 2: cmov_l_rr(S4,S1,7); break;
+      case 3: cmov_l_rr(S4,S1,3); break;
+      case 4: mov_l_rr(S2,S4); 
+ 	cmov_l_rr(S4,S1,2); 
+ 	cmov_l_rr(S4,S2,10); break;
+      case 5: mov_l_rr(S2,S4); 
+ 	cmov_l_rr(S4,S1,6); 
+ 	cmov_l_rr(S4,S2,10); break;
+      case 6: cmov_l_rr(S4,S1,5); break;
+      case 7: cmov_l_rr(S4,S1,11); break;
+      case 8: cmov_l_rr(S4,S1,10); break;
+      case 9: cmov_l_rr(S4,S1,4); break;
+      case 10: cmov_l_rr(S4,S1,10); cmov_l_rr(S4,S1,7); break;
+      case 11: cmov_l_rr(S4,S1,4); cmov_l_rr(S4,S1,3); break;
+      case 12: cmov_l_rr(S4,S1,2); break;
+      case 13: cmov_l_rr(S4,S1,6); break;
+      case 14: cmov_l_rr(S4,S1,5); cmov_l_rr(S4,S1,10); break;
+      case 15: mov_l_rr(S4,S1); break;
+     }
+ 
+     if ((opcode & 0x38) == 0) {
+ 	mov_b_rr(reg,S4);
+     } else {
+ 	abort();
+ 	if (get_fp_ad (opcode, &ad) == 0) {
+ 	    m68k_setpc (m68k_getpc () - 4);
+ 	    op_illg (opcode);
+ 	} else
+ 	    put_byte (ad, cc ? 0xff : 0x00);
+     }
+ }
+ 
+ void comp_ftrapcc_opp (uae_u32 opcode, uaecptr oldpc)
+ {
+     int cc;
+ 
+     FAIL(1);
+     return;
+ }
+ 
+ extern unsigned long foink3, oink;
+ 
+ void comp_fbcc_opp (uae_u32 opcode)
+ {
+     uae_u32 start_68k_offset=m68k_pc_offset;
+     uae_u32 off;
+     uae_u32 v1;
+     uae_u32 v2;
+     uae_u32 nh;
+     int cc;
+ 
+     if (!currprefs.compfpu) {
+ 	FAIL(1);
+ 	return;
+     }
+ 
+     if (opcode&0x20) {  /* only cc from 00 to 1f are defined */
+ 	FAIL(1);
+ 	return;
+     }
+     if ((opcode&0x40)==0) {
+ 	off=(uae_s32)(uae_s16)comp_get_iword((m68k_pc_offset+=2)-2);
+     }
+     else {
+ 	off=comp_get_ilong((m68k_pc_offset+=4)-4);
+     }
+     mov_l_ri(S1,(uae_u32)
+ 	     (comp_pc_p+off-(m68k_pc_offset-start_68k_offset)));
+     mov_l_ri(PC_P,(uae_u32)comp_pc_p);
+ 
+     /* Now they are both constant. Might as well fold in m68k_pc_offset */
+     add_l_ri(S1,m68k_pc_offset);
+     add_l_ri(PC_P,m68k_pc_offset);
+     m68k_pc_offset=0;
+ 
+     /* according to fpp.c, the 0x10 bit is ignored
+        (it handles exception handling, which we don't
+        do, anyway ;-) */
+     cc=opcode&0x0f;
+     v1=get_const(PC_P);
+     v2=get_const(S1);
+     fflags_into_flags(S2);
+ 
+     // mov_l_mi((uae_u32)&foink3,cc);
+     switch(cc) {  
+      case 0: break;  /* jump never */
+      case 1: 
+ 	mov_l_rr(S2,PC_P); 
+ 	cmov_l_rr(PC_P,S1,4); 
+ 	cmov_l_rr(PC_P,S2,10); break;
+      case 2: register_branch(v1,v2,7); break;
+      case 3: register_branch(v1,v2,3); break;
+      case 4: 
+ 	mov_l_rr(S2,PC_P); 
+ 	cmov_l_rr(PC_P,S1,2); 
+ 	cmov_l_rr(PC_P,S2,10); break;
+      case 5:
+ 	mov_l_rr(S2,PC_P); 
+ 	cmov_l_rr(PC_P,S1,6); 
+ 	cmov_l_rr(PC_P,S2,10); break;
+      case 6: register_branch(v1,v2,5); break;
+      case 7: register_branch(v1,v2,11); break;
+      case 8: register_branch(v1,v2,10); break;
+      case 9: register_branch(v1,v2,4); break;
+      case 10: 
+ 	cmov_l_rr(PC_P,S1,10); 
+ 	cmov_l_rr(PC_P,S1,7); break;
+      case 11: 
+ 	cmov_l_rr(PC_P,S1,4); 
+ 	cmov_l_rr(PC_P,S1,3); break;
+      case 12: register_branch(v1,v2,2); break;
+      case 13: register_branch(v1,v2,6); break;
+      case 14: 
+ 	cmov_l_rr(PC_P,S1,5); 
+ 	cmov_l_rr(PC_P,S1,10); break;
+      case 15: mov_l_rr(PC_P,S1); break;
+     }
+ }
+ 
+     /* Floating point conditions 
+        The "NotANumber" part could be problematic; Howver, when NaN is
+        encountered, the ftst instruction sets bot N and Z to 1 on the x87,
+        so quite often things just fall into place. This is probably not
+        accurate wrt the 68k FPU, but it is *as* accurate as this was before.
+        However, some more thought should go into fixing this stuff up so
+        it accurately emulates the 68k FPU.
+ >=<U 
+ 0000    0x00: 0                        ---   Never jump
+ 0101    0x01: Z                        ---   jump if zero (x86: 4)
+ 1000    0x02: !(NotANumber || Z || N)  --- Neither Z nor N set (x86: 7)
+ 1101    0x03: Z || !(NotANumber || N); --- Z or !N (x86: 4 and 3)
+ 0010    0x04: N && !(NotANumber || Z); --- N and !Z (x86: hard!)
+ 0111    0x05: Z || (N && !NotANumber); --- Z or N (x86: 6)
+ 1010    0x06: !(NotANumber || Z);      --- not Z (x86: 5)
+ 1110    0x07: !NotANumber;             --- not NaN (x86: 11, not parity)
+ 0001    0x08: NotANumber;              --- NaN (x86: 10)
+ 0101    0x09: NotANumber || Z;         --- Z (x86: 4)
+ 1001    0x0a: NotANumber || !(N || Z); --- NaN or neither N nor Z (x86: 10 and 7)
+ 1101    0x0b: NotANumber || Z || !N;   --- Z or !N (x86: 4 and 3)
+ 0011    0x0c: NotANumber || (N && !Z); --- N (x86: 2)
+ 0111    0x0d: NotANumber || Z || N;    --- Z or N (x86: 6)
+ 1010    0x0e: !Z;                      --- not Z (x86: 5)
+ 1111    0x0f: 1;                       --- always
+ 
+ This is not how the 68k handles things, though --- it sets Z to 0 and N
+ to the NaN's sign.... ('o' and 'i' denote differences from the above
+ table)
+ 
+ >=<U 
+ 0000    0x00: 0                        ---   Never jump
+ 010o    0x01: Z                        ---   jump if zero (x86: 4, not 10)
+ 1000    0x02: !(NotANumber || Z || N)  --- Neither Z nor N set (x86: 7)
+ 110o    0x03: Z || !(NotANumber || N); --- Z or !N (x86: 3)
+ 0010    0x04: N && !(NotANumber || Z); --- N and !Z (x86: 2, not 10)
+ 011o    0x05: Z || (N && !NotANumber); --- Z or N (x86: 6, not 10)
+ 1010    0x06: !(NotANumber || Z);      --- not Z (x86: 5)
+ 1110    0x07: !NotANumber;             --- not NaN (x86: 11, not parity)
+ 0001    0x08: NotANumber;              --- NaN (x86: 10)
+ 0101    0x09: NotANumber || Z;         --- Z (x86: 4)
+ 1001    0x0a: NotANumber || !(N || Z); --- NaN or neither N nor Z (x86: 10 and 7)
+ 1101    0x0b: NotANumber || Z || !N;   --- Z or !N (x86: 4 and 3)
+ 0011    0x0c: NotANumber || (N && !Z); --- N (x86: 2)
+ 0111    0x0d: NotANumber || Z || N;    --- Z or N (x86: 6)
+ 101i    0x0e: !Z;                      --- not Z (x86: 5 and 10)
+ 1111    0x0f: 1;                       --- always
+ 
+ Of course, this *still* doesn't mean that the x86 and 68k conditions are
+ equivalent --- the handling of infinities is different, for one thing.
+ On the 68k, +infinity minus +infinity is NotANumber (as it should be). On
+ the x86, it is +infinity, and some exception is raised (which I suspect
+ is promptly ignored) STUPID! 
+ The more I learn about their CPUs, the more I detest Intel....
+ 
+ You can see this in action if you have "Benoit" (see Aminet) and
+ set the exponent to 16. Wait for a long time, and marvel at the extra black
+ areas outside the center one. That's where Benoit expects NaN, and the x86
+ gives +infinity. [Ooops --- that must have been some kind of bug in my code.
+ it no longer happens, and the resulting graphic looks much better, too]
+ 
+ x86 conditions
+ 0011    : 2
+ 1100    : 3
+ 0101    : 4
+ 1010    : 5
+ 0111    : 6
+ 1000    : 7
+ 0001    : 10
+ 1110    : 11
+     */
+ void comp_fsave_opp (uae_u32 opcode)
+ {
+     uae_u32 ad;
+     int incr = (opcode & 0x38) == 0x20 ? -1 : 1;
+     int i;
+ 
+     FAIL(1);
+     return;
+ 
+     if (!currprefs.compfpu) {
+ 	FAIL(1);
+ 	return;
+     }
+ 
+ #if DEBUG_FPP
+     printf ("fsave_opp at %08lx\n", m68k_getpc ());
+     fflush (stdout);
+ #endif
+     if (get_fp_ad (opcode, &ad) == 0) {
+ 	m68k_setpc (m68k_getpc () - 2);
+ 	op_illg (opcode);
+ 	return;
+     }
+ 
+     if (currprefs.cpu_level == 4) {
+ 	/* 4 byte 68040 IDLE frame.  */
+ 	if (incr < 0) {
+ 	    ad -= 4;
+ 	    put_long (ad, 0x41000000);
+ 	} else {
+ 	    put_long (ad, 0x41000000);
+ 	    ad += 4;
+ 	}
+     } else {
+ 	if (incr < 0) {
+ 	    ad -= 4;
+ 	    put_long (ad, 0x70000000);
+ 	    for (i = 0; i < 5; i++) {
+ 		ad -= 4;
+ 		put_long (ad, 0x00000000);
+ 	    }
+ 	    ad -= 4;
+ 	    put_long (ad, 0x1f180000);
+ 	} else {
+ 	    put_long (ad, 0x1f180000);
+ 	    ad += 4;
+ 	    for (i = 0; i < 5; i++) {
+ 		put_long (ad, 0x00000000);
+ 		ad += 4;
+ 	    }
+ 	    put_long (ad, 0x70000000);
+ 	    ad += 4;
+ 	}
+     }
+     if ((opcode & 0x38) == 0x18)
+ 	m68k_areg (regs, opcode & 7) = ad;
+     if ((opcode & 0x38) == 0x20)
+ 	m68k_areg (regs, opcode & 7) = ad;
+ }
+ 
+ void comp_frestore_opp (uae_u32 opcode)
+ {
+     uae_u32 ad;
+     uae_u32 d;
+     int incr = (opcode & 0x38) == 0x20 ? -1 : 1;
+ 
+     FAIL(1);
+     return;
+ 
+     if (!currprefs.compfpu) {
+ 	FAIL(1);
+ 	return;
+     }
+ 
+ #if DEBUG_FPP
+     printf ("frestore_opp at %08lx\n", m68k_getpc ());
+     fflush (stdout);
+ #endif
+     if (get_fp_ad (opcode, &ad) == 0) {
+ 	m68k_setpc (m68k_getpc () - 2);
+ 	op_illg (opcode);
+ 	return;
+     }
+     if (currprefs.cpu_level == 4) {
+ 	/* 68040 */
+ 	if (incr < 0) {
+ 	    /* @@@ This may be wrong.  */
+ 	    ad -= 4;
+ 	    d = get_long (ad);
+ 	    if ((d & 0xff000000) != 0) { /* Not a NULL frame? */
+ 		if ((d & 0x00ff0000) == 0) { /* IDLE */
+ 		} else if ((d & 0x00ff0000) == 0x00300000) { /* UNIMP */
+ 		    ad -= 44;
+ 		} else if ((d & 0x00ff0000) == 0x00600000) { /* BUSY */
+ 		    ad -= 92;
+ 		}
+ 	    }
+ 	} else {
+ 	    d = get_long (ad);
+ 	    ad += 4;
+ 	    if ((d & 0xff000000) != 0) { /* Not a NULL frame? */
+ 		if ((d & 0x00ff0000) == 0) { /* IDLE */
+ 		} else if ((d & 0x00ff0000) == 0x00300000) { /* UNIMP */
+ 		    ad += 44;
+ 		} else if ((d & 0x00ff0000) == 0x00600000) { /* BUSY */
+ 		    ad += 92;
+ 		}
+ 	    }
+ 	}
+     } else {
+ 	if (incr < 0) {
+ 	    ad -= 4;
+ 	    d = get_long (ad);
+ 	    if ((d & 0xff000000) != 0) {
+ 		if ((d & 0x00ff0000) == 0x00180000)
+ 		    ad -= 6 * 4;
+ 		else if ((d & 0x00ff0000) == 0x00380000)
+ 		    ad -= 14 * 4;
+ 		else if ((d & 0x00ff0000) == 0x00b40000)
+ 		    ad -= 45 * 4;
+ 	    }
+ 	} else {
+ 	    d = get_long (ad);
+ 	    ad += 4;
+ 	    if ((d & 0xff000000) != 0) {
+ 		if ((d & 0x00ff0000) == 0x00180000)
+ 		    ad += 6 * 4;
+ 		else if ((d & 0x00ff0000) == 0x00380000)
+ 		    ad += 14 * 4;
+ 		else if ((d & 0x00ff0000) == 0x00b40000)
+ 		    ad += 45 * 4;
+ 	    }
+ 	}
+     }
+     if ((opcode & 0x38) == 0x18)
+ 	m68k_areg (regs, opcode & 7) = ad;
+     if ((opcode & 0x38) == 0x20)
+ 	m68k_areg (regs, opcode & 7) = ad;
+ }
+ 
+ static fptype const_e=2.718281828;  /* Got some more digits? */
+ static fptype const_log10_e=0.4342944819;
+ static fptype const_loge_10=2.302585093;
+ static fptype power10[]={1e0,1e1,1e2,1e4,1e8,1e16,1e32,1e64,1e128,1e256
+ #if USE_LONG_DOUBLE
+ ,       1e512, 1e1024, 1e2048, 1e4096
+ #endif
+ };
+ 
+ /* 128 words, indexed through the low byte of the 68k fpu control word */
+ static uae_u16 x86_fpucw[]={
+     0x137f, 0x137f, 0x137f, 0x137f, 0x137f, 0x137f, 0x137f, 0x137f, /* p0r0 */
+     0x1f7f, 0x1f7f, 0x1f7f, 0x1f7f, 0x1f7f, 0x1f7f, 0x1f7f, 0x1f7f, /* p0r1 */
+     0x177f, 0x177f, 0x177f, 0x177f, 0x177f, 0x177f, 0x177f, 0x177f, /* p0r2 */
+     0x1b7f, 0x1b7f, 0x1b7f, 0x1b7f, 0x1b7f, 0x1b7f, 0x1b7f, 0x1b7f, /* p0r3 */
+ 
+     0x107f, 0x107f, 0x107f, 0x107f, 0x107f, 0x107f, 0x107f, 0x107f, /* p1r0 */
+     0x1c7f, 0x1c7f, 0x1c7f, 0x1c7f, 0x1c7f, 0x1c7f, 0x1c7f, 0x1c7f, /* p1r1 */
+     0x147f, 0x147f, 0x147f, 0x147f, 0x147f, 0x147f, 0x147f, 0x147f, /* p1r2 */
+     0x187f, 0x187f, 0x187f, 0x187f, 0x187f, 0x187f, 0x187f, 0x187f, /* p1r3 */
+ 
+     0x127f, 0x127f, 0x127f, 0x127f, 0x127f, 0x127f, 0x127f, 0x127f, /* p2r0 */
+     0x1e7f, 0x1e7f, 0x1e7f, 0x1e7f, 0x1e7f, 0x1e7f, 0x1e7f, 0x1e7f, /* p2r1 */
+     0x167f, 0x167f, 0x167f, 0x167f, 0x167f, 0x167f, 0x167f, 0x167f, /* p2r2 */
+     0x1a7f, 0x1a7f, 0x1a7f, 0x1a7f, 0x1a7f, 0x1a7f, 0x1a7f, 0x1a7f, /* p2r3 */
+ 
+     0x137f, 0x137f, 0x137f, 0x137f, 0x137f, 0x137f, 0x137f, 0x137f, /* p3r0 */
+     0x1f7f, 0x1f7f, 0x1f7f, 0x1f7f, 0x1f7f, 0x1f7f, 0x1f7f, 0x1f7f, /* p3r1 */
+     0x177f, 0x177f, 0x177f, 0x177f, 0x177f, 0x177f, 0x177f, 0x177f, /* p3r2 */
+     0x1b7f, 0x1b7f, 0x1b7f, 0x1b7f, 0x1b7f, 0x1b7f, 0x1b7f, 0x1b7f  /* p3r3 */
+ };
+ 
+ void comp_fpp_opp (uae_u32 opcode, uae_u16 extra)
+ {
+     int reg;
+     int src;
+     
+     if (!currprefs.compfpu) {
+ 	FAIL(1);
+ 	return;
+     }
+     switch ((extra >> 13) & 0x7) {
+      case 3: /* 2nd most common */
+ 	if (put_fp_value ((extra >> 7)&7 , opcode, extra) < 0) {
+ 	    FAIL(1);
+ 	    return;
+ 	}
+ 	return;
+      case 6:
+      case 7: 
+ 	{
+ 	    uae_u32 ad, list = 0;
+ 	    int incr = 0;
+ 	    if (extra & 0x2000) {
+ 		int ad;
+ 
+ 		/* FMOVEM FPP->memory */
+ 		switch ((extra >> 11) & 3) { /* Get out early if failure */
+ 		 case 0:
+ 		 case 2:
+ 		    break;
+ 		 case 1:
+ 		 case 3: 
+ 		 default:
+ 		    FAIL(1); return;
+ 		}
+ 		ad=get_fp_ad (opcode, &ad);
+ 		if (ad<0) {
+ 		    m68k_setpc (m68k_getpc () - 4);
+ 		    op_illg (opcode);
+ 		    return;
+ 		}
+ 		switch ((extra >> 11) & 3) {
+ 		case 0:	/* static pred */
+ 		    list = extra & 0xff;
+ 		    incr = -1;
+ 		    break;
+ 		case 2:	/* static postinc */
+ 		    list = extra & 0xff;
+ 		    incr = 1;
+ 		    break;
+ 		case 1:	/* dynamic pred */
+ 		case 3:	/* dynamic postinc */
+ 		   abort();
+ 		}
+ 		while (list) {
+ 		    uae_u32 wrd1, wrd2, wrd3;
+ 		    if (incr < 0) { /* Predecrement */
+ 			fmov_ext_mr((uae_u32)temp_fp,fpp_movem_index2[list]);
+ 			delay;
+ 			sub_l_ri(ad,4); 
+ 			mov_l_rm(S2,(uae_u32)temp_fp);
+ 			writelong_clobber(ad,S2,S3);
+ 			sub_l_ri(ad,4); 
+ 			mov_l_rm(S2,(uae_u32)temp_fp+4);
+ 			writelong_clobber(ad,S2,S3);
+ 			sub_l_ri(ad,4); 
+ 			mov_w_rm(S2,(uae_u32)temp_fp+8);
+ 			writeword_clobber(ad,S2,S3);
+ 		    } else { /* postinc */
+ 			fmov_ext_mr((uae_u32)temp_fp,fpp_movem_index2[list]);
+ 			delay;
+ 			mov_w_rm(S2,(uae_u32)temp_fp+8);
+ 			writeword_clobber(ad,S2,S3);
+ 			add_l_ri(ad,4);
+ 			mov_l_rm(S2,(uae_u32)temp_fp+4);
+ 			writelong_clobber(ad,S2,S3);
+ 			add_l_ri(ad,4);
+ 			mov_l_rm(S2,(uae_u32)temp_fp);
+ 			writelong_clobber(ad,S2,S3);
+ 			add_l_ri(ad,4);
+ 		    }
+ 		    list = fpp_movem_next[list];
+ 		}
+ 		if ((opcode & 0x38) == 0x18)
+ 		    mov_l_rr((opcode & 7)+8,ad);
+ 		if ((opcode & 0x38) == 0x20)
+ 		    mov_l_rr((opcode & 7)+8,ad);
+ 	    } else {
+ 		/* FMOVEM memory->FPP */
+ 
+ 		int ad;
+ 		switch ((extra >> 11) & 3) { /* Get out early if failure */
+ 		 case 0:
+ 		 case 2:
+ 		    break;
+ 		 case 1:
+ 		 case 3: 
+ 		 default:
+ 		    FAIL(1); return;
+ 		}
+ 		ad=get_fp_ad (opcode, &ad);
+ 		if (ad<0) {
+ 		    m68k_setpc (m68k_getpc () - 4);
+ 		    op_illg (opcode);
+ 		    return;
+ 		}
+ 		switch ((extra >> 11) & 3) {
+ 		case 0:	/* static pred */
+ 		    list = extra & 0xff;
+ 		    incr = -1;
+ 		    break;
+ 		case 2:	/* static postinc */
+ 		    list = extra & 0xff;
+ 		    incr = 1;
+ 		    break;
+ 		case 1:	/* dynamic pred */
+ 		case 3:	/* dynamic postinc */
+ 		   abort();
+ 		}
+ 
+ 		while (list) {
+ 		    uae_u32 wrd1, wrd2, wrd3;
+ 		    if (incr < 0) {
+ 			sub_l_ri(ad,4);
+ 			readlong(ad,S2,S3);
+ 			mov_l_mr((uae_u32)(temp_fp),S2);
+ 			sub_l_ri(ad,4);
+ 			readlong(ad,S2,S3);
+ 			mov_l_mr((uae_u32)(temp_fp)+4,S2);
+ 			sub_l_ri(ad,4);
+ 			readword(ad,S2,S3);
+ 			mov_w_mr(((uae_u32)temp_fp)+8,S2);
+ 			delay2;
+ 			fmov_ext_rm(fpp_movem_index2[list],(uae_u32)(temp_fp));
+ 		    } else {
+ 			readword(ad,S2,S3);
+ 			mov_w_mr(((uae_u32)temp_fp)+8,S2);
+ 			add_l_ri(ad,4);
+ 			readlong(ad,S2,S3);
+ 			mov_l_mr((uae_u32)(temp_fp)+4,S2);
+ 			add_l_ri(ad,4);
+ 			readlong(ad,S2,S3);
+ 			mov_l_mr((uae_u32)(temp_fp),S2);
+ 			add_l_ri(ad,4);
+ 			delay2;
+ 			fmov_ext_rm(fpp_movem_index1[list],(uae_u32)(temp_fp));
+ 		    }
+ 		    list = fpp_movem_next[list];
+ 		}
+ 		if ((opcode & 0x38) == 0x18)
+ 		    mov_l_rr((opcode & 7)+8,ad);
+ 		if ((opcode & 0x38) == 0x20)
+ 		    mov_l_rr((opcode & 7)+8,ad);
+ 	    }
+ 	}
+ 	return;
+ 
+      case 4:
+      case 5:  /* rare */
+ 	if ((opcode & 0x30) == 0) {
+ 	    if (extra & 0x2000) {
+ 		if (extra & 0x1000) {
+ 		    mov_l_rm(opcode & 15,(uae_u32)&regs.fpcr); return;
+ 		}
+ 		if (extra & 0x0800) {
+ 		    FAIL(1);
+ 		    return;
+ 		}
+ 		if (extra & 0x0400) {
+ 		    mov_l_rm(opcode & 15,(uae_u32)&regs.fpiar); return;
+ 		}
+ 	    } else {
+ 		if (extra & 0x1000) {
+ 		    mov_l_mr((uae_u32)&regs.fpcr,opcode & 15); 
+ #if USE_X86_FPUCW
+ 		    mov_l_rr(S1,opcode & 15);
+ 		    and_l_ri(S1,0x000000f0);
+ 		    fldcw_m_indexed(S1,(uae_u32)x86_fpucw);
+ #endif		    
+ 		    return;
+ 		}
+ 		if (extra & 0x0800) {
+ 		    FAIL(1);
+ 		    return;
+ 		    // set_fpsr(m68k_dreg (regs, opcode & 15));
+ 		}
+ 		if (extra & 0x0400) {
+ 		    mov_l_mr((uae_u32)&regs.fpiar,opcode & 15); return;
+ 		}
+ 	    }
+ 	} else if ((opcode & 0x3f) == 0x3c) {
+ 	    if ((extra & 0x2000) == 0) {
+ 		if (extra & 0x1000) {
+ 		    uae_u32 val=comp_get_ilong((m68k_pc_offset+=4)-4);
+ 		    mov_l_mi((uae_u32)&regs.fpcr,val);
+ #if USE_X86_FPUCW
+ 		    mov_l_ri(S1,val&0x000000f0);
+ 		    fldcw_m_indexed(S1,(uae_u32)x86_fpucw);
+ #endif		    
+ 		    return;
+ 		}
+ 		if (extra & 0x0800) {
+ 		    FAIL(1);
+ 		    return;
+ 		}
+ 		if (extra & 0x0400) {
+ 		    uae_u32 val=comp_get_ilong((m68k_pc_offset+=4)-4);
+ 		    mov_l_mi((uae_u32)&regs.fpiar,val);
+ 		    return;
+ 		}
+ 	    }
+ 	    FAIL(1);
+ 	    return;
+ 	} else if (extra & 0x2000) {
+ 	    FAIL(1);
+ 	    return;
+ 	} else {
+ 	    FAIL(1);
+ 	    return;
+ 	}
+ 	FAIL(1);
+ 	return;
+ 
+      case 0:
+      case 2: /* Extremely common */
+ 	reg = (extra >> 7) & 7;
+ 	if ((extra & 0xfc00) == 0x5c00) {
+ 	    switch (extra & 0x7f) {
+ 	     case 0x00:
+ 		fmov_pi(reg);
+ 		break;
+ 	     case 0x0b:
+ 		fmov_log10_2(reg);
+ 		break;
+ 	     case 0x0c:
+ 		fmov_rm(reg,(uae_u32)&const_e);
+ 		break;
+ 	     case 0x0d:
+ 		fmov_log2_e(reg);
+ 		break;
+ 	     case 0x0e:
+ 		fmov_rm(reg,(uae_u32)&const_log10_e);
+ 		break;
+ 	     case 0x0f:
+ 		fmov_0(reg);
+ 		break;
+ 	     case 0x30:
+ 		fmov_loge_2(reg);
+ 		break;
+ 	     case 0x31:
+ 		fmov_rm(reg,(uae_u32)&const_loge_10);
+ 		break;
+ 	     case 0x32:
+ 		fmov_1(reg);
+ 		break;
+ 	     case 0x33:
+ 	     case 0x34:
+ 	     case 0x35:
+ 	     case 0x36:
+ 	     case 0x37:
+ 	     case 0x38:
+ 	     case 0x39:
+ 	     case 0x3a:
+ 	     case 0x3b:
+ 		fmov_rm(reg,(uae_u32)(power10+(extra & 0x7f)-0x32));
+ 		break;
+ 	     default:
+ 		/* This is not valid, so we fail */
+ 		FAIL(1);
+ 		return;
+ 	    }
+ 	    return;
+ 	}
+ 	
+ 	switch (extra & 0x7f) {
+ 	 case 0x00:		/* FMOVE */
+ 	 case 0x40:  /* Explicit rounding. This is just a quick fix. Same
+ 		      * for all other cases that have three choices */
+ 	 case 0x44:   
+ 	    dont_care_fflags();
+ 	    src=get_fp_value (opcode, extra);
+ 	    if (src < 0) {
+ 		FAIL(1);  /* Illegal instruction */
+ 		return;
+ 	    }
+ 	    fmov_rr(reg,src);
+ 	    MAKE_FPSR (src);
+ 	    break;
+ 	 case 0x01:		/* FINT */
+ 	    FAIL(1);    
+ 	    return;
+ 	    dont_care_fflags();
+ 	 case 0x02:		/* FSINH */
+ 	    FAIL(1);  
+ 	    return;
+ 
+ 	    dont_care_fflags();
+ 	    regs.fp[reg] = sinh (src);
+ 	    MAKE_FPSR (regs.fp[reg]);
+ 	    break;
+ 	 case 0x03:		/* FINTRZ */
+ #if USE_X86_FPUCW 
+ 	    /* If we have control over the CW, we can do this */
+ 	    dont_care_fflags();
+ 	    src=get_fp_value (opcode, extra);
+ 	    if (src < 0) {
+ 		FAIL(1);  /* Illegal instruction */
+ 		return;
+ 	    }
+ 	    mov_l_ri(S1,16);  /* Switch to "round to zero" mode */
+ 	    fldcw_m_indexed(S1,(uae_u32)x86_fpucw);
+ 	    
+ 	    frndint_rr(reg,src);
+ 
+ 	    /* restore control word */
+ 	    mov_l_rm(S1,(uae_u32)&regs.fpcr); 
+ 	    and_l_ri(S1,0x000000f0);
+ 	    fldcw_m_indexed(S1,(uae_u32)x86_fpucw);
+ 
+ 	    MAKE_FPSR (reg);
+ 	    break;
+ #endif		    
+ 	    FAIL(1);  
+ 	    return;
+ 	    regs.fp[reg] = (int) src;
+ 	    MAKE_FPSR (regs.fp[reg]);
+ 	    break;
+ 	 case 0x04:		/* FSQRT */
+ 	 case 0x41:
+ 	 case 0x45:
+ 	    dont_care_fflags();
+ 	    src=get_fp_value (opcode, extra);
+ 	    if (src < 0) {
+ 		FAIL(1);  /* Illegal instruction */
+ 		return;
+ 	    }
+ 	    fsqrt_rr(reg,src);
+ 	    MAKE_FPSR (reg);
+ 	    break;
+ 	 case 0x06:		/* FLOGNP1 */
+ 	    FAIL(1);  
+ 	    return;
+ 	    dont_care_fflags();
+ 	    regs.fp[reg] = log (src + 1.0);
+ 	    MAKE_FPSR (regs.fp[reg]);
+ 	    break;
+ 	 case 0x08:		/* FETOXM1 */
+ 	    FAIL(1);  
+ 	    return;
+ 	    dont_care_fflags();
+ 	    regs.fp[reg] = exp (src) - 1.0;
+ 	    MAKE_FPSR (regs.fp[reg]);
+ 	    break;
+ 	 case 0x09:		/* FTANH */
+ 	    FAIL(1);  
+ 	    return;
+ 	    dont_care_fflags();
+ 	    regs.fp[reg] = tanh (src);
+ 	    MAKE_FPSR (regs.fp[reg]);
+ 	    break;
+ 	 case 0x0a:		/* FATAN */
+ 	    FAIL(1);  
+ 	    return;
+ 	    dont_care_fflags();
+ 	    regs.fp[reg] = atan (src);
+ 	    MAKE_FPSR (regs.fp[reg]);
+ 	    break;
+ 	 case 0x0c:		/* FASIN */
+ 	    FAIL(1);  
+ 	    return;
+ 	    dont_care_fflags();
+ 	    regs.fp[reg] = asin (src);
+ 	    MAKE_FPSR (regs.fp[reg]);
+ 	    break;
+ 	 case 0x0d:		/* FATANH */
+ 	    FAIL(1);  
+ 	    return;
+ 	    dont_care_fflags();
+ #if 1				/* The BeBox doesn't have atanh, and it isn't in the HPUX libm either */
+ 	    regs.fp[reg] = log ((1 + src) / (1 - src)) / 2;
+ #else
+ 	    regs.fp[reg] = atanh (src);
+ #endif
+ 	    MAKE_FPSR (regs.fp[reg]);
+ 	    break;
+ 	 case 0x0e:		/* FSIN */
+ 	    dont_care_fflags();
+ 	    src=get_fp_value (opcode, extra);
+ 	    if (src < 0) {
+ 		FAIL(1);  /* Illegal instruction */
+ 		return;
+ 	    }
+ 	    fsin_rr(reg,src);
+ 	    MAKE_FPSR (reg);
+ 	    break;
+ 	 case 0x0f:		/* FTAN */
+ 	    FAIL(1);  
+ 	    return;
+ 	    dont_care_fflags();
+ 	    regs.fp[reg] = tan (src);
+ 	    MAKE_FPSR (regs.fp[reg]);
+ 	    break;
+ 	 case 0x10:		/* FETOX */
+ 	    dont_care_fflags();
+ 	    src=get_fp_value (opcode, extra);
+ 	    if (src < 0) {
+ 		FAIL(1);  /* Illegal instruction */
+ 		return;
+ 	    }
+ 	    fetox_rr(reg,src);
+ 	    MAKE_FPSR (reg);
+ 	    break;
+ 	 case 0x11:		/* FTWOTOX */
+ 	    dont_care_fflags();
+ 	    src=get_fp_value (opcode, extra);
+ 	    if (src < 0) {
+ 		FAIL(1);  /* Illegal instruction */
+ 		return;
+ 	    }
+ 	    ftwotox_rr(reg,src);
+ 	    MAKE_FPSR (reg);
+ 	    break;
+ 	 case 0x12:		/* FTENTOX */
+ 	    FAIL(1);  
+ 	    return;
+ 	    dont_care_fflags();
+ 	    regs.fp[reg] = pow (10.0, src);
+ 	    MAKE_FPSR (regs.fp[reg]);
+ 	    break;
+ 	 case 0x14:		/* FLOGN */
+ 	    FAIL(1);  
+ 	    return;
+ 	    dont_care_fflags();
+ 	    regs.fp[reg] = log (src);
+ 	    MAKE_FPSR (regs.fp[reg]);
+ 	    break;
+ 	 case 0x15:		/* FLOG10 */
+ 	    FAIL(1);  
+ 	    return;
+ 	    dont_care_fflags();
+ 	    regs.fp[reg] = log10 (src);
+ 	    MAKE_FPSR (regs.fp[reg]);
+ 	    break;
+ 	 case 0x16:		/* FLOG2 */
+ 	    dont_care_fflags();
+ 	    src=get_fp_value (opcode, extra);
+ 	    if (src < 0) {
+ 		FAIL(1);  /* Illegal instruction */
+ 		return;
+ 	    }
+ 	    flog2_rr(reg,src);
+ 	    MAKE_FPSR (reg);
+ 	    break;
+ 	 case 0x18:		/* FABS */
+ 	 case 0x58:
+ 	 case 0x5c:
+ 	    dont_care_fflags();
+ 	    src=get_fp_value (opcode, extra);
+ 	    if (src < 0) {
+ 		FAIL(1);  /* Illegal instruction */
+ 		return;
+ 	    }
+ 	    fabs_rr(reg,src);
+ 	    MAKE_FPSR (reg);
+ 	    break;
+ 	 case 0x19:		/* FCOSH */
+ 	    FAIL(1);  
+ 	    return;
+ 	    dont_care_fflags();
+ 	    regs.fp[reg] = cosh (src);
+ 	    MAKE_FPSR (regs.fp[reg]);
+ 	    break;
+ 	 case 0x1a:		/* FNEG */
+ 	 case 0x5a:
+ 	 case 0x5e:
+ 	    dont_care_fflags();
+ 	    src=get_fp_value (opcode, extra);
+ 	    if (src < 0) {
+ 		FAIL(1);  /* Illegal instruction */
+ 		return;
+ 	    }
+ 	    fneg_rr(reg,src);
+ 	    MAKE_FPSR (reg);
+ 	    break;
+ 	 case 0x1c:		/* FACOS */
+ 	    FAIL(1);  
+ 	    return;
+ 	    dont_care_fflags();
+ 	    regs.fp[reg] = acos (src);
+ 	    MAKE_FPSR (regs.fp[reg]);
+ 	    break;
+ 	 case 0x1d:		/* FCOS */
+ 	    dont_care_fflags();
+ 	    src=get_fp_value (opcode, extra);
+ 	    if (src < 0) {
+ 		FAIL(1);  /* Illegal instruction */
+ 		return;
+ 	    }
+ 	    fcos_rr(reg,src);
+ 	    MAKE_FPSR (reg);
+ 	    break;
+ 	 case 0x1e:		/* FGETEXP */
+ 	    FAIL(1);  
+ 	    return;
+ 	    dont_care_fflags();
+ 	    {
+ 		int expon;
+ 		frexp (src, &expon);
+ 		regs.fp[reg] = (double) (expon - 1);
+ 		MAKE_FPSR (regs.fp[reg]);
+ 	    }
+ 	    break;
+ 	 case 0x1f:		/* FGETMAN */
+ 	    FAIL(1);  
+ 	    return;
+ 	    dont_care_fflags();
+ 	    {
+ 		int expon;
+ 		regs.fp[reg] = frexp (src, &expon) * 2.0;
+ 		MAKE_FPSR (regs.fp[reg]);
+ 	    }
+ 	    break;
+ 	 case 0x20:		/* FDIV */
+ 	 case 0x60:
+ 	 case 0x64:
+ 	    dont_care_fflags();
+ 	    src=get_fp_value (opcode, extra);
+ 	    if (src < 0) {
+ 		FAIL(1);  /* Illegal instruction */
+ 		return;
+ 	    }
+ 	    fdiv_rr(reg,src);
+ 	    MAKE_FPSR (reg);
+ 	    break;
+ 	 case 0x21:		/* FMOD */
+ 	    dont_care_fflags();
+ 	    src=get_fp_value (opcode, extra);
+ 	    if (src < 0) {
+ 		FAIL(1);  /* Illegal instruction */
+ 		return;
+ 	    }
+ 	    frem_rr(reg,src);
+ 	    MAKE_FPSR (reg);
+ 	    break;
+ 	 case 0x22:		/* FADD */
+ 	 case 0x62:
+ 	 case 0x66:
+ 	    dont_care_fflags();
+ 	    src=get_fp_value (opcode, extra);
+ 	    if (src < 0) {
+ 		FAIL(1);  /* Illegal instruction */
+ 		return;
+ 	    }
+ 	    fadd_rr(reg,src);
+ 	    MAKE_FPSR (reg);
+ 	    break;
+ 	 case 0x23:		/* FMUL */
+ 	 case 0x63:
+ 	 case 0x67:
+ 	    dont_care_fflags();
+ 	    src=get_fp_value (opcode, extra);
+ 	    if (src < 0) {
+ 		FAIL(1);  /* Illegal instruction */
+ 		return;
+ 	    }
+ 	    fmul_rr(reg,src);
+ 	    MAKE_FPSR (reg);
+ 	    break;
+ 	 case 0x24:		/* FSGLDIV */
+ 	    dont_care_fflags();
+ 	    src=get_fp_value (opcode, extra);
+ 	    if (src < 0) {
+ 		FAIL(1);  /* Illegal instruction */
+ 		return;
+ 	    }
+ 	    fdiv_rr(reg,src);
+ 	    MAKE_FPSR (reg);
+ 	    break;
+ 	 case 0x25:		/* FREM */
+ 	    dont_care_fflags();
+ 	    src=get_fp_value (opcode, extra);
+ 	    if (src < 0) {
+ 		FAIL(1);  /* Illegal instruction */
+ 		return;
+ 	    }
+ 	    frem1_rr(reg,src);
+ 	    MAKE_FPSR (reg);
+ 	    break;
+ 	 case 0x26:		/* FSCALE */
+ 	    dont_care_fflags();
+ 	    FAIL(1);  
+ 	    return;
+ 	    regs.fp[reg] *= exp (log (2.0) * src);
+ 	    MAKE_FPSR (regs.fp[reg]);
+ 	    break;
+ 	 case 0x27:		/* FSGLMUL */
+ 	    dont_care_fflags();
+ 	    src=get_fp_value (opcode, extra);
+ 	    if (src < 0) {
+ 		FAIL(1);  /* Illegal instruction */
+ 		return;
+ 	    }
+ 	    fmul_rr(reg,src);
+ 	    MAKE_FPSR (reg);
+ 	    break;
+ 	 case 0x28:		/* FSUB */
+ 	 case 0x68:
+ 	 case 0x6c:
+ 	    dont_care_fflags();
+ 	    src=get_fp_value (opcode, extra);
+ 	    if (src < 0) {
+ 		FAIL(1);  /* Illegal instruction */
+ 		return;
+ 	    }
+ 	    fsub_rr(reg,src);
+ 	    MAKE_FPSR (reg);
+ 	    break;
+ 	 case 0x30:		/* FSINCOS */
+ 	 case 0x31:
+ 	 case 0x32:
+ 	 case 0x33:
+ 	 case 0x34:
+ 	 case 0x35:
+ 	 case 0x36:
+ 	 case 0x37:
+ 	    FAIL(1);  
+ 	    return;
+ 	    dont_care_fflags();
+ 	    regs.fp[reg] = sin (src);
+ 	    regs.fp[extra & 7] = cos (src);
+ 	    MAKE_FPSR (regs.fp[reg]);
+ 	    break;
+ 	 case 0x38:		/* FCMP */
+ 	    src=get_fp_value (opcode, extra);
+ 	    if (src < 0) {
+ 		FAIL(1);  /* Illegal instruction */
+ 		return;
+ 	    }
+ 	    fmov_rr(FP_RESULT,reg);
+ 	    fsub_rr(FP_RESULT,src); /* Right way? */
+ 	    break;
+ 	 case 0x3a:		/* FTST */
+ 	    src=get_fp_value (opcode, extra);
+ 	    if (src < 0) {
+ 		FAIL(1);  /* Illegal instruction */
+ 		return;
+ 	    }
+ 	    fmov_rr(FP_RESULT,src);
+ 	    break;
+ 	 default:
+ 	    FAIL(1);  
+ 	    return;
+ 	    break;
+ 	}
+ 	return;
+     }
+     m68k_setpc (m68k_getpc () - 4);
+     op_illg (opcode);
+ }
diff -crB --new-file ./uae-0.8.21/src/compemu_optimizer.c ../uae_jit_cleaning/uae-0.8.21/src/compemu_optimizer.c
*** ./uae-0.8.21/src/compemu_optimizer.c	1970-01-01 02:00:00.000000000 +0200
--- ../uae_jit_cleaning/uae-0.8.21/src/compemu_optimizer.c	2021-01-10 13:10:29.842591684 +0200
***************
*** 0 ****
--- 1,174 ----
+ #if USE_OPTIMIZER
+ /* Welcome to the magical world of cpp ;-) */
+ 
+ #define USE_REGALLOC optlev>=2
+ 
+ #define opt_op0(dummy) opt_store_op0()
+ #define opt_op1(a1) opt_store_op1(OPT_##a1)
+ #define opt_op2(a1,a2) opt_store_op2(OPT_##a1,OPT_##a2)
+ #define opt_op3(a1,a2,a3) opt_store_op3(OPT_##a1,OPT_##a2,OPT_##a3)
+ #define opt_op4(a1,a2,a3,a4) opt_store_op4(OPT_##a1,OPT_##a2,OPT_##a3,OPT_##a4)
+ #define opt_op5(a1,a2,a3,a4,a5) opt_store_op5(OPT_##a1,OPT_##a2,OPT_##a3,OPT_##a4,OPT_##a5)
+ 
+ #define direct0(dummy) ()
+ #define direct1(a1) (DIR_##a1)
+ #define direct2(a1,a2) (DIR_##a1,DIR_##a2)
+ #define direct3(a1,a2,a3) (DIR_##a1,DIR_##a2,DIR_##a3)
+ #define direct4(a1,a2,a3,a4) (DIR_##a1,DIR_##a2,DIR_##a3,DIR_##a4)
+ #define direct5(a1,a2,a3,a4,a5) (DIR_##a1,DIR_##a2,DIR_##a3,DIR_##a4,DIR_##a5)
+ 
+ #define OIMM 0
+ #define OMEMR 0
+ #define OMEMW 0
+ #define OMEMRW 0 /* These are all 32 bit immediates */
+ #define OR1  1
+ #define OR2  2
+ #define OR4  3
+ #define OW1  4
+ #define OW2  5
+ #define OW4  6
+ #define ORW1 7
+ #define ORW2 8
+ #define ORW4 9
+ 
+ #define OFW 10
+ #define OFR 11
+ #define OFRW 12
+ 
+ #define INST_END 98
+ #define FLUSH 99
+ 
+ #define OPT_IMM OIMM,
+ #define OPT_MEMR OMEMR,
+ #define OPT_MEMW OMEMW,
+ #define OPT_MEMRW OMEMRW,
+ #define OPT_R1  OR1 ,
+ #define OPT_R2  OR2 ,
+ #define OPT_R4  OR4 ,
+ #define OPT_W1  OW1 ,
+ #define OPT_W2  OW2 ,
+ #define OPT_W4  OW4 ,
+ #define OPT_RW1 ORW1,
+ #define OPT_RW2 ORW2,
+ #define OPT_RW4 ORW4,
+ 
+ #define OPT_FW  OFW ,
+ #define OPT_FR  OFR ,
+ #define OPT_FRW OFRW ,
+ 
+ #define DIR_IMM 
+ #define DIR_MEMR 
+ #define DIR_MEMW 
+ #define DIR_MEMRW 
+ #define DIR_R1  
+ #define DIR_R2  
+ #define DIR_R4  
+ #define DIR_W1  
+ #define DIR_W2  
+ #define DIR_W4  
+ #define DIR_RW1 
+ #define DIR_RW2 
+ #define DIR_RW4 
+ 
+ #define DIR_FR
+ #define DIR_FW
+ #define DIR_FRW
+ 
+ #undef MIDFUNC
+ #undef MENDFUNC
+ 
+ #define MIDFUNC(nargs,func,args) \
+   __inline__ void do_##func args
+ 
+ #define MENDFUNC(nargs,func,args) \
+   void func args \
+   { \
+     if (reg_alloc_run) { \
+       opt_op##nargs##args; \
+     } else { \
+       do_##func direct##nargs##args; \
+     } \
+   }
+ 
+ #undef COMPCALL
+ #define COMPCALL(func) do_##func
+ 
+ int opt_index=0;
+ 
+ static __inline__ void store_any(uae_u8 type, uae_u32 val)
+ {
+     ra[opt_index].type=type;
+     ra[opt_index].reg=val;
+     opt_index++;
+     if (opt_index>=MAXREGOPT) {
+ 	printf("Oops! opt_index overflow....\n");
+ 	abort();
+     }
+ }
+ 
+ static __inline__ void store_arg(uae_u8 type, uae_u32 val)
+ {
+     if (type<OR1 || type>ORW4) 
+ 	return;
+     store_any(type,val);
+ }
+ 
+ static __inline__ void opt_store_op0(void)
+ {
+     /* zilch */
+ }
+ 
+ static __inline__ void opt_store_op1(uae_u8 t1, uae_u32 a1)
+ {
+     store_arg(t1,a1);
+     opt_store_op0();
+ }
+  
+ static __inline__ void opt_store_op2(uae_u8 t1, uae_u32 a1,
+ 				     uae_u8 t2, uae_u32 a2)
+ {
+     store_arg(t2,a2);
+     opt_store_op1(t1,a1);
+ }
+ 
+ static __inline__ void opt_store_op3(uae_u8 t1, uae_u32 a1,
+ 				     uae_u8 t2, uae_u32 a2,
+ 				     uae_u8 t3, uae_u32 a3)
+ {
+     store_arg(t3,a3);
+     opt_store_op2(t1,a1,t2,a2);
+ }
+ 
+ static __inline__ void opt_store_op4(uae_u8 t1, uae_u32 a1,
+ 				     uae_u8 t2, uae_u32 a2,
+ 				     uae_u8 t3, uae_u32 a3,
+ 				     uae_u8 t4, uae_u32 a4)
+ {
+     store_arg(t4,a4);
+     opt_store_op3(t1,a1,t2,a2,t3,a3);
+ }
+ 
+ static __inline__ void opt_store_op5(uae_u8 t1, uae_u32 a1,
+ 				     uae_u8 t2, uae_u32 a2,
+ 				     uae_u8 t3, uae_u32 a3,
+ 				     uae_u8 t4, uae_u32 a4,
+ 				     uae_u8 t5, uae_u32 a5)
+ {
+     store_arg(t5,a5);
+     opt_store_op4(t1,a1,t2,a2,t3,a3,t4,a4);
+ }
+ 
+ static void opt_assert_empty(int line)
+ {
+ }
+ 
+ void empty_optimizer(void) 
+ {
+ }
+ 
+ #else
+ static __inline__ void opt_emit_all(void) {}
+ static __inline__ void opt_assert_empty(int line) {}
+ void empty_optimizer(void) {}
+ #define USE_REGALLOC 0
+ #endif
diff -crB --new-file ./uae-0.8.21/src/compemu_optimizer_x86.c ../uae_jit_cleaning/uae-0.8.21/src/compemu_optimizer_x86.c
*** ./uae-0.8.21/src/compemu_optimizer_x86.c	1970-01-01 02:00:00.000000000 +0200
--- ../uae_jit_cleaning/uae-0.8.21/src/compemu_optimizer_x86.c	2021-01-10 13:10:29.846591684 +0200
***************
*** 0 ****
--- 1,421 ----
+ #if USE_LOW_OPTIMIZER
+ /* Welcome to the magical world of cpp ;-) */
+ 
+ /* This was broken by the advent of FPU emulation. It also didn't
+    provide any useful speedup while it worked. *Sigh* Someone fix my
+    software, please ;-) */
+ 
+ #define MAXLOPTINST 100
+ 
+ #define LDECISION currprefs.comp_lowopt
+ 
+ #define lopt_op0(dummy) lopt_store_op0(
+ #define lopt_op1(a1) lopt_store_op1(LOPT_##a1,
+ #define lopt_op2(a1,a2) lopt_store_op2(LOPT_##a1,LOPT_##a2,
+ #define lopt_op3(a1,a2,a3) lopt_store_op3(LOPT_##a1,LOPT_##a2,LOPT_##a3,
+ #define lopt_op4(a1,a2,a3,a4) lopt_store_op4(LOPT_##a1,LOPT_##a2,LOPT_##a3,LOPT_##a4,
+ #define lopt_op5(a1,a2,a3,a4,a5) lopt_store_op5(LOPT_##a1,LOPT_##a2,LOPT_##a3,LOPT_##a4,LOPT_##a5,
+ 
+ #define ldirect0(dummy) ()
+ #define ldirect1(a1) (LDIR_##a1)
+ #define ldirect2(a1,a2) (LDIR_##a1,LDIR_##a2)
+ #define ldirect3(a1,a2,a3) (LDIR_##a1,LDIR_##a2,LDIR_##a3)
+ #define ldirect4(a1,a2,a3,a4) (LDIR_##a1,LDIR_##a2,LDIR_##a3,LDIR_##a4)
+ #define ldirect5(a1,a2,a3,a4,a5) (LDIR_##a1,LDIR_##a2,LDIR_##a3,LDIR_##a4,LDIR_##a5)
+ 
+ #define NONE 0
+ #define READ 1
+ #define WRITE 2
+ #define RMW (READ|WRITE)
+ 
+ #define SIZE1 4
+ #define SIZE2 8
+ #define SIZE4 12
+ #define FLOAT 16
+ #define SIZEMASK 12
+ 
+ #define LIMM NONE
+ #define LR1  (READ | SIZE1)
+ #define LR2  (READ | SIZE2)
+ #define LR4  (READ | SIZE4)
+ #define LW1  (WRITE | SIZE1)
+ #define LW2  (WRITE | SIZE2)
+ #define LW4  (WRITE | SIZE4)
+ #define LRW1 (RMW | SIZE1)
+ #define LRW2 (RMW | SIZE2)
+ #define LRW4 (RMW | SIZE4)
+ #define LFW  (READ | FLOAT)
+ #define LFR  (WRITE | FLOAT)
+ #define LFRW (RMW | FLOAT)
+ #define LMEMR NONE
+ #define LMEMW NONE
+ #define LMEMRW NONE
+ 
+ #define LOPT_IMM LIMM,
+ #define LOPT_R1  LR1 ,
+ #define LOPT_R2  LR2 ,
+ #define LOPT_R4  LR4 ,
+ #define LOPT_W1  LW1 ,
+ #define LOPT_W2  LW2 ,
+ #define LOPT_W4  LW4 ,
+ #define LOPT_RW1 LRW1,
+ #define LOPT_RW2 LRW2,
+ #define LOPT_RW4 LRW4,
+ #define LOPT_FR  LFR,
+ #define LOPT_FW  LFW,
+ #define LOPT_FRW LFRW,
+ #define LOPT_MEMR LMEMR,
+ #define LOPT_MEMW LMEMW,
+ #define LOPT_MEMRW LMEMRW,
+ 
+ #define LDIR_IMM 
+ #define LDIR_R1  
+ #define LDIR_R2  
+ #define LDIR_R4  
+ #define LDIR_W1  
+ #define LDIR_W2  
+ #define LDIR_W4  
+ #define LDIR_RW1 
+ #define LDIR_RW2 
+ #define LDIR_RW4 
+ #define LDIR_FW
+ #define LDIR_FR
+ #define LDIR_FRW
+ #define LDIR_MEMR 
+ #define LDIR_MEMW 
+ #define LDIR_MEMRW 
+ 
+ 
+ #undef LOWFUNC
+ #undef LENDFUNC
+ 
+ #define LOWFUNC(flags,mem,nargs,func,args) \
+   static __inline__ void do_##func args
+ 
+ #define LENDFUNC(flags,mem,nargs,func,args) \
+   static __inline__ void func args \
+   { \
+   if (LDECISION) { \
+     lopt_op##nargs##args do_##func, mem, flags); \
+   } else { \
+     do_##func ldirect##nargs##args; \
+   } \
+   } 
+ 
+ typedef struct lopt_inst_rec {
+     void* func;
+     uae_u32 args[5];
+     uae_u8 argtype[5];
+     uae_s8 nargs;
+     uae_u8 mem;
+     uae_u8 flags;
+ } lopt_inst;
+ 
+ 
+ 
+ static lopt_inst linst[MAXLOPTINST];
+ static int lopt_index=0;
+ 
+ static __inline__ int argsize(int type)
+ {
+     return type&SIZEMASK;
+ }
+ 
+ static __inline__ int reads_mem(int i) {
+     return linst[i].mem & READ;
+ }
+     
+     
+ static __inline__ int access_reg(int i, int r, int mode)
+ {
+     int k;
+     for (k=0;k<linst[i].nargs;k++)
+ 	if (linst[i].args[k]==r && 
+ 	    (linst[i].argtype[k]&mode) &&
+ 	    !(linst[i].argtype[k]&FLOAT))
+ 	    return 1;
+     return 0;
+ }
+ 
+ static __inline__ int writes_reg(int i, int r)
+ {
+     return access_reg(i,r,WRITE);
+ }
+ 
+ static __inline__ int reads_reg(int i, int r)
+ {
+     return access_reg(i,r,READ);
+ }
+ 
+ static __inline__ int uses_reg(int i, int r)
+ {
+     return access_reg(i,r,RMW);
+ }
+ 
+ 
+ static __inline__ int writes_mem(int i) {
+     return linst[i].mem & WRITE;
+ }
+ 
+ static __inline__ int uses_mem(int i)
+ {
+     return linst[i].mem & RMW;
+ }
+ 
+ static __inline__ int reads_flags(int i) {
+     return linst[i].flags & READ;
+ }
+ 
+ static __inline__ int writes_flags(int i) {
+     return linst[i].flags & WRITE;
+ }
+ 
+ static __inline__ int uses_flags(int i)
+ {
+     return linst[i].flags & RMW;
+ }
+ 
+ static void do_raw_mov_l_rm(W4,MEMR);
+ static void do_raw_fflags_save(void);
+ 
+ 
+ /* Whether i depends on j */
+ static __inline__ int depends_on(int i, int j)
+ {
+     int n;
+ 
+     /* First, check memory */
+     if (writes_mem(i) && uses_mem(j))
+ 	return 1;
+     if (reads_mem(i) && writes_mem(j))
+ 	return 1;
+ 
+     /* Next, check flags */
+     if (writes_flags(i) && uses_flags(j))
+ 	return 1;
+     if (reads_flags(i) && writes_flags(j))
+ 	return 1;
+     
+     for (n=0;n<linst[i].nargs;n++) {
+ 	if (linst[i].argtype[n] & FLOAT)
+ 	    return 1;
+     }
+     for (n=0;n<linst[j].nargs;n++) {
+ 	if (linst[j].argtype[n] & FLOAT)
+ 	    return 1;
+     }
+ 
+     for (n=0;n<linst[i].nargs;n++) {
+ 	if ((linst[i].argtype[n] & WRITE) &&
+ 	    !(linst[i].argtype[n] & FLOAT)) {
+ 	    if (uses_reg(j,linst[i].args[n]))
+ 		return 1;
+ 	}
+ 	else if ((linst[i].argtype[n] & READ) &&
+ 		 !(linst[i].argtype[n] & FLOAT))  {
+ 	    if (writes_reg(j,linst[i].args[n]))
+ 		return 1;
+ 	}
+     }
+ 
+     /* The need for this indicates a problem somewhere in the
+        LOWFUNC definitions --- I think. FIXME! */
+ 
+     if (uses_flags(j) && uses_flags(i))
+ 	return 1;
+     if (linst[i].func==do_raw_fflags_save)
+ 	return 1;
+     if (linst[j].func==do_raw_fflags_save)
+ 	return 1;
+ 
+     return 0;
+ }
+ 
+ static void do_raw_mov_l_rm(W4 d, MEMR s);
+ 	    
+ static __inline__ void low_peephole(void)
+ {
+     int i;
+     
+     for (i=0;i<lopt_index;i++) {
+ 	if (uses_mem(i)) {
+ 	    int j=i-1;
+ 	    
+ 	    while (j>=i-4 && j>=0 && !depends_on(i,j)) {
+ 		j--;
+ 	    }
+ 	    if (j!=i-1) {
+ 		lopt_inst x=linst[i];
+ 		int k=i;
+ 
+ 		j++;
+ 		while (k>j) {
+ 		    linst[k]=linst[k-1];
+ 		    k--;
+ 		}
+ 		linst[j]=x;
+ 	    }
+ 	}
+     }
+ }
+ 
+ 
+ typedef void lopt_handler0(void);
+ typedef void lopt_handler1(uae_u32);
+ typedef void lopt_handler2(uae_u32,uae_u32);
+ typedef void lopt_handler3(uae_u32,uae_u32,uae_u32);
+ typedef void lopt_handler4(uae_u32,uae_u32,uae_u32,uae_u32);
+ typedef void lopt_handler5(uae_u32,uae_u32,uae_u32,uae_u32,uae_u32);
+ 
+ static void lopt_emit_all(void)
+ {
+     int i;
+     lopt_inst* x;
+     static int inemit=0;
+     
+     if (inemit) {
+ 	printf("WARNING: lopt_emit is not reentrant!\n");
+     }
+     inemit=1;
+ 
+     low_peephole();
+ 
+     for (i=0;i<lopt_index;i++) {
+ 	x=linst+i;
+ 	switch(x->nargs) {
+ 	 case 0: ((lopt_handler0*)x->func)(); break;
+ 	 case 1: ((lopt_handler1*)x->func)(x->args[0]); break;
+ 	 case 2: ((lopt_handler2*)x->func)(x->args[0],x->args[1]); break;
+ 	 case 3: ((lopt_handler3*)x->func)(x->args[0],x->args[1],x->args[2]); break;
+ 	 case 4: ((lopt_handler4*)x->func)(x->args[0],x->args[1],x->args[2],
+ 					   x->args[3]); break;
+ 	 case 5: ((lopt_handler5*)x->func)(x->args[0],x->args[1],x->args[2],
+ 					   x->args[3],x->args[4]); break;
+ 	 default: abort();
+ 	}
+     }
+     lopt_index=0;
+     inemit=0;
+ }
+ 
+ static __inline__ void low_advance(void)
+ {
+   lopt_index++;
+   if (lopt_index==MAXLOPTINST)
+     lopt_emit_all();
+ }
+ 
+ static __inline__ void lopt_store_op0(void* lfuncptr, uae_u32 lmem, 
+ 				      uae_u32 lflags)
+ {
+   linst[lopt_index].func=lfuncptr;
+   linst[lopt_index].mem=lmem;
+   linst[lopt_index].flags=lflags;
+   linst[lopt_index].nargs=0;
+   low_advance();
+ }
+ 
+ static __inline__ void lopt_store_op1(uae_u8 t1, uae_u32 a1,
+ 				      void* lfuncptr, uae_u32 lmem, 
+ 				      uae_u32 lflags)
+ {
+   linst[lopt_index].func=lfuncptr;
+   linst[lopt_index].mem=lmem;
+   linst[lopt_index].flags=lflags;
+   linst[lopt_index].nargs=1;
+   linst[lopt_index].argtype[0]=t1;
+   linst[lopt_index].args[0]=a1;
+   low_advance();
+ }
+ 
+ static __inline__ void lopt_store_op2(uae_u8 t1, uae_u32 a1,
+ 				      uae_u8 t2, uae_u32 a2,
+ 				      void* lfuncptr, uae_u32 lmem, 
+ 				      uae_u32 lflags)
+ {
+   linst[lopt_index].func=lfuncptr;
+   linst[lopt_index].mem=lmem;
+   linst[lopt_index].flags=lflags;
+   linst[lopt_index].nargs=2;
+   linst[lopt_index].argtype[0]=t1;
+   linst[lopt_index].args[0]=a1;
+   linst[lopt_index].argtype[1]=t2;
+   linst[lopt_index].args[1]=a2;
+   low_advance();
+ }
+ 
+ static __inline__ void lopt_store_op3(uae_u8 t1, uae_u32 a1,
+ 				      uae_u8 t2, uae_u32 a2,
+ 				      uae_u8 t3, uae_u32 a3,
+ 				      void* lfuncptr, uae_u32 lmem, 
+ 				      uae_u32 lflags)
+ {
+   linst[lopt_index].func=lfuncptr;
+   linst[lopt_index].mem=lmem;
+   linst[lopt_index].flags=lflags;
+   linst[lopt_index].nargs=3;
+   linst[lopt_index].argtype[0]=t1;
+   linst[lopt_index].args[0]=a1;
+   linst[lopt_index].argtype[1]=t2;
+   linst[lopt_index].args[1]=a2;
+   linst[lopt_index].argtype[2]=t3;
+   linst[lopt_index].args[2]=a3;
+   low_advance();
+ }
+ 
+ static __inline__ void lopt_store_op4(uae_u8 t1, uae_u32 a1,
+ 				      uae_u8 t2, uae_u32 a2,
+ 				      uae_u8 t3, uae_u32 a3,
+ 				      uae_u8 t4, uae_u32 a4,
+ 				      void* lfuncptr, uae_u32 lmem, 
+ 				      uae_u32 lflags)
+ {
+   linst[lopt_index].func=lfuncptr;
+   linst[lopt_index].mem=lmem;
+   linst[lopt_index].flags=lflags;
+   linst[lopt_index].nargs=4;
+   linst[lopt_index].argtype[0]=t1;
+   linst[lopt_index].args[0]=a1;
+   linst[lopt_index].argtype[1]=t2;
+   linst[lopt_index].args[1]=a2;
+   linst[lopt_index].argtype[2]=t3;
+   linst[lopt_index].args[2]=a3;
+   linst[lopt_index].argtype[3]=t4;
+   linst[lopt_index].args[3]=a4;
+   low_advance();
+ }
+ 
+ static __inline__ void lopt_store_op5(uae_u8 t1, uae_u32 a1,
+ 				      uae_u8 t2, uae_u32 a2,
+ 				      uae_u8 t3, uae_u32 a3,
+ 				      uae_u8 t4, uae_u32 a4,
+ 				      uae_u8 t5, uae_u32 a5,
+ 				      void* lfuncptr, uae_u32 lmem, 
+ 				      uae_u32 lflags)
+ {
+   linst[lopt_index].func=lfuncptr;
+   linst[lopt_index].mem=lmem;
+   linst[lopt_index].flags=lflags;
+   linst[lopt_index].nargs=5;
+   linst[lopt_index].argtype[0]=t1;
+   linst[lopt_index].args[0]=a1;
+   linst[lopt_index].argtype[1]=t2;
+   linst[lopt_index].args[1]=a2;
+   linst[lopt_index].argtype[2]=t3;
+   linst[lopt_index].args[2]=a3;
+   linst[lopt_index].argtype[3]=t4;
+   linst[lopt_index].args[3]=a4;
+   linst[lopt_index].argtype[4]=t5;
+   linst[lopt_index].args[4]=a5;
+   low_advance();
+ }
+ 
+ static __inline__ void empty_low_optimizer(void) 
+ {
+   lopt_emit_all();
+ }
+ 
+ #else
+ static __inline__ void lopt_emit_all(void) {}
+ static __inline__ void empty_low_optimizer(void) {}
+ #endif
diff -crB --new-file ./uae-0.8.21/src/compemu_raw_x86.c ../uae_jit_cleaning/uae-0.8.21/src/compemu_raw_x86.c
*** ./uae-0.8.21/src/compemu_raw_x86.c	1970-01-01 02:00:00.000000000 +0200
--- ../uae_jit_cleaning/uae-0.8.21/src/compemu_raw_x86.c	2021-01-10 14:05:32.858591684 +0200
***************
*** 0 ****
--- 1,3259 ----
+ /* This should eventually end up in machdep/, but for now, x86 is the
+    only target, and it's easier this way... */
+ 
+ /*************************************************************************
+  * Some basic information about the the target CPU                       *
+  *************************************************************************/
+ 
+ #define EAX 0
+ #define ECX 1
+ #define EDX 2
+ #define EBX 3
+ 
+ /* The register in which subroutines return an integer return value */
+ #define REG_RESULT 0
+ 
+ /* The registers subroutines take their first and second argument in */
+ #define REG_PAR1 0
+ #define REG_PAR2 2
+ 
+ /* Three registers that are not used for any of the above */
+ #define REG_NOPAR1 6
+ #define REG_NOPAR2 5
+ #define REG_NOPAR3 3
+ 
+ #define REG_PC_PRE 0 /* The register we use for preloading regs.pc_p */
+ #define REG_PC_TMP 1 /* Another register that is not the above */
+ 
+ #define SHIFTCOUNT_NREG 1  /* Register that can be used for shiftcount.
+ 			      -1 if any reg will do */
+ #define MUL_NREG1 0 /* %eax will hold the low 32 bits after a 32x32 mul */
+ #define MUL_NREG2 2 /* %edx will hold the high 32 bits */
+ 
+ uae_s8 always_used[]={4,-1};
+ uae_s8 can_byte[]={0,1,2,3,-1};
+ uae_s8 can_word[]={0,1,2,3,5,6,7,-1};
+ 
+ uae_u8 call_saved[]={0,0,0,0,1,0,0,0};
+ 
+ /* This *should* be the same as call_saved. But:
+    - We might not really know which registers are saved, and which aren't,
+      so we need to preserve some, but don't want to rely on everyone else
+      also saving those registers
+    - Special registers (such like the stack pointer) should not be "preserved"
+      by pushing, even though they are "saved" across function calls
+ */
+ uae_u8 need_to_preserve[]={1,1,1,1,0,1,1,1};
+ 
+ /* Whether classes of instructions do or don't clobber the native flags */
+ #define CLOBBER_MOV
+ #define CLOBBER_LEA
+ #define CLOBBER_CMOV
+ #define CLOBBER_POP
+ #define CLOBBER_PUSH
+ #define CLOBBER_SUB  clobber_flags()
+ #define CLOBBER_SBB  clobber_flags()
+ #define CLOBBER_CMP  clobber_flags()
+ #define CLOBBER_ADD  clobber_flags()
+ #define CLOBBER_ADC  clobber_flags()
+ #define CLOBBER_AND  clobber_flags()
+ #define CLOBBER_OR   clobber_flags()
+ #define CLOBBER_XOR  clobber_flags()
+ 
+ #define CLOBBER_ROL  clobber_flags()
+ #define CLOBBER_ROR  clobber_flags()
+ #define CLOBBER_SHLL clobber_flags()
+ #define CLOBBER_SHRL clobber_flags()
+ #define CLOBBER_SHRA clobber_flags()
+ #define CLOBBER_TEST clobber_flags()
+ #define CLOBBER_CL16 
+ #define CLOBBER_CL8  
+ #define CLOBBER_SE16
+ #define CLOBBER_SE8
+ #define CLOBBER_ZE16
+ #define CLOBBER_ZE8
+ #define CLOBBER_SW16 clobber_flags()
+ #define CLOBBER_SW32
+ #define CLOBBER_SETCC
+ #define CLOBBER_MUL  clobber_flags()
+ #define CLOBBER_BT   clobber_flags()
+ #define CLOBBER_BSF  clobber_flags()
+ 
+ /*************************************************************************
+  * Actual encoding of the instructions on the target CPU                 *
+  *************************************************************************/
+ 
+ static int have_cmov=0;  /* We need to generate different code if 
+ 			    we don't have cmov */
+ 
+ #include "compemu_optimizer_x86.c"
+ 
+ static uae_u16 swap16(uae_u16 x)
+ {
+     return ((x&0xff00)>>8)|((x&0x00ff)<<8);
+ }
+ 
+ static uae_u32 swap32(uae_u32 x)
+ {
+     return ((x&0xff00)<<8)|((x&0x00ff)<<24)|((x&0xff0000)>>8)|((x&0xff000000)>>24);
+ }
+ 
+ static __inline__ int isbyte(uae_s32 x)
+ {
+   return (x>=-128 && x<=127);
+ }
+ 
+ LOWFUNC(NONE,WRITE,1,raw_push_l_r,(R4 r))
+ {
+ 	emit_byte(0x50+r);
+ }
+ LENDFUNC(NONE,WRITE,1,raw_push_l_r,(R4 r))
+ 
+ LOWFUNC(NONE,READ,1,raw_pop_l_r,(R4 r))
+ {
+ 	emit_byte(0x58+r);
+ }
+ LENDFUNC(NONE,READ,1,raw_pop_l_r,(R4 r))
+ 
+ LOWFUNC(WRITE,NONE,2,raw_bt_l_ri,(R4 r, IMM i))
+ {
+ 	emit_byte(0x0f);
+ 	emit_byte(0xba);
+ 	emit_byte(0xe0+r);
+ 	emit_byte(i);
+ }
+ LENDFUNC(WRITE,NONE,2,raw_bt_l_ri,(R4 r, IMM i))
+ 
+ LOWFUNC(WRITE,NONE,2,raw_bt_l_rr,(R4 r, R4 b))
+ {
+ 	emit_byte(0x0f);
+ 	emit_byte(0xa3);
+ 	emit_byte(0xc0+8*b+r);
+ }
+ LENDFUNC(WRITE,NONE,2,raw_bt_l_rr,(R4 r, R4 b))
+ 
+ LOWFUNC(WRITE,NONE,2,raw_btc_l_ri,(RW4 r, IMM i))
+ {
+ 	emit_byte(0x0f);
+ 	emit_byte(0xba);
+ 	emit_byte(0xf8+r);
+ 	emit_byte(i);
+ }
+ LENDFUNC(WRITE,NONE,2,raw_btc_l_ri,(RW4 r, IMM i))
+ 
+ LOWFUNC(WRITE,NONE,2,raw_btc_l_rr,(RW4 r, R4 b))
+ {
+ 	emit_byte(0x0f);
+ 	emit_byte(0xbb);
+ 	emit_byte(0xc0+8*b+r);
+ }
+ LENDFUNC(WRITE,NONE,2,raw_btc_l_rr,(RW4 r, R4 b))
+ 
+ 
+ LOWFUNC(WRITE,NONE,2,raw_btr_l_ri,(RW4 r, IMM i))
+ {
+ 	emit_byte(0x0f);
+ 	emit_byte(0xba);
+ 	emit_byte(0xf0+r);
+ 	emit_byte(i);
+ }
+ LENDFUNC(WRITE,NONE,2,raw_btr_l_ri,(RW4 r, IMM i))
+ 
+ LOWFUNC(WRITE,NONE,2,raw_btr_l_rr,(RW4 r, R4 b))
+ {
+ 	emit_byte(0x0f);
+ 	emit_byte(0xb3);
+ 	emit_byte(0xc0+8*b+r);
+ }
+ LENDFUNC(WRITE,NONE,2,raw_btr_l_rr,(RW4 r, R4 b))
+ 
+ LOWFUNC(WRITE,NONE,2,raw_bts_l_ri,(RW4 r, IMM i))
+ {
+ 	emit_byte(0x0f);
+ 	emit_byte(0xba);
+ 	emit_byte(0xe8+r);
+ 	emit_byte(i);
+ }
+ LENDFUNC(WRITE,NONE,2,raw_bts_l_ri,(RW4 r, IMM i))
+ 
+ LOWFUNC(WRITE,NONE,2,raw_bts_l_rr,(RW4 r, R4 b))
+ {
+ 	emit_byte(0x0f);
+ 	emit_byte(0xab);
+ 	emit_byte(0xc0+8*b+r);
+ }
+ LENDFUNC(WRITE,NONE,2,raw_bts_l_rr,(RW4 r, R4 b))
+ 
+ LOWFUNC(WRITE,NONE,2,raw_sub_w_ri,(RW2 d, IMM i))
+ {
+     emit_byte(0x66);
+     if (isbyte(i)) {
+ 	emit_byte(0x83);
+ 	emit_byte(0xe8+d);
+ 	emit_byte(i);
+     }
+     else {
+ 	emit_byte(0x81);
+ 	emit_byte(0xe8+d);
+ 	emit_word(i);
+     }
+ }
+ LENDFUNC(WRITE,NONE,2,raw_sub_w_ri,(RW2 d, IMM i))
+ 
+ 
+ LOWFUNC(NONE,WRITE,2,raw_mov_l_mi,(MEMW d, IMM s))
+ {
+     emit_byte(0xc7);
+     emit_byte(0x05);
+     emit_long(d);
+     emit_long(s);
+ }
+ LENDFUNC(NONE,WRITE,2,raw_mov_l_mi,(MEMW d, IMM s))
+ 
+ LOWFUNC(NONE,WRITE,2,raw_mov_w_mi,(MEMW d, IMM s))
+ {
+     emit_byte(0x66);
+     emit_byte(0xc7);
+     emit_byte(0x05);
+     emit_long(d);
+     emit_word(s);
+ }
+ LENDFUNC(NONE,WRITE,2,raw_mov_w_mi,(MEMW d, IMM s))
+ 
+ LOWFUNC(NONE,WRITE,2,raw_mov_b_mi,(MEMW d, IMM s))
+ {
+     emit_byte(0xc6);
+     emit_byte(0x05);
+     emit_long(d);
+     emit_byte(s);
+ }
+ LENDFUNC(NONE,WRITE,2,raw_mov_b_mi,(MEMW d, IMM s))
+ 
+ LOWFUNC(WRITE,RMW,2,raw_rol_b_mi,(MEMRW d, IMM i))
+ {
+     emit_byte(0xc0);
+     emit_byte(0x05);
+     emit_long(d);
+     emit_byte(i);
+ }
+ LENDFUNC(WRITE,RMW,2,raw_rol_b_mi,(MEMRW d, IMM i))
+ 
+ LOWFUNC(WRITE,NONE,2,raw_rol_b_ri,(RW1 r, IMM i))
+ {
+     emit_byte(0xc0);
+     emit_byte(0xc0+r);
+     emit_byte(i);
+ }
+ LENDFUNC(WRITE,NONE,2,raw_rol_b_ri,(RW1 r, IMM i))
+ 
+ LOWFUNC(WRITE,NONE,2,raw_rol_w_ri,(RW2 r, IMM i))
+ {
+     emit_byte(0x66);
+     emit_byte(0xc1);
+     emit_byte(0xc0+r);
+     emit_byte(i);
+ }
+ LENDFUNC(WRITE,NONE,2,raw_rol_w_ri,(RW2 r, IMM i))
+ 
+ LOWFUNC(WRITE,NONE,2,raw_rol_l_ri,(RW4 r, IMM i))
+ {
+     emit_byte(0xc1);
+     emit_byte(0xc0+r);
+     emit_byte(i);
+ }
+ LENDFUNC(WRITE,NONE,2,raw_rol_l_ri,(RW4 r, IMM i))
+ 
+ LOWFUNC(WRITE,NONE,2,raw_rol_l_rr,(RW4 d, R1 r))
+ {
+     emit_byte(0xd3);
+     emit_byte(0xc0+d);
+ }
+ LENDFUNC(WRITE,NONE,2,raw_rol_l_rr,(RW4 d, R1 r))
+ 
+ LOWFUNC(WRITE,NONE,2,raw_rol_w_rr,(RW2 d, R1 r))
+ {
+     emit_byte(0x66);
+     emit_byte(0xd3);
+     emit_byte(0xc0+d);
+ }
+ LENDFUNC(WRITE,NONE,2,raw_rol_w_rr,(RW2 d, R1 r))
+ 
+ LOWFUNC(WRITE,NONE,2,raw_rol_b_rr,(RW1 d, R1 r))
+ {
+     emit_byte(0xd2);
+     emit_byte(0xc0+d);
+ }
+ LENDFUNC(WRITE,NONE,2,raw_rol_b_rr,(RW1 d, R1 r))
+ 
+ LOWFUNC(WRITE,NONE,2,raw_shll_l_rr,(RW4 d, R1 r))
+ {
+     emit_byte(0xd3);
+     emit_byte(0xe0+d);
+ }
+ LENDFUNC(WRITE,NONE,2,raw_shll_l_rr,(RW4 d, R1 r))
+ 
+ LOWFUNC(WRITE,NONE,2,raw_shll_w_rr,(RW2 d, R1 r))
+ {
+     emit_byte(0x66);
+     emit_byte(0xd3);
+     emit_byte(0xe0+d);
+ }
+ LENDFUNC(WRITE,NONE,2,raw_shll_w_rr,(RW2 d, R1 r))
+ 
+ LOWFUNC(WRITE,NONE,2,raw_shll_b_rr,(RW1 d, R1 r))
+ {
+     emit_byte(0xd2);
+     emit_byte(0xe0+d);
+ }
+ LENDFUNC(WRITE,NONE,2,raw_shll_b_rr,(RW1 d, R1 r))
+ 
+ LOWFUNC(WRITE,NONE,2,raw_ror_b_ri,(RW1 r, IMM i))
+ {
+     emit_byte(0xc0);
+     emit_byte(0xc8+r);
+     emit_byte(i);
+ }
+ LENDFUNC(WRITE,NONE,2,raw_ror_b_ri,(RW1 r, IMM i))
+ 
+ LOWFUNC(WRITE,NONE,2,raw_ror_w_ri,(RW2 r, IMM i))
+ {
+     emit_byte(0x66);
+     emit_byte(0xc1);
+     emit_byte(0xc8+r);
+     emit_byte(i);
+ }
+ LENDFUNC(WRITE,NONE,2,raw_ror_w_ri,(RW2 r, IMM i))
+ 
+ LOWFUNC(WRITE,NONE,2,raw_ror_l_ri,(RW4 r, IMM i))
+ {
+     emit_byte(0xc1);
+     emit_byte(0xc8+r);
+     emit_byte(i);
+ }
+ LENDFUNC(WRITE,NONE,2,raw_ror_l_ri,(RW4 r, IMM i))
+ 
+ LOWFUNC(WRITE,NONE,2,raw_ror_l_rr,(RW4 d, R1 r))
+ {
+     emit_byte(0xd3);
+     emit_byte(0xc8+d);
+ }
+ LENDFUNC(WRITE,NONE,2,raw_ror_l_rr,(RW4 d, R1 r))
+ 
+ LOWFUNC(WRITE,NONE,2,raw_ror_w_rr,(RW2 d, R1 r))
+ {
+     emit_byte(0x66);
+     emit_byte(0xd3);
+     emit_byte(0xc8+d);
+ }
+ LENDFUNC(WRITE,NONE,2,raw_ror_w_rr,(RW2 d, R1 r))
+ 
+ LOWFUNC(WRITE,NONE,2,raw_ror_b_rr,(RW1 d, R1 r))
+ {
+     emit_byte(0xd2);
+     emit_byte(0xc8+d);
+ }
+ LENDFUNC(WRITE,NONE,2,raw_ror_b_rr,(RW1 d, R1 r))
+ 
+ LOWFUNC(WRITE,NONE,2,raw_shrl_l_rr,(RW4 d, R1 r))
+ {
+     emit_byte(0xd3);
+     emit_byte(0xe8+d);
+ }
+ LENDFUNC(WRITE,NONE,2,raw_shrl_l_rr,(RW4 d, R1 r))
+ 
+ LOWFUNC(WRITE,NONE,2,raw_shrl_w_rr,(RW2 d, R1 r))
+ {
+     emit_byte(0x66);
+     emit_byte(0xd3);
+     emit_byte(0xe8+d);
+ }
+ LENDFUNC(WRITE,NONE,2,raw_shrl_w_rr,(RW2 d, R1 r))
+ 
+ LOWFUNC(WRITE,NONE,2,raw_shrl_b_rr,(RW1 d, R1 r))
+ {
+     emit_byte(0xd2);
+     emit_byte(0xe8+d);
+ }
+ LENDFUNC(WRITE,NONE,2,raw_shrl_b_rr,(RW1 d, R1 r))
+ 
+ LOWFUNC(WRITE,NONE,2,raw_shra_l_rr,(RW4 d, R1 r))
+ {
+     emit_byte(0xd3);
+     emit_byte(0xf8+d);
+ }
+ LENDFUNC(WRITE,NONE,2,raw_shra_l_rr,(RW4 d, R1 r))
+ 
+ LOWFUNC(WRITE,NONE,2,raw_shra_w_rr,(RW2 d, R1 r))
+ {
+     emit_byte(0x66);
+     emit_byte(0xd3);
+     emit_byte(0xf8+d);
+ }
+ LENDFUNC(WRITE,NONE,2,raw_shra_w_rr,(RW2 d, R1 r))
+ 
+ LOWFUNC(WRITE,NONE,2,raw_shra_b_rr,(RW1 d, R1 r))
+ {
+     emit_byte(0xd2);
+     emit_byte(0xf8+d);
+ }
+ LENDFUNC(WRITE,NONE,2,raw_shra_b_rr,(RW1 d, R1 r))
+ 
+ LOWFUNC(WRITE,NONE,2,raw_shll_l_ri,(RW4 r, IMM i))
+ {
+     emit_byte(0xc1);
+     emit_byte(0xe0+r);
+     emit_byte(i);
+ }
+ LENDFUNC(WRITE,NONE,2,raw_shll_l_ri,(RW4 r, IMM i))
+ 
+ LOWFUNC(WRITE,NONE,2,raw_shll_w_ri,(RW2 r, IMM i))
+ {
+     emit_byte(0x66);
+     emit_byte(0xc1);
+     emit_byte(0xe0+r);
+     emit_byte(i);
+ }
+ LENDFUNC(WRITE,NONE,2,raw_shll_w_ri,(RW2 r, IMM i))
+ 
+ LOWFUNC(WRITE,NONE,2,raw_shll_b_ri,(RW1 r, IMM i))
+ {
+     emit_byte(0xc0);
+     emit_byte(0xe0+r);
+     emit_byte(i);
+ }
+ LENDFUNC(WRITE,NONE,2,raw_shll_b_ri,(RW1 r, IMM i))
+ 
+ LOWFUNC(WRITE,NONE,2,raw_shrl_l_ri,(RW4 r, IMM i))
+ {
+     emit_byte(0xc1);
+     emit_byte(0xe8+r);
+     emit_byte(i);
+ }
+ LENDFUNC(WRITE,NONE,2,raw_shrl_l_ri,(RW4 r, IMM i))
+ 
+ LOWFUNC(WRITE,NONE,2,raw_shrl_w_ri,(RW2 r, IMM i))
+ {
+     emit_byte(0x66);
+     emit_byte(0xc1);
+     emit_byte(0xe8+r);
+     emit_byte(i);
+ }
+ LENDFUNC(WRITE,NONE,2,raw_shrl_w_ri,(RW2 r, IMM i))
+ 
+ LOWFUNC(WRITE,NONE,2,raw_shrl_b_ri,(RW1 r, IMM i))
+ {
+     emit_byte(0xc0);
+     emit_byte(0xe8+r);
+     emit_byte(i);
+ }
+ LENDFUNC(WRITE,NONE,2,raw_shrl_b_ri,(RW1 r, IMM i))
+ 
+ LOWFUNC(WRITE,NONE,2,raw_shra_l_ri,(RW4 r, IMM i))
+ {
+     emit_byte(0xc1);
+     emit_byte(0xf8+r);
+     emit_byte(i);
+ }
+ LENDFUNC(WRITE,NONE,2,raw_shra_l_ri,(RW4 r, IMM i))
+ 
+ LOWFUNC(WRITE,NONE,2,raw_shra_w_ri,(RW2 r, IMM i))
+ {
+     emit_byte(0x66);
+     emit_byte(0xc1);
+     emit_byte(0xf8+r);
+     emit_byte(i);
+ }
+ LENDFUNC(WRITE,NONE,2,raw_shra_w_ri,(RW2 r, IMM i))
+ 
+ LOWFUNC(WRITE,NONE,2,raw_shra_b_ri,(RW1 r, IMM i))
+ {
+     emit_byte(0xc0);
+     emit_byte(0xf8+r);
+     emit_byte(i);
+ }
+ LENDFUNC(WRITE,NONE,2,raw_shra_b_ri,(RW1 r, IMM i))
+ 
+ LOWFUNC(WRITE,NONE,1,raw_sahf,(R2 dummy_ah))
+ {
+     emit_byte(0x9e);
+ }
+ LENDFUNC(WRITE,NONE,1,raw_sahf,(R2 dummy_ah))
+ 
+ LOWFUNC(NONE,NONE,1,raw_cpuid,(R4 dummy_eax))
+ {
+     emit_byte(0x0f);
+     emit_byte(0xa2);
+ }
+ LENDFUNC(NONE,NONE,1,raw_cpuid,(R4 dummy_eax))
+ 
+ LOWFUNC(READ,NONE,1,raw_lahf,(W2 dummy_ah))
+ {
+     emit_byte(0x9f);
+ }
+ LENDFUNC(READ,NONE,1,raw_lahf,(W2 dummy_ah))
+ 
+ LOWFUNC(READ,NONE,2,raw_setcc,(W1 d, IMM cc))
+ {
+     emit_byte(0x0f);
+     emit_byte(0x90+cc);
+     emit_byte(0xc0+d);
+ }
+ LENDFUNC(READ,NONE,2,raw_setcc,(W1 d, IMM cc))
+ 
+ LOWFUNC(READ,WRITE,2,raw_setcc_m,(MEMW d, IMM cc))
+ {
+     emit_byte(0x0f);
+     emit_byte(0x90+cc);
+     emit_byte(0x05);
+     emit_long(d);
+ }
+ LENDFUNC(READ,WRITE,2,raw_setcc_m,(MEMW d, IMM cc))
+ 
+ LOWFUNC(READ,NONE,3,raw_cmov_l_rr,(RW4 d, R4 s, IMM cc))
+ {
+     if (have_cmov) {
+ 	emit_byte(0x0f);
+ 	emit_byte(0x40+cc);
+ 	emit_byte(0xc0+8*d+s);
+     }
+     else { /* replacement using branch and mov */
+ 	int uncc=(cc^1);
+ 	emit_byte(0x70+uncc); 
+ 	emit_byte(2);  /* skip next 2 bytes if not cc=true */
+ 	emit_byte(0x89);
+ 	emit_byte(0xc0+8*s+d);
+     }
+ }
+ LENDFUNC(READ,NONE,3,raw_cmov_l_rr,(RW4 d, R4 s, IMM cc))
+ 
+ LOWFUNC(WRITE,NONE,2,raw_bsf_l_rr,(W4 d, R4 s))
+ {
+     emit_byte(0x0f);
+     emit_byte(0xbc);
+     emit_byte(0xc0+8*d+s);
+ }
+ LENDFUNC(WRITE,NONE,2,raw_bsf_l_rr,(W4 d, R4 s))
+ 
+ LOWFUNC(NONE,NONE,2,raw_sign_extend_16_rr,(W4 d, R2 s))
+ {
+     emit_byte(0x0f);
+     emit_byte(0xbf);
+     emit_byte(0xc0+8*d+s);
+ }
+ LENDFUNC(NONE,NONE,2,raw_sign_extend_16_rr,(W4 d, R2 s))
+ 
+ LOWFUNC(NONE,NONE,2,raw_sign_extend_8_rr,(W4 d, R1 s))
+ {
+     emit_byte(0x0f);
+     emit_byte(0xbe);
+     emit_byte(0xc0+8*d+s);
+ }
+ LENDFUNC(NONE,NONE,2,raw_sign_extend_8_rr,(W4 d, R1 s))
+ 
+ LOWFUNC(NONE,NONE,2,raw_zero_extend_16_rr,(W4 d, R2 s))
+ {
+     emit_byte(0x0f);
+     emit_byte(0xb7);
+     emit_byte(0xc0+8*d+s);
+ }
+ LENDFUNC(NONE,NONE,2,raw_zero_extend_16_rr,(W4 d, R2 s))
+ 
+ LOWFUNC(NONE,NONE,2,raw_zero_extend_8_rr,(W4 d, R1 s))
+ {
+     emit_byte(0x0f);
+     emit_byte(0xb6);
+     emit_byte(0xc0+8*d+s);
+ }
+ LENDFUNC(NONE,NONE,2,raw_zero_extend_8_rr,(W4 d, R1 s))
+ 
+ LOWFUNC(NONE,NONE,2,raw_imul_32_32,(RW4 d, R4 s))
+ {
+     emit_byte(0x0f);
+     emit_byte(0xaf);
+     emit_byte(0xc0+8*d+s);
+ }
+ LENDFUNC(NONE,NONE,2,raw_imul_32_32,(RW4 d, R4 s))
+ 
+ LOWFUNC(NONE,NONE,2,raw_imul_64_32,(RW4 d, RW4 s))
+ {
+     if (d!=MUL_NREG1 || s!=MUL_NREG2)
+ 	abort();
+     emit_byte(0xf7);
+     emit_byte(0xea);
+ }
+ LENDFUNC(NONE,NONE,2,raw_imul_64_32,(RW4 d, RW4 s))
+ 
+ LOWFUNC(NONE,NONE,2,raw_mul_64_32,(RW4 d, RW4 s))
+ {
+     if (d!=MUL_NREG1 || s!=MUL_NREG2) {
+ 	printf("Bad register in MUL: d=%d, s=%d\n",d,s);
+ 	abort();
+     }
+     emit_byte(0xf7);
+     emit_byte(0xe2);
+ }
+ LENDFUNC(NONE,NONE,2,raw_mul_64_32,(RW4 d, RW4 s))
+ 
+ LOWFUNC(NONE,NONE,2,raw_mul_32_32,(RW4 d, R4 s))
+ {
+     abort(); /* %^$&%^$%#^ x86! */
+     emit_byte(0x0f);
+     emit_byte(0xaf);
+     emit_byte(0xc0+8*d+s);
+ }
+ LENDFUNC(NONE,NONE,2,raw_mul_32_32,(RW4 d, R4 s))
+ 
+ LOWFUNC(NONE,NONE,2,raw_mov_b_rr,(W1 d, R1 s))
+ {
+     emit_byte(0x88);
+     emit_byte(0xc0+8*s+d);
+ }
+ LENDFUNC(NONE,NONE,2,raw_mov_b_rr,(W1 d, R1 s))
+ 
+ LOWFUNC(NONE,NONE,2,raw_mov_w_rr,(W2 d, R2 s))
+ {
+     emit_byte(0x66);
+     emit_byte(0x89);
+     emit_byte(0xc0+8*s+d);
+ }
+ LENDFUNC(NONE,NONE,2,raw_mov_w_rr,(W2 d, R2 s))
+ 
+ LOWFUNC(NONE,READ,4,raw_mov_l_rrm_indexed,(W4 d,R4 baser, R4 index, IMM factor))
+ {
+     int isebp=(baser==5)?0x40:0;
+     int fi;
+     
+     switch(factor) {
+      case 1: fi=0; break;
+      case 2: fi=1; break;
+      case 4: fi=2; break;
+      case 8: fi=3; break;
+      default: abort();
+     }
+ 
+ 
+     emit_byte(0x8b);
+     emit_byte(0x04+8*d+isebp);
+     emit_byte(baser+8*index+0x40*fi);
+     if (isebp)
+ 	emit_byte(0x00);
+ }
+ LENDFUNC(NONE,READ,4,raw_mov_l_rrm_indexed,(W4 d,R4 baser, R4 index, IMM factor))
+ 
+ LOWFUNC(NONE,READ,4,raw_mov_w_rrm_indexed,(W2 d, R4 baser, R4 index, IMM factor))
+ {
+     int fi;
+     int isebp;
+     
+     switch(factor) {
+      case 1: fi=0; break;
+      case 2: fi=1; break;
+      case 4: fi=2; break;
+      case 8: fi=3; break;
+      default: abort();
+     }
+     isebp=(baser==5)?0x40:0;
+     
+     emit_byte(0x66);
+     emit_byte(0x8b);
+     emit_byte(0x04+8*d+isebp);
+     emit_byte(baser+8*index+0x40*fi);
+     if (isebp)
+ 	emit_byte(0x00);
+ }
+ LENDFUNC(NONE,READ,4,raw_mov_w_rrm_indexed,(W2 d, R4 baser, R4 index, IMM factor))
+ 
+ LOWFUNC(NONE,READ,4,raw_mov_b_rrm_indexed,(W1 d, R4 baser, R4 index, IMM factor))
+ {
+    int fi;
+   int isebp;
+ 
+   switch(factor) {
+   case 1: fi=0; break;
+   case 2: fi=1; break;
+   case 4: fi=2; break;
+   case 8: fi=3; break;
+   default: abort();
+   }
+   isebp=(baser==5)?0x40:0;
+ 
+    emit_byte(0x8a);
+     emit_byte(0x04+8*d+isebp);
+     emit_byte(baser+8*index+0x40*fi);
+     if (isebp)
+ 	emit_byte(0x00);
+ }
+ LENDFUNC(NONE,READ,4,raw_mov_b_rrm_indexed,(W1 d, R4 baser, R4 index, IMM factor))
+ 
+ LOWFUNC(NONE,WRITE,4,raw_mov_l_mrr_indexed,(R4 baser, R4 index, IMM factor, R4 s))
+ {
+   int fi;
+   int isebp;
+ 
+   switch(factor) {
+   case 1: fi=0; break;
+   case 2: fi=1; break;
+   case 4: fi=2; break;
+   case 8: fi=3; break;
+   default: abort();
+   }
+ 
+   
+   isebp=(baser==5)?0x40:0;
+ 
+     emit_byte(0x89);
+     emit_byte(0x04+8*s+isebp);
+     emit_byte(baser+8*index+0x40*fi);
+     if (isebp)
+ 	emit_byte(0x00);
+ }
+ LENDFUNC(NONE,WRITE,4,raw_mov_l_mrr_indexed,(R4 baser, R4 index, IMM factor, R4 s))
+ 
+ LOWFUNC(NONE,WRITE,4,raw_mov_w_mrr_indexed,(R4 baser, R4 index, IMM factor, R2 s))
+ {
+   int fi;
+   int isebp;
+ 
+   switch(factor) {
+   case 1: fi=0; break;
+   case 2: fi=1; break;
+   case 4: fi=2; break;
+   case 8: fi=3; break;
+   default: abort();
+   }
+   isebp=(baser==5)?0x40:0;
+ 
+     emit_byte(0x66);
+     emit_byte(0x89);
+     emit_byte(0x04+8*s+isebp);
+     emit_byte(baser+8*index+0x40*fi);
+     if (isebp)
+ 	emit_byte(0x00);
+ }
+ LENDFUNC(NONE,WRITE,4,raw_mov_w_mrr_indexed,(R4 baser, R4 index, IMM factor, R2 s))
+ 
+ LOWFUNC(NONE,WRITE,4,raw_mov_b_mrr_indexed,(R4 baser, R4 index, IMM factor, R1 s))
+ {
+   int fi;
+   int isebp;
+ 
+   switch(factor) {
+   case 1: fi=0; break;
+   case 2: fi=1; break;
+   case 4: fi=2; break;
+   case 8: fi=3; break;
+   default: abort();
+   }
+   isebp=(baser==5)?0x40:0;
+ 
+     emit_byte(0x88);
+     emit_byte(0x04+8*s+isebp);
+     emit_byte(baser+8*index+0x40*fi);
+     if (isebp)
+ 	emit_byte(0x00);
+ }
+ LENDFUNC(NONE,WRITE,4,raw_mov_b_mrr_indexed,(R4 baser, R4 index, IMM factor, R1 s))
+ 
+ LOWFUNC(NONE,WRITE,5,raw_mov_l_bmrr_indexed,(IMM base, R4 baser, R4 index, IMM factor, R4 s))
+ {
+   int fi;
+ 
+   switch(factor) {
+   case 1: fi=0; break;
+   case 2: fi=1; break;
+   case 4: fi=2; break;
+   case 8: fi=3; break;
+   default: abort();
+   }
+ 
+     emit_byte(0x89);
+     emit_byte(0x84+8*s);
+     emit_byte(baser+8*index+0x40*fi);
+     emit_long(base);
+ }
+ LENDFUNC(NONE,WRITE,5,raw_mov_l_bmrr_indexed,(IMM base, R4 baser, R4 index, IMM factor, R4 s))
+ 
+ LOWFUNC(NONE,WRITE,5,raw_mov_w_bmrr_indexed,(IMM base, R4 baser, R4 index, IMM factor, R2 s))
+ {
+   int fi;
+ 
+   switch(factor) {
+   case 1: fi=0; break;
+   case 2: fi=1; break;
+   case 4: fi=2; break;
+   case 8: fi=3; break;
+   default: abort();
+   }
+ 
+     emit_byte(0x66);
+     emit_byte(0x89);
+     emit_byte(0x84+8*s);
+     emit_byte(baser+8*index+0x40*fi);
+     emit_long(base);
+ }
+ LENDFUNC(NONE,WRITE,5,raw_mov_w_bmrr_indexed,(IMM base, R4 baser, R4 index, IMM factor, R2 s))
+ 
+ LOWFUNC(NONE,WRITE,5,raw_mov_b_bmrr_indexed,(IMM base, R4 baser, R4 index, IMM factor, R1 s))
+ {
+   int fi;
+ 
+   switch(factor) {
+   case 1: fi=0; break;
+   case 2: fi=1; break;
+   case 4: fi=2; break;
+   case 8: fi=3; break;
+   default: abort();
+   }
+ 
+     emit_byte(0x88);
+     emit_byte(0x84+8*s);
+     emit_byte(baser+8*index+0x40*fi);
+     emit_long(base);
+ }
+ LENDFUNC(NONE,WRITE,5,raw_mov_b_bmrr_indexed,(IMM base, R4 baser, R4 index, IMM factor, R1 s))
+ 
+ LOWFUNC(NONE,READ,5,raw_mov_l_brrm_indexed,(W4 d, IMM base, R4 baser, R4 index, IMM factor))
+ {
+   int fi;
+ 
+   switch(factor) {
+   case 1: fi=0; break;
+   case 2: fi=1; break;
+   case 4: fi=2; break;
+   case 8: fi=3; break;
+   default: abort();
+   }
+ 
+     emit_byte(0x8b);
+     emit_byte(0x84+8*d);
+     emit_byte(baser+8*index+0x40*fi);
+     emit_long(base);
+ }
+ LENDFUNC(NONE,READ,5,raw_mov_l_brrm_indexed,(W4 d, IMM base, R4 baser, R4 index, IMM factor))
+ 
+ LOWFUNC(NONE,READ,5,raw_mov_w_brrm_indexed,(W2 d, IMM base, R4 baser, R4 index, IMM factor))
+ {
+   int fi;
+ 
+   switch(factor) {
+   case 1: fi=0; break;
+   case 2: fi=1; break;
+   case 4: fi=2; break;
+   case 8: fi=3; break;
+   default: abort();
+   }
+ 
+     emit_byte(0x66);
+     emit_byte(0x8b);
+     emit_byte(0x84+8*d);
+     emit_byte(baser+8*index+0x40*fi);
+     emit_long(base);
+ }
+ LENDFUNC(NONE,READ,5,raw_mov_w_brrm_indexed,(W2 d, IMM base, R4 baser, R4 index, IMM factor))
+ 
+ LOWFUNC(NONE,READ,5,raw_mov_b_brrm_indexed,(W1 d, IMM base, R4 baser, R4 index, IMM factor))
+ {
+   int fi;
+ 
+   switch(factor) {
+   case 1: fi=0; break;
+   case 2: fi=1; break;
+   case 4: fi=2; break;
+   case 8: fi=3; break;
+   default: abort();
+   }
+ 
+     emit_byte(0x8a);
+     emit_byte(0x84+8*d);
+     emit_byte(baser+8*index+0x40*fi);
+     emit_long(base);
+ }
+ LENDFUNC(NONE,READ,5,raw_mov_b_brrm_indexed,(W1 d, IMM base, R4 baser, R4 index, IMM factor))
+ 
+ LOWFUNC(NONE,READ,4,raw_mov_l_rm_indexed,(W4 d, IMM base, R4 index, IMM factor))
+ {
+   int fi;
+   switch(factor) {
+   case 1: fi=0; break;
+   case 2: fi=1; break;
+   case 4: fi=2; break;
+   case 8: fi=3; break;
+   default: 
+     fprintf(stderr,"Bad factor %d in mov_l_rm_indexed!\n",factor);
+     abort();
+   }
+     emit_byte(0x8b);
+     emit_byte(0x04+8*d);
+     emit_byte(0x05+8*index+64*fi);
+     emit_long(base);
+ }
+ LENDFUNC(NONE,READ,4,raw_mov_l_rm_indexed,(W4 d, IMM base, R4 index, IMM factor))
+ 
+ LOWFUNC(NONE,READ,5,raw_cmov_l_rm_indexed,(W4 d, IMM base, R4 index, IMM factor, IMM cond))
+ {
+     int fi;
+     switch(factor) {
+      case 1: fi=0; break;
+      case 2: fi=1; break;
+      case 4: fi=2; break;
+      case 8: fi=3; break;
+      default: 
+ 	fprintf(stderr,"Bad factor %d in mov_l_rm_indexed!\n",factor);
+ 	abort();
+     }
+     if (have_cmov) {
+ 	emit_byte(0x0f);
+ 	emit_byte(0x40+cond);
+ 	emit_byte(0x04+8*d);
+ 	emit_byte(0x05+8*index+64*fi);
+ 	emit_long(base);
+     }
+     else { /* replacement using branch and mov */
+ 	int uncc=(cond^1);
+ 	emit_byte(0x70+uncc); 
+ 	emit_byte(7);  /* skip next 7 bytes if not cc=true */
+ 	emit_byte(0x8b);
+ 	emit_byte(0x04+8*d);
+ 	emit_byte(0x05+8*index+64*fi);
+ 	emit_long(base);
+     }
+ }
+ LENDFUNC(NONE,READ,5,raw_cmov_l_rm_indexed,(W4 d, IMM base, R4 index, IMM factor, IMM cond))
+ 
+ LOWFUNC(NONE,READ,3,raw_cmov_l_rm,(W4 d, IMM mem, IMM cond))
+ {
+     if (have_cmov) {
+ 	emit_byte(0x0f);
+ 	emit_byte(0x40+cond);
+ 	emit_byte(0x05+8*d);
+ 	emit_long(mem);
+     }
+     else { /* replacement using branch and mov */
+ 	int uncc=(cond^1);
+ 	emit_byte(0x70+uncc); 
+ 	emit_byte(6);  /* skip next 6 bytes if not cc=true */
+ 	emit_byte(0x8b);
+ 	emit_byte(0x05+8*d);
+ 	emit_long(mem);
+     }
+ }
+ LENDFUNC(NONE,READ,3,raw_cmov_l_rm,(W4 d, IMM mem, IMM cond))
+ 
+ LOWFUNC(NONE,READ,3,raw_mov_l_rR,(W4 d, R4 s, IMM offset))
+ {
+     emit_byte(0x8b);
+     emit_byte(0x40+8*d+s);
+     emit_byte(offset);
+ }
+ LENDFUNC(NONE,READ,3,raw_mov_l_rR,(W4 d, R4 s, IMM offset))
+ 
+ LOWFUNC(NONE,READ,3,raw_mov_w_rR,(W2 d, R4 s, IMM offset))
+ {
+     emit_byte(0x66);
+     emit_byte(0x8b);
+     emit_byte(0x40+8*d+s);
+     emit_byte(offset);
+ }
+ LENDFUNC(NONE,READ,3,raw_mov_w_rR,(W2 d, R4 s, IMM offset))
+ 
+ LOWFUNC(NONE,READ,3,raw_mov_b_rR,(W1 d, R4 s, IMM offset))
+ {
+     emit_byte(0x8a);
+     emit_byte(0x40+8*d+s);
+     emit_byte(offset);
+ }
+ LENDFUNC(NONE,READ,3,raw_mov_b_rR,(W1 d, R4 s, IMM offset))
+ 
+ LOWFUNC(NONE,READ,3,raw_mov_l_rR_gs,(W4 d, R4 s, IMM offset))
+ {
+     emit_byte(0x65);
+     emit_byte(0x8b);
+     emit_byte(0x40+8*d+s);
+     emit_byte(offset);
+ }
+ LENDFUNC(NONE,READ,3,raw_mov_l_rR_gs,(W4 d, R4 s, IMM offset))
+ 
+ LOWFUNC(NONE,READ,3,raw_mov_w_rR_gs,(W2 d, R4 s, IMM offset))
+ {
+     emit_byte(0x65);
+     emit_byte(0x66);
+     emit_byte(0x8b);
+     emit_byte(0x40+8*d+s);
+     emit_byte(offset);
+ }
+ LENDFUNC(NONE,READ,3,raw_mov_w_rR_gs,(W2 d, R4 s, IMM offset))
+ 
+ LOWFUNC(NONE,READ,3,raw_mov_b_rR_gs,(W1 d, R4 s, IMM offset))
+ {
+     emit_byte(0x65);
+     emit_byte(0x8a);
+     emit_byte(0x40+8*d+s);
+     emit_byte(offset);
+ }
+ LENDFUNC(NONE,READ,3,raw_mov_b_rR_gs,(W1 d, R4 s, IMM offset))
+ 
+ LOWFUNC(NONE,READ,3,raw_mov_l_brR,(W4 d, R4 s, IMM offset))
+ {
+     emit_byte(0x8b);
+     emit_byte(0x80+8*d+s);
+     emit_long(offset);
+ }
+ LENDFUNC(NONE,READ,3,raw_mov_l_brR,(W4 d, R4 s, IMM offset))
+ 
+ LOWFUNC(NONE,READ,3,raw_mov_w_brR,(W2 d, R4 s, IMM offset))
+ {
+     emit_byte(0x66);
+     emit_byte(0x8b);
+     emit_byte(0x80+8*d+s);
+     emit_long(offset);
+ }
+ LENDFUNC(NONE,READ,3,raw_mov_w_brR,(W2 d, R4 s, IMM offset))
+ 
+ LOWFUNC(NONE,READ,3,raw_mov_b_brR,(W1 d, R4 s, IMM offset))
+ {
+     emit_byte(0x8a);
+     emit_byte(0x80+8*d+s);
+     emit_long(offset);
+ }
+ LENDFUNC(NONE,READ,3,raw_mov_b_brR,(W1 d, R4 s, IMM offset))
+ 
+ LOWFUNC(NONE,READ,3,raw_mov_l_brR_gs,(W4 d, R4 s, IMM offset))
+ {
+     emit_byte(0x65);
+     emit_byte(0x8b);
+     emit_byte(0x80+8*d+s);
+     emit_long(offset);
+ }
+ LENDFUNC(NONE,READ,3,raw_mov_l_brR_gs,(W4 d, R4 s, IMM offset))
+ 
+ LOWFUNC(NONE,READ,3,raw_mov_w_brR_gs,(W2 d, R4 s, IMM offset))
+ {
+     emit_byte(0x65);
+     emit_byte(0x66);
+     emit_byte(0x8b);
+     emit_byte(0x80+8*d+s);
+     emit_long(offset);
+ }
+ LENDFUNC(NONE,READ,3,raw_mov_w_brR_gs,(W2 d, R4 s, IMM offset))
+ 
+ LOWFUNC(NONE,READ,3,raw_mov_b_brR_gs,(W1 d, R4 s, IMM offset))
+ {
+     emit_byte(0x65);
+     emit_byte(0x8a);
+     emit_byte(0x80+8*d+s);
+     emit_long(offset);
+ }
+ LENDFUNC(NONE,READ,3,raw_mov_b_brR_gs,(W1 d, R4 s, IMM offset))
+ 
+ LOWFUNC(NONE,WRITE,3,raw_mov_l_Ri,(R4 d, IMM i, IMM offset))
+ {
+     emit_byte(0xc7);
+     emit_byte(0x40+d);
+     emit_byte(offset);
+     emit_long(i);
+ }
+ LENDFUNC(NONE,WRITE,3,raw_mov_l_Ri,(R4 d, IMM i, IMM offset))
+ 
+ LOWFUNC(NONE,WRITE,3,raw_mov_w_Ri,(R4 d, IMM i, IMM offset))
+ {
+     emit_byte(0x66);
+     emit_byte(0xc7);
+     emit_byte(0x40+d);
+     emit_byte(offset);
+     emit_word(i);
+ }
+ LENDFUNC(NONE,WRITE,3,raw_mov_w_Ri,(R4 d, IMM i, IMM offset))
+ 
+ LOWFUNC(NONE,WRITE,3,raw_mov_b_Ri,(R4 d, IMM i, IMM offset))
+ {
+     emit_byte(0xc6);
+     emit_byte(0x40+d);
+     emit_byte(offset);
+     emit_byte(i);
+ }
+ LENDFUNC(NONE,WRITE,3,raw_mov_b_Ri,(R4 d, IMM i, IMM offset))
+ 
+ LOWFUNC(NONE,WRITE,3,raw_mov_l_Rr,(R4 d, R4 s, IMM offset))
+ {
+     emit_byte(0x89);
+     emit_byte(0x40+8*s+d);
+     emit_byte(offset);
+ }
+ LENDFUNC(NONE,WRITE,3,raw_mov_l_Rr,(R4 d, R4 s, IMM offset))
+ 
+ LOWFUNC(NONE,WRITE,3,raw_mov_w_Rr,(R4 d, R2 s, IMM offset))
+ {
+     emit_byte(0x66);
+     emit_byte(0x89);
+     emit_byte(0x40+8*s+d);
+     emit_byte(offset);
+ }
+ LENDFUNC(NONE,WRITE,3,raw_mov_w_Rr,(R4 d, R2 s, IMM offset))
+ 
+ LOWFUNC(NONE,WRITE,3,raw_mov_b_Rr,(R4 d, R1 s, IMM offset))
+ {
+     emit_byte(0x88);
+     emit_byte(0x40+8*s+d);
+     emit_byte(offset);
+ }
+ LENDFUNC(NONE,WRITE,3,raw_mov_b_Rr,(R4 d, R1 s, IMM offset))
+ 
+ LOWFUNC(NONE,WRITE,3,raw_mov_l_Rr_gs,(R4 d, R4 s, IMM offset))
+ {
+     emit_byte(0x65);
+     emit_byte(0x89);
+     emit_byte(0x40+8*s+d);
+     emit_byte(offset);
+ }
+ LENDFUNC(NONE,WRITE,3,raw_mov_l_Rr_gs,(R4 d, R4 s, IMM offset))
+ 
+ LOWFUNC(NONE,WRITE,3,raw_mov_w_Rr_gs,(R4 d, R2 s, IMM offset))
+ {
+     emit_byte(0x65);
+     emit_byte(0x66);
+     emit_byte(0x89);
+     emit_byte(0x40+8*s+d);
+     emit_byte(offset);
+ }
+ LENDFUNC(NONE,WRITE,3,raw_mov_w_Rr_gs,(R4 d, R2 s, IMM offset))
+ 
+ LOWFUNC(NONE,WRITE,3,raw_mov_b_Rr_gs,(R4 d, R1 s, IMM offset))
+ {
+     emit_byte(0x65);
+     emit_byte(0x88);
+     emit_byte(0x40+8*s+d);
+     emit_byte(offset);
+ }
+ LENDFUNC(NONE,WRITE,3,raw_mov_b_Rr_gs,(R4 d, R1 s, IMM offset))
+ 
+ LOWFUNC(NONE,NONE,3,raw_lea_l_brr,(W4 d, R4 s, IMM offset))
+ {
+     emit_byte(0x8d);
+     emit_byte(0x80+8*d+s);
+     emit_long(offset);
+ }
+ LENDFUNC(NONE,NONE,3,raw_lea_l_brr,(W4 d, R4 s, IMM offset))
+ 
+ LOWFUNC(NONE,NONE,5,raw_lea_l_brr_indexed,(W4 d, R4 s, R4 index, IMM factor, IMM offset))
+ {
+   int fi;
+   
+   switch(factor) {
+   case 1: fi=0; break;
+   case 2: fi=1; break;
+   case 4: fi=2; break;
+   case 8: fi=3; break;
+   default: abort();
+   }
+ 
+     emit_byte(0x8d);
+     emit_byte(0x84+8*d);
+     emit_byte(0x40*fi+8*index+s);
+     emit_long(offset);
+ }
+ LENDFUNC(NONE,NONE,5,raw_lea_l_brr_indexed,(W4 d, R4 s, R4 index, IMM factor, IMM offset))
+ 
+ LOWFUNC(NONE,NONE,4,raw_lea_l_rr_indexed,(W4 d, R4 s, R4 index, IMM factor))
+ {
+   int isebp=(s==5)?0x40:0;
+   int fi;
+   
+   switch(factor) {
+   case 1: fi=0; break;
+   case 2: fi=1; break;
+   case 4: fi=2; break;
+   case 8: fi=3; break;
+   default: abort();
+   }
+ 
+     emit_byte(0x8d);
+     emit_byte(0x04+8*d+isebp);
+     emit_byte(0x40*fi+8*index+s);
+     if (isebp)
+       emit_byte(0);
+ }
+ LENDFUNC(NONE,NONE,4,raw_lea_l_rr_indexed,(W4 d, R4 s, R4 index, IMM factor))
+ 
+ LOWFUNC(NONE,WRITE,3,raw_mov_l_bRr,(R4 d, R4 s, IMM offset))
+ {
+     emit_byte(0x89);
+     emit_byte(0x80+8*s+d);
+     emit_long(offset);
+ }
+ LENDFUNC(NONE,WRITE,3,raw_mov_l_bRr,(R4 d, R4 s, IMM offset))
+ 
+ LOWFUNC(NONE,WRITE,3,raw_mov_w_bRr,(R4 d, R2 s, IMM offset))
+ {
+     emit_byte(0x66);
+     emit_byte(0x89);
+     emit_byte(0x80+8*s+d);
+     emit_long(offset);
+ }
+ LENDFUNC(NONE,WRITE,3,raw_mov_w_bRr,(R4 d, R2 s, IMM offset))
+ 
+ LOWFUNC(NONE,WRITE,3,raw_mov_b_bRr,(R4 d, R1 s, IMM offset))
+ {
+     emit_byte(0x88);
+     emit_byte(0x80+8*s+d);
+     emit_long(offset);
+ }
+ LENDFUNC(NONE,WRITE,3,raw_mov_b_bRr,(R4 d, R1 s, IMM offset))
+ 
+ LOWFUNC(NONE,WRITE,3,raw_mov_l_bRr_gs,(R4 d, R4 s, IMM offset))
+ {
+     emit_byte(0x65);
+     emit_byte(0x89);
+     emit_byte(0x80+8*s+d);
+     emit_long(offset);
+ }
+ LENDFUNC(NONE,WRITE,3,raw_mov_l_bRr_gs,(R4 d, R4 s, IMM offset))
+ 
+ LOWFUNC(NONE,WRITE,3,raw_mov_w_bRr_gs,(R4 d, R2 s, IMM offset))
+ {
+     emit_byte(0x65);
+     emit_byte(0x66);
+     emit_byte(0x89);
+     emit_byte(0x80+8*s+d);
+     emit_long(offset);
+ }
+ LENDFUNC(NONE,WRITE,3,raw_mov_w_bRr_gs,(R4 d, R2 s, IMM offset))
+ 
+ LOWFUNC(NONE,WRITE,3,raw_mov_b_bRr_gs,(R4 d, R1 s, IMM offset))
+ {
+     emit_byte(0x65);
+     emit_byte(0x88);
+     emit_byte(0x80+8*s+d);
+     emit_long(offset);
+ }
+ LENDFUNC(NONE,WRITE,3,raw_mov_b_bRr_gs,(R4 d, R1 s, IMM offset))
+ 
+ LOWFUNC(NONE,NONE,1,raw_bswap_32,(RW4 r))
+ {
+     emit_byte(0x0f);
+     emit_byte(0xc8+r);
+ }
+ LENDFUNC(NONE,NONE,1,raw_bswap_32,(RW4 r))
+ 
+ LOWFUNC(WRITE,NONE,1,raw_bswap_16,(RW2 r))
+ {
+     emit_byte(0x66);
+     emit_byte(0xc1);
+     emit_byte(0xc0+r);
+     emit_byte(0x08);
+ }
+ LENDFUNC(WRITE,NONE,1,raw_bswap_16,(RW2 r))
+ 
+ LOWFUNC(NONE,NONE,2,raw_mov_l_rr,(W4 d, R4 s))
+ {
+     emit_byte(0x89);
+     emit_byte(0xc0+8*s+d);
+ }
+ LENDFUNC(NONE,NONE,2,raw_mov_l_rr,(W4 d, R4 s))
+ 
+ LOWFUNC(NONE,WRITE,2,raw_mov_l_mr,(IMM d, R4 s))
+ {
+     emit_byte(0x89);
+     emit_byte(0x05+8*s);
+     emit_long(d);
+ }
+ LENDFUNC(NONE,WRITE,2,raw_mov_l_mr,(IMM d, R4 s))
+ 
+ LOWFUNC(NONE,READ,2,raw_mov_l_rm,(W4 d, MEMR s))
+ {
+     emit_byte(0x8b);
+     emit_byte(0x05+8*d);
+     emit_long(s);
+ }
+ LENDFUNC(NONE,READ,2,raw_mov_l_rm,(W4 d, MEMR s))
+ 
+ LOWFUNC(NONE,WRITE,2,raw_mov_w_mr,(IMM d, R2 s))
+ {
+     emit_byte(0x66);
+     emit_byte(0x89);
+     emit_byte(0x05+8*s);
+     emit_long(d);
+ }
+ LENDFUNC(NONE,WRITE,2,raw_mov_w_mr,(IMM d, R2 s))
+ 
+ LOWFUNC(NONE,READ,2,raw_mov_w_rm,(W2 d, IMM s))
+ {
+     emit_byte(0x66);
+     emit_byte(0x8b);
+     emit_byte(0x05+8*d);
+     emit_long(s);
+ }
+ LENDFUNC(NONE,READ,2,raw_mov_w_rm,(W2 d, IMM s))
+ 
+ LOWFUNC(NONE,WRITE,2,raw_mov_b_mr,(IMM d, R1 s))
+ {
+     emit_byte(0x88);
+     emit_byte(0x05+8*s);
+     emit_long(d);
+ }
+ LENDFUNC(NONE,WRITE,2,raw_mov_b_mr,(IMM d, R1 s))
+ 
+ LOWFUNC(NONE,READ,2,raw_mov_b_rm,(W1 d, IMM s))
+ {
+     emit_byte(0x8a);
+     emit_byte(0x05+8*d);
+     emit_long(s);
+ }
+ LENDFUNC(NONE,READ,2,raw_mov_b_rm,(W1 d, IMM s))
+ 
+ LOWFUNC(NONE,NONE,2,raw_mov_l_ri,(W4 d, IMM s))
+ {
+     emit_byte(0xb8+d);
+     emit_long(s);
+ }
+ LENDFUNC(NONE,NONE,2,raw_mov_l_ri,(W4 d, IMM s))
+ 
+ LOWFUNC(NONE,NONE,2,raw_mov_w_ri,(W2 d, IMM s))
+ {
+     emit_byte(0x66);
+     emit_byte(0xb8+d);
+     emit_word(s);
+ }
+ LENDFUNC(NONE,NONE,2,raw_mov_w_ri,(W2 d, IMM s))
+ 
+ LOWFUNC(NONE,NONE,2,raw_mov_b_ri,(W1 d, IMM s))
+ {
+     emit_byte(0xb0+d);
+     emit_byte(s);
+ }
+ LENDFUNC(NONE,NONE,2,raw_mov_b_ri,(W1 d, IMM s))
+ 
+ LOWFUNC(RMW,RMW,2,raw_adc_l_mi,(MEMRW d, IMM s))
+ {
+     emit_byte(0x81);
+     emit_byte(0x15);
+     emit_long(d);
+     emit_long(s);
+ }
+ LENDFUNC(RMW,RMW,2,raw_adc_l_mi,(MEMRW d, IMM s))
+ 
+ LOWFUNC(WRITE,RMW,2,raw_add_l_mi,(IMM d, IMM s)) 
+ {
+     emit_byte(0x81);
+     emit_byte(0x05);
+     emit_long(d);
+     emit_long(s);
+ }
+ LENDFUNC(WRITE,RMW,2,raw_add_l_mi,(IMM d, IMM s)) 
+ 
+ LOWFUNC(WRITE,RMW,2,raw_add_w_mi,(IMM d, IMM s)) 
+ {
+     emit_byte(0x66);
+     emit_byte(0x81);
+     emit_byte(0x05);
+     emit_long(d);
+     emit_word(s);
+ }
+ LENDFUNC(WRITE,RMW,2,raw_add_w_mi,(IMM d, IMM s)) 
+ 
+ LOWFUNC(WRITE,RMW,2,raw_add_b_mi,(IMM d, IMM s)) 
+ {
+     emit_byte(0x80);
+     emit_byte(0x05);
+     emit_long(d);
+     emit_byte(s);
+ }
+ LENDFUNC(WRITE,RMW,2,raw_add_b_mi,(IMM d, IMM s)) 
+ 
+ LOWFUNC(WRITE,NONE,2,raw_test_l_ri,(R4 d, IMM i))
+ {
+     emit_byte(0xf7);
+     emit_byte(0xc0+d);
+     emit_long(i);
+ }
+ LENDFUNC(WRITE,NONE,2,raw_test_l_ri,(R4 d, IMM i))
+ 
+ LOWFUNC(WRITE,NONE,2,raw_test_l_rr,(R4 d, R4 s))
+ {
+     emit_byte(0x85);
+     emit_byte(0xc0+8*s+d);
+ }
+ LENDFUNC(WRITE,NONE,2,raw_test_l_rr,(R4 d, R4 s))
+ 
+ LOWFUNC(WRITE,NONE,2,raw_test_w_rr,(R2 d, R2 s))
+ {
+     emit_byte(0x66);
+     emit_byte(0x85);
+     emit_byte(0xc0+8*s+d);
+ }
+ LENDFUNC(WRITE,NONE,2,raw_test_w_rr,(R2 d, R2 s))
+ 
+ LOWFUNC(WRITE,NONE,2,raw_test_b_rr,(R1 d, R1 s))
+ {
+     emit_byte(0x84);
+     emit_byte(0xc0+8*s+d);
+ }
+ LENDFUNC(WRITE,NONE,2,raw_test_b_rr,(R1 d, R1 s))
+ 
+ LOWFUNC(WRITE,NONE,2,raw_and_l_ri,(RW4 d, IMM i))
+ {
+     emit_byte(0x81);
+     emit_byte(0xe0+d);
+     emit_long(i);
+ }
+ LENDFUNC(WRITE,NONE,2,raw_and_l_ri,(RW4 d, IMM i))
+ 
+ LOWFUNC(WRITE,NONE,2,raw_and_w_ri,(RW2 d, IMM i))
+ {
+     emit_byte(0x66);
+     emit_byte(0x81);
+     emit_byte(0xe0+d);
+     emit_word(i);
+ }
+ LENDFUNC(WRITE,NONE,2,raw_and_w_ri,(RW2 d, IMM i))
+ 
+ LOWFUNC(WRITE,NONE,2,raw_and_l,(RW4 d, R4 s))
+ {
+     emit_byte(0x21);
+     emit_byte(0xc0+8*s+d);
+ }
+ LENDFUNC(WRITE,NONE,2,raw_and_l,(RW4 d, R4 s))
+ 
+ LOWFUNC(WRITE,NONE,2,raw_and_w,(RW2 d, R2 s))
+ {
+     emit_byte(0x66);
+     emit_byte(0x21);
+     emit_byte(0xc0+8*s+d);
+ }
+ LENDFUNC(WRITE,NONE,2,raw_and_w,(RW2 d, R2 s))
+ 
+ LOWFUNC(WRITE,NONE,2,raw_and_b,(RW1 d, R1 s))
+ {
+     emit_byte(0x20);
+     emit_byte(0xc0+8*s+d);
+ }
+ LENDFUNC(WRITE,NONE,2,raw_and_b,(RW1 d, R1 s))
+ 
+ LOWFUNC(WRITE,NONE,2,raw_or_l_ri,(RW4 d, IMM i))
+ {
+     emit_byte(0x81);
+     emit_byte(0xc8+d);
+     emit_long(i);
+ }
+ LENDFUNC(WRITE,NONE,2,raw_or_l_ri,(RW4 d, IMM i))
+ 
+ LOWFUNC(WRITE,NONE,2,raw_or_l,(RW4 d, R4 s))
+ {
+     emit_byte(0x09);
+     emit_byte(0xc0+8*s+d);
+ }
+ LENDFUNC(WRITE,NONE,2,raw_or_l,(RW4 d, R4 s))
+ 
+ LOWFUNC(WRITE,NONE,2,raw_or_w,(RW2 d, R2 s))
+ {
+     emit_byte(0x66);
+     emit_byte(0x09);
+     emit_byte(0xc0+8*s+d);
+ }
+ LENDFUNC(WRITE,NONE,2,raw_or_w,(RW2 d, R2 s))
+ 
+ LOWFUNC(WRITE,NONE,2,raw_or_b,(RW1 d, R1 s))
+ {
+     emit_byte(0x08);
+     emit_byte(0xc0+8*s+d);
+ }
+ LENDFUNC(WRITE,NONE,2,raw_or_b,(RW1 d, R1 s))
+ 
+ LOWFUNC(RMW,NONE,2,raw_adc_l,(RW4 d, R4 s))
+ {
+     emit_byte(0x11);
+     emit_byte(0xc0+8*s+d);
+ }
+ LENDFUNC(RMW,NONE,2,raw_adc_l,(RW4 d, R4 s))
+ 
+ LOWFUNC(RMW,NONE,2,raw_adc_w,(RW2 d, R2 s))
+ {
+     emit_byte(0x66);
+     emit_byte(0x11);
+     emit_byte(0xc0+8*s+d);
+ }
+ LENDFUNC(RMW,NONE,2,raw_adc_w,(RW2 d, R2 s))
+ 
+ LOWFUNC(RMW,NONE,2,raw_adc_b,(RW1 d, R1 s))
+ {
+     emit_byte(0x10);
+     emit_byte(0xc0+8*s+d);
+ }
+ LENDFUNC(RMW,NONE,2,raw_adc_b,(RW1 d, R1 s))
+ 
+ LOWFUNC(WRITE,NONE,2,raw_add_l,(RW4 d, R4 s))
+ {
+     emit_byte(0x01);
+     emit_byte(0xc0+8*s+d);
+ }
+ LENDFUNC(WRITE,NONE,2,raw_add_l,(RW4 d, R4 s))
+ 
+ LOWFUNC(WRITE,NONE,2,raw_add_w,(RW2 d, R2 s))
+ {
+     emit_byte(0x66);
+     emit_byte(0x01);
+     emit_byte(0xc0+8*s+d);
+ }
+ LENDFUNC(WRITE,NONE,2,raw_add_w,(RW2 d, R2 s))
+ 
+ LOWFUNC(WRITE,NONE,2,raw_add_b,(RW1 d, R1 s))
+ {
+     emit_byte(0x00);
+     emit_byte(0xc0+8*s+d);
+ }
+ LENDFUNC(WRITE,NONE,2,raw_add_b,(RW1 d, R1 s))
+ 
+ LOWFUNC(WRITE,NONE,2,raw_sub_l_ri,(RW4 d, IMM i))
+ {
+   if (isbyte(i)) {
+     emit_byte(0x83);
+     emit_byte(0xe8+d);
+     emit_byte(i);
+   }
+   else {
+     emit_byte(0x81);
+     emit_byte(0xe8+d);
+     emit_long(i);
+   }
+ }
+ LENDFUNC(WRITE,NONE,2,raw_sub_l_ri,(RW4 d, IMM i))
+ 
+ LOWFUNC(WRITE,NONE,2,raw_sub_b_ri,(RW1 d, IMM i))
+ {
+     emit_byte(0x80);
+     emit_byte(0xe8+d);
+     emit_byte(i);
+ }
+ LENDFUNC(WRITE,NONE,2,raw_sub_b_ri,(RW1 d, IMM i))
+ 
+ LOWFUNC(WRITE,NONE,2,raw_add_l_ri,(RW4 d, IMM i))
+ {
+     if (isbyte(i)) {
+ 	emit_byte(0x83);
+ 	emit_byte(0xc0+d);
+ 	emit_byte(i);
+     }
+     else {
+ 	emit_byte(0x81);
+ 	emit_byte(0xc0+d);
+ 	emit_long(i);
+     }
+ }
+ LENDFUNC(WRITE,NONE,2,raw_add_l_ri,(RW4 d, IMM i))
+ 
+ LOWFUNC(WRITE,NONE,2,raw_add_w_ri,(RW2 d, IMM i))
+ {
+     if (isbyte(i)) {
+ 	emit_byte(0x66);
+ 	emit_byte(0x83);
+ 	emit_byte(0xc0+d);
+ 	emit_byte(i);
+     }
+     else {
+ 	emit_byte(0x66);
+ 	emit_byte(0x81);
+ 	emit_byte(0xc0+d);
+ 	emit_word(i);
+     }
+ }
+ LENDFUNC(WRITE,NONE,2,raw_add_w_ri,(RW2 d, IMM i))
+ 
+ LOWFUNC(WRITE,NONE,2,raw_add_b_ri,(RW1 d, IMM i))
+ {
+     emit_byte(0x80);
+     emit_byte(0xc0+d);
+     emit_byte(i);
+ }
+ LENDFUNC(WRITE,NONE,2,raw_add_b_ri,(RW1 d, IMM i))
+ 
+ LOWFUNC(RMW,NONE,2,raw_sbb_l,(RW4 d, R4 s))
+ {
+     emit_byte(0x19);
+     emit_byte(0xc0+8*s+d);
+ }
+ LENDFUNC(RMW,NONE,2,raw_sbb_l,(RW4 d, R4 s))
+ 
+ LOWFUNC(RMW,NONE,2,raw_sbb_w,(RW2 d, R2 s))
+ {
+     emit_byte(0x66);
+     emit_byte(0x19);
+     emit_byte(0xc0+8*s+d);
+ }
+ LENDFUNC(RMW,NONE,2,raw_sbb_w,(RW2 d, R2 s))
+ 
+ LOWFUNC(RMW,NONE,2,raw_sbb_b,(RW1 d, R1 s))
+ {
+     emit_byte(0x18);
+     emit_byte(0xc0+8*s+d);
+ }
+ LENDFUNC(RMW,NONE,2,raw_sbb_b,(RW1 d, R1 s))
+ 
+ LOWFUNC(WRITE,NONE,2,raw_sub_l,(RW4 d, R4 s))
+ {
+     emit_byte(0x29);
+     emit_byte(0xc0+8*s+d);
+ }
+ LENDFUNC(WRITE,NONE,2,raw_sub_l,(RW4 d, R4 s))
+ 
+ LOWFUNC(WRITE,NONE,2,raw_sub_w,(RW2 d, R2 s))
+ {
+     emit_byte(0x66);
+     emit_byte(0x29);
+     emit_byte(0xc0+8*s+d);
+ }
+ LENDFUNC(WRITE,NONE,2,raw_sub_w,(RW2 d, R2 s))
+ 
+ LOWFUNC(WRITE,NONE,2,raw_sub_b,(RW1 d, R1 s))
+ {
+     emit_byte(0x28);
+     emit_byte(0xc0+8*s+d);
+ }
+ LENDFUNC(WRITE,NONE,2,raw_sub_b,(RW1 d, R1 s))
+ 
+ LOWFUNC(WRITE,NONE,2,raw_cmp_l,(R4 d, R4 s))
+ {
+     emit_byte(0x39);
+     emit_byte(0xc0+8*s+d);
+ }
+ LENDFUNC(WRITE,NONE,2,raw_cmp_l,(R4 d, R4 s))
+ 
+ LOWFUNC(WRITE,NONE,2,raw_cmp_l_ri,(R4 r, IMM i))
+ {
+     emit_byte(0x81);
+     emit_byte(0xf8+r);
+     emit_long(i);
+ }
+ LENDFUNC(WRITE,NONE,2,raw_cmp_l_ri,(R4 r, IMM i))
+ 
+ LOWFUNC(WRITE,NONE,2,raw_cmp_w,(R2 d, R2 s))
+ {
+     emit_byte(0x66);
+     emit_byte(0x39);
+     emit_byte(0xc0+8*s+d);
+ }
+ LENDFUNC(WRITE,NONE,2,raw_cmp_w,(R2 d, R2 s))
+ 
+ LOWFUNC(WRITE,NONE,2,raw_cmp_b_ri,(R1 d, IMM i))
+ {
+   emit_byte(0x80);
+   emit_byte(0xf8+d);
+   emit_byte(i);
+ }
+ LENDFUNC(WRITE,NONE,2,raw_cmp_b_ri,(R1 d, IMM i))
+ 
+ LOWFUNC(WRITE,NONE,2,raw_cmp_b,(R1 d, R1 s))
+ {
+     emit_byte(0x38);
+     emit_byte(0xc0+8*s+d);
+ }
+ LENDFUNC(WRITE,NONE,2,raw_cmp_b,(R1 d, R1 s))
+ 
+ LOWFUNC(WRITE,READ,4,raw_cmp_l_rm_indexed,(R4 d, IMM offset, R4 index, IMM factor))
+ {
+     int fi;
+     
+     switch(factor) {
+      case 1: fi=0; break;
+      case 2: fi=1; break;
+      case 4: fi=2; break;
+      case 8: fi=3; break;
+      default: abort();
+     }
+     emit_byte(0x39);
+     emit_byte(0x04+8*d);
+     emit_byte(5+8*index+0x40*fi);
+     emit_long(offset);
+ }
+ LENDFUNC(WRITE,READ,4,raw_cmp_l_rm_indexed,(R4 d, IMM offset, R4 index, IMM factor))
+ 
+ LOWFUNC(WRITE,NONE,2,raw_xor_l,(RW4 d, R4 s))
+ {
+     emit_byte(0x31);
+     emit_byte(0xc0+8*s+d);
+ }
+ LENDFUNC(WRITE,NONE,2,raw_xor_l,(RW4 d, R4 s))
+ 
+ LOWFUNC(WRITE,NONE,2,raw_xor_w,(RW2 d, R2 s))
+ {
+     emit_byte(0x66);
+     emit_byte(0x31);
+     emit_byte(0xc0+8*s+d);
+ }
+ LENDFUNC(WRITE,NONE,2,raw_xor_w,(RW2 d, R2 s))
+ 
+ LOWFUNC(WRITE,NONE,2,raw_xor_b,(RW1 d, R1 s))
+ {
+     emit_byte(0x30);
+     emit_byte(0xc0+8*s+d);
+ }
+ LENDFUNC(WRITE,NONE,2,raw_xor_b,(RW1 d, R1 s))
+ 
+ LOWFUNC(WRITE,RMW,2,raw_sub_l_mi,(MEMRW d, IMM s))
+ {
+     emit_byte(0x81);
+     emit_byte(0x2d);
+     emit_long(d);
+     emit_long(s);
+ }
+ LENDFUNC(WRITE,RMW,2,raw_sub_l_mi,(MEMRW d, IMM s))
+ 
+ LOWFUNC(WRITE,READ,2,raw_cmp_l_mi,(MEMR d, IMM s))
+ {
+     emit_byte(0x81);
+     emit_byte(0x3d);
+     emit_long(d);
+     emit_long(s);
+ }
+ LENDFUNC(WRITE,READ,2,raw_cmp_l_mi,(MEMR d, IMM s))
+ 
+ LOWFUNC(NONE,NONE,2,raw_xchg_l_rr,(RW4 r1, RW4 r2))
+ {
+   emit_byte(0x87);
+   emit_byte(0xc0+8*r1+r2);
+ }
+ LENDFUNC(NONE,NONE,2,raw_xchg_l_rr,(RW4 r1, RW4 r2))
+ 
+ 
+ /*************************************************************************
+  * Unoptimizable stuff --- jump                                          *
+  *************************************************************************/
+ 
+ static __inline__ void raw_call_r(R4 r)
+ {
+     lopt_emit_all();
+     emit_byte(0xff);
+     emit_byte(0xd0+r);
+ }
+ 
+ static __inline__ void raw_jmp_r(R4 r)
+ {
+     lopt_emit_all();
+     emit_byte(0xff);
+     emit_byte(0xe0+r);
+ }
+ 
+ static __inline__ void raw_jmp_m_indexed(uae_u32 base, uae_u32 r, uae_u32 m)
+ {
+     int mu;
+     switch(m) {
+      case 1: mu=0; break;
+      case 2: mu=1; break;
+      case 4: mu=2; break;
+      case 8: mu=3; break;
+      default: abort();
+     }
+     lopt_emit_all();
+     emit_byte(0xff);
+     emit_byte(0x24);
+     emit_byte(0x05+8*r+0x40*mu);
+     emit_long(base);
+ }
+ 
+ static __inline__ void raw_jmp_m(uae_u32 base)
+ {
+     lopt_emit_all();
+     emit_byte(0xff);
+     emit_byte(0x25);
+     emit_long(base);
+ }
+ 
+ 
+ static __inline__ void raw_call(uae_u32 t)
+ {
+     lopt_emit_all();
+     emit_byte(0xe8);
+     emit_long(t-(uae_u32)target-4);
+ }
+ 
+ static __inline__ void raw_jmp(uae_u32 t)
+ {
+     lopt_emit_all();
+     emit_byte(0xe9);
+     emit_long(t-(uae_u32)target-4);
+ }
+ 
+ static __inline__ void raw_jl(uae_u32 t)
+ {
+     lopt_emit_all();
+     emit_byte(0x0f);
+     emit_byte(0x8c);
+     emit_long(t-(uae_u32)target-4);
+ }
+ 
+ static __inline__ void raw_jz(uae_u32 t)
+ {
+     lopt_emit_all();
+     emit_byte(0x0f);
+     emit_byte(0x84);
+     emit_long(t-(uae_u32)target-4);
+ }
+ 
+ static __inline__ void raw_jnz(uae_u32 t)
+ {
+     lopt_emit_all();
+     emit_byte(0x0f);
+     emit_byte(0x85);
+     emit_long(t-(uae_u32)target-4);
+ }
+ 
+ static __inline__ void raw_jnz_l_oponly(void)
+ {
+     lopt_emit_all();
+     emit_byte(0x0f); 
+     emit_byte(0x85); 
+ }
+ 
+ static __inline__ void raw_jcc_l_oponly(int cc)
+ {
+     lopt_emit_all();
+     emit_byte(0x0f); 
+     emit_byte(0x80+cc); 
+ }
+ 
+ static __inline__ void raw_jnz_b_oponly(void)
+ {
+     lopt_emit_all();
+     emit_byte(0x75); 
+ }
+ 
+ static __inline__ void raw_jz_b_oponly(void)
+ {
+     lopt_emit_all();
+     emit_byte(0x74); 
+ }
+ 
+ static __inline__ void raw_jmp_l_oponly(void)
+ {
+     lopt_emit_all();
+     emit_byte(0xe9); 
+ }
+ 
+ static __inline__ void raw_jmp_b_oponly(void)
+ {
+     lopt_emit_all();
+     emit_byte(0xeb); 
+ }
+ 
+ static __inline__ void raw_ret(void)
+ {
+     lopt_emit_all();
+     emit_byte(0xc3);  
+ }
+ 
+ static __inline__ void raw_nop(void)
+ {
+     lopt_emit_all();
+     emit_byte(0x90);
+ }
+ 
+ 
+ /*************************************************************************
+  * Flag handling, to and fro UAE flag register                           *
+  *************************************************************************/
+ 
+ 
+ #define FLAG_NREG1 0  /* Set to -1 if any register will do */
+ 
+ static __inline__ void raw_flags_to_reg(int r)
+ {
+   raw_lahf(0);  /* Most flags in AH */
+   //raw_setcc(r,0); /* V flag in AL */
+   raw_setcc_m((uae_u32)live.state[FLAGTMP].mem,0); 
+   
+ #if 1   /* Let's avoid those nasty partial register stalls */
+   //raw_mov_b_mr((uae_u32)live.state[FLAGTMP].mem,r);
+   raw_mov_b_mr(((uae_u32)live.state[FLAGTMP].mem)+1,r+4);
+   //live.state[FLAGTMP].status=CLEAN;
+   live.state[FLAGTMP].status=INMEM;
+   live.state[FLAGTMP].realreg=-1;
+   /* We just "evicted" FLAGTMP. */
+   if (live.nat[r].nholds!=1) {
+       /* Huh? */
+       abort();
+   }
+   live.nat[r].nholds=0;
+ #endif
+ }
+ 
+ #define FLAG_NREG2 0  /* Set to -1 if any register will do */
+ static __inline__ void raw_reg_to_flags(int r)
+ {
+   raw_cmp_b_ri(r,-127); /* set V */
+   raw_sahf(0);
+ }
+ 
+ /* Apparently, there are enough instructions between flag store and
+    flag reload to avoid the partial memory stall */
+ static __inline__ void raw_load_flagreg(uae_u32 target, uae_u32 r)
+ {
+ #if 1
+     raw_mov_l_rm(target,(uae_u32)live.state[r].mem);
+ #else
+     raw_mov_b_rm(target,(uae_u32)live.state[r].mem);
+     raw_mov_b_rm(target+4,((uae_u32)live.state[r].mem)+1);
+ #endif
+ }
+ 
+ /* FLAGX is byte sized, and we *do* write it at that size */
+ static __inline__ void raw_load_flagx(uae_u32 target, uae_u32 r)
+ {
+     if (live.nat[target].canbyte)
+ 	raw_mov_b_rm(target,(uae_u32)live.state[r].mem);
+     else if (live.nat[target].canword)
+ 	raw_mov_w_rm(target,(uae_u32)live.state[r].mem);
+     else
+ 	raw_mov_l_rm(target,(uae_u32)live.state[r].mem);
+ }
+ 
+ 
+ static __inline__ void raw_inc_sp(int off)
+ {
+     raw_add_l_ri(4,off);
+ }
+ 
+ /*************************************************************************
+  * Handling mistaken direct memory access                                *
+  *************************************************************************/
+ 
+ #ifdef NATMEM_OFFSET
+ # ifdef _WIN32 // %%% BRIAN KING WAS HERE %%%
+ #  include <winbase.h>
+ # else
+ #  ifndef __USE_GNU
+ #   define __USE_GNU
+ #  endif
+ #  include <sys/ucontext.h>
+ # endif
+ # include <signal.h>
+ 
+ #define SIG_READ 1
+ #define SIG_WRITE 2
+ 
+ static int in_handler=0;
+ static uae_u8 veccode[256];
+ 
+ #ifdef _WIN32
+ int EvalException ( LPEXCEPTION_POINTERS blah, int n_except )
+ {
+     PEXCEPTION_RECORD pExceptRecord = NULL;
+     PCONTEXT          pContext = NULL;
+ 
+     uae_u8* i = NULL;
+     uae_u32 addr = 0;
+     int r=-1;
+     int size=4;
+     int dir=-1;
+     int len=0;
+     int j;
+ 
+     write_log( "EvalException!\n" );
+ 
+     if( n_except != STATUS_ACCESS_VIOLATION )
+         return EXCEPTION_CONTINUE_SEARCH;
+ 
+     pExceptRecord = blah->ExceptionRecord;
+     pContext = blah->ContextRecord;
+ 
+     if( pContext )
+     {
+ 	i = (uae_u8 *)(pContext->Eip);
+     }
+     if( pExceptRecord )
+     {
+ 	addr = (uae_u32)(pExceptRecord->ExceptionInformation[1]);
+     }
+ 
+     write_log("fault address is 0x%x at 0x%x\n",addr,i);
+     if (!canbang || !currprefs.cachesize) 
+     {
+ 	write_log("Not happy! Canbang or cachesize is 0 in SIGSEGV handler!\n");
+ 	return EXCEPTION_CONTINUE_SEARCH;
+     }
+ 
+     if (in_handler) 
+ 	write_log("Argh --- Am already in a handler. Shouldn't happen!\n");
+     
+     if (canbang && i>=compiled_code && i<=current_compile_p) {
+ 	if (*i==0x66) {
+ 	    i++;
+ 	    size=2;
+ 	    len++;
+ 	}
+ 	
+ 	switch(i[0]) {
+ 	case 0x8a:
+ 	    if ((i[1]&0xc0)==0x80) {
+ 		r=(i[1]>>3)&7;
+ 		dir=SIG_READ;
+ 		size=1;
+ 		len+=6;
+ 		break;
+ 	    }
+ 	    break;
+ 	case 0x88:
+ 	    if ((i[1]&0xc0)==0x80) {
+ 		r=(i[1]>>3)&7;
+ 		dir=SIG_WRITE;
+ 		size=1;
+ 		len+=6;
+ 		break;
+ 	    }
+ 	    break;
+ 	case 0x8b:
+ 	    switch(i[1]&0xc0) {
+ 	    case 0x80:
+ 		r=(i[1]>>3)&7;
+ 		dir=SIG_READ;
+ 		len+=6;
+ 		break;
+ 	    case 0x40:
+ 		r=(i[1]>>3)&7;
+ 		dir=SIG_READ;
+ 		len+=3;
+ 		break;
+ 	    case 0x00:
+ 		r=(i[1]>>3)&7;
+ 		dir=SIG_READ;
+ 		len+=2;
+ 		break;
+ 	    default: 
+ 		break;
+ 	    }
+ 	    break;
+ 	    case 0x89:
+ 		switch(i[1]&0xc0) {
+ 		case 0x80:
+ 		    r=(i[1]>>3)&7;
+ 		    dir=SIG_WRITE;
+ 		    len+=6;
+ 		    break;
+ 		case 0x40:
+ 		    r=(i[1]>>3)&7;
+ 		    dir=SIG_WRITE;
+ 		    len+=3;
+ 		    break;
+ 		case 0x00:
+ 		    r=(i[1]>>3)&7;
+ 		    dir=SIG_WRITE;
+ 		    len+=2;
+ 		    break;
+ 		}
+ 		break;
+ 	}	
+     }
+     
+     if (r!=-1) { 
+ 	void* pr=NULL;
+ 	write_log("register was %d, direction was %d, size was %d\n",r,dir,size);
+ 	
+ 	switch(r) {
+ 	case 0: pr=&(pContext->Eax); break;
+ 	case 1: pr=&(pContext->Ecx); break;
+ 	case 2: pr=&(pContext->Edx); break;
+ 	case 3: pr=&(pContext->Ebx); break;
+ 	case 4: pr=(size>1)?NULL:(((uae_u8*)&(pContext->Eax))+1); break;
+ 	case 5: pr=(size>1)?
+ 		    (void*)(&(pContext->Ebp)):
+ 	    (void*)(((uae_u8*)&(pContext->Ecx))+1); break;
+ 	case 6: pr=(size>1)?
+ 		    (void*)(&(pContext->Esi)):
+ 	    (void*)(((uae_u8*)&(pContext->Edx))+1); break;
+ 	case 7: pr=(size>1)?
+ 		    (void*)(&(pContext->Edi)):
+ 	    (void*)(((uae_u8*)&(pContext->Ebx))+1); break;
+ 	default: abort();
+ 	}
+ 	if (pr) {
+ 	    blockinfo* bi;
+ 	    
+ 	    if (currprefs.comp_oldsegv) {
+ 		addr-=GS_NATMEM_OFFSET;
+ 		
+ 		if ((addr>=0x10000000 && addr<0x40000000) ||
+ 		    (addr>=0x50000000)) {
+ 		    write_log("Suspicious address 0x%x in SEGV handler.\n",addr);
+ 		}
+ 		if (dir==SIG_READ) {
+ 		    switch(size) {
+ 		    case 1: *((uae_u8*)pr)=get_byte(addr); break;
+ 		    case 2: *((uae_u16*)pr)=swap16(get_word(addr)); break;
+ 		    case 4: *((uae_u32*)pr)=swap32(get_long(addr)); break;
+ 		    default: abort();
+ 		    }
+ 		}
+ 		else { /* write */
+ 		    switch(size) {
+ 		    case 1: put_byte(addr,*((uae_u8*)pr)); break;
+ 		    case 2: put_word(addr,swap16(*((uae_u16*)pr))); break;
+ 		    case 4: put_long(addr,swap32(*((uae_u32*)pr))); break;
+ 		    default: abort();
+ 		    }
+ 		}
+ 		write_log("Handled one access!\n");
+ 		fflush(stdout);
+ 		segvcount++;
+ 		pContext->Eip+=len;
+ 	    }
+ 	    else {
+ 		void* tmp=target;
+ 		int i;
+ 		uae_u8 vecbuf[5];
+ 		
+ 		addr-=GS_NATMEM_OFFSET;
+ 		
+ 		if ((addr>=0x10000000 && addr<0x40000000) ||
+ 		    (addr>=0x50000000)) {
+ 		    write_log("Suspicious address 0x%x in SEGV handler.\n",addr);
+ 		}
+ 		
+ 		target=(uae_u8*)pContext->Eip;
+ 		for (i=0;i<5;i++)
+ 		    vecbuf[i]=target[i];
+ 		emit_byte(0xe9);
+ 		emit_long((uae_u32)veccode-(uae_u32)target-4);
+ 		write_log("Create jump to %p\n",veccode);
+ 		
+ 		write_log("Handled one access!\n");
+ 		segvcount++;
+ 		
+ 		target=veccode;
+ 		
+ 		if (dir==SIG_READ) {
+ 		    switch(size) {
+ 		    case 1: raw_mov_b_ri(r,get_byte(addr)); break;
+ 		    case 2: raw_mov_w_ri(r,swap16(get_word(addr))); break;
+ 		    case 4: raw_mov_l_ri(r,swap32(get_long(addr))); break;
+ 		    default: abort();
+ 		    }
+ 		}
+ 		else { /* write */
+ 		    switch(size) {
+ 		    case 1: put_byte(addr,*((uae_u8*)pr)); break;
+ 		    case 2: put_word(addr,swap16(*((uae_u16*)pr))); break;
+ 		    case 4: put_long(addr,swap32(*((uae_u32*)pr))); break;
+ 		    default: abort();
+ 		    }
+ 		}
+ 		for (i=0;i<5;i++)
+ 		    raw_mov_b_mi(pContext->Eip+i,vecbuf[i]);
+ 		raw_mov_l_mi((uae_u32)&in_handler,0);
+ 		emit_byte(0xe9);
+ 		emit_long(pContext->Eip+len-(uae_u32)target-4);
+ 		in_handler=1;
+ 		target=tmp;
+ 	    }
+ 	    bi=active;
+ 	    while (bi) {
+ 		if (bi->handler && 
+ 		    (uae_u8*)bi->direct_handler<=i &&
+ 		    (uae_u8*)bi->nexthandler>i) {
+ 		    write_log("deleted trigger (%p<%p<%p) %p\n",
+ 			bi->handler,
+ 			i,
+ 			bi->nexthandler,
+ 			bi->pc_p);
+ 		    invalidate_block(bi);
+ 		    raise_in_cl_list(bi);
+ 		    set_special(0);
+ 		    return EXCEPTION_CONTINUE_EXECUTION;
+ 		}
+ 		bi=bi->next;
+ 	    }
+ 	    /* Not found in the active list. Might be a rom routine that
+ 	    is in the dormant list */
+ 	    bi=dormant;
+ 	    while (bi) {
+ 		if (bi->handler && 
+ 		    (uae_u8*)bi->direct_handler<=i &&
+ 		    (uae_u8*)bi->nexthandler>i) {
+ 		    write_log("deleted trigger (%p<%p<%p) %p\n",
+ 			bi->handler,
+ 			i,
+ 			bi->nexthandler,
+ 			bi->pc_p);
+ 		    invalidate_block(bi);
+ 		    raise_in_cl_list(bi);
+ 		    set_special(0);
+ 		    return EXCEPTION_CONTINUE_EXECUTION;
+ 		}
+ 		bi=bi->next;
+ 	    }
+ 	    write_log("Huh? Could not find trigger!\n");
+ 	    return EXCEPTION_CONTINUE_EXECUTION;
+ 	}
+     }
+     write_log("Can't handle access!\n");
+     if (i) {
+ 	for (j=0;j<10;j++) {
+ 	    write_log("instruction byte %2d is 0x%02x\n",j,i[j]);
+ 	}
+     }
+ #if 0
+     write_log("Please send the above info (starting at \"fault address\") to\n"
+ 	   "bmeyer@csse.monash.edu.au\n"
+ 	   "This shouldn't happen ;-)\n");
+ #endif
+     return EXCEPTION_CONTINUE_SEARCH;
+ }
+ #else
+ 
+ static void segfault_vec (int x, struct sigcontext sc);
+ 
+ static void vec(int x, siginfo_t * info, void *other)
+ {
+ 	struct sigcontext sc;
+ 	memcpy(&sc, (char *) other + 4*6, 13*4);
+     sc.cr2 = (uae_u32 *) info->si_addr;
+ 	segfault_vec(x, sc);
+ }
+ 
+ static void segfault_vec (int x, struct sigcontext sc)
+ {
+     uae_u8 *i = (uae_u8*)sc.eip;
+     uae_u32 addr=sc.cr2;
+     int r = -1;
+     int size = 4;
+     int dir = -1;
+     int len = 1;
+     int j;
+     
+     write_log("fault address is %08x at %08x\n",sc.cr2,sc.eip);
+     if (!canbang) 
+ 	write_log("Not happy! Canbang is 0 in SIGSEGV handler!\n");
+     if (in_handler) 
+ 	write_log("Argh --- Am already in a handler. Shouldn't happen!\n");
+ 
+     if (canbang && i>=compiled_code && i<=current_compile_p) {
+ 	if (*i++ != 0x65)
+ 	    goto oh_dear;
+ 
+ 	if (*i == 0x66) {
+ 	    i++;
+ 	    size=2;
+ 	    len++;
+ 	}
+ 	
+ 	switch(i[0]) {
+ 	case 0x8a:
+ 	    if ((i[1]&0xc0)==0x80) {
+ 		r=(i[1]>>3)&7;
+ 		dir=SIG_READ;
+ 		size=1;
+ 		len+=6;
+ 		break;
+ 	    }
+ 	    break;
+ 	case 0x88:
+ 	    if ((i[1]&0xc0)==0x80) {
+ 		r=(i[1]>>3)&7;
+ 		dir=SIG_WRITE;
+ 		size=1;
+ 		len+=6;
+ 		break;
+ 	    }
+ 	    break;
+ 
+ 	case 0x8b:
+ 	    switch(i[1]&0xc0) {
+ 	    case 0x80:
+ 		r=(i[1]>>3)&7;
+ 		dir=SIG_READ;
+ 		len+=6;
+ 		break;
+ 	    case 0x40:
+ 		r=(i[1]>>3)&7;
+ 		dir=SIG_READ;
+ 		len+=3;
+ 		break;
+ 	    case 0x00:
+ 		r=(i[1]>>3)&7;
+ 		dir=SIG_READ;
+ 		len+=2;
+ 		break;
+ 	    default: 
+ 		break;
+ 	    }
+ 	    break;
+ 	    
+ 	case 0x89:
+ 	    switch(i[1]&0xc0) {
+ 	    case 0x80:
+ 		r=(i[1]>>3)&7;
+ 		dir=SIG_WRITE;
+ 		len+=6;
+ 		break;
+ 	    case 0x40:
+ 		r=(i[1]>>3)&7;
+ 		dir=SIG_WRITE;
+ 		len+=3;
+ 		break;
+ 	    case 0x00:
+ 		r=(i[1]>>3)&7;
+ 		dir=SIG_WRITE;
+ 		len+=2;
+ 		break;
+ 	    }
+ 	    break;
+ 	}	
+     }
+ 
+     if (r!=-1) { 
+ 	void* pr=NULL;
+ 	write_log("register was %d, direction was %d, size was %d\n",r,dir,size);
+ 	
+ 	switch(r) {
+ 	case 0: pr=&(sc.eax); break;
+ 	case 1: pr=&(sc.ecx); break;
+ 	case 2: pr=&(sc.edx); break;
+ 	case 3: pr=&(sc.ebx); break;
+ 	case 4: pr=(size>1)?NULL:(((uae_u8*)&(sc.eax))+1); break;
+ 	case 5: pr=(size>1)?
+ 		    (void*)(&(sc.ebp)):
+ 			(void*)(((uae_u8*)&(sc.ecx))+1); break;
+ 	case 6: pr=(size>1)?
+ 		    (void*)(&(sc.esi)):
+ 			(void*)(((uae_u8*)&(sc.edx))+1); break;
+ 	case 7: pr=(size>1)?
+ 		    (void*)(&(sc.edi)):
+ 			(void*)(((uae_u8*)&(sc.ebx))+1); break;
+ 	default: abort();
+ 	}
+ 	if (pr) {
+ 	    blockinfo* bi;
+ 
+ 	    if (currprefs.comp_oldsegv) {
+ 		addr-=GS_NATMEM_OFFSET;
+ 		
+ 		if ((addr>=0x10000000 && addr<0x40000000) ||
+ 		    (addr>=0x50000000)) {
+ 		    write_log("Suspicious address in %x SEGV handler.\n",addr);
+ 		}
+ 		if (dir==SIG_READ) {
+ 		    switch(size) {
+ 		    case 1: *((uae_u8*)pr)=get_byte(addr); break;
+ 		    case 2: *((uae_u16*)pr)=get_word(addr); break;
+ 		    case 4: *((uae_u32*)pr)=get_long(addr); break;
+ 		    default: abort();
+ 		    }
+ 		}
+ 		else { /* write */
+ 		    switch(size) {
+ 		    case 1: put_byte(addr,*((uae_u8*)pr)); break;
+ 		    case 2: put_word(addr,*((uae_u16*)pr)); break;
+ 		    case 4: put_long(addr,*((uae_u32*)pr)); break;
+ 		    default: abort();
+ 		    }
+ 		}
+ 		write_log("Handled one access!\n");
+ 		fflush(stdout);
+ 		segvcount++;
+ 		sc.eip+=len;
+ 	    }
+ 	    else {
+ 		void* tmp=target;
+ 		int i;
+ 		uae_u8 vecbuf[5];
+ 		
+ 		addr-=GS_NATMEM_OFFSET;
+ 		
+ 		if ((addr>=0x10000000 && addr<0x40000000) ||
+ 		    (addr>=0x50000000)) {
+ 		    write_log("Suspicious address 0x%x in SEGV handler.\n",addr);
+ 		}
+ 		
+ 		target=(uae_u8*)sc.eip;
+ 		for (i=0;i<5;i++)
+ 		    vecbuf[i]=target[i];
+ 		emit_byte(0xe9);
+ 		emit_long((uae_u32)veccode-(uae_u32)target-4);
+ 		write_log("Create jump to %p\n",veccode);
+ 
+ 		write_log("Handled one access!\n");
+ 		fflush(stdout);
+ 		segvcount++;
+ 		
+ 		target=veccode;
+ 
+ 		if (dir==SIG_READ) {
+ 		    switch(size) {
+ 		    case 1: raw_mov_b_ri(r,get_byte(addr)); break;
+ 		    case 2: raw_mov_w_ri(r,get_word(addr)); break;
+ 		    case 4: raw_mov_l_ri(r,get_long(addr)); break;
+ 		    default: abort();
+ 		    }
+ 		}
+ 		else { /* write */
+ 		    switch(size) {
+ 		    case 1: put_byte(addr,*((uae_u8*)pr)); break;
+ 		    case 2: put_word(addr,*((uae_u16*)pr)); break;
+ 		    case 4: put_long(addr,*((uae_u32*)pr)); break;
+ 		    default: abort();
+ 		    }
+ 		}
+ 		for (i=0;i<5;i++)
+ 		    raw_mov_b_mi(sc.eip+i,vecbuf[i]);
+ 		raw_mov_l_mi((uae_u32)&in_handler,0);
+ 		emit_byte(0xe9);
+ 		emit_long(sc.eip+len-(uae_u32)target-4);
+ 		in_handler=1;
+ 		target=tmp;
+ 	    }
+ 	    bi=active;
+ 	    while (bi) {
+ 		if (bi->handler && 
+ 		    (uae_u8*)bi->direct_handler<=i &&
+ 		    (uae_u8*)bi->nexthandler>i) {
+ 		    write_log("deleted trigger (%p<%p<%p) %p\n",
+ 			      bi->handler,
+ 			      i,
+ 			      bi->nexthandler,
+ 			      bi->pc_p);
+ 		    invalidate_block(bi);
+ 		    raise_in_cl_list(bi);
+ 		    set_special(0);
+ 		    return;
+ 		}
+ 		bi=bi->next;
+ 	    }
+ 	    /* Not found in the active list. Might be a rom routine that
+ 	       is in the dormant list */
+ 	    bi=dormant;
+ 	    while (bi) {
+ 		if (bi->handler && 
+ 		    (uae_u8*)bi->direct_handler<=i &&
+ 		    (uae_u8*)bi->nexthandler>i) {
+ 		    write_log("deleted trigger (%p<%p<%p) %p\n",
+ 			      bi->handler,
+ 			      i,
+ 			      bi->nexthandler,
+ 			      bi->pc_p);
+ 		    invalidate_block(bi);
+ 		    raise_in_cl_list(bi);
+ 		    set_special(0);
+ 		    return;
+ 		}
+ 		bi=bi->next;
+ 	    }
+ 	    write_log("Huh? Could not find trigger!\n");
+ 	    return;
+ 	}
+     }
+   oh_dear:
+     write_log ("Can't handle access!\n");
+     if (sc.eip >= compiled_code && sc.eip + 12 <= current_compile_p)
+ 	for (j = 0; j < 12; j++) {
+ 	    write_log ("instruction byte %2d is %02x\n", j, ((uae_u8 *)sc.eip)[j]);
+ 	}
+ #if 0
+     write_log("Please send the above info (starting at \"fault address\") to\n"
+ 	      "bmeyer@csse.monash.edu.au\n"
+ 	      "This shouldn't happen ;-)\n");
+     fflush(stdout);
+ #endif
+     signal (SIGSEGV, SIG_DFL);  /* returning here will cause a "real" SEGV */
+ }
+ #endif
+ #endif
+ 
+ /*************************************************************************
+  * Checking for CPU features                                             *
+  *************************************************************************/
+ 
+ typedef struct {
+     uae_u32 eax;
+     uae_u32 ecx;
+     uae_u32 edx;
+     uae_u32 ebx;
+ } x86_regs;
+ 
+ 
+ /* This could be so much easier if it could make assumptions about the
+    compiler... */
+ 
+ static uae_u8 cpuid_space[256];   
+ static uae_u32 cpuid_ptr;
+ static uae_u32 cpuid_level;
+ 
+ static x86_regs cpuid(uae_u32 level)
+ {
+     x86_regs answer;
+     void* tmp=get_target();
+ 
+     cpuid_ptr=(uae_u32)&answer;
+     cpuid_level=level;
+ 
+     set_target(cpuid_space);
+     raw_push_l_r(0); /* eax */
+     raw_push_l_r(1); /* ecx */
+     raw_push_l_r(2); /* edx */
+     raw_push_l_r(3); /* ebx */
+     raw_push_l_r(7); /* edi */
+     raw_mov_l_rm(0,(uae_u32)&cpuid_level);
+     raw_cpuid(0);
+     raw_mov_l_rm(7,(uae_u32)&cpuid_ptr);
+     raw_mov_l_Rr(7,0,0);
+     raw_mov_l_Rr(7,1,4);
+     raw_mov_l_Rr(7,2,8);
+     raw_mov_l_Rr(7,3,12);
+     raw_pop_l_r(7);
+     raw_pop_l_r(3);
+     raw_pop_l_r(2);
+     raw_pop_l_r(1);
+     raw_pop_l_r(0);
+     raw_ret();
+     set_target(tmp);
+ 
+     ((cpuop_func*)cpuid_space)(0);
+     return answer;
+ }
+ 
+ static void raw_init_cpu(void)
+ {
+     x86_regs x;
+     uae_u32 maxlev;
+     
+     x=cpuid(0);
+     maxlev=x.eax;
+     write_log("Max CPUID level=%d Processor is %c%c%c%c%c%c%c%c%c%c%c%c\n",
+ 	      maxlev,
+ 	      x.ebx,
+ 	      x.ebx>>8,
+ 	      x.ebx>>16,
+ 	      x.ebx>>24,
+ 	      x.edx,
+ 	      x.edx>>8,
+ 	      x.edx>>16,
+ 	      x.edx>>24,
+ 	      x.ecx,
+ 	      x.ecx>>8,
+ 	      x.ecx>>16,
+ 	      x.ecx>>24
+ 	      );
+     have_rat_stall=(x.ecx==0x6c65746e);
+ 
+     if (maxlev>=1) {
+ 	x=cpuid(1);
+ 	if (x.edx&(1<<15)) 
+ 	    have_cmov=1;
+     }
+     if (!have_cmov)
+ 	have_rat_stall=0;
+ #if 0
+     write_log ("have_cmov=%d, avoid_cmov=%d, have_rat_stall=%d\n",
+ 	       have_cmov,currprefs.avoid_cmov,have_rat_stall);
+     if (currprefs.avoid_cmov) {
+ 	write_log("Disabling cmov use despite processor claiming to support it!\n");
+ 	have_cmov=0;
+     }
+ #else
+     /* Dear Bernie, I don't want to keep around options which are useless, and not
+        represented in the GUI anymore... Is this okay? */
+     write_log ("have_cmov=%d, have_rat_stall=%d\n", have_cmov, have_rat_stall);
+ #endif
+ #if 0   /* For testing of non-cmov code! */
+     have_cmov=0;
+ #endif
+ #if 1 /* It appears that partial register writes are a bad idea even on
+ 	 AMD K7 cores, even though they are not supposed to have the
+ 	 dreaded rat stall. Why? Anyway, that's why we lie about it ;-) */
+     if (have_cmov)
+       have_rat_stall=1;
+ #endif
+ }
+ 
+ /*************************************************************************
+  * FPU stuff                                                             *
+  *************************************************************************/
+ 
+ 
+ static __inline__ void raw_fp_init(void)
+ {
+     int i;
+     
+     for (i=0;i<N_FREGS;i++)
+ 	live.spos[i]=-2;
+     live.tos=-1;  /* Stack is empty */
+ }
+ 
+ static __inline__ void raw_fp_cleanup_drop(void)
+ {
+ #if 0
+     /* using FINIT instead of popping all the entries.
+        Seems to have side effects --- there is display corruption in
+        Quake when this is used */
+     if (live.tos>1) {
+ 	emit_byte(0x9b);
+ 	emit_byte(0xdb);
+ 	emit_byte(0xe3);
+ 	live.tos=-1;
+     }
+ #endif
+     while (live.tos>=1) {
+ 	emit_byte(0xde);
+ 	emit_byte(0xd9);
+ 	live.tos-=2;
+     }
+     while (live.tos>=0) {
+ 	emit_byte(0xdd);
+ 	emit_byte(0xd8);
+ 	live.tos--;
+     }
+     raw_fp_init();
+ }
+ 
+ static __inline__ void make_tos(int r)
+ {
+     int p,q;
+ 
+     if (live.spos[r]<0) { /* Register not yet on stack */
+ 	emit_byte(0xd9);
+ 	emit_byte(0xe8);  /* Push '1' on the stack, just to grow it */
+ 	live.tos++;
+ 	live.spos[r]=live.tos;
+ 	live.onstack[live.tos]=r;
+ 	return;
+     }
+     /* Register is on stack */
+     if (live.tos==live.spos[r])
+ 	return;
+     p=live.spos[r];
+     q=live.onstack[live.tos];
+ 
+     emit_byte(0xd9);
+     emit_byte(0xc8+live.tos-live.spos[r]);  /* exchange it with top of stack */
+     live.onstack[live.tos]=r;
+     live.spos[r]=live.tos;
+     live.onstack[p]=q;
+     live.spos[q]=p;
+ }
+ 
+ static __inline__ void make_tos2(int r, int r2)
+ {
+     int q;
+ 
+     make_tos(r2); /* Put the reg that's supposed to end up in position2
+ 		     on top */
+ 
+     if (live.spos[r]<0) { /* Register not yet on stack */
+ 	make_tos(r); /* This will extend the stack */
+ 	return;
+     }
+     /* Register is on stack */
+     emit_byte(0xd9);
+     emit_byte(0xc9); /* Move r2 into position 2 */
+ 
+     q=live.onstack[live.tos-1];
+     live.onstack[live.tos]=q;
+     live.spos[q]=live.tos;
+     live.onstack[live.tos-1]=r2;
+     live.spos[r2]=live.tos-1;
+ 
+     make_tos(r); /* And r into 1 */
+ }
+ 
+ static __inline__ int stackpos(int r)
+ {
+     if (live.spos[r]<0)
+ 	abort();
+     if (live.tos<live.spos[r]) {
+ 	printf("Looking for spos for fnreg %d\n",r);
+ 	abort();
+     }
+     return live.tos-live.spos[r];
+ }
+ 
+ static __inline__ void usereg(int r)
+ {
+     if (live.spos[r]<0)
+ 	make_tos(r);
+ }
+ 
+ /* This is called with one FP value in a reg *above* tos, which it will
+    pop off the stack if necessary */
+ static __inline__ void tos_make(int r)
+ {
+     if (live.spos[r]<0) {
+ 	live.tos++;
+ 	live.spos[r]=live.tos;
+ 	live.onstack[live.tos]=r;
+ 	return;
+     }
+     emit_byte(0xdd);
+     emit_byte(0xd8+(live.tos+1)-live.spos[r]);  /* store top of stack in reg, 
+ 					 and pop it*/
+ }
+     
+ 	
+ LOWFUNC(NONE,WRITE,2,raw_fmov_mr,(MEMW m, FR r))
+ {
+     make_tos(r);
+     emit_byte(0xdd);
+     emit_byte(0x15);
+     emit_long(m);
+ }
+ LENDFUNC(NONE,WRITE,2,raw_fmov_mr,(MEMW m, FR r))
+ 
+ LOWFUNC(NONE,WRITE,2,raw_fmov_mr_drop,(MEMW m, FR r))
+ {
+     make_tos(r);
+     emit_byte(0xdd);
+     emit_byte(0x1d);
+     emit_long(m);
+     live.onstack[live.tos]=-1;
+     live.tos--;
+     live.spos[r]=-2;
+ }
+ LENDFUNC(NONE,WRITE,2,raw_fmov_mr,(MEMW m, FR r))
+ 
+ LOWFUNC(NONE,READ,2,raw_fmov_rm,(FW r, MEMR m))
+ {
+     emit_byte(0xdd);
+     emit_byte(0x05);
+     emit_long(m);
+     tos_make(r);
+ }
+ LENDFUNC(NONE,READ,2,raw_fmov_rm,(FW r, MEMR m))
+ 
+ LOWFUNC(NONE,READ,2,raw_fmovi_rm,(FW r, MEMR m))
+ {
+     emit_byte(0xdb);
+     emit_byte(0x05);
+     emit_long(m);
+     tos_make(r);
+ }
+ LENDFUNC(NONE,READ,2,raw_fmovi_rm,(FW r, MEMR m))
+ 
+ LOWFUNC(NONE,WRITE,2,raw_fmovi_mr,(MEMW m, FR r))
+ {
+     make_tos(r);
+     emit_byte(0xdb);
+     emit_byte(0x15);
+     emit_long(m);
+ }
+ LENDFUNC(NONE,WRITE,2,raw_fmovi_mr,(MEMW m, FR r))
+ 
+ LOWFUNC(NONE,READ,2,raw_fmovs_rm,(FW r, MEMR m))
+ {
+     emit_byte(0xd9);
+     emit_byte(0x05);
+     emit_long(m);
+     tos_make(r);
+ }
+ LENDFUNC(NONE,READ,2,raw_fmovs_rm,(FW r, MEMR m))
+ 
+ LOWFUNC(NONE,WRITE,2,raw_fmovs_mr,(MEMW m, FR r))
+ {
+     make_tos(r);
+     emit_byte(0xd9);
+     emit_byte(0x15);
+     emit_long(m);
+ }
+ LENDFUNC(NONE,WRITE,2,raw_fmovs_mr,(MEMW m, FR r))
+ 
+ LOWFUNC(NONE,WRITE,2,raw_fmov_ext_mr,(MEMW m, FR r))
+ {
+     int rs;
+ 
+     /* Stupid x87 can't write a long double to mem without popping the 
+        stack! */
+     usereg(r);
+     rs=stackpos(r);
+     emit_byte(0xd9);     /* Get a copy to the top of stack */
+     emit_byte(0xc0+rs);
+ 
+     emit_byte(0xdb);  /* store and pop it */
+     emit_byte(0x3d);
+     emit_long(m);
+ }
+ LENDFUNC(NONE,WRITE,2,raw_fmov_ext_mr,(MEMW m, FR r))
+ 
+ LOWFUNC(NONE,WRITE,2,raw_fmov_ext_mr_drop,(MEMW m, FR r))
+ {
+     int rs;
+ 
+     make_tos(r);
+     emit_byte(0xdb);  /* store and pop it */
+     emit_byte(0x3d);
+     emit_long(m);
+     live.onstack[live.tos]=-1;
+     live.tos--;
+     live.spos[r]=-2;
+ }
+ LENDFUNC(NONE,WRITE,2,raw_fmov_ext_mr,(MEMW m, FR r))
+ 
+ LOWFUNC(NONE,READ,2,raw_fmov_ext_rm,(FW r, MEMR m))
+ {
+     emit_byte(0xdb);
+     emit_byte(0x2d);
+     emit_long(m);
+     tos_make(r);
+ }
+ LENDFUNC(NONE,READ,2,raw_fmov_ext_rm,(FW r, MEMR m))
+ 
+ LOWFUNC(NONE,NONE,1,raw_fmov_pi,(FW r))
+ {
+     emit_byte(0xd9);
+     emit_byte(0xeb);
+     tos_make(r);
+ }
+ LENDFUNC(NONE,NONE,1,raw_fmov_pi,(FW r))
+ 
+ LOWFUNC(NONE,NONE,1,raw_fmov_log10_2,(FW r))
+ {
+     emit_byte(0xd9);
+     emit_byte(0xec);
+     tos_make(r);
+ }
+ LENDFUNC(NONE,NONE,1,raw_fmov_log10_2,(FW r))
+ 
+ LOWFUNC(NONE,NONE,1,raw_fmov_log2_e,(FW r))
+ {
+     emit_byte(0xd9);
+     emit_byte(0xea);
+     tos_make(r);
+ }
+ LENDFUNC(NONE,NONE,1,raw_fmov_log2_e,(FW r))
+ 
+ LOWFUNC(NONE,NONE,1,raw_fmov_loge_2,(FW r))
+ {
+     emit_byte(0xd9);
+     emit_byte(0xed);
+     tos_make(r);
+ }
+ LENDFUNC(NONE,NONE,1,raw_fmov_loge_2,(FW r))
+ 
+ LOWFUNC(NONE,NONE,1,raw_fmov_1,(FW r))
+ {
+     emit_byte(0xd9);
+     emit_byte(0xe8);
+     tos_make(r);
+ }
+ LENDFUNC(NONE,NONE,1,raw_fmov_1,(FW r))
+ 
+ LOWFUNC(NONE,NONE,1,raw_fmov_0,(FW r))
+ {
+     emit_byte(0xd9);
+     emit_byte(0xee);
+     tos_make(r);
+ }
+ LENDFUNC(NONE,NONE,1,raw_fmov_0,(FW r))
+ 
+ LOWFUNC(NONE,NONE,2,raw_fmov_rr,(FW d, FR s))
+ {
+     int ds;
+ 
+     usereg(s);
+     ds=stackpos(s);
+     if (ds==0 && live.spos[d]>=0) {
+ 	/* source is on top of stack, and we already have the dest */
+ 	int dd=stackpos(d);
+ 	emit_byte(0xdd);
+ 	emit_byte(0xd0+dd);
+     }
+     else {
+ 	emit_byte(0xd9);
+ 	emit_byte(0xc0+ds); /* duplicate source on tos */
+ 	tos_make(d); /* store to destination, pop if necessary */
+     }
+ }
+ LENDFUNC(NONE,NONE,2,raw_fmov_rr,(FW d, FR s))
+ 
+ LOWFUNC(NONE,READ,4,raw_fldcw_m_indexed,(R4 index, IMM base))
+ {
+     emit_byte(0xd9);
+     emit_byte(0xa8+index);
+     emit_long(base);
+ }
+ LENDFUNC(NONE,READ,4,raw_fldcw_m_indexed,(R4 index, IMM base))
+ 
+ 
+ LOWFUNC(NONE,NONE,2,raw_fsqrt_rr,(FW d, FR s))
+ {
+     int ds;
+ 
+     if (d!=s) {
+ 	usereg(s);
+ 	ds=stackpos(s);
+ 	emit_byte(0xd9);
+ 	emit_byte(0xc0+ds); /* duplicate source */
+ 	emit_byte(0xd9);
+ 	emit_byte(0xfa); /* take square root */
+ 	tos_make(d); /* store to destination */
+     }
+     else {
+ 	make_tos(d);
+ 	emit_byte(0xd9);
+ 	emit_byte(0xfa); /* take square root */
+     }	
+ }
+ LENDFUNC(NONE,NONE,2,raw_fsqrt_rr,(FW d, FR s))
+ 
+ LOWFUNC(NONE,NONE,2,raw_fabs_rr,(FW d, FR s))
+ {
+     int ds;
+ 
+     if (d!=s) {
+ 	usereg(s);
+ 	ds=stackpos(s);
+ 	emit_byte(0xd9);
+ 	emit_byte(0xc0+ds); /* duplicate source */
+ 	emit_byte(0xd9);
+ 	emit_byte(0xe1); /* take fabs */
+ 	tos_make(d); /* store to destination */
+     }
+     else {
+ 	make_tos(d);
+ 	emit_byte(0xd9);
+ 	emit_byte(0xe1); /* take fabs */
+     }	
+ }
+ LENDFUNC(NONE,NONE,2,raw_fabs_rr,(FW d, FR s))
+ 
+ LOWFUNC(NONE,NONE,2,raw_frndint_rr,(FW d, FR s))
+ {
+     int ds;
+ 
+     if (d!=s) {
+ 	usereg(s);
+ 	ds=stackpos(s);
+ 	emit_byte(0xd9);
+ 	emit_byte(0xc0+ds); /* duplicate source */
+ 	emit_byte(0xd9);
+ 	emit_byte(0xfc); /* take frndint */
+ 	tos_make(d); /* store to destination */
+     }
+     else {
+ 	make_tos(d);
+ 	emit_byte(0xd9);
+ 	emit_byte(0xfc); /* take frndint */
+     }	
+ }
+ LENDFUNC(NONE,NONE,2,raw_frndint_rr,(FW d, FR s))
+ 
+ LOWFUNC(NONE,NONE,2,raw_fcos_rr,(FW d, FR s))
+ {
+     int ds;
+ 
+     if (d!=s) {
+ 	usereg(s);
+ 	ds=stackpos(s);
+ 	emit_byte(0xd9);
+ 	emit_byte(0xc0+ds); /* duplicate source */
+ 	emit_byte(0xd9);
+ 	emit_byte(0xff); /* take cos */
+ 	tos_make(d); /* store to destination */
+     }
+     else {
+ 	make_tos(d);
+ 	emit_byte(0xd9);
+ 	emit_byte(0xff); /* take cos */
+     }	
+ }
+ LENDFUNC(NONE,NONE,2,raw_fcos_rr,(FW d, FR s))
+ 
+ LOWFUNC(NONE,NONE,2,raw_fsin_rr,(FW d, FR s))
+ {
+     int ds;
+ 
+     if (d!=s) {
+ 	usereg(s);
+ 	ds=stackpos(s);
+ 	emit_byte(0xd9);
+ 	emit_byte(0xc0+ds); /* duplicate source */
+ 	emit_byte(0xd9);
+ 	emit_byte(0xfe); /* take sin */
+ 	tos_make(d); /* store to destination */
+     }
+     else {
+ 	make_tos(d);
+ 	emit_byte(0xd9);
+ 	emit_byte(0xfe); /* take sin */
+     }	
+ }
+ LENDFUNC(NONE,NONE,2,raw_fsin_rr,(FW d, FR s))
+ 
+ double one=1;
+ LOWFUNC(NONE,NONE,2,raw_ftwotox_rr,(FW d, FR s))
+ {
+     int ds;
+ 
+     usereg(s);
+     ds=stackpos(s);
+     emit_byte(0xd9);
+     emit_byte(0xc0+ds); /* duplicate source */
+ 
+     emit_byte(0xd9);
+     emit_byte(0xc0);  /* duplicate top of stack. Now up to 8 high */
+     emit_byte(0xd9);
+     emit_byte(0xfc);  /* rndint */
+     emit_byte(0xd9);
+     emit_byte(0xc9);  /* swap top two elements */
+     emit_byte(0xd8);
+     emit_byte(0xe1);  /* subtract rounded from original */
+     emit_byte(0xd9);
+     emit_byte(0xf0);  /* f2xm1 */
+     emit_byte(0xdc);
+     emit_byte(0x05);
+     emit_long((uae_u32)&one);  /* Add '1' without using extra stack space */
+     emit_byte(0xd9);
+     emit_byte(0xfd);  /* and scale it */
+     emit_byte(0xdd);
+     emit_byte(0xd9);  /* take he rounded value off */
+     tos_make(d); /* store to destination */
+ }
+ LENDFUNC(NONE,NONE,2,raw_ftwotox_rr,(FW d, FR s))
+ 
+ LOWFUNC(NONE,NONE,2,raw_fetox_rr,(FW d, FR s))
+ {
+     int ds;
+ 
+     usereg(s);
+     ds=stackpos(s);
+     emit_byte(0xd9);
+     emit_byte(0xc0+ds); /* duplicate source */
+     emit_byte(0xd9);
+     emit_byte(0xea);   /* fldl2e */
+     emit_byte(0xde);
+     emit_byte(0xc9);  /* fmulp --- multiply source by log2(e) */
+ 
+     emit_byte(0xd9);
+     emit_byte(0xc0);  /* duplicate top of stack. Now up to 8 high */
+     emit_byte(0xd9);
+     emit_byte(0xfc);  /* rndint */
+     emit_byte(0xd9);
+     emit_byte(0xc9);  /* swap top two elements */
+     emit_byte(0xd8);
+     emit_byte(0xe1);  /* subtract rounded from original */
+     emit_byte(0xd9);
+     emit_byte(0xf0);  /* f2xm1 */
+     emit_byte(0xdc);
+     emit_byte(0x05);
+     emit_long((uae_u32)&one);  /* Add '1' without using extra stack space */
+     emit_byte(0xd9);
+     emit_byte(0xfd);  /* and scale it */
+     emit_byte(0xdd);
+     emit_byte(0xd9);  /* take he rounded value off */
+     tos_make(d); /* store to destination */
+ }
+ LENDFUNC(NONE,NONE,2,raw_fetox_rr,(FW d, FR s))
+  
+ LOWFUNC(NONE,NONE,2,raw_flog2_rr,(FW d, FR s))
+ {
+     int ds;
+ 
+     usereg(s);
+     ds=stackpos(s);
+     emit_byte(0xd9);
+     emit_byte(0xc0+ds); /* duplicate source */
+     emit_byte(0xd9);
+     emit_byte(0xe8); /* push '1' */
+     emit_byte(0xd9);
+     emit_byte(0xc9); /* swap top two */
+     emit_byte(0xd9);
+     emit_byte(0xf1); /* take 1*log2(x) */
+     tos_make(d); /* store to destination */
+ }
+ LENDFUNC(NONE,NONE,2,raw_flog2_rr,(FW d, FR s))
+ 
+ 
+ LOWFUNC(NONE,NONE,2,raw_fneg_rr,(FW d, FR s))
+ {
+     int ds;
+ 
+     if (d!=s) {
+ 	usereg(s);
+ 	ds=stackpos(s);
+ 	emit_byte(0xd9);
+ 	emit_byte(0xc0+ds); /* duplicate source */
+ 	emit_byte(0xd9);
+ 	emit_byte(0xe0); /* take fchs */
+ 	tos_make(d); /* store to destination */
+     }
+     else {
+ 	make_tos(d);
+ 	emit_byte(0xd9);
+ 	emit_byte(0xe0); /* take fchs */
+     }	
+ }
+ LENDFUNC(NONE,NONE,2,raw_fneg_rr,(FW d, FR s))
+ 
+ LOWFUNC(NONE,NONE,2,raw_fadd_rr,(FRW d, FR s))
+ {
+     int ds;
+ 
+     usereg(s);
+     usereg(d);
+     
+     if (live.spos[s]==live.tos) {
+ 	/* Source is on top of stack */
+ 	ds=stackpos(d);
+ 	emit_byte(0xdc);
+ 	emit_byte(0xc0+ds); /* add source to dest*/
+     }
+     else {
+ 	make_tos(d);
+ 	ds=stackpos(s);
+ 	
+ 	emit_byte(0xd8);
+ 	emit_byte(0xc0+ds); /* add source to dest*/
+     }
+ }
+ LENDFUNC(NONE,NONE,2,raw_fadd_rr,(FRW d, FR s))
+ 
+ LOWFUNC(NONE,NONE,2,raw_fsub_rr,(FRW d, FR s))
+ {
+     int ds;
+ 
+     usereg(s);
+     usereg(d);
+     
+     if (live.spos[s]==live.tos) {
+ 	/* Source is on top of stack */
+ 	ds=stackpos(d);
+ 	emit_byte(0xdc);
+ 	emit_byte(0xe8+ds); /* sub source from dest*/
+     }
+     else {
+ 	make_tos(d);
+ 	ds=stackpos(s);
+ 	
+ 	emit_byte(0xd8);
+ 	emit_byte(0xe0+ds); /* sub src from dest */
+     }
+ }
+ LENDFUNC(NONE,NONE,2,raw_fsub_rr,(FRW d, FR s))
+ 
+ LOWFUNC(NONE,NONE,2,raw_fcmp_rr,(FR d, FR s))
+ {
+     int ds;
+ 
+     usereg(s);
+     usereg(d);
+     
+     make_tos(d);
+     ds=stackpos(s);
+ 
+     emit_byte(0xdd);
+     emit_byte(0xe0+ds); /* cmp dest with source*/
+ }
+ LENDFUNC(NONE,NONE,2,raw_fcmp_rr,(FR d, FR s))
+ 
+ LOWFUNC(NONE,NONE,2,raw_fmul_rr,(FRW d, FR s))
+ {
+     int ds;
+ 
+     usereg(s);
+     usereg(d);
+     
+     if (live.spos[s]==live.tos) {
+ 	/* Source is on top of stack */
+ 	ds=stackpos(d);
+ 	emit_byte(0xdc);
+ 	emit_byte(0xc8+ds); /* mul dest by source*/
+     }
+     else {
+ 	make_tos(d);
+ 	ds=stackpos(s);
+ 	
+ 	emit_byte(0xd8);
+ 	emit_byte(0xc8+ds); /* mul dest by source*/
+     }
+ }
+ LENDFUNC(NONE,NONE,2,raw_fmul_rr,(FRW d, FR s))
+ 
+ LOWFUNC(NONE,NONE,2,raw_fdiv_rr,(FRW d, FR s))
+ {
+     int ds;
+ 
+     usereg(s);
+     usereg(d);
+     
+     if (live.spos[s]==live.tos) {
+ 	/* Source is on top of stack */
+ 	ds=stackpos(d);
+ 	emit_byte(0xdc);
+ 	emit_byte(0xf8+ds); /* div dest by source */
+     }
+     else {
+ 	make_tos(d);
+ 	ds=stackpos(s);
+ 	
+ 	emit_byte(0xd8);
+ 	emit_byte(0xf0+ds); /* div dest by source*/
+     }
+ }
+ LENDFUNC(NONE,NONE,2,raw_fdiv_rr,(FRW d, FR s))
+ 
+ LOWFUNC(NONE,NONE,2,raw_frem_rr,(FRW d, FR s))
+ {
+     int ds;
+ 
+     usereg(s);
+     usereg(d);
+     
+     make_tos2(d,s);
+     ds=stackpos(s);
+ 
+     if (ds!=1) {
+ 	printf("Failed horribly in raw_frem_rr! ds is %d\n",ds);
+ 	abort();
+     }
+     emit_byte(0xd9);
+     emit_byte(0xf8); /* take rem from dest by source */
+ }
+ LENDFUNC(NONE,NONE,2,raw_frem_rr,(FRW d, FR s))
+ 
+ LOWFUNC(NONE,NONE,2,raw_frem1_rr,(FRW d, FR s))
+ {
+     int ds;
+ 
+     usereg(s);
+     usereg(d);
+     
+     make_tos2(d,s);
+     ds=stackpos(s);
+ 
+     if (ds!=1) {
+ 	printf("Failed horribly in raw_frem1_rr! ds is %d\n",ds);
+ 	abort();
+     }
+     emit_byte(0xd9);
+     emit_byte(0xf5); /* take rem1 from dest by source */
+ }
+ LENDFUNC(NONE,NONE,2,raw_frem1_rr,(FRW d, FR s))
+ 
+ 
+ LOWFUNC(NONE,NONE,1,raw_ftst_r,(FR r))
+ {
+     make_tos(r);
+     emit_byte(0xd9);  /* ftst */
+     emit_byte(0xe4);
+ }
+ LENDFUNC(NONE,NONE,1,raw_ftst_r,(FR r))
+ 
+ static __inline__ void raw_fflags_into_flags(int r)
+ {
+     int p;
+ 
+     usereg(r);
+     p=stackpos(r);
+ 
+     emit_byte(0xd9);
+     emit_byte(0xee); /* Push 0 */
+     emit_byte(0xd9);
+     emit_byte(0xc9+p); /* swap top two around */
+     if (have_cmov) {
+             // gb-- fucomi is for P6 cores only, not K6-2 then...
+     emit_byte(0xdb);
+     emit_byte(0xe9+p); /* fucomi them */
+     }
+     else {
+             emit_byte(0xdd);
+             emit_byte(0xe1+p); /* fucom them */
+             emit_byte(0x9b);
+             emit_byte(0xdf);
+             emit_byte(0xe0); /* fstsw ax */
+             raw_sahf(0); /* sahf */
+     }
+     emit_byte(0xdd);
+     emit_byte(0xd9+p);  /* store value back, and get rid of 0 */
+ }
diff -crB --new-file ./uae-0.8.21/src/compemu_support.c ../uae_jit_cleaning/uae-0.8.21/src/compemu_support.c
*** ./uae-0.8.21/src/compemu_support.c	1970-01-01 02:00:00.000000000 +0200
--- ../uae_jit_cleaning/uae-0.8.21/src/compemu_support.c	2021-01-10 14:06:16.934591684 +0200
***************
*** 0 ****
--- 1,6250 ----
+ #define writemem_special writemem
+ #define readmem_special  readmem
+ 
+ #define GS_NATMEM_OFFSET 0
+ 
+ #define USE_MATCHSTATE 0
+ 
+ #include "sysconfig.h"
+ #include "sysdeps.h"
+ #include "config.h"
+ #include "options.h"
+ #include "events.h"
+ #include "include/memory.h"
+ #include "custom.h"
+ #include "newcpu.h"
+ #include "compiler.h"
+ #include "comptbl.h"
+ #include "compemu.h"
+ 
+ // %%% BRIAN KING WAS HERE %%%
+ extern int canbang;
+ static int use_gs_seg = 0;
+ 
+ #ifndef _WIN32
+ #include <sys/mman.h>
+ #else
+ #include <signal.h>
+ #include "osdep/mman.h"
+ #endif
+ #include <limits.h>		/* for PAGESIZE */
+ 
+ struct sigaction act;
+ 
+ cpuop_func *compfunctbl[65536];
+ cpuop_func *nfcompfunctbl[65536];
+ #ifdef NOFLAGS_SUPPORT
+ cpuop_func *nfcpufunctbl[65536];
+ #endif
+ uae_u8 *comp_pc_p;
+ 
+ uae_u8 *start_pc_p;
+ uae_u32 start_pc;
+ uae_u32 current_block_pc_p;
+ uae_u32 current_block_start_target;
+ uae_u32 needed_flags;
+ static uae_u32 next_pc_p;
+ static uae_u32 taken_pc_p;
+ static int branch_cc;
+ int segvcount = 0;
+ int soft_flush_count = 0;
+ int hard_flush_count = 0;
+ int compile_count = 0;
+ int checksum_count = 0;
+ static uae_u8 *current_compile_p = NULL;
+ static uae_u8 *max_compile_start;
+ static uae_u8 *compiled_code = NULL;
+ static uae_s32 reg_alloc_run;
+ static int have_rat_stall = 0;
+ 
+ void *pushall_call_handler = NULL;
+ static void *popall_do_nothing = NULL;
+ static void *popall_exec_nostats = NULL;
+ static void *popall_execute_normal = NULL;
+ static void *popall_cache_miss = NULL;
+ static void *popall_recompile_block = NULL;
+ static void *popall_check_checksum = NULL;
+ 
+ extern uae_u32 oink;
+ extern unsigned long foink3;
+ extern unsigned long foink;
+ 
+ /* The 68k only ever executes from even addresses. So right now, we
+    waste half the entries in this array
+    UPDATE: We now use those entries to store the start of the linked
+    lists that we maintain for each hash result. */
+ cacheline cache_tags[TAGSIZE];
+ int letit = 0;
+ blockinfo *hold_bi[MAX_HOLD_BI];
+ blockinfo *active;
+ blockinfo *dormant;
+ 
+ op_properties prop[65536];
+ 
+ #ifdef NOFLAGS_SUPPORT
+ /* 68040 */
+ extern struct cputbl op_smalltbl_0_nf[];
+ #endif
+ extern struct cputbl op_smalltbl_0_comp_nf[];
+ extern struct cputbl op_smalltbl_0_comp_ff[];
+ #ifdef NOFLAGS_SUPPORT
+ /* 68020 + 68881 */
+ extern struct cputbl op_smalltbl_1_nf[];
+ /* 68020 */
+ extern struct cputbl op_smalltbl_2_nf[];
+ /* 68010 */
+ extern struct cputbl op_smalltbl_3_nf[];
+ /* 68000 */
+ extern struct cputbl op_smalltbl_4_nf[];
+ /* 68000 slow but compatible.  */
+ extern struct cputbl op_smalltbl_5_nf[];
+ #endif
+ 
+ static void flush_icache_hard (int n);
+ 
+ 
+ 
+ bigstate live;
+ smallstate empty_ss;
+ smallstate default_ss;
+ static int optlev;
+ 
+ static int writereg (int r, int size);
+ static void unlock (int r);
+ static void setlock (int r);
+ static int readreg_specific (int r, int size, int spec);
+ static int writereg_specific (int r, int size, int spec);
+ static void prepare_for_call_1 (void);
+ static void prepare_for_call_2 (void);
+ static void align_target (uae_u32 a);
+ 
+ static uae_s32 nextused[VREGS];
+ 
+ uae_u32 m68k_pc_offset;
+ 
+ /* Some arithmetic ooperations can be optimized away if the operands
+    are known to be constant. But that's only a good idea when the
+    side effects they would have on the flags are not important. This
+    variable indicates whether we need the side effects or not 
+ */
+ uae_u32 needflags = 0;
+ 
+ /* Flag handling is complicated.
+ 
+    x86 instructions create flags, which quite often are exactly what we
+    want. So at times, the "68k" flags are actually in the x86 flags.
+ 
+    Then again, sometimes we do x86 instructions that clobber the x86
+    flags, but don't represent a corresponding m68k instruction. In that
+    case, we have to save them. 
+ 
+    We used to save them to the stack, but now store them back directly
+    into the regflags.cznv of the traditional emulation. Thus some odd
+    names.
+ 
+    So flags can be in either of two places (used to be three; boy were
+    things complicated back then!); And either place can contain either
+    valid flags or invalid trash (and on the stack, there was also the
+    option of "nothing at all", now gone). A couple of variables keep
+    track of the respective states.
+ 
+    To make things worse, we might or might not be interested in the flags.
+    by default, we are, but a call to dont_care_flags can change that 
+    until the next call to live_flags. If we are not, pretty much whatever
+    is in the register and/or the native flags is seen as valid.
+ */
+ 
+ 
+ static __inline__ blockinfo *get_blockinfo (uae_u32 cl)
+ {
+     return cache_tags[cl + 1].bi;
+ }
+ 
+ static __inline__ blockinfo *get_blockinfo_addr (void *addr)
+ {
+     blockinfo *bi = get_blockinfo (cacheline (addr));
+ 
+     while (bi) {
+ 	if (bi->pc_p == addr)
+ 	    return bi;
+ 	bi = bi->next_same_cl;
+     }
+     return NULL;
+ }
+ 
+ 
+ /*******************************************************************
+  * All sorts of list related functions for all of the lists        *
+  *******************************************************************/
+ 
+ static __inline__ void remove_from_cl_list (blockinfo * bi)
+ {
+     uae_u32 cl = cacheline (bi->pc_p);
+ 
+     if (bi->prev_same_cl_p)
+ 	*(bi->prev_same_cl_p) = bi->next_same_cl;
+     if (bi->next_same_cl)
+ 	bi->next_same_cl->prev_same_cl_p = bi->prev_same_cl_p;
+     if (cache_tags[cl + 1].bi)
+ 	cache_tags[cl].handler = cache_tags[cl + 1].bi->handler_to_use;
+     else
+ 	cache_tags[cl].handler = popall_execute_normal;
+ }
+ 
+ static __inline__ void remove_from_list (blockinfo * bi)
+ {
+     if (bi->prev_p)
+ 	*(bi->prev_p) = bi->next;
+     if (bi->next)
+ 	bi->next->prev_p = bi->prev_p;
+ }
+ 
+ static __inline__ void remove_from_lists (blockinfo * bi)
+ {
+     remove_from_list (bi);
+     remove_from_cl_list (bi);
+ }
+ 
+ static __inline__ void add_to_cl_list (blockinfo * bi)
+ {
+     uae_u32 cl = cacheline (bi->pc_p);
+ 
+     if (cache_tags[cl + 1].bi)
+ 	cache_tags[cl + 1].bi->prev_same_cl_p = &(bi->next_same_cl);
+     bi->next_same_cl = cache_tags[cl + 1].bi;
+ 
+     cache_tags[cl + 1].bi = bi;
+     bi->prev_same_cl_p = &(cache_tags[cl + 1].bi);
+ 
+     cache_tags[cl].handler = bi->handler_to_use;
+ }
+ 
+ static __inline__ void raise_in_cl_list (blockinfo * bi)
+ {
+     remove_from_cl_list (bi);
+     add_to_cl_list (bi);
+ }
+ 
+ static __inline__ void add_to_active (blockinfo * bi)
+ {
+     if (active)
+ 	active->prev_p = &(bi->next);
+     bi->next = active;
+ 
+     active = bi;
+     bi->prev_p = &active;
+ }
+ 
+ static __inline__ void add_to_dormant (blockinfo * bi)
+ {
+     if (dormant)
+ 	dormant->prev_p = &(bi->next);
+     bi->next = dormant;
+ 
+     dormant = bi;
+     bi->prev_p = &dormant;
+ }
+ 
+ static __inline__ void remove_dep (dependency * d)
+ {
+     if (d->prev_p)
+ 	*(d->prev_p) = d->next;
+     if (d->next)
+ 	d->next->prev_p = d->prev_p;
+     d->prev_p = NULL;
+     d->next = NULL;
+ }
+ 
+ /* This block's code is about to be thrown away, so it no longer
+    depends on anything else */
+ static __inline__ void remove_deps (blockinfo * bi)
+ {
+     remove_dep (&(bi->dep[0]));
+     remove_dep (&(bi->dep[1]));
+ }
+ 
+ static __inline__ void adjust_jmpdep (dependency * d, void *a)
+ {
+     *(d->jmp_off) = (uae_u32) a - ((uae_u32) d->jmp_off + 4);
+ }
+ 
+ /********************************************************************
+  * Soft flush handling support functions                            *
+  ********************************************************************/
+ 
+ static __inline__ void set_dhtu (blockinfo * bi, void *dh)
+ {
+     //printf("bi is %p\n",bi);
+     if (dh != bi->direct_handler_to_use) {
+ 	dependency *x = bi->deplist;
+ 	//printf("bi->deplist=%p\n",bi->deplist);
+ 	while (x) {
+ 	    //printf("x is %p\n",x);
+ 	    //printf("x->next is %p\n",x->next);
+ 	    //printf("x->prev_p is %p\n",x->prev_p);
+ 
+ 	    if (x->jmp_off) {
+ 		adjust_jmpdep (x, dh);
+ 	    }
+ 	    x = x->next;
+ 	}
+ 	bi->direct_handler_to_use = dh;
+     }
+ }
+ 
+ static __inline__ void invalidate_block (blockinfo * bi)
+ {
+     int i;
+ 
+     bi->optlevel = 0;
+     bi->count = currprefs.optcount[0] - 1;
+     bi->handler = NULL;
+     bi->handler_to_use = popall_execute_normal;
+     bi->direct_handler = NULL;
+     set_dhtu (bi, bi->direct_pen);
+     bi->needed_flags = 0xff;
+ 
+     for (i = 0; i < 2; i++) {
+ 	bi->dep[i].jmp_off = NULL;
+ 	bi->dep[i].target = NULL;
+     }
+     remove_deps (bi);
+ }
+ 
+ static __inline__ void create_jmpdep (blockinfo * bi, int i, uae_u32 * jmpaddr, uae_u32 target)
+ {
+     blockinfo *tbi = get_blockinfo_addr ((void *) target);
+ 
+     Dif (!tbi) {
+ 	printf ("Could not create jmpdep!\n");
+ 	abort ();
+     }
+     bi->dep[i].jmp_off = jmpaddr;
+     bi->dep[i].target = tbi;
+     bi->dep[i].next = tbi->deplist;
+     if (bi->dep[i].next)
+ 	bi->dep[i].next->prev_p = &(bi->dep[i].next);
+     bi->dep[i].prev_p = &(tbi->deplist);
+     tbi->deplist = &(bi->dep[i]);
+ }
+ 
+ static __inline__ void big_to_small_state (bigstate * b, smallstate * s)
+ {
+     int i;
+     int count = 0;
+ 
+     for (i = 0; i < N_REGS; i++) {
+ 	s->nat[i].validsize = 0;
+ 	s->nat[i].dirtysize = 0;
+ 	if (b->nat[i].nholds) {
+ 	    int index = b->nat[i].nholds - 1;
+ 	    int r = b->nat[i].holds[index];
+ 	    s->nat[i].holds = r;
+ 	    s->nat[i].validsize = b->state[r].validsize;
+ 	    s->nat[i].dirtysize = b->state[r].dirtysize;
+ 	    count++;
+ 	}
+     }
+     printf ("count=%d\n", count);
+     for (i = 0; i < N_REGS; i++) {	// FIXME --- don't do dirty yet 
+ 	s->nat[i].dirtysize = 0;
+     }
+ }
+ 
+ static __inline__ void attached_state (blockinfo * bi)
+ {
+     bi->havestate = 1;
+     if (bi->direct_handler_to_use == bi->direct_handler)
+ 	set_dhtu (bi, bi->direct_pen);
+     bi->direct_handler = bi->direct_pen;
+     bi->status = BI_TARGETTED;
+ }
+ 
+ static __inline__ blockinfo *get_blockinfo_addr_new (void *addr, int setstate)
+ {
+     blockinfo *bi = get_blockinfo_addr (addr);
+     int i;
+ 
+ #if USE_OPTIMIZER
+     if (reg_alloc_run)
+ 	return NULL;
+ #endif
+     if (!bi) {
+ 	for (i = 0; i < MAX_HOLD_BI && !bi; i++) {
+ 	    if (hold_bi[i]) {
+ 		uae_u32 cl = cacheline (addr);
+ 
+ 		bi = hold_bi[i];
+ 		hold_bi[i] = NULL;
+ 		bi->pc_p = addr;
+ 		invalidate_block (bi);
+ 		add_to_active (bi);
+ 		add_to_cl_list (bi);
+ 
+ 	    }
+ 	}
+     }
+     if (!bi) {
+ 	fprintf (stderr, "Looking for blockinfo, can't find free one\n");
+ 	abort ();
+     }
+ #if USE_MATCHSTATE
+     if (setstate && !bi->havestate) {
+ 	big_to_small_state (&live, &(bi->env));
+ 	attached_state (bi);
+     }
+ #endif
+     return bi;
+ }
+ 
+ static void prepare_block (blockinfo * bi);
+ 
+ static __inline__ void alloc_blockinfos (void)
+ {
+     int i;
+     blockinfo *bi;
+ 
+     for (i = 0; i < MAX_HOLD_BI; i++) {
+ 	if (hold_bi[i])
+ 	    return;
+ 	bi = hold_bi[i] = (blockinfo *) current_compile_p;
+ 	current_compile_p += sizeof (blockinfo);
+ 
+ 	prepare_block (bi);
+     }
+ }
+ 
+ /********************************************************************
+  * Preferences handling. This is just a convenient place to put it  *
+  ********************************************************************/
+ extern int have_done_picasso;
+ 
+ void check_prefs_changed_comp (void)
+ {
+     currprefs.comptrustbyte = changed_prefs.comptrustbyte;
+     currprefs.comptrustword = changed_prefs.comptrustword;
+     currprefs.comptrustlong = changed_prefs.comptrustlong;
+     currprefs.comptrustnaddr = changed_prefs.comptrustnaddr;
+     currprefs.compnf = changed_prefs.compnf;
+     currprefs.comp_hardflush = changed_prefs.comp_hardflush;
+     currprefs.comp_constjump = changed_prefs.comp_constjump;
+     currprefs.comp_oldsegv = changed_prefs.comp_oldsegv;
+     currprefs.compfpu = changed_prefs.compfpu;
+ 
+     // Turn off JIT for 24-bit address-space CPU settings...
+     if (currprefs.address_space_24 || (currprefs.cpu_level < 2)) {
+ 	changed_prefs.cachesize = 0;
+     }
+ 
+     if (currprefs.cachesize != changed_prefs.cachesize) {
+ 	currprefs.cachesize = changed_prefs.cachesize;
+ 	alloc_cache ();
+     }
+     // Turn off illegal-mem logging when using JIT...
+     if (currprefs.cachesize)
+ 	currprefs.illegal_mem = changed_prefs.illegal_mem;	// = 0;
+ 
+     currprefs.comp_midopt = changed_prefs.comp_midopt;
+     currprefs.comp_lowopt = changed_prefs.comp_lowopt;
+ 
+     if ((!canbang || !currprefs.cachesize) && currprefs.comptrustbyte != 1) {
+ 	// Set all of these to indirect when canbang == 0
+ 	// Basically, set the  compforcesettings option...
+ 	currprefs.comptrustbyte = 1;
+ 	currprefs.comptrustword = 1;
+ 	currprefs.comptrustlong = 1;
+ 	currprefs.comptrustnaddr = 1;
+ 	currprefs.compforcesettings = 1;
+ 
+ 	changed_prefs.comptrustbyte = 1;
+ 	changed_prefs.comptrustword = 1;
+ 	changed_prefs.comptrustlong = 1;
+ 	changed_prefs.comptrustnaddr = 1;
+ 	changed_prefs.compforcesettings = 1;
+ 
+ 	if (currprefs.cachesize) {
+ 	    write_log ("JIT: Reverting to \"indirect\" access, because canbang is zero!\n");
+ 	}
+     }
+ 
+     if (!currprefs.compforcesettings && !have_done_picasso) {
+ 	int stop = 0;
+ 	if (currprefs.comptrustbyte != 0 && currprefs.comptrustbyte != 3)
+ 	    stop = 1, write_log ("<JIT compiler> : comptrustbyte is not 'direct' or 'afterpic'\n");
+ 	if (currprefs.comptrustword != 0 && currprefs.comptrustword != 3)
+ 	    stop = 1, write_log ("<JIT compiler> : comptrustword is not 'direct' or 'afterpic'\n");
+ 	if (currprefs.comptrustlong != 0 && currprefs.comptrustlong != 3)
+ 	    stop = 1, write_log ("<JIT compiler> : comptrustlong is not 'direct' or 'afterpic'\n");
+ 	if (currprefs.comptrustnaddr != 0 && currprefs.comptrustnaddr != 3)
+ 	    stop = 1, write_log ("<JIT compiler> : comptrustnaddr is not 'direct' or 'afterpic'\n");
+ 	if (currprefs.compnf != 1)
+ 	    stop = 1, write_log ("<JIT compiler> : compnf is not 'yes'\n");
+ 	if (currprefs.cachesize < 1024)
+ 	    stop = 1, write_log ("<JIT compiler> : cachesize is less than 1024\n");
+ 	if (currprefs.comp_hardflush)
+ 	    stop = 1, write_log ("<JIT compiler> : comp_flushmode is 'hard'\n");
+ 	if (!canbang)
+ 	    stop = 1, write_log ("<JIT compiler> : Cannot use most direct memory access,\n"
+ 				 "                 and unable to recover from failed guess!\n");
+ #if 0
+ 	if (stop) {
+ 	    gui_message ("JIT: Configuration problems were detected!\n"
+ 			 "JIT: These will adversely affect performance, and should\n"
+ 			 "JIT: not be used. For more info, please see README.JIT-tuning\n"
+ 			 "JIT: in the UAE documentation directory. You can force\n"
+ 			 "JIT: your settings to be used by setting\n"
+ 			 "JIT:      'compforcesettings=yes'\n" "JIT: in your config file\n");
+ 	    exit (1);
+ 	}
+ #endif
+     }
+ }
+ 
+ /********************************************************************
+  * Get the optimizer stuff                                          *
+  ********************************************************************/
+ 
+ #include "compemu_optimizer.c"
+ 
+ /********************************************************************
+  * Functions to emit data into memory, and other general support    *
+  ********************************************************************/
+ 
+ static uae_u8 *target;
+ 
+ static void emit_init (void)
+ {
+ }
+ 
+ static __inline__ void emit_byte (uae_u8 x)
+ {
+     *target++ = x;
+ }
+ 
+ static __inline__ void emit_word (uae_u16 x)
+ {
+     *((uae_u16 *) target) = x;
+     target += 2;
+ }
+ 
+ static __inline__ void emit_long (uae_u32 x)
+ {
+     *((uae_u32 *) target) = x;
+     target += 4;
+ }
+ 
+ static __inline__ uae_u32 reverse32 (uae_u32 oldv)
+ {
+     return ((oldv >> 24) & 0xff) | ((oldv >> 8) & 0xff00) | ((oldv << 8) & 0xff0000) | ((oldv << 24) & 0xff000000);
+ }
+ 
+ 
+ void set_target (uae_u8 * t)
+ {
+     lopt_emit_all ();
+     target = t;
+ }
+ 
+ static __inline__ uae_u8 *get_target_noopt (void)
+ {
+     return target;
+ }
+ 
+ __inline__ uae_u8 *get_target (void)
+ {
+     lopt_emit_all ();
+     return get_target_noopt ();
+ }
+ 
+ 
+ /********************************************************************
+  * Getting the information about the target CPU                     *
+  ********************************************************************/
+ 
+ #include "compemu_raw_x86.c"
+ 
+ 
+ /********************************************************************
+  * Flags status handling. EMIT TIME!                                *
+  ********************************************************************/
+ 
+ static void bt_l_ri_noclobber (R4 r, IMM i);
+ 
+ static void make_flags_live_internal (void)
+ {
+     if (live.flags_in_flags == VALID)
+ 	return;
+     Dif (live.flags_on_stack == TRASH) {
+ 	printf ("Want flags, got something on stack, but it is TRASH\n");
+ 	abort ();
+     }
+     if (live.flags_on_stack == VALID) {
+ 	int tmp;
+ 	tmp = readreg_specific (FLAGTMP, 4, FLAG_NREG2);
+ 	raw_reg_to_flags (tmp);
+ 	unlock (tmp);
+ 
+ 	live.flags_in_flags = VALID;
+ 	return;
+     }
+     printf ("Huh? live.flags_in_flags=%d, live.flags_on_stack=%d, but need to make live\n",
+ 	    live.flags_in_flags, live.flags_on_stack);
+     abort ();
+ }
+ 
+ static void flags_to_stack (void)
+ {
+     if (live.flags_on_stack == VALID)
+ 	return;
+     if (!live.flags_are_important) {
+ 	live.flags_on_stack = VALID;
+ 	return;
+     }
+     Dif (live.flags_in_flags != VALID)
+ 	abort ();
+     else {
+ 	int tmp;
+ 	tmp = writereg_specific (FLAGTMP, 4, FLAG_NREG1);
+ 	raw_flags_to_reg (tmp);
+ 	unlock (tmp);
+     }
+     live.flags_on_stack = VALID;
+ }
+ 
+ static __inline__ void clobber_flags (void)
+ {
+     if (live.flags_in_flags == VALID && live.flags_on_stack != VALID)
+ 	flags_to_stack ();
+     live.flags_in_flags = TRASH;
+ }
+ 
+ /* Prepare for leaving the compiled stuff */
+ static __inline__ void flush_flags (void)
+ {
+     flags_to_stack ();
+     return;
+ }
+ 
+ int touchcnt;
+ 
+ /********************************************************************
+  * register allocation per block logging                            *
+  ********************************************************************/
+ 
+ static uae_s8 vstate[VREGS];
+ static uae_s8 nstate[N_REGS];
+ 
+ #define L_UNKNOWN -127
+ #define L_UNAVAIL -1
+ #define L_NEEDED -2
+ #define L_UNNEEDED -3
+ 
+ static __inline__ void log_startblock (void)
+ {
+     int i;
+     for (i = 0; i < VREGS; i++)
+ 	vstate[i] = L_UNKNOWN;
+     for (i = 0; i < N_REGS; i++)
+ 	nstate[i] = L_UNKNOWN;
+ }
+ 
+ static __inline__ void log_isused (int n)
+ {
+     if (nstate[n] == L_UNKNOWN)
+ 	nstate[n] = L_UNAVAIL;
+ }
+ 
+ static __inline__ void log_isreg (int n, int r)
+ {
+     if (nstate[n] == L_UNKNOWN)
+ 	nstate[n] = r;
+     if (vstate[r] == L_UNKNOWN)
+ 	vstate[r] = L_NEEDED;
+ }
+ 
+ static __inline__ void log_clobberreg (int r)
+ {
+     if (vstate[r] == L_UNKNOWN)
+ 	vstate[r] = L_UNNEEDED;
+ }
+ 
+ /* This ends all possibility of clever register allocation */
+ 
+ static __inline__ void log_flush (void)
+ {
+     int i;
+     for (i = 0; i < VREGS; i++)
+ 	if (vstate[i] == L_UNKNOWN)
+ 	    vstate[i] = L_NEEDED;
+     for (i = 0; i < N_REGS; i++)
+ 	if (nstate[i] == L_UNKNOWN)
+ 	    nstate[i] = L_UNAVAIL;
+ }
+ 
+ static __inline__ void log_dump (void)
+ {
+     int i;
+ 
+     return;
+ 
+     write_log ("----------------------\n");
+     for (i = 0; i < N_REGS; i++) {
+ 	switch (nstate[i]) {
+ 	case L_UNKNOWN:
+ 	    write_log ("Nat %d : UNKNOWN\n", i);
+ 	    break;
+ 	case L_UNAVAIL:
+ 	    write_log ("Nat %d : UNAVAIL\n", i);
+ 	    break;
+ 	default:
+ 	    write_log ("Nat %d : %d\n", i, nstate[i]);
+ 	    break;
+ 	}
+     }
+     for (i = 0; i < VREGS; i++) {
+ 	if (vstate[i] == L_UNNEEDED)
+ 	    write_log ("Virt %d: UNNEEDED\n", i);
+     }
+ }
+ 
+ /********************************************************************
+  * register status handling. EMIT TIME!                             *
+  ********************************************************************/
+ 
+ static __inline__ void set_status (int r, int status)
+ {
+     if (status == ISCONST)
+ 	log_clobberreg (r);
+     live.state[r].status = status;
+ }
+ 
+ 
+ static __inline__ int isinreg (int r)
+ {
+     return live.state[r].status == CLEAN || live.state[r].status == DIRTY;
+ }
+ 
+ static __inline__ void adjust_nreg (int r, uae_u32 val)
+ {
+     if (!val)
+ 	return;
+     raw_lea_l_brr (r, r, val);
+ }
+ 
+ static void tomem (int r)
+ {
+     int rr = live.state[r].realreg;
+ 
+     if (isinreg (r)) {
+ 	if (live.state[r].val && live.nat[rr].nholds == 1 && !live.nat[rr].locked) {
+ 	    // printf("RemovingA offset %x from reg %d (%d) at %p\n",
+ 	    //   live.state[r].val,r,rr,target); 
+ 	    adjust_nreg (rr, live.state[r].val);
+ 	    live.state[r].val = 0;
+ 	    live.state[r].dirtysize = 4;
+ 	    set_status (r, DIRTY);
+ 	}
+     }
+ 
+     if (live.state[r].status == DIRTY) {
+ 	switch (live.state[r].dirtysize) {
+ 	case 1:
+ 	    raw_mov_b_mr ((uae_u32) live.state[r].mem, rr);
+ 	    break;
+ 	case 2:
+ 	    raw_mov_w_mr ((uae_u32) live.state[r].mem, rr);
+ 	    break;
+ 	case 4:
+ 	    raw_mov_l_mr ((uae_u32) live.state[r].mem, rr);
+ 	    break;
+ 	default:
+ 	    abort ();
+ 	}
+ 	set_status (r, CLEAN);
+ 	live.state[r].dirtysize = 0;
+     }
+ }
+ 
+ static __inline__ int isconst (int r)
+ {
+     return live.state[r].status == ISCONST;
+ }
+ 
+ int is_const (int r)
+ {
+     return isconst (r);
+ }
+ 
+ static __inline__ void writeback_const (int r)
+ {
+     if (!isconst (r))
+ 	return;
+     Dif (live.state[r].needflush == NF_HANDLER) {
+ 	fprintf (stderr, "Trying to write back constant NF_HANDLER!\n");
+ 	abort ();
+     }
+ 
+     raw_mov_l_mi ((uae_u32) live.state[r].mem, live.state[r].val);
+     live.state[r].val = 0;
+     set_status (r, INMEM);
+ }
+ 
+ static __inline__ void tomem_c (int r)
+ {
+     if (isconst (r)) {
+ 	writeback_const (r);
+     } else
+ 	tomem (r);
+ }
+ 
+ static void evict (int r)
+ {
+     int rr;
+ 
+     if (!isinreg (r))
+ 	return;
+     tomem (r);
+     rr = live.state[r].realreg;
+ 
+     Dif (live.nat[rr].locked && live.nat[rr].nholds == 1) {
+ 	fprintf (stderr, "register %d in nreg %d is locked!\n", r, live.state[r].realreg);
+ 	abort ();
+     }
+ 
+     live.nat[rr].nholds--;
+     if (live.nat[rr].nholds != live.state[r].realind) {	/* Was not last */
+ 	int topreg = live.nat[rr].holds[live.nat[rr].nholds];
+ 	int thisind = live.state[r].realind;
+ 	live.nat[rr].holds[thisind] = topreg;
+ 	live.state[topreg].realind = thisind;
+     }
+     live.state[r].realreg = -1;
+     set_status (r, INMEM);
+ }
+ 
+ static __inline__ void free_nreg (int r)
+ {
+     int i = live.nat[r].nholds;
+ 
+     while (i) {
+ 	int vr;
+ 
+ 	--i;
+ 	vr = live.nat[r].holds[i];
+ 	evict (vr);
+     }
+     Dif (live.nat[r].nholds != 0) {
+ 	printf ("Failed to free nreg %d, nholds is %d\n", r, live.nat[r].nholds);
+ 	abort ();
+     }
+ }
+ 
+ /* Use with care! */
+ static __inline__ void isclean (int r)
+ {
+     if (!isinreg (r))
+ 	return;
+     live.state[r].validsize = 4;
+     live.state[r].dirtysize = 0;
+     live.state[r].val = 0;
+     set_status (r, CLEAN);
+ }
+ 
+ static __inline__ void disassociate (int r)
+ {
+     isclean (r);
+     evict (r);
+ }
+ 
+ static __inline__ void set_const (int r, uae_u32 val)
+ {
+     disassociate (r);
+     live.state[r].val = val;
+     set_status (r, ISCONST);
+ }
+ 
+ static __inline__ uae_u32 get_offset (int r)
+ {
+     return live.state[r].val;
+ }
+ 
+ static int alloc_reg_hinted (int r, int size, int willclobber, int hint)
+ {
+     int bestreg;
+     uae_s32 when;
+     int i;
+     uae_s32 badness = 0;	/* to shut up gcc */
+     bestreg = -1;
+     when = 2000000000;
+ 
+     for (i = N_REGS; i--;) {
+ 	badness = live.nat[i].touched;
+ 	if (live.nat[i].nholds == 0)
+ 	    badness = 0;
+ 	if (i == hint)
+ 	    badness -= 200000000;
+ 	if (!live.nat[i].locked && badness < when) {
+ 	    if ((size == 1 && live.nat[i].canbyte) || (size == 2 && live.nat[i].canword) || (size == 4)) {
+ 		bestreg = i;
+ 		when = badness;
+ 		if (live.nat[i].nholds == 0 && hint < 0)
+ 		    break;
+ 		if (i == hint)
+ 		    break;
+ 	    }
+ 	}
+     }
+     Dif (bestreg == -1)
+ 	abort ();
+ 
+     if (live.nat[bestreg].nholds > 0) {
+ 	free_nreg (bestreg);
+     }
+     if (isinreg (r)) {
+ 	int rr = live.state[r].realreg;
+ 	/* This will happen if we read a partially dirty register at a
+ 	   bigger size */
+ 	Dif (willclobber || live.state[r].validsize >= size)
+ 	    abort ();
+ 	Dif (live.nat[rr].nholds != 1)
+ 	    abort ();
+ 	if (size == 4 && live.state[r].validsize == 2) {
+ 	    log_isused (bestreg);
+ 	    raw_mov_l_rm (bestreg, (uae_u32) live.state[r].mem);
+ 	    raw_bswap_32 (bestreg);
+ 	    raw_zero_extend_16_rr (rr, rr);
+ 	    raw_zero_extend_16_rr (bestreg, bestreg);
+ 	    raw_bswap_32 (bestreg);
+ 	    raw_lea_l_brr_indexed (rr, rr, bestreg, 1, 0);
+ 	    live.state[r].validsize = 4;
+ 	    live.nat[rr].touched = touchcnt++;
+ 	    return rr;
+ 	}
+ 	if (live.state[r].validsize == 1) {
+ 	    /* Nothing yet */
+ 	}
+ 	evict (r);
+     }
+ 
+     if (!willclobber) {
+ 	if (live.state[r].status != UNDEF) {
+ 	    if (isconst (r)) {
+ 		raw_mov_l_ri (bestreg, live.state[r].val);
+ 		live.state[r].val = 0;
+ 		live.state[r].dirtysize = 4;
+ 		set_status (r, DIRTY);
+ 		log_isused (bestreg);
+ 	    } else {
+ 		if (r == FLAGTMP)
+ 		    raw_load_flagreg (bestreg, r);
+ 		else if (r == FLAGX)
+ 		    raw_load_flagx (bestreg, r);
+ 		else {
+ 		    raw_mov_l_rm (bestreg, (uae_u32) live.state[r].mem);
+ 		}
+ 		live.state[r].dirtysize = 0;
+ 		set_status (r, CLEAN);
+ 		log_isreg (bestreg, r);
+ 	    }
+ 	} else {
+ 	    live.state[r].val = 0;
+ 	    live.state[r].dirtysize = 0;
+ 	    set_status (r, CLEAN);
+ 	    log_isused (bestreg);
+ 	}
+ 	live.state[r].validsize = 4;
+     } else {			/* this is the easiest way, but not optimal. FIXME! */
+ 	/* Now it's trickier, but hopefully still OK */
+ 	if (!isconst (r) || size == 4) {
+ 	    live.state[r].validsize = size;
+ 	    live.state[r].dirtysize = size;
+ 	    live.state[r].val = 0;
+ 	    set_status (r, DIRTY);
+ 	    if (size == 4)
+ 		log_isused (bestreg);
+ 	    else
+ 		log_isreg (bestreg, r);
+ 	} else {
+ 	    if (live.state[r].status != UNDEF)
+ 		raw_mov_l_ri (bestreg, live.state[r].val);
+ 	    live.state[r].val = 0;
+ 	    live.state[r].validsize = 4;
+ 	    live.state[r].dirtysize = 4;
+ 	    set_status (r, DIRTY);
+ 	    log_isused (bestreg);
+ 	}
+     }
+     live.state[r].realreg = bestreg;
+     live.state[r].realind = live.nat[bestreg].nholds;
+     live.nat[bestreg].touched = touchcnt++;
+     live.nat[bestreg].holds[live.nat[bestreg].nholds] = r;
+     live.nat[bestreg].nholds++;
+ 
+     return bestreg;
+ }
+ 
+ static int alloc_reg (int r, int size, int willclobber)
+ {
+     return alloc_reg_hinted (r, size, willclobber, -1);
+ }
+ 
+ static void unlock (int r)
+ {
+     Dif (!live.nat[r].locked)
+ 	abort ();
+     live.nat[r].locked--;
+ }
+ 
+ static void setlock (int r)
+ {
+     live.nat[r].locked++;
+ }
+ 
+ 
+ static void mov_nregs (int d, int s)
+ {
+     int ns = live.nat[s].nholds;
+     int nd = live.nat[d].nholds;
+     int i;
+ 
+     if (s == d)
+ 	return;
+ 
+     if (nd > 0)
+ 	free_nreg (d);
+ 
+     raw_mov_l_rr (d, s);
+     log_isused (d);
+ 
+     for (i = 0; i < live.nat[s].nholds; i++) {
+ 	int vs = live.nat[s].holds[i];
+ 
+ 	live.state[vs].realreg = d;
+ 	live.state[vs].realind = i;
+ 	live.nat[d].holds[i] = vs;
+     }
+     live.nat[d].nholds = live.nat[s].nholds;
+ 
+     live.nat[s].nholds = 0;
+ }
+ 
+ 
+ static __inline__ void make_exclusive (int r, int size, int spec)
+ {
+     int clobber;
+     reg_status oldstate;
+     int rr = live.state[r].realreg;
+     int nr;
+     int nind;
+     int ndirt = 0;
+     int i;
+ 
+     if (!isinreg (r))
+ 	return;
+     if (live.nat[rr].nholds == 1)
+ 	return;
+     for (i = 0; i < live.nat[rr].nholds; i++) {
+ 	int vr = live.nat[rr].holds[i];
+ 	if (vr != r && (live.state[vr].status == DIRTY || live.state[vr].val))
+ 	    ndirt++;
+     }
+     if (!ndirt && size < live.state[r].validsize && !live.nat[rr].locked) {
+ 	/* Everything else is clean, so let's keep this register */
+ 	for (i = 0; i < live.nat[rr].nholds; i++) {
+ 	    int vr = live.nat[rr].holds[i];
+ 	    if (vr != r) {
+ 		evict (vr);
+ 		i--;		/* Try that index again! */
+ 	    }
+ 	}
+ 	Dif (live.nat[rr].nholds != 1) {
+ 	    printf ("natreg %d holds %d vregs, %d not exclusive\n", rr, live.nat[rr].nholds, r);
+ 	    abort ();
+ 	}
+ 	return;
+     }
+ 
+     /* We have to split the register */
+     oldstate = live.state[r];
+ 
+     setlock (rr);		/* Make sure this doesn't go away */
+     /* Forget about r being in the register rr */
+     disassociate (r);
+     /* Get a new register, that we will clobber completely */
+     if (oldstate.status == DIRTY) {
+ 	/* If dirtysize is <4, we need a register that can handle the
+ 	   eventual smaller memory store! Thanks to Quake68k for exposing
+ 	   this detail ;-) */
+ 	nr = alloc_reg_hinted (r, oldstate.dirtysize, 1, spec);
+     } else {
+ 	nr = alloc_reg_hinted (r, 4, 1, spec);
+     }
+     nind = live.state[r].realind;
+     live.state[r] = oldstate;	/* Keep all the old state info */
+     live.state[r].realreg = nr;
+     live.state[r].realind = nind;
+ 
+     if (size < live.state[r].validsize) {
+ 	if (live.state[r].val) {
+ 	    /* Might as well compensate for the offset now */
+ 	    raw_lea_l_brr (nr, rr, oldstate.val);
+ 	    live.state[r].val = 0;
+ 	    live.state[r].dirtysize = 4;
+ 	    set_status (r, DIRTY);
+ 	} else
+ 	    raw_mov_l_rr (nr, rr);	/* Make another copy */
+     }
+     unlock (rr);
+ }
+ 
+ static __inline__ void add_offset (int r, uae_u32 off)
+ {
+     live.state[r].val += off;
+ }
+ 
+ static __inline__ void remove_offset (int r, int spec)
+ {
+     reg_status oldstate;
+     int rr;
+ 
+     if (isconst (r))
+ 	return;
+     if (live.state[r].val == 0)
+ 	return;
+     if (isinreg (r) && live.state[r].validsize < 4)
+ 	evict (r);
+ 
+     if (!isinreg (r))
+ 	alloc_reg_hinted (r, 4, 0, spec);
+ 
+     Dif (live.state[r].validsize != 4) {
+ 	printf ("Validsize=%d in remove_offset\n", live.state[r].validsize);
+ 	abort ();
+     }
+     make_exclusive (r, 0, -1);
+     /* make_exclusive might have done the job already */
+     if (live.state[r].val == 0)
+ 	return;
+ 
+     rr = live.state[r].realreg;
+ 
+     if (live.nat[rr].nholds == 1) {
+ 	//printf("RemovingB offset %x from reg %d (%d) at %p\n",
+ 	//       live.state[r].val,r,rr,target); 
+ 	adjust_nreg (rr, live.state[r].val);
+ 	live.state[r].dirtysize = 4;
+ 	live.state[r].val = 0;
+ 	set_status (r, DIRTY);
+ 	return;
+     }
+     printf ("Failed in remove_offset\n");
+     abort ();
+ }
+ 
+ STATIC_INLINE void remove_all_offsets (void)
+ {
+     int i;
+ 
+     for (i = 0; i < VREGS; i++)
+ 	remove_offset (i, -1);
+ }
+ 
+ static __inline__ int readreg_general (int r, int size, int spec, int can_offset)
+ {
+     int n;
+     int answer = -1;
+ 
+     if (live.state[r].status == UNDEF) {
+ 	printf ("WARNING: Unexpected read of undefined register %d\n", r);
+     }
+     if (!can_offset)
+ 	remove_offset (r, spec);
+ 
+     if (isinreg (r) && live.state[r].validsize >= size) {
+ 	n = live.state[r].realreg;
+ 	switch (size) {
+ 	case 1:
+ 	    if (live.nat[n].canbyte || spec >= 0) {
+ 		answer = n;
+ 	    }
+ 	    break;
+ 	case 2:
+ 	    if (live.nat[n].canword || spec >= 0) {
+ 		answer = n;
+ 	    }
+ 	    break;
+ 	case 4:
+ 	    answer = n;
+ 	    break;
+ 	default:
+ 	    abort ();
+ 	}
+ 	if (answer < 0)
+ 	    evict (r);
+     }
+     /* either the value was in memory to start with, or it was evicted and 
+        is in memory now */
+     if (answer < 0) {
+ 	answer = alloc_reg_hinted (r, spec >= 0 ? 4 : size, 0, spec);
+     }
+ 
+     if (spec >= 0 && spec != answer) {
+ 	/* Too bad */
+ 	mov_nregs (spec, answer);
+ 	answer = spec;
+     }
+     live.nat[answer].locked++;
+     live.nat[answer].touched = touchcnt++;
+     return answer;
+ }
+ 
+ static int readreg (int r, int size)
+ {
+     return readreg_general (r, size, -1, 0);
+ }
+ 
+ static int readreg_specific (int r, int size, int spec)
+ {
+     return readreg_general (r, size, spec, 0);
+ }
+ 
+ static int readreg_offset (int r, int size)
+ {
+     return readreg_general (r, size, -1, 1);
+ }
+ 
+ 
+ static __inline__ int writereg_general (int r, int size, int spec)
+ {
+     int n;
+     int answer = -1;
+ 
+     if (size < 4) {
+ 	remove_offset (r, spec);
+     }
+ 
+     make_exclusive (r, size, spec);
+     if (isinreg (r)) {
+ 	int nvsize = size > live.state[r].validsize ? size : live.state[r].validsize;
+ 	int ndsize = size > live.state[r].dirtysize ? size : live.state[r].dirtysize;
+ 	n = live.state[r].realreg;
+ 
+ 	Dif (live.nat[n].nholds != 1)
+ 	    abort ();
+ 	switch (size) {
+ 	case 1:
+ 	    if (live.nat[n].canbyte || spec >= 0) {
+ 		live.state[r].dirtysize = ndsize;
+ 		live.state[r].validsize = nvsize;
+ 		answer = n;
+ 	    }
+ 	    break;
+ 	case 2:
+ 	    if (live.nat[n].canword || spec >= 0) {
+ 		live.state[r].dirtysize = ndsize;
+ 		live.state[r].validsize = nvsize;
+ 		answer = n;
+ 	    }
+ 	    break;
+ 	case 4:
+ 	    live.state[r].dirtysize = ndsize;
+ 	    live.state[r].validsize = nvsize;
+ 	    answer = n;
+ 	    break;
+ 	default:
+ 	    abort ();
+ 	}
+ 	if (answer < 0)
+ 	    evict (r);
+     }
+     /* either the value was in memory to start with, or it was evicted and 
+        is in memory now */
+     if (answer < 0) {
+ 	answer = alloc_reg_hinted (r, size, 1, spec);
+     }
+     if (spec >= 0 && spec != answer) {
+ 	mov_nregs (spec, answer);
+ 	answer = spec;
+     }
+     if (live.state[r].status == UNDEF)
+ 	live.state[r].validsize = 4;
+     live.state[r].dirtysize = size > live.state[r].dirtysize ? size : live.state[r].dirtysize;
+     live.state[r].validsize = size > live.state[r].validsize ? size : live.state[r].validsize;
+ 
+     live.nat[answer].locked++;
+     live.nat[answer].touched = touchcnt++;
+     if (size == 4) {
+ 	live.state[r].val = 0;
+     } else {
+ 	Dif (live.state[r].val) {
+ 	    printf ("Problem with val\n");
+ 	    abort ();
+ 	}
+     }
+     set_status (r, DIRTY);
+     return answer;
+ }
+ 
+ static int writereg (int r, int size)
+ {
+     return writereg_general (r, size, -1);
+ }
+ 
+ static int writereg_specific (int r, int size, int spec)
+ {
+     return writereg_general (r, size, spec);
+ }
+ 
+ static __inline__ int rmw_general (int r, int wsize, int rsize, int spec)
+ {
+     int n;
+     int answer = -1;
+ 
+     if (live.state[r].status == UNDEF) {
+ 	printf ("WARNING: Unexpected read of undefined register %d\n", r);
+     }
+     remove_offset (r, spec);
+     make_exclusive (r, 0, spec);
+ 
+     Dif (wsize < rsize) {
+ 	printf ("Cannot handle wsize<rsize in rmw_general()\n");
+ 	abort ();
+     }
+     if (isinreg (r) && live.state[r].validsize >= rsize) {
+ 	n = live.state[r].realreg;
+ 	Dif (live.nat[n].nholds != 1)
+ 	    abort ();
+ 
+ 	switch (rsize) {
+ 	case 1:
+ 	    if (live.nat[n].canbyte || spec >= 0) {
+ 		answer = n;
+ 	    }
+ 	    break;
+ 	case 2:
+ 	    if (live.nat[n].canword || spec >= 0) {
+ 		answer = n;
+ 	    }
+ 	    break;
+ 	case 4:
+ 	    answer = n;
+ 	    break;
+ 	default:
+ 	    abort ();
+ 	}
+ 	if (answer < 0)
+ 	    evict (r);
+     }
+     /* either the value was in memory to start with, or it was evicted and 
+        is in memory now */
+     if (answer < 0) {
+ 	answer = alloc_reg_hinted (r, spec >= 0 ? 4 : rsize, 0, spec);
+     }
+ 
+     if (spec >= 0 && spec != answer) {
+ 	/* Too bad */
+ 	mov_nregs (spec, answer);
+ 	answer = spec;
+     }
+     if (wsize > live.state[r].dirtysize)
+ 	live.state[r].dirtysize = wsize;
+     if (wsize > live.state[r].validsize)
+ 	live.state[r].validsize = wsize;
+     set_status (r, DIRTY);
+ 
+     live.nat[answer].locked++;
+     live.nat[answer].touched = touchcnt++;
+ 
+     Dif (live.state[r].val) {
+ 	printf ("Problem with val(rmw)\n");
+ 	abort ();
+     }
+     return answer;
+ }
+ 
+ static int rmw (int r, int wsize, int rsize)
+ {
+     return rmw_general (r, wsize, rsize, -1);
+ }
+ 
+ static int rmw_specific (int r, int wsize, int rsize, int spec)
+ {
+     return rmw_general (r, wsize, rsize, spec);
+ }
+ 
+ 
+ /* needed for restoring the carry flag on non-P6 cores */
+ static void bt_l_ri_noclobber (R4 r, IMM i)
+ {
+     int size = 4;
+     if (i < 16)
+ 	size = 2;
+     r = readreg (r, size);
+     raw_bt_l_ri (r, i);
+     unlock (r);
+ }
+ 
+ /********************************************************************
+  * FPU register status handling. EMIT TIME!                         *
+  ********************************************************************/
+ 
+ static void f_tomem (int r)
+ {
+     if (live.fate[r].status == DIRTY) {
+ #if USE_LONG_DOUBLE
+ 	raw_fmov_ext_mr ((uae_u32) live.fate[r].mem, live.fate[r].realreg);
+ #else
+ 	raw_fmov_mr ((uae_u32) live.fate[r].mem, live.fate[r].realreg);
+ #endif
+ 	live.fate[r].status = CLEAN;
+     }
+ }
+ 
+ static void f_tomem_drop (int r)
+ {
+     if (live.fate[r].status == DIRTY) {
+ #if USE_LONG_DOUBLE
+ 	raw_fmov_ext_mr_drop ((uae_u32) live.fate[r].mem, live.fate[r].realreg);
+ #else
+ 	raw_fmov_mr_drop ((uae_u32) live.fate[r].mem, live.fate[r].realreg);
+ #endif
+ 	live.fate[r].status = INMEM;
+     }
+ }
+ 
+ 
+ static __inline__ int f_isinreg (int r)
+ {
+     return live.fate[r].status == CLEAN || live.fate[r].status == DIRTY;
+ }
+ 
+ static void f_evict (int r)
+ {
+     int rr;
+ 
+     if (!f_isinreg (r))
+ 	return;
+     rr = live.fate[r].realreg;
+     if (live.fat[rr].nholds == 1)
+ 	f_tomem_drop (r);
+     else
+ 	f_tomem (r);
+ 
+     Dif (live.fat[rr].locked && live.fat[rr].nholds == 1) {
+ 	fprintf (stderr, "FPU register %d in nreg %d is locked!\n", r, live.fate[r].realreg);
+ 	abort ();
+     }
+ 
+     live.fat[rr].nholds--;
+     if (live.fat[rr].nholds != live.fate[r].realind) {	/* Was not last */
+ 	int topreg = live.fat[rr].holds[live.fat[rr].nholds];
+ 	int thisind = live.fate[r].realind;
+ 	live.fat[rr].holds[thisind] = topreg;
+ 	live.fate[topreg].realind = thisind;
+     }
+     live.fate[r].status = INMEM;
+     live.fate[r].realreg = -1;
+ }
+ 
+ static __inline__ void f_free_nreg (int r)
+ {
+     int i = live.fat[r].nholds;
+ 
+     while (i) {
+ 	int vr;
+ 
+ 	--i;
+ 	vr = live.fat[r].holds[i];
+ 	f_evict (vr);
+     }
+     Dif (live.fat[r].nholds != 0) {
+ 	printf ("Failed to free nreg %d, nholds is %d\n", r, live.fat[r].nholds);
+ 	abort ();
+     }
+ }
+ 
+ 
+ /* Use with care! */
+ static __inline__ void f_isclean (int r)
+ {
+     if (!f_isinreg (r))
+ 	return;
+     live.fate[r].status = CLEAN;
+ }
+ 
+ static __inline__ void f_disassociate (int r)
+ {
+     f_isclean (r);
+     f_evict (r);
+ }
+ 
+ 
+ 
+ static int f_alloc_reg (int r, int willclobber)
+ {
+     int bestreg;
+     uae_s32 when;
+     int i;
+     uae_s32 badness;
+     bestreg = -1;
+     when = 2000000000;
+     for (i = N_FREGS; i--;) {
+ 	badness = live.fat[i].touched;
+ 	if (live.fat[i].nholds == 0)
+ 	    badness = 0;
+ 
+ 	if (!live.fat[i].locked && badness < when) {
+ 	    bestreg = i;
+ 	    when = badness;
+ 	    if (live.fat[i].nholds == 0)
+ 		break;
+ 	}
+     }
+     Dif (bestreg == -1)
+ 	abort ();
+ 
+     if (live.fat[bestreg].nholds > 0) {
+ 	f_free_nreg (bestreg);
+     }
+     if (f_isinreg (r)) {
+ 	f_evict (r);
+     }
+ 
+     if (!willclobber) {
+ 	if (live.fate[r].status != UNDEF) {
+ #if USE_LONG_DOUBLE
+ 	    raw_fmov_ext_rm (bestreg, (uae_u32) live.fate[r].mem);
+ #else
+ 	    raw_fmov_rm (bestreg, (uae_u32) live.fate[r].mem);
+ #endif
+ 	}
+ 	live.fate[r].status = CLEAN;
+     } else {
+ 	live.fate[r].status = DIRTY;
+     }
+     live.fate[r].realreg = bestreg;
+     live.fate[r].realind = live.fat[bestreg].nholds;
+     live.fat[bestreg].touched = touchcnt++;
+     live.fat[bestreg].holds[live.fat[bestreg].nholds] = r;
+     live.fat[bestreg].nholds++;
+ 
+     return bestreg;
+ }
+ 
+ static void f_unlock (int r)
+ {
+     Dif (!live.fat[r].locked)
+ 	abort ();
+     live.fat[r].locked--;
+ }
+ 
+ static void f_setlock (int r)
+ {
+     live.fat[r].locked++;
+ }
+ 
+ static __inline__ int f_readreg (int r)
+ {
+     int n;
+     int answer = -1;
+ 
+     if (f_isinreg (r)) {
+ 	n = live.fate[r].realreg;
+ 	answer = n;
+     }
+     /* either the value was in memory to start with, or it was evicted and 
+        is in memory now */
+     if (answer < 0)
+ 	answer = f_alloc_reg (r, 0);
+ 
+     live.fat[answer].locked++;
+     live.fat[answer].touched = touchcnt++;
+     return answer;
+ }
+ 
+ static __inline__ void f_make_exclusive (int r, int clobber)
+ {
+     freg_status oldstate;
+     int rr = live.fate[r].realreg;
+     int nr;
+     int nind;
+     int ndirt = 0;
+     int i;
+ 
+     if (!f_isinreg (r))
+ 	return;
+     if (live.fat[rr].nholds == 1)
+ 	return;
+     for (i = 0; i < live.fat[rr].nholds; i++) {
+ 	int vr = live.fat[rr].holds[i];
+ 	if (vr != r && live.fate[vr].status == DIRTY)
+ 	    ndirt++;
+     }
+     if (!ndirt && !live.fat[rr].locked) {
+ 	/* Everything else is clean, so let's keep this register */
+ 	for (i = 0; i < live.fat[rr].nholds; i++) {
+ 	    int vr = live.fat[rr].holds[i];
+ 	    if (vr != r) {
+ 		f_evict (vr);
+ 		i--;		/* Try that index again! */
+ 	    }
+ 	}
+ 	Dif (live.fat[rr].nholds != 1) {
+ 	    printf ("realreg %d holds %d (", rr, live.fat[rr].nholds);
+ 	    for (i = 0; i < live.fat[rr].nholds; i++) {
+ 		printf (" %d(%d,%d)", live.fat[rr].holds[i],
+ 			live.fate[live.fat[rr].holds[i]].realreg, live.fate[live.fat[rr].holds[i]].realind);
+ 	    }
+ 	    printf ("\n");
+ 	    abort ();
+ 	}
+ 	return;
+     }
+ 
+     /* We have to split the register */
+     oldstate = live.fate[r];
+ 
+     f_setlock (rr);		/* Make sure this doesn't go away */
+     /* Forget about r being in the register rr */
+     f_disassociate (r);
+     /* Get a new register, that we will clobber completely */
+     nr = f_alloc_reg (r, 1);
+     nind = live.fate[r].realind;
+     if (!clobber)
+ 	raw_fmov_rr (nr, rr);	/* Make another copy */
+     live.fate[r] = oldstate;	/* Keep all the old state info */
+     live.fate[r].realreg = nr;
+     live.fate[r].realind = nind;
+     f_unlock (rr);
+ }
+ 
+ 
+ static __inline__ int f_writereg (int r)
+ {
+     int n;
+     int answer = -1;
+ 
+     f_make_exclusive (r, 1);
+     if (f_isinreg (r)) {
+ 	n = live.fate[r].realreg;
+ 	answer = n;
+     }
+     if (answer < 0) {
+ 	answer = f_alloc_reg (r, 1);
+     }
+     live.fate[r].status = DIRTY;
+     live.fat[answer].locked++;
+     live.fat[answer].touched = touchcnt++;
+     return answer;
+ }
+ 
+ static int f_rmw (int r)
+ {
+     int n;
+ 
+     f_make_exclusive (r, 0);
+     if (f_isinreg (r)) {
+ 	n = live.fate[r].realreg;
+     } else
+ 	n = f_alloc_reg (r, 0);
+     live.fate[r].status = DIRTY;
+     live.fat[n].locked++;
+     live.fat[n].touched = touchcnt++;
+     return n;
+ }
+ 
+ static void fflags_into_flags_internal (uae_u32 tmp)
+ {
+     int r;
+ 
+     clobber_flags ();
+     r = f_readreg (FP_RESULT);
+     raw_fflags_into_flags (r);
+     f_unlock (r);
+ }
+ 
+ 
+ 
+ 
+ /********************************************************************
+  * CPU functions exposed to gencomp. Both CREATE and EMIT time      *
+  ********************************************************************/
+ 
+ /* 
+  *  RULES FOR HANDLING REGISTERS:
+  *
+  *  * In the function headers, order the parameters 
+  *     - 1st registers written to
+  *     - 2nd read/modify/write registers
+  *     - 3rd registers read from
+  *  * Before calling raw_*, you must call readreg, writereg or rmw for
+  *    each register
+  *  * The order for this is
+  *     - 1st call remove_offset for all registers written to with size<4
+  *     - 2nd call readreg for all registers read without offset
+  *     - 3rd call rmw for all rmw registers
+  *     - 4th call readreg_offset for all registers that can handle offsets
+  *     - 5th call get_offset for all the registers from the previous step
+  *     - 6th call writereg for all written-to registers
+  *     - 7th call raw_*
+  *     - 8th unlock all registers that were locked
+  */
+ 
+ MIDFUNC (0, live_flags, (void))
+ {
+     live.flags_on_stack = TRASH;
+     live.flags_in_flags = VALID;
+     live.flags_are_important = 1;
+ }
+ MENDFUNC (0, live_flags, (void))
+ 
+ MIDFUNC (0, dont_care_flags, (void))
+ {
+     live.flags_are_important = 0;
+ }
+ MENDFUNC (0, dont_care_flags, (void))
+ 
+ 
+ MIDFUNC (0, duplicate_carry, (void))
+ {
+     evict (FLAGX);
+     make_flags_live_internal ();
+     COMPCALL (setcc_m) ((uae_u32) live.state[FLAGX].mem, 2);
+ }
+ MENDFUNC (0, duplicate_carry, (void))
+ 
+ MIDFUNC (0, restore_carry, (void))
+ {
+     if (!have_rat_stall) {	/* Not a P6 core, i.e. no partial stalls */
+ 	bt_l_ri_noclobber (FLAGX, 0);
+     } else {			/* Avoid the stall the above creates.
+ 				   This is slow on non-P6, though.
+ 				 */
+ 	COMPCALL (rol_b_ri (FLAGX, 8));
+ 	isclean (FLAGX);
+ 	/* Why is the above faster than the below? */
+ 	//raw_rol_b_mi((uae_u32)live.state[FLAGX].mem,8);
+     }
+ }
+ MENDFUNC (0, restore_carry, (void))
+ 
+ MIDFUNC (0, start_needflags, (void))
+ {
+     needflags = 1;
+ }
+ MENDFUNC (0, start_needflags, (void))
+ 
+ MIDFUNC (0, end_needflags, (void))
+ {
+     needflags = 0;
+ }
+ MENDFUNC (0, end_needflags, (void))
+ 
+ MIDFUNC (0, make_flags_live, (void))
+ {
+     make_flags_live_internal ();
+ }
+ MENDFUNC (0, make_flags_live, (void))
+ 
+ MIDFUNC (1, fflags_into_flags, (W2 tmp))
+ {
+     clobber_flags ();
+     fflags_into_flags_internal (tmp);
+ }
+ MENDFUNC (1, fflags_into_flags, (W2 tmp))
+ 
+ 
+ MIDFUNC (2, bt_l_ri, (R4 r, IMM i))
+ {				/* This is defined as only affecting C */
+     int size = 4;
+     if (i < 16)
+ 	size = 2;
+     CLOBBER_BT;
+     r = readreg (r, size);
+     raw_bt_l_ri (r, i);
+     unlock (r);
+ }
+ MENDFUNC (2, bt_l_ri, (R4 r, IMM i))
+     /* This is defined as only affecting C */
+ MIDFUNC (2, bt_l_rr, (R4 r, R4 b))
+ {				/* This is defined as only affecting C */
+     CLOBBER_BT;
+     r = readreg (r, 4);
+     b = readreg (b, 4);
+     raw_bt_l_rr (r, b);
+     unlock (r);
+     unlock (b);
+ }
+ MENDFUNC (2, bt_l_rr, (R4 r, R4 b))
+     /* This is defined as only affecting C */
+ MIDFUNC (2, btc_l_ri, (RW4 r, IMM i))
+ {
+     int size = 4;
+     if (i < 16)
+ 	size = 2;
+     CLOBBER_BT;
+     r = rmw (r, size, size);
+     raw_btc_l_ri (r, i);
+     unlock (r);
+ }
+ MENDFUNC (2, btc_l_ri, (RW4 r, IMM i))
+ 
+ MIDFUNC (2, btc_l_rr, (RW4 r, R4 b))
+ {
+     CLOBBER_BT;
+     b = readreg (b, 4);
+     r = rmw (r, 4, 4);
+     raw_btc_l_rr (r, b);
+     unlock (r);
+     unlock (b);
+ }
+ MENDFUNC (2, btc_l_rr, (RW4 r, R4 b))
+ 
+ 
+ MIDFUNC (2, btr_l_ri, (RW4 r, IMM i))
+ {
+     int size = 4;
+     if (i < 16)
+ 	size = 2;
+     CLOBBER_BT;
+     r = rmw (r, size, size);
+     raw_btr_l_ri (r, i);
+     unlock (r);
+ }
+ MENDFUNC (2, btr_l_ri, (RW4 r, IMM i))
+ 
+ MIDFUNC (2, btr_l_rr, (RW4 r, R4 b))
+ {
+     CLOBBER_BT;
+     b = readreg (b, 4);
+     r = rmw (r, 4, 4);
+     raw_btr_l_rr (r, b);
+     unlock (r);
+     unlock (b);
+ }
+ MENDFUNC (2, btr_l_rr, (RW4 r, R4 b))
+ 
+ 
+ MIDFUNC (2, bts_l_ri, (RW4 r, IMM i))
+ {
+     int size = 4;
+     if (i < 16)
+ 	size = 2;
+     CLOBBER_BT;
+     r = rmw (r, size, size);
+     raw_bts_l_ri (r, i);
+     unlock (r);
+ }
+ MENDFUNC (2, bts_l_ri, (RW4 r, IMM i))
+ 
+ MIDFUNC (2, bts_l_rr, (RW4 r, R4 b))
+ {
+     CLOBBER_BT;
+     b = readreg (b, 4);
+     r = rmw (r, 4, 4);
+     raw_bts_l_rr (r, b);
+     unlock (r);
+     unlock (b);
+ }
+ MENDFUNC (2, bts_l_rr, (RW4 r, R4 b))
+ 
+ MIDFUNC (2, mov_l_rm, (W4 d, IMM s))
+ {
+     CLOBBER_MOV;
+     d = writereg (d, 4);
+     raw_mov_l_rm (d, s);
+     unlock (d);
+ }
+ MENDFUNC (2, mov_l_rm, (W4 d, IMM s))
+ 
+ 
+ MIDFUNC (1, call_r, (R4 r))
+ {				/* Clobbering is implicit */
+     r = readreg (r, 4);
+     raw_call_r (r);
+     unlock (r);
+ }
+ MENDFUNC (1, call_r, (R4 r))
+     /* Clobbering is implicit */
+ MIDFUNC (2, sub_l_mi, (IMM d, IMM s))
+ {
+     CLOBBER_SUB;
+     raw_sub_l_mi (d, s);
+ }
+ MENDFUNC (2, sub_l_mi, (IMM d, IMM s))
+ 
+ MIDFUNC (2, mov_l_mi, (IMM d, IMM s))
+ {
+     CLOBBER_MOV;
+     raw_mov_l_mi (d, s);
+ }
+ MENDFUNC (2, mov_l_mi, (IMM d, IMM s))
+ 
+ MIDFUNC (2, mov_w_mi, (IMM d, IMM s))
+ {
+     CLOBBER_MOV;
+     raw_mov_w_mi (d, s);
+ }
+ MENDFUNC (2, mov_w_mi, (IMM d, IMM s))
+ 
+ MIDFUNC (2, mov_b_mi, (IMM d, IMM s))
+ {
+     CLOBBER_MOV;
+     raw_mov_b_mi (d, s);
+ }
+ MENDFUNC (2, mov_b_mi, (IMM d, IMM s))
+ 
+ MIDFUNC (2, rol_b_ri, (RW1 r, IMM i))
+ {
+     CLOBBER_ROL;
+     r = rmw (r, 1, 1);
+     raw_rol_b_ri (r, i);
+     unlock (r);
+ }
+ MENDFUNC (2, rol_b_ri, (RW1 r, IMM i))
+ 
+ MIDFUNC (2, rol_w_ri, (RW2 r, IMM i))
+ {
+     CLOBBER_ROL;
+     r = rmw (r, 2, 2);
+     raw_rol_w_ri (r, i);
+     unlock (r);
+ }
+ MENDFUNC (2, rol_w_ri, (RW2 r, IMM i))
+ 
+ MIDFUNC (2, rol_l_ri, (RW4 r, IMM i))
+ {
+     CLOBBER_ROL;
+     r = rmw (r, 4, 4);
+     raw_rol_l_ri (r, i);
+     unlock (r);
+ }
+ MENDFUNC (2, rol_l_ri, (RW4 r, IMM i))
+ 
+ MIDFUNC (2, rol_l_rr, (RW4 d, R1 r))
+ {
+     if (isconst (r)) {
+ 	COMPCALL (rol_l_ri) (d, (uae_u8) live.state[r].val);
+ 	return;
+     }
+     CLOBBER_ROL;
+     r = readreg_specific (r, 1, SHIFTCOUNT_NREG);
+     d = rmw (d, 4, 4);
+     Dif (r != 1) {
+ 	fprintf (stderr, "Illegal register %d in raw_rol_b\n", r);
+ 	abort ();
+     }
+     raw_rol_l_rr (d, r);
+     unlock (r);
+     unlock (d);
+ }
+ MENDFUNC (2, rol_l_rr, (RW4 d, R1 r))
+ 
+ MIDFUNC (2, rol_w_rr, (RW2 d, R1 r))
+ {				/* Can only do this with r==1, i.e. cl */
+ 
+     if (isconst (r)) {
+ 	COMPCALL (rol_w_ri) (d, (uae_u8) live.state[r].val);
+ 	return;
+     }
+     CLOBBER_ROL;
+     r = readreg_specific (r, 1, SHIFTCOUNT_NREG);
+     d = rmw (d, 2, 2);
+     Dif (r != 1) {
+ 	fprintf (stderr, "Illegal register %d in raw_rol_b\n", r);
+ 	abort ();
+     }
+     raw_rol_w_rr (d, r);
+     unlock (r);
+     unlock (d);
+ }
+ MENDFUNC (2, rol_w_rr, (RW2 d, R1 r))
+ 
+ MIDFUNC (2, rol_b_rr, (RW1 d, R1 r))
+ {				/* Can only do this with r==1, i.e. cl */
+ 
+     if (isconst (r)) {
+ 	COMPCALL (rol_b_ri) (d, (uae_u8) live.state[r].val);
+ 	return;
+     }
+ 
+     CLOBBER_ROL;
+     r = readreg_specific (r, 1, SHIFTCOUNT_NREG);
+     d = rmw (d, 1, 1);
+     Dif (r != 1) {
+ 	fprintf (stderr, "Illegal register %d in raw_rol_b\n", r);
+ 	abort ();
+     }
+     raw_rol_b_rr (d, r);
+     unlock (r);
+     unlock (d);
+ }
+ MENDFUNC (2, rol_b_rr, (RW1 d, R1 r))
+ 
+ 
+ MIDFUNC (2, shll_l_rr, (RW4 d, R1 r))
+ {
+     if (isconst (r)) {
+ 	COMPCALL (shll_l_ri) (d, (uae_u8) live.state[r].val);
+ 	return;
+     }
+     CLOBBER_SHLL;
+     r = readreg_specific (r, 1, SHIFTCOUNT_NREG);
+     d = rmw (d, 4, 4);
+     Dif (r != 1) {
+ 	fprintf (stderr, "Illegal register %d in raw_rol_b\n", r);
+ 	abort ();
+     }
+     raw_shll_l_rr (d, r);
+     unlock (r);
+     unlock (d);
+ }
+ MENDFUNC (2, shll_l_rr, (RW4 d, R1 r))
+ 
+ MIDFUNC (2, shll_w_rr, (RW2 d, R1 r))
+ {				/* Can only do this with r==1, i.e. cl */
+ 
+     if (isconst (r)) {
+ 	COMPCALL (shll_w_ri) (d, (uae_u8) live.state[r].val);
+ 	return;
+     }
+     CLOBBER_SHLL;
+     r = readreg_specific (r, 1, SHIFTCOUNT_NREG);
+     d = rmw (d, 2, 2);
+     Dif (r != 1) {
+ 	fprintf (stderr, "Illegal register %d in raw_shll_b\n", r);
+ 	abort ();
+     }
+     raw_shll_w_rr (d, r);
+     unlock (r);
+     unlock (d);
+ }
+ MENDFUNC (2, shll_w_rr, (RW2 d, R1 r))
+ 
+ MIDFUNC (2, shll_b_rr, (RW1 d, R1 r))
+ {				/* Can only do this with r==1, i.e. cl */
+ 
+     if (isconst (r)) {
+ 	COMPCALL (shll_b_ri) (d, (uae_u8) live.state[r].val);
+ 	return;
+     }
+ 
+     CLOBBER_SHLL;
+     r = readreg_specific (r, 1, SHIFTCOUNT_NREG);
+     d = rmw (d, 1, 1);
+     Dif (r != 1) {
+ 	fprintf (stderr, "Illegal register %d in raw_shll_b\n", r);
+ 	abort ();
+     }
+     raw_shll_b_rr (d, r);
+     unlock (r);
+     unlock (d);
+ }
+ MENDFUNC (2, shll_b_rr, (RW1 d, R1 r))
+ 
+ 
+ MIDFUNC (2, ror_b_ri, (R1 r, IMM i))
+ {
+     CLOBBER_ROR;
+     r = rmw (r, 1, 1);
+     raw_ror_b_ri (r, i);
+     unlock (r);
+ }
+ MENDFUNC (2, ror_b_ri, (R1 r, IMM i))
+ 
+ MIDFUNC (2, ror_w_ri, (R2 r, IMM i))
+ {
+     CLOBBER_ROR;
+     r = rmw (r, 2, 2);
+     raw_ror_w_ri (r, i);
+     unlock (r);
+ }
+ MENDFUNC (2, ror_w_ri, (R2 r, IMM i))
+ 
+ MIDFUNC (2, ror_l_ri, (R4 r, IMM i))
+ {
+     CLOBBER_ROR;
+     r = rmw (r, 4, 4);
+     raw_ror_l_ri (r, i);
+     unlock (r);
+ }
+ MENDFUNC (2, ror_l_ri, (R4 r, IMM i))
+ 
+ MIDFUNC (2, ror_l_rr, (R4 d, R1 r))
+ {
+     if (isconst (r)) {
+ 	COMPCALL (ror_l_ri) (d, (uae_u8) live.state[r].val);
+ 	return;
+     }
+     CLOBBER_ROR;
+     r = readreg_specific (r, 1, SHIFTCOUNT_NREG);
+     d = rmw (d, 4, 4);
+     raw_ror_l_rr (d, r);
+     unlock (r);
+     unlock (d);
+ }
+ MENDFUNC (2, ror_l_rr, (R4 d, R1 r))
+ 
+ MIDFUNC (2, ror_w_rr, (R2 d, R1 r))
+ {
+     if (isconst (r)) {
+ 	COMPCALL (ror_w_ri) (d, (uae_u8) live.state[r].val);
+ 	return;
+     }
+     CLOBBER_ROR;
+     r = readreg_specific (r, 1, SHIFTCOUNT_NREG);
+     d = rmw (d, 2, 2);
+     raw_ror_w_rr (d, r);
+     unlock (r);
+     unlock (d);
+ }
+ MENDFUNC (2, ror_w_rr, (R2 d, R1 r))
+ 
+ MIDFUNC (2, ror_b_rr, (R1 d, R1 r))
+ {
+     if (isconst (r)) {
+ 	COMPCALL (ror_b_ri) (d, (uae_u8) live.state[r].val);
+ 	return;
+     }
+ 
+     CLOBBER_ROR;
+     r = readreg_specific (r, 1, SHIFTCOUNT_NREG);
+     d = rmw (d, 1, 1);
+     raw_ror_b_rr (d, r);
+     unlock (r);
+     unlock (d);
+ }
+ MENDFUNC (2, ror_b_rr, (R1 d, R1 r))
+ 
+ MIDFUNC (2, shrl_l_rr, (RW4 d, R1 r))
+ {
+     if (isconst (r)) {
+ 	COMPCALL (shrl_l_ri) (d, (uae_u8) live.state[r].val);
+ 	return;
+     }
+     CLOBBER_SHRL;
+     r = readreg_specific (r, 1, SHIFTCOUNT_NREG);
+     d = rmw (d, 4, 4);
+     Dif (r != 1) {
+ 	fprintf (stderr, "Illegal register %d in raw_rol_b\n", r);
+ 	abort ();
+     }
+     raw_shrl_l_rr (d, r);
+     unlock (r);
+     unlock (d);
+ }
+ MENDFUNC (2, shrl_l_rr, (RW4 d, R1 r))
+ 
+ MIDFUNC (2, shrl_w_rr, (RW2 d, R1 r))
+ {				/* Can only do this with r==1, i.e. cl */
+ 
+     if (isconst (r)) {
+ 	COMPCALL (shrl_w_ri) (d, (uae_u8) live.state[r].val);
+ 	return;
+     }
+     CLOBBER_SHRL;
+     r = readreg_specific (r, 1, SHIFTCOUNT_NREG);
+     d = rmw (d, 2, 2);
+     Dif (r != 1) {
+ 	fprintf (stderr, "Illegal register %d in raw_shrl_b\n", r);
+ 	abort ();
+     }
+     raw_shrl_w_rr (d, r);
+     unlock (r);
+     unlock (d);
+ }
+ MENDFUNC (2, shrl_w_rr, (RW2 d, R1 r))
+ 
+ MIDFUNC (2, shrl_b_rr, (RW1 d, R1 r))
+ {				/* Can only do this with r==1, i.e. cl */
+ 
+     if (isconst (r)) {
+ 	COMPCALL (shrl_b_ri) (d, (uae_u8) live.state[r].val);
+ 	return;
+     }
+ 
+     CLOBBER_SHRL;
+     r = readreg_specific (r, 1, SHIFTCOUNT_NREG);
+     d = rmw (d, 1, 1);
+     Dif (r != 1) {
+ 	fprintf (stderr, "Illegal register %d in raw_shrl_b\n", r);
+ 	abort ();
+     }
+     raw_shrl_b_rr (d, r);
+     unlock (r);
+     unlock (d);
+ }
+ MENDFUNC (2, shrl_b_rr, (RW1 d, R1 r))
+ 
+ 
+ 
+ MIDFUNC (2, shll_l_ri, (RW4 r, IMM i))
+ {
+     if (!i && !needflags)
+ 	return;
+     if (isconst (r) && !needflags) {
+ 	live.state[r].val <<= i;
+ 	return;
+     }
+     CLOBBER_SHLL;
+     r = rmw (r, 4, 4);
+     raw_shll_l_ri (r, i);
+     unlock (r);
+ }
+ MENDFUNC (2, shll_l_ri, (RW4 r, IMM i))
+ 
+ MIDFUNC (2, shll_w_ri, (RW2 r, IMM i))
+ {
+     if (!i && !needflags)
+ 	return;
+     CLOBBER_SHLL;
+     r = rmw (r, 2, 2);
+     raw_shll_w_ri (r, i);
+     unlock (r);
+ }
+ MENDFUNC (2, shll_w_ri, (RW2 r, IMM i))
+ 
+ MIDFUNC (2, shll_b_ri, (RW1 r, IMM i))
+ {
+     if (!i && !needflags)
+ 	return;
+     CLOBBER_SHLL;
+     r = rmw (r, 1, 1);
+     raw_shll_b_ri (r, i);
+     unlock (r);
+ }
+ MENDFUNC (2, shll_b_ri, (RW1 r, IMM i))
+ 
+ MIDFUNC (2, shrl_l_ri, (RW4 r, IMM i))
+ {
+     if (!i && !needflags)
+ 	return;
+     if (isconst (r) && !needflags) {
+ 	live.state[r].val >>= i;
+ 	return;
+     }
+     CLOBBER_SHRL;
+     r = rmw (r, 4, 4);
+     raw_shrl_l_ri (r, i);
+     unlock (r);
+ }
+ MENDFUNC (2, shrl_l_ri, (RW4 r, IMM i))
+ 
+ MIDFUNC (2, shrl_w_ri, (RW2 r, IMM i))
+ {
+     if (!i && !needflags)
+ 	return;
+     CLOBBER_SHRL;
+     r = rmw (r, 2, 2);
+     raw_shrl_w_ri (r, i);
+     unlock (r);
+ }
+ MENDFUNC (2, shrl_w_ri, (RW2 r, IMM i))
+ 
+ MIDFUNC (2, shrl_b_ri, (RW1 r, IMM i))
+ {
+     if (!i && !needflags)
+ 	return;
+     CLOBBER_SHRL;
+     r = rmw (r, 1, 1);
+     raw_shrl_b_ri (r, i);
+     unlock (r);
+ }
+ MENDFUNC (2, shrl_b_ri, (RW1 r, IMM i))
+ 
+ MIDFUNC (2, shra_l_ri, (RW4 r, IMM i))
+ {
+     if (!i && !needflags)
+ 	return;
+     CLOBBER_SHRA;
+     r = rmw (r, 4, 4);
+     raw_shra_l_ri (r, i);
+     unlock (r);
+ }
+ MENDFUNC (2, shra_l_ri, (RW4 r, IMM i))
+ 
+ MIDFUNC (2, shra_w_ri, (RW2 r, IMM i))
+ {
+     if (!i && !needflags)
+ 	return;
+     CLOBBER_SHRA;
+     r = rmw (r, 2, 2);
+     raw_shra_w_ri (r, i);
+     unlock (r);
+ }
+ MENDFUNC (2, shra_w_ri, (RW2 r, IMM i))
+ 
+ MIDFUNC (2, shra_b_ri, (RW1 r, IMM i))
+ {
+     if (!i && !needflags)
+ 	return;
+     CLOBBER_SHRA;
+     r = rmw (r, 1, 1);
+     raw_shra_b_ri (r, i);
+     unlock (r);
+ }
+ MENDFUNC (2, shra_b_ri, (RW1 r, IMM i))
+ 
+ MIDFUNC (2, shra_l_rr, (RW4 d, R1 r))
+ {
+     if (isconst (r)) {
+ 	COMPCALL (shra_l_ri) (d, (uae_u8) live.state[r].val);
+ 	return;
+     }
+     CLOBBER_SHRA;
+     r = readreg_specific (r, 1, SHIFTCOUNT_NREG);
+     d = rmw (d, 4, 4);
+     Dif (r != 1) {
+ 	fprintf (stderr, "Illegal register %d in raw_rol_b\n", r);
+ 	abort ();
+     }
+     raw_shra_l_rr (d, r);
+     unlock (r);
+     unlock (d);
+ }
+ MENDFUNC (2, shra_l_rr, (RW4 d, R1 r))
+ 
+ MIDFUNC (2, shra_w_rr, (RW2 d, R1 r))
+ {				/* Can only do this with r==1, i.e. cl */
+ 
+     if (isconst (r)) {
+ 	COMPCALL (shra_w_ri) (d, (uae_u8) live.state[r].val);
+ 	return;
+     }
+     CLOBBER_SHRA;
+     r = readreg_specific (r, 1, SHIFTCOUNT_NREG);
+     d = rmw (d, 2, 2);
+     Dif (r != 1) {
+ 	fprintf (stderr, "Illegal register %d in raw_shra_b\n", r);
+ 	abort ();
+     }
+     raw_shra_w_rr (d, r);
+     unlock (r);
+     unlock (d);
+ }
+ MENDFUNC (2, shra_w_rr, (RW2 d, R1 r))
+ 
+ MIDFUNC (2, shra_b_rr, (RW1 d, R1 r))
+ {				/* Can only do this with r==1, i.e. cl */
+ 
+     if (isconst (r)) {
+ 	COMPCALL (shra_b_ri) (d, (uae_u8) live.state[r].val);
+ 	return;
+     }
+ 
+     CLOBBER_SHRA;
+     r = readreg_specific (r, 1, SHIFTCOUNT_NREG);
+     d = rmw (d, 1, 1);
+     Dif (r != 1) {
+ 	fprintf (stderr, "Illegal register %d in raw_shra_b\n", r);
+ 	abort ();
+     }
+     raw_shra_b_rr (d, r);
+     unlock (r);
+     unlock (d);
+ }
+ MENDFUNC (2, shra_b_rr, (RW1 d, R1 r))
+ 
+ 
+ MIDFUNC (2, setcc, (W1 d, IMM cc))
+ {
+     CLOBBER_SETCC;
+     d = writereg (d, 1);
+     raw_setcc (d, cc);
+     unlock (d);
+ }
+ MENDFUNC (2, setcc, (W1 d, IMM cc))
+ 
+ MIDFUNC (2, setcc_m, (IMM d, IMM cc))
+ {
+     CLOBBER_SETCC;
+     raw_setcc_m (d, cc);
+ }
+ MENDFUNC (2, setcc_m, (IMM d, IMM cc))
+ 
+ MIDFUNC (3, cmov_l_rr, (RW4 d, R4 s, IMM cc))
+ {
+     if (d == s)
+ 	return;
+     CLOBBER_CMOV;
+     s = readreg (s, 4);
+     d = rmw (d, 4, 4);
+     raw_cmov_l_rr (d, s, cc);
+     unlock (s);
+     unlock (d);
+ }
+ MENDFUNC (3, cmov_l_rr, (RW4 d, R4 s, IMM cc))
+ 
+ MIDFUNC (3, cmov_l_rm, (RW4 d, IMM s, IMM cc))
+ {
+     CLOBBER_CMOV;
+     d = rmw (d, 4, 4);
+     raw_cmov_l_rm (d, s, cc);
+     unlock (d);
+ }
+ MENDFUNC (3, cmov_l_rm, (RW4 d, IMM s, IMM cc))
+ 
+ MIDFUNC (2, bsf_l_rr, (W4 d, R4 s))
+ {
+     CLOBBER_BSF;
+     s = readreg (s, 4);
+     d = writereg (d, 4);
+     raw_bsf_l_rr (d, s);
+     unlock (s);
+     unlock (d);
+ }
+ MENDFUNC (2, bsf_l_rr, (W4 d, R4 s))
+ 
+ MIDFUNC (2, imul_32_32, (RW4 d, R4 s))
+ {
+     CLOBBER_MUL;
+     s = readreg (s, 4);
+     d = rmw (d, 4, 4);
+     raw_imul_32_32 (d, s);
+     unlock (s);
+     unlock (d);
+ }
+ MENDFUNC (2, imul_32_32, (RW4 d, R4 s))
+ 
+ MIDFUNC (2, imul_64_32, (RW4 d, RW4 s))
+ {
+     CLOBBER_MUL;
+     s = rmw_specific (s, 4, 4, MUL_NREG2);
+     d = rmw_specific (d, 4, 4, MUL_NREG1);
+     raw_imul_64_32 (d, s);
+     unlock (s);
+     unlock (d);
+ }
+ MENDFUNC (2, imul_64_32, (RW4 d, RW4 s))
+ 
+ MIDFUNC (2, mul_64_32, (RW4 d, RW4 s))
+ {
+     CLOBBER_MUL;
+     s = rmw_specific (s, 4, 4, MUL_NREG2);
+     d = rmw_specific (d, 4, 4, MUL_NREG1);
+     raw_mul_64_32 (d, s);
+     unlock (s);
+     unlock (d);
+ }
+ MENDFUNC (2, mul_64_32, (RW4 d, RW4 s))
+ 
+ MIDFUNC (2, mul_32_32, (RW4 d, R4 s))
+ {
+     CLOBBER_MUL;
+     s = readreg (s, 4);
+     d = rmw (d, 4, 4);
+     raw_mul_32_32 (d, s);
+     unlock (s);
+     unlock (d);
+ }
+ MENDFUNC (2, mul_32_32, (RW4 d, R4 s))
+ 
+ MIDFUNC (2, sign_extend_16_rr, (W4 d, R2 s))
+ {
+     int isrmw;
+ 
+     if (isconst (s)) {
+ 	set_const (d, (uae_s32) (uae_s16) live.state[s].val);
+ 	return;
+     }
+ 
+     CLOBBER_SE16;
+     isrmw = (s == d);
+     if (!isrmw) {
+ 	s = readreg (s, 2);
+ 	d = writereg (d, 4);
+     } else {			/* If we try to lock this twice, with different sizes, we
+ 				   are int trouble! */
+ 	s = d = rmw (s, 4, 2);
+     }
+     raw_sign_extend_16_rr (d, s);
+     if (!isrmw) {
+ 	unlock (d);
+ 	unlock (s);
+     } else {
+ 	unlock (s);
+     }
+ }
+ MENDFUNC (2, sign_extend_16_rr, (W4 d, R2 s))
+ 
+ MIDFUNC (2, sign_extend_8_rr, (W4 d, R1 s))
+ {
+     int isrmw;
+ 
+     if (isconst (s)) {
+ 	set_const (d, (uae_s32) (uae_s8) live.state[s].val);
+ 	return;
+     }
+ 
+     isrmw = (s == d);
+     CLOBBER_SE8;
+     if (!isrmw) {
+ 	s = readreg (s, 1);
+ 	d = writereg (d, 4);
+     } else {			/* If we try to lock this twice, with different sizes, we
+ 				   are int trouble! */
+ 	s = d = rmw (s, 4, 1);
+     }
+ 
+     raw_sign_extend_8_rr (d, s);
+ 
+     if (!isrmw) {
+ 	unlock (d);
+ 	unlock (s);
+     } else {
+ 	unlock (s);
+     }
+ }
+ MENDFUNC (2, sign_extend_8_rr, (W4 d, R1 s))
+ 
+ 
+ MIDFUNC (2, zero_extend_16_rr, (W4 d, R2 s))
+ {
+     int isrmw;
+ 
+     if (isconst (s)) {
+ 	set_const (d, (uae_u32) (uae_u16) live.state[s].val);
+ 	return;
+     }
+ 
+     isrmw = (s == d);
+     CLOBBER_ZE16;
+     if (!isrmw) {
+ 	s = readreg (s, 2);
+ 	d = writereg (d, 4);
+     } else {			/* If we try to lock this twice, with different sizes, we
+ 				   are int trouble! */
+ 	s = d = rmw (s, 4, 2);
+     }
+     raw_zero_extend_16_rr (d, s);
+     if (!isrmw) {
+ 	unlock (d);
+ 	unlock (s);
+     } else {
+ 	unlock (s);
+     }
+ }
+ MENDFUNC (2, zero_extend_16_rr, (W4 d, R2 s))
+ 
+ MIDFUNC (2, zero_extend_8_rr, (W4 d, R1 s))
+ {
+     int isrmw;
+     if (isconst (s)) {
+ 	set_const (d, (uae_u32) (uae_u8) live.state[s].val);
+ 	return;
+     }
+ 
+     isrmw = (s == d);
+     CLOBBER_ZE8;
+     if (!isrmw) {
+ 	s = readreg (s, 1);
+ 	d = writereg (d, 4);
+     } else {			/* If we try to lock this twice, with different sizes, we
+ 				   are int trouble! */
+ 	s = d = rmw (s, 4, 1);
+     }
+ 
+     raw_zero_extend_8_rr (d, s);
+ 
+     if (!isrmw) {
+ 	unlock (d);
+ 	unlock (s);
+     } else {
+ 	unlock (s);
+     }
+ }
+ MENDFUNC (2, zero_extend_8_rr, (W4 d, R1 s))
+ 
+ MIDFUNC (2, mov_b_rr, (W1 d, R1 s))
+ {
+     if (d == s)
+ 	return;
+     if (isconst (s)) {
+ 	COMPCALL (mov_b_ri) (d, (uae_u8) live.state[s].val);
+ 	return;
+     }
+ 
+     CLOBBER_MOV;
+     s = readreg (s, 1);
+     d = writereg (d, 1);
+     raw_mov_b_rr (d, s);
+     unlock (d);
+     unlock (s);
+ }
+ MENDFUNC (2, mov_b_rr, (W1 d, R1 s))
+ 
+ MIDFUNC (2, mov_w_rr, (W2 d, R2 s))
+ {
+     if (d == s)
+ 	return;
+     if (isconst (s)) {
+ 	COMPCALL (mov_w_ri) (d, (uae_u16) live.state[s].val);
+ 	return;
+     }
+ 
+     CLOBBER_MOV;
+     s = readreg (s, 2);
+     d = writereg (d, 2);
+     raw_mov_w_rr (d, s);
+     unlock (d);
+     unlock (s);
+ }
+ MENDFUNC (2, mov_w_rr, (W2 d, R2 s))
+ 
+ 
+ MIDFUNC (4, mov_l_rrm_indexed, (W4 d, R4 baser, R4 index, IMM factor))
+ {
+     CLOBBER_MOV;
+     baser = readreg (baser, 4);
+     index = readreg (index, 4);
+     d = writereg (d, 4);
+ 
+     raw_mov_l_rrm_indexed (d, baser, index, factor);
+     unlock (d);
+     unlock (baser);
+     unlock (index);
+ }
+ MENDFUNC (4, mov_l_rrm_indexed, (W4 d, R4 baser, R4 index, IMM factor))
+ 
+ MIDFUNC (4, mov_w_rrm_indexed, (W2 d, R4 baser, R4 index, IMM factor))
+ {
+     CLOBBER_MOV;
+     baser = readreg (baser, 4);
+     index = readreg (index, 4);
+     d = writereg (d, 2);
+ 
+     raw_mov_w_rrm_indexed (d, baser, index, factor);
+     unlock (d);
+     unlock (baser);
+     unlock (index);
+ }
+ MENDFUNC (4, mov_w_rrm_indexed, (W2 d, R4 baser, R4 index, IMM factor))
+ 
+ MIDFUNC (4, mov_b_rrm_indexed, (W1 d, R4 baser, R4 index, IMM factor))
+ {
+     CLOBBER_MOV;
+     baser = readreg (baser, 4);
+     index = readreg (index, 4);
+     d = writereg (d, 1);
+ 
+     raw_mov_b_rrm_indexed (d, baser, index, factor);
+ 
+     unlock (d);
+     unlock (baser);
+     unlock (index);
+ }
+ MENDFUNC (4, mov_b_rrm_indexed, (W1 d, R4 baser, R4 index, IMM factor))
+ 
+ 
+ MIDFUNC (4, mov_l_mrr_indexed, (R4 baser, R4 index, IMM factor, R4 s))
+ {
+     CLOBBER_MOV;
+     baser = readreg (baser, 4);
+     index = readreg (index, 4);
+     s = readreg (s, 4);
+ 
+     Dif (baser == s || index == s)
+ 	abort ();
+ 
+ 
+     raw_mov_l_mrr_indexed (baser, index, factor, s);
+     unlock (s);
+     unlock (baser);
+     unlock (index);
+ }
+ MENDFUNC (4, mov_l_mrr_indexed, (R4 baser, R4 index, IMM factor, R4 s))
+ 
+ MIDFUNC (4, mov_w_mrr_indexed, (R4 baser, R4 index, IMM factor, R2 s))
+ {
+     CLOBBER_MOV;
+     baser = readreg (baser, 4);
+     index = readreg (index, 4);
+     s = readreg (s, 2);
+ 
+     raw_mov_w_mrr_indexed (baser, index, factor, s);
+     unlock (s);
+     unlock (baser);
+     unlock (index);
+ }
+ MENDFUNC (4, mov_w_mrr_indexed, (R4 baser, R4 index, IMM factor, R2 s))
+ 
+ MIDFUNC (4, mov_b_mrr_indexed, (R4 baser, R4 index, IMM factor, R1 s))
+ {
+     CLOBBER_MOV;
+     s = readreg (s, 1);
+     baser = readreg (baser, 4);
+     index = readreg (index, 4);
+ 
+     raw_mov_b_mrr_indexed (baser, index, factor, s);
+     unlock (s);
+     unlock (baser);
+     unlock (index);
+ }
+ MENDFUNC (4, mov_b_mrr_indexed, (R4 baser, R4 index, IMM factor, R1 s))
+ 
+ 
+ MIDFUNC (5, mov_l_bmrr_indexed, (IMM base, R4 baser, R4 index, IMM factor, R4 s))
+ {
+     int basereg = baser;
+     int indexreg = index;
+ 
+     CLOBBER_MOV;
+     s = readreg (s, 4);
+     baser = readreg_offset (baser, 4);
+     index = readreg_offset (index, 4);
+ 
+     base += get_offset (basereg);
+     base += factor * get_offset (indexreg);
+ 
+     raw_mov_l_bmrr_indexed (base, baser, index, factor, s);
+     unlock (s);
+     unlock (baser);
+     unlock (index);
+ }
+ MENDFUNC (5, mov_l_bmrr_indexed, (IMM base, R4 baser, R4 index, IMM factor, R4 s))
+ 
+ MIDFUNC (5, mov_w_bmrr_indexed, (IMM base, R4 baser, R4 index, IMM factor, R2 s))
+ {
+     int basereg = baser;
+     int indexreg = index;
+ 
+     CLOBBER_MOV;
+     s = readreg (s, 2);
+     baser = readreg_offset (baser, 4);
+     index = readreg_offset (index, 4);
+ 
+     base += get_offset (basereg);
+     base += factor * get_offset (indexreg);
+ 
+     raw_mov_w_bmrr_indexed (base, baser, index, factor, s);
+     unlock (s);
+     unlock (baser);
+     unlock (index);
+ }
+ MENDFUNC (5, mov_w_bmrr_indexed, (IMM base, R4 baser, R4 index, IMM factor, R2 s))
+ 
+ MIDFUNC (5, mov_b_bmrr_indexed, (IMM base, R4 baser, R4 index, IMM factor, R1 s))
+ {
+     int basereg = baser;
+     int indexreg = index;
+ 
+     CLOBBER_MOV;
+     s = readreg (s, 1);
+     baser = readreg_offset (baser, 4);
+     index = readreg_offset (index, 4);
+ 
+     base += get_offset (basereg);
+     base += factor * get_offset (indexreg);
+ 
+     raw_mov_b_bmrr_indexed (base, baser, index, factor, s);
+     unlock (s);
+     unlock (baser);
+     unlock (index);
+ }
+ MENDFUNC (5, mov_b_bmrr_indexed, (IMM base, R4 baser, R4 index, IMM factor, R1 s))
+ 
+ 
+ 
+ /* Read a long from base+baser+factor*index */
+ MIDFUNC (5, mov_l_brrm_indexed, (W4 d, IMM base, R4 baser, R4 index, IMM factor))
+ {
+     int basereg = baser;
+     int indexreg = index;
+ 
+     CLOBBER_MOV;
+     baser = readreg_offset (baser, 4);
+     index = readreg_offset (index, 4);
+     base += get_offset (basereg);
+     base += factor * get_offset (indexreg);
+     d = writereg (d, 4);
+     raw_mov_l_brrm_indexed (d, base, baser, index, factor);
+     unlock (d);
+     unlock (baser);
+     unlock (index);
+ }
+ MENDFUNC (5, mov_l_brrm_indexed, (W4 d, IMM base, R4 baser, R4 index, IMM factor))
+ 
+ 
+ MIDFUNC (5, mov_w_brrm_indexed, (W2 d, IMM base, R4 baser, R4 index, IMM factor))
+ {
+     int basereg = baser;
+     int indexreg = index;
+ 
+     CLOBBER_MOV;
+     remove_offset (d, -1);
+     baser = readreg_offset (baser, 4);
+     index = readreg_offset (index, 4);
+     base += get_offset (basereg);
+     base += factor * get_offset (indexreg);
+     d = writereg (d, 2);
+     raw_mov_w_brrm_indexed (d, base, baser, index, factor);
+     unlock (d);
+     unlock (baser);
+     unlock (index);
+ }
+ MENDFUNC (5, mov_w_brrm_indexed, (W2 d, IMM base, R4 baser, R4 index, IMM factor))
+ 
+ 
+ MIDFUNC (5, mov_b_brrm_indexed, (W1 d, IMM base, R4 baser, R4 index, IMM factor))
+ {
+     int basereg = baser;
+     int indexreg = index;
+ 
+     CLOBBER_MOV;
+     remove_offset (d, -1);
+     baser = readreg_offset (baser, 4);
+     index = readreg_offset (index, 4);
+     base += get_offset (basereg);
+     base += factor * get_offset (indexreg);
+     d = writereg (d, 1);
+     raw_mov_b_brrm_indexed (d, base, baser, index, factor);
+     unlock (d);
+     unlock (baser);
+     unlock (index);
+ }
+ MENDFUNC (5, mov_b_brrm_indexed, (W1 d, IMM base, R4 baser, R4 index, IMM factor))
+ 
+ /* Read a long from base+factor*index */
+ MIDFUNC (4, mov_l_rm_indexed, (W4 d, IMM base, R4 index, IMM factor))
+ {
+     int indexreg = index;
+ 
+     if (isconst (index)) {
+ 	COMPCALL (mov_l_rm) (d, base + factor * live.state[index].val);
+ 	return;
+     }
+ 
+     CLOBBER_MOV;
+     index = readreg_offset (index, 4);
+     base += get_offset (indexreg) * factor;
+     d = writereg (d, 4);
+ 
+     raw_mov_l_rm_indexed (d, base, index, factor);
+     unlock (index);
+     unlock (d);
+ }
+ MENDFUNC (4, mov_l_rm_indexed, (W4 d, IMM base, R4 index, IMM factor))
+ 
+ 
+ /* read the long at the address contained in s+offset and store in d */
+ MIDFUNC (3, mov_l_rR, (W4 d, R4 s, IMM offset))
+ {
+     if (isconst (s)) {
+ 	COMPCALL (mov_l_rm) (d, live.state[s].val + offset);
+ 	return;
+     }
+     CLOBBER_MOV;
+     s = readreg (s, 4);
+     d = writereg (d, 4);
+ 
+     raw_mov_l_rR (d, s, offset);
+     unlock (d);
+     unlock (s);
+ }
+ MENDFUNC (3, mov_l_rR, (W4 d, R4 s, IMM offset))
+ 
+ /* read the word at the address contained in s+offset and store in d */
+ MIDFUNC (3, mov_w_rR, (W2 d, R4 s, IMM offset))
+ {
+     if (isconst (s)) {
+ 	COMPCALL (mov_w_rm) (d, live.state[s].val + offset);
+ 	return;
+     }
+     CLOBBER_MOV;
+     s = readreg (s, 4);
+     d = writereg (d, 2);
+ 
+     raw_mov_w_rR (d, s, offset);
+     unlock (d);
+     unlock (s);
+ }
+ MENDFUNC (3, mov_w_rR, (W2 d, R4 s, IMM offset))
+ 
+ /* read the word at the address contained in s+offset and store in d */
+ MIDFUNC (3, mov_b_rR, (W1 d, R4 s, IMM offset))
+ {
+     if (isconst (s)) {
+ 	COMPCALL (mov_b_rm) (d, live.state[s].val + offset);
+ 	return;
+     }
+     CLOBBER_MOV;
+     s = readreg (s, 4);
+     d = writereg (d, 1);
+ 
+     raw_mov_b_rR (d, s, offset);
+     unlock (d);
+     unlock (s);
+ }
+ MENDFUNC (3, mov_b_rR, (W1 d, R4 s, IMM offset))
+ 
+ /* read the long at the address contained in s+offset and store in d */
+ MIDFUNC (3, mov_l_rR_gs, (W4 d, R4 s, IMM offset))
+ {
+     CLOBBER_MOV;
+     s = readreg (s, 4);
+     d = writereg (d, 4);
+ 
+     raw_mov_l_rR_gs (d, s, offset);
+     unlock (d);
+     unlock (s);
+ }
+ MENDFUNC (3, mov_l_rR_gs, (W4 d, R4 s, IMM offset))
+ 
+ /* read the word at the address contained in s+offset and store in d */
+ MIDFUNC (3, mov_w_rR_gs, (W2 d, R4 s, IMM offset))
+ {
+     CLOBBER_MOV;
+     s = readreg (s, 4);
+     d = writereg (d, 2);
+ 
+     raw_mov_w_rR_gs (d, s, offset);
+     unlock (d);
+     unlock (s);
+ }
+ MENDFUNC (3, mov_w_rR_gs, (W2 d, R4 s, IMM offset))
+ 
+ /* read the word at the address contained in s+offset and store in d */
+ MIDFUNC (3, mov_b_rR_gs, (W1 d, R4 s, IMM offset))
+ {
+     CLOBBER_MOV;
+     s = readreg (s, 4);
+     d = writereg (d, 1);
+ 
+     raw_mov_b_rR_gs (d, s, offset);
+     unlock (d);
+     unlock (s);
+ }
+ MENDFUNC (3, mov_b_rR_gs, (W1 d, R4 s, IMM offset))
+ 
+ /* read the long at the address contained in s+offset and store in d */
+ MIDFUNC (3, mov_l_brR, (W4 d, R4 s, IMM offset))
+ {
+     int sreg = s;
+     if (isconst (s) && ! use_gs_seg) {
+ 	COMPCALL (mov_l_rm) (d, live.state[s].val + offset);
+ 	return;
+     }
+     CLOBBER_MOV;
+     s = readreg_offset (s, 4);
+     offset += get_offset (sreg);
+     d = writereg (d, 4);
+ 
+     if (use_gs_seg)
+ 	raw_mov_l_brR_gs (d, s, offset);
+     else
+ 	raw_mov_l_brR (d, s, offset);
+     unlock (d);
+     unlock (s);
+ }
+ MENDFUNC (3, mov_l_brR, (W4 d, R4 s, IMM offset))
+ 
+ /* read the word at the address contained in s+offset and store in d */
+ MIDFUNC (3, mov_w_brR, (W2 d, R4 s, IMM offset))
+ {
+     int sreg = s;
+     if (isconst (s) && ! use_gs_seg) {
+ 	COMPCALL (mov_w_rm) (d, live.state[s].val + offset);
+ 	return;
+     }
+     CLOBBER_MOV;
+     remove_offset (d, -1);
+     s = readreg_offset (s, 4);
+     offset += get_offset (sreg);
+     d = writereg (d, 2);
+ 
+     if (use_gs_seg)
+ 	raw_mov_w_brR_gs (d, s, offset);
+     else
+ 	raw_mov_w_brR (d, s, offset);
+     unlock (d);
+     unlock (s);
+ }
+ MENDFUNC (3, mov_w_brR, (W2 d, R4 s, IMM offset))
+ 
+ /* read the word at the address contained in s+offset and store in d */
+ MIDFUNC (3, mov_b_brR, (W1 d, R4 s, IMM offset))
+ {
+     int sreg = s;
+     if (isconst (s) && ! use_gs_seg) {
+ 	COMPCALL (mov_b_rm) (d, live.state[s].val + offset);
+ 	return;
+     }
+     CLOBBER_MOV;
+     remove_offset (d, -1);
+     s = readreg_offset (s, 4);
+     offset += get_offset (sreg);
+     d = writereg (d, 1);
+ 
+     if (use_gs_seg)
+ 	raw_mov_b_brR_gs (d, s, offset);
+     else
+ 	raw_mov_b_brR (d, s, offset);
+     unlock (d);
+     unlock (s);
+ }
+ MENDFUNC (3, mov_b_brR, (W1 d, R4 s, IMM offset))
+ 
+ /* Warning! OFFSET is byte sized only! */
+ MIDFUNC (3, mov_l_Rr, (R4 d, R4 s, IMM offset))
+ {
+     if (isconst (d)) {
+ 	COMPCALL (mov_l_mr) (live.state[d].val + offset, s);
+ 	return;
+     }
+ 
+     CLOBBER_MOV;
+     s = readreg (s, 4);
+     d = readreg (d, 4);
+ 
+     raw_mov_l_Rr (d, s, offset);
+     unlock (d);
+     unlock (s);
+ }
+ MENDFUNC (3, mov_l_Rr, (R4 d, R4 s, IMM offset))
+ 
+ MIDFUNC (3, mov_w_Rr, (R4 d, R2 s, IMM offset))
+ {
+     if (isconst (d)) {
+ 	COMPCALL (mov_w_mr) (live.state[d].val + offset, s);
+ 	return;
+     }
+ 
+     CLOBBER_MOV;
+     s = readreg (s, 2);
+     d = readreg (d, 4);
+     raw_mov_w_Rr (d, s, offset);
+     unlock (d);
+     unlock (s);
+ }
+ MENDFUNC (3, mov_w_Rr, (R4 d, R2 s, IMM offset))
+ 
+ MIDFUNC (3, mov_b_Rr, (R4 d, R1 s, IMM offset))
+ {
+     if (isconst (d)) {
+ 	COMPCALL (mov_b_mr) (live.state[d].val + offset, s);
+ 	return;
+     }
+ 
+     CLOBBER_MOV;
+     s = readreg (s, 1);
+     d = readreg (d, 4);
+     raw_mov_b_Rr (d, s, offset);
+     unlock (d);
+     unlock (s);
+ }
+ MENDFUNC (3, mov_b_Rr, (R4 d, R1 s, IMM offset))
+ 
+ /* Warning! OFFSET is byte sized only! */
+ MIDFUNC (3, mov_l_Rr_gs, (R4 d, R4 s, IMM offset))
+ {
+     CLOBBER_MOV;
+     s = readreg (s, 4);
+     d = readreg (d, 4);
+ 
+     raw_mov_l_Rr_gs (d, s, offset);
+     unlock (d);
+     unlock (s);
+ }
+ MENDFUNC (3, mov_l_Rr_gs, (R4 d, R4 s, IMM offset))
+ 
+ MIDFUNC (3, mov_w_Rr_gs, (R4 d, R2 s, IMM offset))
+ {
+     CLOBBER_MOV;
+     s = readreg (s, 2);
+     d = readreg (d, 4);
+     raw_mov_w_Rr_gs (d, s, offset);
+     unlock (d);
+     unlock (s);
+ }
+ MENDFUNC (3, mov_w_Rr_gs, (R4 d, R2 s, IMM offset))
+ 
+ MIDFUNC (3, mov_b_Rr_gs, (R4 d, R1 s, IMM offset))
+ {
+     CLOBBER_MOV;
+     s = readreg (s, 1);
+     d = readreg (d, 4);
+     raw_mov_b_Rr_gs (d, s, offset);
+     unlock (d);
+     unlock (s);
+ }
+ MENDFUNC (3, mov_b_Rr_gs, (R4 d, R1 s, IMM offset))
+ 
+ MIDFUNC (3, lea_l_brr, (W4 d, R4 s, IMM offset))
+ {
+     if (isconst (s)) {
+ 	COMPCALL (mov_l_ri) (d, live.state[s].val + offset);
+ 	return;
+     }
+ #if USE_OFFSET
+     if (d == s) {
+ 	add_offset (d, offset);
+ 	return;
+     }
+ #endif
+     CLOBBER_LEA;
+     s = readreg (s, 4);
+     d = writereg (d, 4);
+     raw_lea_l_brr (d, s, offset);
+     unlock (d);
+     unlock (s);
+ }
+ MENDFUNC (3, lea_l_brr, (W4 d, R4 s, IMM offset))
+ 
+ MIDFUNC (5, lea_l_brr_indexed, (W4 d, R4 s, R4 index, IMM factor, IMM offset))
+ {
+     if (!offset) {
+ 	COMPCALL (lea_l_rr_indexed) (d, s, index, factor);
+ 	return;
+     }
+     CLOBBER_LEA;
+     s = readreg (s, 4);
+     index = readreg (index, 4);
+     d = writereg (d, 4);
+ 
+     raw_lea_l_brr_indexed (d, s, index, factor, offset);
+     unlock (d);
+     unlock (index);
+     unlock (s);
+ }
+ MENDFUNC (5, lea_l_brr_indexed, (W4 d, R4 s, R4 index, IMM factor, IMM offset))
+ 
+ MIDFUNC (4, lea_l_rr_indexed, (W4 d, R4 s, R4 index, IMM factor))
+ {
+     CLOBBER_LEA;
+     s = readreg (s, 4);
+     index = readreg (index, 4);
+     d = writereg (d, 4);
+ 
+     raw_lea_l_rr_indexed (d, s, index, factor);
+     unlock (d);
+     unlock (index);
+     unlock (s);
+ }
+ MENDFUNC (4, lea_l_rr_indexed, (W4 d, R4 s, R4 index, IMM factor))
+ 
+ /* write d to the long at the address contained in s+offset */
+ MIDFUNC (3, mov_l_bRr, (R4 d, R4 s, IMM offset))
+ {
+     int dreg = d;
+     if (isconst (d) && ! use_gs_seg) {
+ 	COMPCALL (mov_l_mr) (live.state[d].val + offset, s);
+ 	return;
+     }
+ 
+     CLOBBER_MOV;
+     s = readreg (s, 4);
+     d = readreg_offset (d, 4);
+     offset += get_offset (dreg);
+ 
+     if (use_gs_seg)
+ 	raw_mov_l_bRr_gs (d, s, offset);
+     else
+ 	raw_mov_l_bRr (d, s, offset);
+     unlock (d);
+     unlock (s);
+ }
+ MENDFUNC (3, mov_l_bRr, (R4 d, R4 s, IMM offset))
+ 
+ /* write the word at the address contained in s+offset and store in d */
+ MIDFUNC (3, mov_w_bRr, (R4 d, R2 s, IMM offset))
+ {
+     int dreg = d;
+ 
+     if (isconst (d) && ! use_gs_seg) {
+ 	COMPCALL (mov_w_mr) (live.state[d].val + offset, s);
+ 	return;
+     }
+ 
+     CLOBBER_MOV;
+     s = readreg (s, 2);
+     d = readreg_offset (d, 4);
+     offset += get_offset (dreg);
+     if (use_gs_seg)
+ 	raw_mov_w_bRr_gs (d, s, offset);
+     else
+ 	raw_mov_w_bRr (d, s, offset);
+     unlock (d);
+     unlock (s);
+ }
+ MENDFUNC (3, mov_w_bRr, (R4 d, R2 s, IMM offset))
+ 
+ MIDFUNC (3, mov_b_bRr, (R4 d, R1 s, IMM offset))
+ {
+     int dreg = d;
+     if (isconst (d) && ! use_gs_seg) {
+ 	COMPCALL (mov_b_mr) (live.state[d].val + offset, s);
+ 	return;
+     }
+ 
+     CLOBBER_MOV;
+     s = readreg (s, 1);
+     d = readreg_offset (d, 4);
+     offset += get_offset (dreg);
+     if (use_gs_seg)
+ 	raw_mov_b_bRr_gs (d, s, offset);
+     else
+ 	raw_mov_b_bRr (d, s, offset);
+     unlock (d);
+     unlock (s);
+ }
+ MENDFUNC (3, mov_b_bRr, (R4 d, R1 s, IMM offset))
+ 
+ MIDFUNC (1, bswap_32, (RW4 r))
+ {
+     int reg = r;
+ 
+     if (isconst (r)) {
+ 	uae_u32 oldv = live.state[r].val;
+ 	live.state[r].val = reverse32 (oldv);
+ 	return;
+     }
+ 
+     CLOBBER_SW32;
+     r = rmw (r, 4, 4);
+     raw_bswap_32 (r);
+     unlock (r);
+ }
+ MENDFUNC (1, bswap_32, (RW4 r))
+ 
+ MIDFUNC (1, bswap_16, (RW2 r))
+ {
+     if (isconst (r)) {
+ 	uae_u32 oldv = live.state[r].val;
+ 	live.state[r].val = ((oldv >> 8) & 0xff) | ((oldv << 8) & 0xff00) | (oldv & 0xffff0000);
+ 	return;
+     }
+ 
+     CLOBBER_SW16;
+     r = rmw (r, 2, 2);
+ 
+     raw_bswap_16 (r);
+     unlock (r);
+ }
+ MENDFUNC (1, bswap_16, (RW2 r))
+ 
+ 
+ 
+ MIDFUNC (2, mov_l_rr, (W4 d, R4 s))
+ {
+     int olds;
+ 
+     if (d == s) {		/* How pointless! */
+ 	return;
+     }
+     if (isconst (s)) {
+ 	COMPCALL (mov_l_ri) (d, live.state[s].val);
+ 	return;
+     }
+ #if USE_ALIAS
+     olds = s;
+     disassociate (d);
+     s = readreg_offset (s, 4);
+     live.state[d].realreg = s;
+     live.state[d].realind = live.nat[s].nholds;
+     live.state[d].val = live.state[olds].val;
+     live.state[d].validsize = 4;
+     live.state[d].dirtysize = 4;
+     set_status (d, DIRTY);
+ 
+     live.nat[s].holds[live.nat[s].nholds] = d;
+     live.nat[s].nholds++;
+     log_clobberreg (d);
+ 
+     /* printf("Added %d to nreg %d(%d), now holds %d regs\n",
+        d,s,live.state[d].realind,live.nat[s].nholds); */
+     unlock (s);
+ #else
+     CLOBBER_MOV;
+     s = readreg (s, 4);
+     d = writereg (d, 4);
+ 
+     raw_mov_l_rr (d, s);
+     unlock (d);
+     unlock (s);
+ #endif
+ }
+ MENDFUNC (2, mov_l_rr, (W4 d, R4 s))
+ 
+ MIDFUNC (2, mov_l_mr, (IMM d, R4 s))
+ {
+     if (isconst (s)) {
+ 	COMPCALL (mov_l_mi) (d, live.state[s].val);
+ 	return;
+     }
+     CLOBBER_MOV;
+     s = readreg (s, 4);
+ 
+     raw_mov_l_mr (d, s);
+     unlock (s);
+ }
+ MENDFUNC (2, mov_l_mr, (IMM d, R4 s))
+ 
+ 
+ MIDFUNC (2, mov_w_mr, (IMM d, R2 s))
+ {
+     if (isconst (s)) {
+ 	COMPCALL (mov_w_mi) (d, (uae_u16) live.state[s].val);
+ 	return;
+     }
+     CLOBBER_MOV;
+     s = readreg (s, 2);
+ 
+     raw_mov_w_mr (d, s);
+     unlock (s);
+ }
+ MENDFUNC (2, mov_w_mr, (IMM d, R2 s))
+ 
+ MIDFUNC (2, mov_w_rm, (W2 d, IMM s))
+ {
+     CLOBBER_MOV;
+     d = writereg (d, 2);
+ 
+     raw_mov_w_rm (d, s);
+     unlock (d);
+ }
+ MENDFUNC (2, mov_w_rm, (W2 d, IMM s))
+ 
+ MIDFUNC (2, mov_b_mr, (IMM d, R1 s))
+ {
+     if (isconst (s)) {
+ 	COMPCALL (mov_b_mi) (d, (uae_u8) live.state[s].val);
+ 	return;
+     }
+ 
+     CLOBBER_MOV;
+     s = readreg (s, 1);
+ 
+     raw_mov_b_mr (d, s);
+     unlock (s);
+ }
+ MENDFUNC (2, mov_b_mr, (IMM d, R1 s))
+ 
+ MIDFUNC (2, mov_b_rm, (W1 d, IMM s))
+ {
+     CLOBBER_MOV;
+     d = writereg (d, 1);
+ 
+     raw_mov_b_rm (d, s);
+     unlock (d);
+ }
+ MENDFUNC (2, mov_b_rm, (W1 d, IMM s))
+ 
+ MIDFUNC (2, mov_l_ri, (W4 d, IMM s))
+ {
+     set_const (d, s);
+     return;
+ }
+ MENDFUNC (2, mov_l_ri, (W4 d, IMM s))
+ 
+ MIDFUNC (2, mov_w_ri, (W2 d, IMM s))
+ {
+     CLOBBER_MOV;
+     d = writereg (d, 2);
+ 
+     raw_mov_w_ri (d, s);
+     unlock (d);
+ }
+ MENDFUNC (2, mov_w_ri, (W2 d, IMM s))
+ 
+ MIDFUNC (2, mov_b_ri, (W1 d, IMM s))
+ {
+     CLOBBER_MOV;
+     d = writereg (d, 1);
+ 
+     raw_mov_b_ri (d, s);
+     unlock (d);
+ }
+ MENDFUNC (2, mov_b_ri, (W1 d, IMM s))
+ 
+ 
+ MIDFUNC (2, add_l_mi, (IMM d, IMM s))
+ {
+     CLOBBER_ADD;
+     raw_add_l_mi (d, s);
+ }
+ MENDFUNC (2, add_l_mi, (IMM d, IMM s))
+ 
+ MIDFUNC (2, add_w_mi, (IMM d, IMM s))
+ {
+     CLOBBER_ADD;
+     raw_add_w_mi (d, s);
+ }
+ MENDFUNC (2, add_w_mi, (IMM d, IMM s))
+ 
+ MIDFUNC (2, add_b_mi, (IMM d, IMM s))
+ {
+     CLOBBER_ADD;
+     raw_add_b_mi (d, s);
+ }
+ MENDFUNC (2, add_b_mi, (IMM d, IMM s))
+ 
+ 
+ MIDFUNC (2, test_l_ri, (R4 d, IMM i))
+ {
+     CLOBBER_TEST;
+     d = readreg (d, 4);
+ 
+     raw_test_l_ri (d, i);
+     unlock (d);
+ }
+ MENDFUNC (2, test_l_ri, (R4 d, IMM i))
+ 
+ MIDFUNC (2, test_l_rr, (R4 d, R4 s))
+ {
+     CLOBBER_TEST;
+     d = readreg (d, 4);
+     s = readreg (s, 4);
+ 
+     raw_test_l_rr (d, s);;
+     unlock (d);
+     unlock (s);
+ }
+ MENDFUNC (2, test_l_rr, (R4 d, R4 s))
+ 
+ MIDFUNC (2, test_w_rr, (R2 d, R2 s))
+ {
+     CLOBBER_TEST;
+     d = readreg (d, 2);
+     s = readreg (s, 2);
+ 
+     raw_test_w_rr (d, s);
+     unlock (d);
+     unlock (s);
+ }
+ MENDFUNC (2, test_w_rr, (R2 d, R2 s))
+ 
+ MIDFUNC (2, test_b_rr, (R1 d, R1 s))
+ {
+     CLOBBER_TEST;
+     d = readreg (d, 1);
+     s = readreg (s, 1);
+ 
+     raw_test_b_rr (d, s);
+     unlock (d);
+     unlock (s);
+ }
+ MENDFUNC (2, test_b_rr, (R1 d, R1 s))
+ 
+ 
+ MIDFUNC (2, and_l_ri, (RW4 d, IMM i))
+ {
+     if (isconst (d) && ! needflags) {
+ 	live.state[d].val &= i;
+ 	return;
+     }
+ 
+     CLOBBER_AND;
+     d = rmw (d, 4, 4);
+ 
+     raw_and_l_ri (d, i);
+     unlock (d);
+ }
+ MENDFUNC (2, and_l_ri, (RW4 d, IMM i))
+ 
+ MIDFUNC (2, and_l, (RW4 d, R4 s))
+ {
+     CLOBBER_AND;
+     s = readreg (s, 4);
+     d = rmw (d, 4, 4);
+ 
+     raw_and_l (d, s);
+     unlock (d);
+     unlock (s);
+ }
+ MENDFUNC (2, and_l, (RW4 d, R4 s))
+ 
+ MIDFUNC (2, and_w, (RW2 d, R2 s))
+ {
+     CLOBBER_AND;
+     s = readreg (s, 2);
+     d = rmw (d, 2, 2);
+ 
+     raw_and_w (d, s);
+     unlock (d);
+     unlock (s);
+ }
+ MENDFUNC (2, and_w, (RW2 d, R2 s))
+ 
+ MIDFUNC (2, and_b, (RW1 d, R1 s))
+ {
+     CLOBBER_AND;
+     s = readreg (s, 1);
+     d = rmw (d, 1, 1);
+ 
+     raw_and_b (d, s);
+     unlock (d);
+     unlock (s);
+ }
+ MENDFUNC (2, and_b, (RW1 d, R1 s))
+ 
+ MIDFUNC (2, or_l_ri, (RW4 d, IMM i))
+ {
+     if (isconst (d) && !needflags) {
+ 	live.state[d].val |= i;
+ 	return;
+     }
+     CLOBBER_OR;
+     d = rmw (d, 4, 4);
+ 
+     raw_or_l_ri (d, i);
+     unlock (d);
+ }
+ MENDFUNC (2, or_l_ri, (RW4 d, IMM i))
+ 
+ MIDFUNC (2, or_l, (RW4 d, R4 s))
+ {
+     if (isconst (d) && isconst (s) && !needflags) {
+ 	live.state[d].val |= live.state[s].val;
+ 	return;
+     }
+     CLOBBER_OR;
+     s = readreg (s, 4);
+     d = rmw (d, 4, 4);
+ 
+     raw_or_l (d, s);
+     unlock (d);
+     unlock (s);
+ }
+ MENDFUNC (2, or_l, (RW4 d, R4 s))
+ 
+ MIDFUNC (2, or_w, (RW2 d, R2 s))
+ {
+     CLOBBER_OR;
+     s = readreg (s, 2);
+     d = rmw (d, 2, 2);
+ 
+     raw_or_w (d, s);
+     unlock (d);
+     unlock (s);
+ }
+ MENDFUNC (2, or_w, (RW2 d, R2 s))
+ 
+ MIDFUNC (2, or_b, (RW1 d, R1 s))
+ {
+     CLOBBER_OR;
+     s = readreg (s, 1);
+     d = rmw (d, 1, 1);
+ 
+     raw_or_b (d, s);
+     unlock (d);
+     unlock (s);
+ }
+ MENDFUNC (2, or_b, (RW1 d, R1 s))
+ 
+ MIDFUNC (2, adc_l, (RW4 d, R4 s))
+ {
+     CLOBBER_ADC;
+     s = readreg (s, 4);
+     d = rmw (d, 4, 4);
+ 
+     raw_adc_l (d, s);
+ 
+     unlock (d);
+     unlock (s);
+ }
+ MENDFUNC (2, adc_l, (RW4 d, R4 s))
+ 
+ MIDFUNC (2, adc_w, (RW2 d, R2 s))
+ {
+     CLOBBER_ADC;
+     s = readreg (s, 2);
+     d = rmw (d, 2, 2);
+ 
+     raw_adc_w (d, s);
+     unlock (d);
+     unlock (s);
+ }
+ MENDFUNC (2, adc_w, (RW2 d, R2 s))
+ 
+ MIDFUNC (2, adc_b, (RW1 d, R1 s))
+ {
+     CLOBBER_ADC;
+     s = readreg (s, 1);
+     d = rmw (d, 1, 1);
+ 
+     raw_adc_b (d, s);
+     unlock (d);
+     unlock (s);
+ }
+ MENDFUNC (2, adc_b, (RW1 d, R1 s))
+ 
+ MIDFUNC (2, add_l, (RW4 d, R4 s))
+ {
+     if (isconst (s)) {
+ 	COMPCALL (add_l_ri) (d, live.state[s].val);
+ 	return;
+     }
+ 
+     CLOBBER_ADD;
+     s = readreg (s, 4);
+     d = rmw (d, 4, 4);
+ 
+     raw_add_l (d, s);
+ 
+     unlock (d);
+     unlock (s);
+ }
+ MENDFUNC (2, add_l, (RW4 d, R4 s))
+ 
+ MIDFUNC (2, add_w, (RW2 d, R2 s))
+ {
+     if (isconst (s)) {
+ 	COMPCALL (add_w_ri) (d, (uae_u16) live.state[s].val);
+ 	return;
+     }
+ 
+     CLOBBER_ADD;
+     s = readreg (s, 2);
+     d = rmw (d, 2, 2);
+ 
+     raw_add_w (d, s);
+     unlock (d);
+     unlock (s);
+ }
+ MENDFUNC (2, add_w, (RW2 d, R2 s))
+ 
+ MIDFUNC (2, add_b, (RW1 d, R1 s))
+ {
+     if (isconst (s)) {
+ 	COMPCALL (add_b_ri) (d, (uae_u8) live.state[s].val);
+ 	return;
+     }
+ 
+     CLOBBER_ADD;
+     s = readreg (s, 1);
+     d = rmw (d, 1, 1);
+ 
+     raw_add_b (d, s);
+     unlock (d);
+     unlock (s);
+ }
+ MENDFUNC (2, add_b, (RW1 d, R1 s))
+ 
+ MIDFUNC (2, sub_l_ri, (RW4 d, IMM i))
+ {
+     if (!i && !needflags)
+ 	return;
+     if (isconst (d) && !needflags) {
+ 	live.state[d].val -= i;
+ 	return;
+     }
+ #if USE_OFFSET
+     if (!needflags) {
+ 	add_offset (d, -(signed) i);
+ 	return;
+     }
+ #endif
+ 
+     CLOBBER_SUB;
+     d = rmw (d, 4, 4);
+ 
+     raw_sub_l_ri (d, i);
+     unlock (d);
+ }
+ MENDFUNC (2, sub_l_ri, (RW4 d, IMM i))
+ 
+ MIDFUNC (2, sub_w_ri, (RW2 d, IMM i))
+ {
+     if (!i && !needflags)
+ 	return;
+ 
+     CLOBBER_SUB;
+     d = rmw (d, 2, 2);
+ 
+     raw_sub_w_ri (d, i);
+     unlock (d);
+ }
+ MENDFUNC (2, sub_w_ri, (RW2 d, IMM i))
+ 
+ MIDFUNC (2, sub_b_ri, (RW1 d, IMM i))
+ {
+     if (!i && !needflags)
+ 	return;
+ 
+     CLOBBER_SUB;
+     d = rmw (d, 1, 1);
+ 
+     raw_sub_b_ri (d, i);
+ 
+     unlock (d);
+ }
+ MENDFUNC (2, sub_b_ri, (RW1 d, IMM i))
+ 
+ MIDFUNC (2, add_l_ri, (RW4 d, IMM i))
+ {
+     if (!i && !needflags)
+ 	return;
+     if (isconst (d) && !needflags) {
+ 	live.state[d].val += i;
+ 	return;
+     }
+ #if USE_OFFSET
+     if (!needflags) {
+ 	add_offset (d, i);
+ 	return;
+     }
+ #endif
+     CLOBBER_ADD;
+     d = rmw (d, 4, 4);
+     raw_add_l_ri (d, i);
+     unlock (d);
+ }
+ MENDFUNC (2, add_l_ri, (RW4 d, IMM i))
+ 
+ MIDFUNC (2, add_w_ri, (RW2 d, IMM i))
+ {
+     if (!i && !needflags)
+ 	return;
+ 
+     CLOBBER_ADD;
+     d = rmw (d, 2, 2);
+ 
+     raw_add_w_ri (d, i);
+     unlock (d);
+ }
+ MENDFUNC (2, add_w_ri, (RW2 d, IMM i))
+ 
+ MIDFUNC (2, add_b_ri, (RW1 d, IMM i))
+ {
+     if (!i && !needflags)
+ 	return;
+ 
+     CLOBBER_ADD;
+     d = rmw (d, 1, 1);
+ 
+     raw_add_b_ri (d, i);
+ 
+     unlock (d);
+ }
+ MENDFUNC (2, add_b_ri, (RW1 d, IMM i))
+ 
+ MIDFUNC (2, sbb_l, (RW4 d, R4 s))
+ {
+     CLOBBER_SBB;
+     s = readreg (s, 4);
+     d = rmw (d, 4, 4);
+ 
+     raw_sbb_l (d, s);
+     unlock (d);
+     unlock (s);
+ }
+ MENDFUNC (2, sbb_l, (RW4 d, R4 s))
+ 
+ MIDFUNC (2, sbb_w, (RW2 d, R2 s))
+ {
+     CLOBBER_SBB;
+     s = readreg (s, 2);
+     d = rmw (d, 2, 2);
+ 
+     raw_sbb_w (d, s);
+     unlock (d);
+     unlock (s);
+ }
+ MENDFUNC (2, sbb_w, (RW2 d, R2 s))
+ 
+ MIDFUNC (2, sbb_b, (RW1 d, R1 s))
+ {
+     CLOBBER_SBB;
+     s = readreg (s, 1);
+     d = rmw (d, 1, 1);
+ 
+     raw_sbb_b (d, s);
+     unlock (d);
+     unlock (s);
+ }
+ MENDFUNC (2, sbb_b, (RW1 d, R1 s))
+ 
+ MIDFUNC (2, sub_l, (RW4 d, R4 s))
+ {
+     if (isconst (s)) {
+ 	COMPCALL (sub_l_ri) (d, live.state[s].val);
+ 	return;
+     }
+ 
+     CLOBBER_SUB;
+     s = readreg (s, 4);
+     d = rmw (d, 4, 4);
+ 
+     raw_sub_l (d, s);
+     unlock (d);
+     unlock (s);
+ }
+ MENDFUNC (2, sub_l, (RW4 d, R4 s))
+ 
+ MIDFUNC (2, sub_w, (RW2 d, R2 s))
+ {
+     if (isconst (s)) {
+ 	COMPCALL (sub_w_ri) (d, (uae_u16) live.state[s].val);
+ 	return;
+     }
+ 
+     CLOBBER_SUB;
+     s = readreg (s, 2);
+     d = rmw (d, 2, 2);
+ 
+     raw_sub_w (d, s);
+     unlock (d);
+     unlock (s);
+ }
+ MENDFUNC (2, sub_w, (RW2 d, R2 s))
+ 
+ MIDFUNC (2, sub_b, (RW1 d, R1 s))
+ {
+     if (isconst (s)) {
+ 	COMPCALL (sub_b_ri) (d, (uae_u8) live.state[s].val);
+ 	return;
+     }
+ 
+     CLOBBER_SUB;
+     s = readreg (s, 1);
+     d = rmw (d, 1, 1);
+ 
+     raw_sub_b (d, s);
+     unlock (d);
+     unlock (s);
+ }
+ MENDFUNC (2, sub_b, (RW1 d, R1 s))
+ 
+ MIDFUNC (2, cmp_l, (R4 d, R4 s))
+ {
+     CLOBBER_CMP;
+     s = readreg (s, 4);
+     d = readreg (d, 4);
+ 
+     raw_cmp_l (d, s);
+     unlock (d);
+     unlock (s);
+ }
+ MENDFUNC (2, cmp_l, (R4 d, R4 s))
+ 
+ MIDFUNC (2, cmp_l_ri, (R4 r, IMM i))
+ {
+     CLOBBER_CMP;
+     r = readreg (r, 4);
+ 
+     raw_cmp_l_ri (r, i);
+     unlock (r);
+ }
+ MENDFUNC (2, cmp_l_ri, (R4 r, IMM i))
+ 
+ MIDFUNC (2, cmp_w, (R2 d, R2 s))
+ {
+     CLOBBER_CMP;
+     s = readreg (s, 2);
+     d = readreg (d, 2);
+ 
+     raw_cmp_w (d, s);
+     unlock (d);
+     unlock (s);
+ }
+ MENDFUNC (2, cmp_w, (R2 d, R2 s))
+ 
+ MIDFUNC (2, cmp_b, (R1 d, R1 s))
+ {
+     CLOBBER_CMP;
+     s = readreg (s, 1);
+     d = readreg (d, 1);
+ 
+     raw_cmp_b (d, s);
+     unlock (d);
+     unlock (s);
+ }
+ MENDFUNC (2, cmp_b, (R1 d, R1 s))
+ 
+ 
+ MIDFUNC (2, xor_l, (RW4 d, R4 s))
+ {
+     CLOBBER_XOR;
+     s = readreg (s, 4);
+     d = rmw (d, 4, 4);
+ 
+     raw_xor_l (d, s);
+     unlock (d);
+     unlock (s);
+ }
+ MENDFUNC (2, xor_l, (RW4 d, R4 s))
+ 
+ MIDFUNC (2, xor_w, (RW2 d, R2 s))
+ {
+     CLOBBER_XOR;
+     s = readreg (s, 2);
+     d = rmw (d, 2, 2);
+ 
+     raw_xor_w (d, s);
+     unlock (d);
+     unlock (s);
+ }
+ MENDFUNC (2, xor_w, (RW2 d, R2 s))
+ 
+ MIDFUNC (2, xor_b, (RW1 d, R1 s))
+ {
+     CLOBBER_XOR;
+     s = readreg (s, 1);
+     d = rmw (d, 1, 1);
+ 
+     raw_xor_b (d, s);
+     unlock (d);
+     unlock (s);
+ }
+ MENDFUNC (2, xor_b, (RW1 d, R1 s))
+ 
+ MIDFUNC (5, call_r_11, (W4 out1, R4 r, R4 in1, IMM osize, IMM isize))
+ {
+     clobber_flags ();
+     remove_all_offsets ();
+     if (osize == 4) {
+ 	if (out1 != in1 && out1 != r) {
+ 	    COMPCALL (forget_about) (out1);
+ 	}
+     } else {
+ 	tomem_c (out1);
+     }
+ 
+     in1 = readreg_specific (in1, isize, REG_PAR1);
+     r = readreg (r, 4);
+     prepare_for_call_1 ();	/* This should ensure that there won't be
+ 				   any need for swapping nregs in prepare_for_call_2
+ 				 */
+ #if USE_NORMAL_CALLING_CONVENTION
+     raw_push_l_r (in1);
+ #endif
+     unlock (in1);
+     unlock (r);
+ 
+     prepare_for_call_2 ();
+     raw_call_r (r);
+ 
+ #if USE_NORMAL_CALLING_CONVENTION
+     raw_inc_sp (4);
+ #endif
+ 
+ 
+     live.nat[REG_RESULT].holds[0] = out1;
+     live.nat[REG_RESULT].nholds = 1;
+     live.nat[REG_RESULT].touched = touchcnt++;
+ 
+     live.state[out1].realreg = REG_RESULT;
+     live.state[out1].realind = 0;
+     live.state[out1].val = 0;
+     live.state[out1].validsize = osize;
+     live.state[out1].dirtysize = osize;
+     set_status (out1, DIRTY);
+ }
+ MENDFUNC (5, call_r_11, (W4 out1, R4 r, R4 in1, IMM osize, IMM isize))
+ 
+ MIDFUNC (5, call_r_02, (R4 r, R4 in1, R4 in2, IMM isize1, IMM isize2))
+ {
+     clobber_flags ();
+     remove_all_offsets ();
+     in1 = readreg_specific (in1, isize1, REG_PAR1);
+     in2 = readreg_specific (in2, isize2, REG_PAR2);
+     r = readreg (r, 4);
+     prepare_for_call_1 ();	/* This should ensure that there won't be
+ 				   any need for swapping nregs in prepare_for_call_2
+ 				 */
+ #if USE_NORMAL_CALLING_CONVENTION
+     raw_push_l_r (in2);
+     raw_push_l_r (in1);
+ #endif
+     unlock (r);
+     unlock (in1);
+     unlock (in2);
+     prepare_for_call_2 ();
+     raw_call_r (r);
+ #if USE_NORMAL_CALLING_CONVENTION
+     raw_inc_sp (8);
+ #endif
+ }
+ MENDFUNC (5, call_r_02, (R4 r, R4 in1, R4 in2, IMM isize1, IMM isize2))
+ 
+ 
+ MIDFUNC (1, forget_about, (W4 r))
+ {
+     if (isinreg (r))
+ 	disassociate (r);
+     live.state[r].val = 0;
+     set_status (r, UNDEF);
+ }
+ MENDFUNC (1, forget_about, (W4 r))
+ 
+ MIDFUNC (0, nop, (void))
+ {
+     raw_nop ();
+ }
+ MENDFUNC (0, nop, (void))
+ 
+ 
+ MIDFUNC (1, f_forget_about, (FW r))
+ {
+     if (f_isinreg (r))
+ 	f_disassociate (r);
+     live.fate[r].status = UNDEF;
+ }
+ MENDFUNC (1, f_forget_about, (FW r))
+ 
+ MIDFUNC (1, fmov_pi, (FW r))
+ {
+     r = f_writereg (r);
+     raw_fmov_pi (r);
+     f_unlock (r);
+ }
+ MENDFUNC (1, fmov_pi, (FW r))
+ 
+ MIDFUNC (1, fmov_log10_2, (FW r))
+ {
+     r = f_writereg (r);
+     raw_fmov_log10_2 (r);
+     f_unlock (r);
+ }
+ MENDFUNC (1, fmov_log10_2, (FW r))
+ 
+ MIDFUNC (1, fmov_log2_e, (FW r))
+ {
+     r = f_writereg (r);
+     raw_fmov_log2_e (r);
+     f_unlock (r);
+ }
+ MENDFUNC (1, fmov_log2_e, (FW r))
+ 
+ MIDFUNC (1, fmov_loge_2, (FW r))
+ {
+     r = f_writereg (r);
+     raw_fmov_loge_2 (r);
+     f_unlock (r);
+ }
+ MENDFUNC (1, fmov_loge_2, (FW r))
+ 
+ MIDFUNC (1, fmov_1, (FW r))
+ {
+     r = f_writereg (r);
+     raw_fmov_1 (r);
+     f_unlock (r);
+ }
+ MENDFUNC (1, fmov_1, (FW r))
+ 
+ MIDFUNC (1, fmov_0, (FW r))
+ {
+     r = f_writereg (r);
+     raw_fmov_0 (r);
+     f_unlock (r);
+ }
+ MENDFUNC (1, fmov_0, (FW r))
+ 
+ MIDFUNC (2, fmov_rm, (FW r, MEMR m))
+ {
+     r = f_writereg (r);
+     raw_fmov_rm (r, m);
+     f_unlock (r);
+ }
+ MENDFUNC (2, fmov_rm, (FW r, MEMR m))
+ 
+ MIDFUNC (2, fmovi_rm, (FW r, MEMR m))
+ {
+     r = f_writereg (r);
+     raw_fmovi_rm (r, m);
+     f_unlock (r);
+ }
+ MENDFUNC (2, fmovi_rm, (FW r, MEMR m))
+ 
+ MIDFUNC (2, fmovi_mr, (MEMW m, FR r))
+ {
+     r = f_readreg (r);
+     raw_fmovi_mr (m, r);
+     f_unlock (r);
+ }
+ MENDFUNC (2, fmovi_mr, (MEMW m, FR r))
+ 
+ MIDFUNC (2, fmovs_rm, (FW r, MEMR m))
+ {
+     r = f_writereg (r);
+     raw_fmovs_rm (r, m);
+     f_unlock (r);
+ }
+ MENDFUNC (2, fmovs_rm, (FW r, MEMR m))
+ 
+ MIDFUNC (2, fmovs_mr, (MEMW m, FR r))
+ {
+     r = f_readreg (r);
+     raw_fmovs_mr (m, r);
+     f_unlock (r);
+ }
+ MENDFUNC (2, fmovs_mr, (MEMW m, FR r))
+ 
+ MIDFUNC (2, fmov_ext_mr, (MEMW m, FR r))
+ {
+     r = f_readreg (r);
+     raw_fmov_ext_mr (m, r);
+     f_unlock (r);
+ }
+ MENDFUNC (2, fmov_ext_mr, (MEMW m, FR r))
+ 
+ MIDFUNC (2, fmov_mr, (MEMW m, FR r))
+ {
+     r = f_readreg (r);
+     raw_fmov_mr (m, r);
+     f_unlock (r);
+ }
+ MENDFUNC (2, fmov_mr, (MEMW m, FR r))
+ 
+ MIDFUNC (2, fmov_ext_rm, (FW r, MEMR m))
+ {
+     r = f_writereg (r);
+     raw_fmov_ext_rm (r, m);
+     f_unlock (r);
+ }
+ MENDFUNC (2, fmov_ext_rm, (FW r, MEMR m))
+ 
+ MIDFUNC (2, fmov_rr, (FW d, FR s))
+ {
+     if (d == s) {		/* How pointless! */
+ 	return;
+     }
+ #if USE_F_ALIAS
+     f_disassociate (d);
+     s = f_readreg (s);
+     live.fate[d].realreg = s;
+     live.fate[d].realind = live.fat[s].nholds;
+     live.fate[d].status = DIRTY;
+     live.fat[s].holds[live.fat[s].nholds] = d;
+     live.fat[s].nholds++;
+     f_unlock (s);
+ #else
+     s = f_readreg (s);
+     d = f_writereg (d);
+     raw_fmov_rr (d, s);
+     f_unlock (s);
+     f_unlock (d);
+ #endif
+ }
+ MENDFUNC (2, fmov_rr, (FW d, FR s))
+ 
+ MIDFUNC (2, fldcw_m_indexed, (R4 index, IMM base))
+ {
+     index = readreg (index, 4);
+ 
+     raw_fldcw_m_indexed (index, base);
+     unlock (index);
+ }
+ MENDFUNC (2, fldcw_m_indexed, (R4 index, IMM base))
+ 
+ MIDFUNC (1, ftst_r, (FR r))
+ {
+     r = f_readreg (r);
+     raw_ftst_r (r);
+     f_unlock (r);
+ }
+ MENDFUNC (1, ftst_r, (FR r))
+ 
+ MIDFUNC (0, dont_care_fflags, (void))
+ {
+     f_disassociate (FP_RESULT);
+ }
+ MENDFUNC (0, dont_care_fflags, (void))
+ 
+ MIDFUNC (2, fsqrt_rr, (FW d, FR s))
+ {
+     s = f_readreg (s);
+     d = f_writereg (d);
+     raw_fsqrt_rr (d, s);
+     f_unlock (s);
+     f_unlock (d);
+ }
+ MENDFUNC (2, fsqrt_rr, (FW d, FR s))
+ 
+ MIDFUNC (2, fabs_rr, (FW d, FR s))
+ {
+     s = f_readreg (s);
+     d = f_writereg (d);
+     raw_fabs_rr (d, s);
+     f_unlock (s);
+     f_unlock (d);
+ }
+ MENDFUNC (2, fabs_rr, (FW d, FR s))
+ 
+ MIDFUNC (2, fsin_rr, (FW d, FR s))
+ {
+     s = f_readreg (s);
+     d = f_writereg (d);
+     raw_fsin_rr (d, s);
+     f_unlock (s);
+     f_unlock (d);
+ }
+ MENDFUNC (2, fsin_rr, (FW d, FR s))
+ 
+ MIDFUNC (2, fcos_rr, (FW d, FR s))
+ {
+     s = f_readreg (s);
+     d = f_writereg (d);
+     raw_fcos_rr (d, s);
+     f_unlock (s);
+     f_unlock (d);
+ }
+ MENDFUNC (2, fcos_rr, (FW d, FR s))
+ 
+ MIDFUNC (2, ftwotox_rr, (FW d, FR s))
+ {
+     s = f_readreg (s);
+     d = f_writereg (d);
+     raw_ftwotox_rr (d, s);
+     f_unlock (s);
+     f_unlock (d);
+ }
+ MENDFUNC (2, ftwotox_rr, (FW d, FR s))
+ 
+ MIDFUNC (2, fetox_rr, (FW d, FR s))
+ {
+     s = f_readreg (s);
+     d = f_writereg (d);
+     raw_fetox_rr (d, s);
+     f_unlock (s);
+     f_unlock (d);
+ }
+ MENDFUNC (2, fetox_rr, (FW d, FR s))
+ 
+ MIDFUNC (2, frndint_rr, (FW d, FR s))
+ {
+     s = f_readreg (s);
+     d = f_writereg (d);
+     raw_frndint_rr (d, s);
+     f_unlock (s);
+     f_unlock (d);
+ }
+ MENDFUNC (2, frndint_rr, (FW d, FR s))
+ 
+ MIDFUNC (2, flog2_rr, (FW d, FR s))
+ {
+     s = f_readreg (s);
+     d = f_writereg (d);
+     raw_flog2_rr (d, s);
+     f_unlock (s);
+     f_unlock (d);
+ }
+ MENDFUNC (2, flog2_rr, (FW d, FR s))
+ 
+ MIDFUNC (2, fneg_rr, (FW d, FR s))
+ {
+     s = f_readreg (s);
+     d = f_writereg (d);
+     raw_fneg_rr (d, s);
+     f_unlock (s);
+     f_unlock (d);
+ }
+ MENDFUNC (2, fneg_rr, (FW d, FR s))
+ 
+ MIDFUNC (2, fadd_rr, (FRW d, FR s))
+ {
+     s = f_readreg (s);
+     d = f_rmw (d);
+     raw_fadd_rr (d, s);
+     f_unlock (s);
+     f_unlock (d);
+ }
+ MENDFUNC (2, fadd_rr, (FRW d, FR s))
+ 
+ MIDFUNC (2, fsub_rr, (FRW d, FR s))
+ {
+     s = f_readreg (s);
+     d = f_rmw (d);
+     raw_fsub_rr (d, s);
+     f_unlock (s);
+     f_unlock (d);
+ }
+ MENDFUNC (2, fsub_rr, (FRW d, FR s))
+ 
+ MIDFUNC (2, fcmp_rr, (FR d, FR s))
+ {
+     d = f_readreg (d);
+     s = f_readreg (s);
+     raw_fcmp_rr (d, s);
+     f_unlock (s);
+     f_unlock (d);
+ }
+ MENDFUNC (2, fcmp_rr, (FR d, FR s))
+ 
+ MIDFUNC (2, fdiv_rr, (FRW d, FR s))
+ {
+     s = f_readreg (s);
+     d = f_rmw (d);
+     raw_fdiv_rr (d, s);
+     f_unlock (s);
+     f_unlock (d);
+ }
+ MENDFUNC (2, fdiv_rr, (FRW d, FR s))
+ 
+ MIDFUNC (2, frem_rr, (FRW d, FR s))
+ {
+     s = f_readreg (s);
+     d = f_rmw (d);
+     raw_frem_rr (d, s);
+     f_unlock (s);
+     f_unlock (d);
+ }
+ MENDFUNC (2, frem_rr, (FRW d, FR s))
+ 
+ MIDFUNC (2, frem1_rr, (FRW d, FR s))
+ {
+     s = f_readreg (s);
+     d = f_rmw (d);
+     raw_frem1_rr (d, s);
+     f_unlock (s);
+     f_unlock (d);
+ }
+ MENDFUNC (2, frem1_rr, (FRW d, FR s))
+ 
+ MIDFUNC (2, fmul_rr, (FRW d, FR s))
+ {
+     s = f_readreg (s);
+     d = f_rmw (d);
+     raw_fmul_rr (d, s);
+     f_unlock (s);
+     f_unlock (d);
+ }
+ MENDFUNC (2, fmul_rr, (FRW d, FR s))
+ 
+ 
+ /********************************************************************
+  * Support functions exposed to gencomp. CREATE time                *
+  ********************************************************************/
+ int kill_rodent (int r)
+ {
+     return KILLTHERAT &&
+ 	have_rat_stall &&
+ 	(live.state[r].status == INMEM ||
+ 	 live.state[r].status == CLEAN || live.state[r].status == ISCONST || live.state[r].dirtysize == 4);
+ }
+ 
+ uae_u32 get_const (int r)
+ {
+ #if USE_OPTIMIZER
+     if (!reg_alloc_run)
+ #endif
+ 	Dif (!isconst (r)) {
+ 	printf ("Register %d should be constant, but isn't\n", r);
+ 	abort ();
+ 	}
+     return live.state[r].val;
+ }
+ 
+ void sync_m68k_pc (void)
+ {
+     if (m68k_pc_offset) {
+ 	add_l_ri (PC_P, m68k_pc_offset);
+ 	comp_pc_p += m68k_pc_offset;
+ 	m68k_pc_offset = 0;
+     }
+ }
+ 
+ /********************************************************************
+  * Support functions exposed to newcpu                              *
+  ********************************************************************/
+ 
+ uae_u32 scratch[VREGS];
+ fptype fscratch[VFREGS];
+ 
+ void init_comp (void)
+ {
+     int i;
+     uae_u8 *cb = can_byte;
+     uae_u8 *cw = can_word;
+     uae_u8 *au = always_used;
+ 
+     for (i = 0; i < VREGS; i++) {
+ 	live.state[i].realreg = -1;
+ 	live.state[i].needflush = NF_SCRATCH;
+ 	live.state[i].val = 0;
+ 	set_status (i, UNDEF);
+     }
+ 
+     for (i = 0; i < VFREGS; i++) {
+ 	live.fate[i].status = UNDEF;
+ 	live.fate[i].realreg = -1;
+ 	live.fate[i].needflush = NF_SCRATCH;
+     }
+ 
+     for (i = 0; i < VREGS; i++) {
+ 	if (i < 16) {		/* First 16 registers map to 68k registers */
+ 	    live.state[i].mem = ((uae_u32 *) & regs) + i;
+ 	    live.state[i].needflush = NF_TOMEM;
+ 	    set_status (i, INMEM);
+ 	} else
+ 	    live.state[i].mem = scratch + i;
+     }
+     live.state[PC_P].mem = (uae_u32 *) & (regs.pc_p);
+     live.state[PC_P].needflush = NF_TOMEM;
+     set_const (PC_P, (uae_u32) comp_pc_p);
+ 
+     live.state[FLAGX].mem = &(regflags.x);
+     live.state[FLAGX].needflush = NF_TOMEM;
+     set_status (FLAGX, INMEM);
+ 
+     live.state[FLAGTMP].mem = &(regflags.cznv);
+     live.state[FLAGTMP].needflush = NF_TOMEM;
+     set_status (FLAGTMP, INMEM);
+ 
+     live.state[NEXT_HANDLER].needflush = NF_HANDLER;
+     set_status (NEXT_HANDLER, UNDEF);
+ 
+     for (i = 0; i < VFREGS; i++) {
+ 	if (i < 8) {		/* First 8 registers map to 68k FPU registers */
+ 	    live.fate[i].mem = (uae_u32 *) (((fptype *) regs.fp) + i);
+ 	    live.fate[i].needflush = NF_TOMEM;
+ 	    live.fate[i].status = INMEM;
+ 	} else if (i == FP_RESULT) {
+ 	    live.fate[i].mem = (uae_u32 *) (&regs.fp_result);
+ 	    live.fate[i].needflush = NF_TOMEM;
+ 	    live.fate[i].status = INMEM;
+ 	} else
+ 	    live.fate[i].mem = (uae_u32 *) (fscratch + i);
+     }
+ 
+ 
+     for (i = 0; i < N_REGS; i++) {
+ 	live.nat[i].touched = 0;
+ 	live.nat[i].nholds = 0;
+ 	live.nat[i].locked = 0;
+ 	if (*cb == i) {
+ 	    live.nat[i].canbyte = 1;
+ 	    cb++;
+ 	} else
+ 	    live.nat[i].canbyte = 0;
+ 	if (*cw == i) {
+ 	    live.nat[i].canword = 1;
+ 	    cw++;
+ 	} else
+ 	    live.nat[i].canword = 0;
+ 	if (*au == i) {
+ 	    live.nat[i].locked = 1;
+ 	    au++;
+ 	}
+     }
+ 
+     for (i = 0; i < N_FREGS; i++) {
+ 	live.fat[i].touched = 0;
+ 	live.fat[i].nholds = 0;
+ 	live.fat[i].locked = 0;
+     }
+ 
+     touchcnt = 1;
+     m68k_pc_offset = 0;
+     live.flags_in_flags = TRASH;
+     live.flags_on_stack = VALID;
+     live.flags_are_important = 1;
+ 
+     raw_fp_init ();
+ }
+ 
+ 
+ static void vinton (int i, uae_s8 * vton, int depth)
+ {
+     int n;
+     int rr;
+ 
+     Dif (vton[i] == -1) {
+ 	printf ("Asked to load register %d, but nowhere to go\n", i);
+ 	abort ();
+     }
+     n = vton[i];
+     Dif (live.nat[n].nholds > 1)
+ 	abort ();
+     if (live.nat[n].nholds && depth < N_REGS) {
+ 	vinton (live.nat[n].holds[0], vton, depth + 1);
+     }
+     if (!isinreg (i))
+ 	return;			/* Oops --- got rid of that one in the recursive calls */
+     rr = live.state[i].realreg;
+     if (rr != n)
+ 	mov_nregs (n, rr);
+ }
+ 
+ #if USE_MATCHSTATE
+ /* This is going to be, amongst other things, a more elaborate version of
+    flush() */
+ static __inline__ void match_states (smallstate * s)
+ {
+     uae_s8 vton[VREGS];
+     uae_s8 ndone[N_REGS];
+     int i;
+     int again = 0;
+ 
+     for (i = 0; i < VREGS; i++)
+ 	vton[i] = -1;
+ 
+     for (i = 0; i < N_REGS; i++)
+ 	if (s->nat[i].validsize)
+ 	    vton[s->nat[i].holds] = i;
+ 
+     flush_flags ();		/* low level */
+     sync_m68k_pc ();		/* mid level */
+ 
+     /* We don't do FREGS yet, so this is raw flush() code */
+     for (i = 0; i < VFREGS; i++) {
+ 	if (live.fate[i].needflush == NF_SCRATCH || live.fate[i].status == CLEAN) {
+ 	    f_disassociate (i);
+ 	}
+     }
+     for (i = 0; i < VFREGS; i++) {
+ 	if (live.fate[i].needflush == NF_TOMEM && live.fate[i].status == DIRTY) {
+ 	    f_evict (i);
+ 	}
+     }
+     raw_fp_cleanup_drop ();
+ 
+     /* Now comes the fun part. First, we need to remove all offsets */
+     for (i = 0; i < VREGS; i++)
+ 	if (!isconst (i) && live.state[i].val)
+ 	    remove_offset (i, -1);
+ 
+     /* Next, we evict everything that does not end up in registers,
+        write back overly dirty registers, and write back constants */
+     for (i = 0; i < VREGS; i++) {
+ 	switch (live.state[i].status) {
+ 	case ISCONST:
+ 	    if (i != PC_P)
+ 		writeback_const (i);
+ 	    break;
+ 	case DIRTY:
+ 	    if (vton[i] == -1) {
+ 		evict (i);
+ 		break;
+ 	    }
+ 	    if (live.state[i].dirtysize > s->nat[vton[i]].dirtysize)
+ 		tomem (i);
+ 	    /* Fall-through! */
+ 	case CLEAN:
+ 	    if (vton[i] == -1 || live.state[i].validsize < s->nat[vton[i]].validsize)
+ 		evict (i);
+ 	    else
+ 		make_exclusive (i, 0, -1);
+ 	    break;
+ 	case INMEM:
+ 	    break;
+ 	case UNDEF:
+ 	    break;
+ 	default:
+ 	    printf ("Weird status: %d\n", live.state[i].status);
+ 	    abort ();
+ 	}
+     }
+ 
+     /* Quick consistency check */
+     for (i = 0; i < VREGS; i++) {
+ 	if (isinreg (i)) {
+ 	    int n = live.state[i].realreg;
+ 
+ 	    if (live.nat[n].nholds != 1) {
+ 		printf ("Register %d isn't alone in nreg %d\n", i, n);
+ 		abort ();
+ 	    }
+ 	    if (vton[i] == -1) {
+ 		printf ("Register %d is still in register, shouldn't be\n", i);
+ 		abort ();
+ 	    }
+ 	}
+     }
+ 
+     /* Now we need to shuffle things around so the VREGs are in the
+        right N_REGs. */
+     for (i = 0; i < VREGS; i++) {
+ 	if (isinreg (i) && vton[i] != live.state[i].realreg)
+ 	    vinton (i, vton, 0);
+     }
+ 
+     /* And now we may need to load some registers from memory */
+     for (i = 0; i < VREGS; i++) {
+ 	int n = vton[i];
+ 	if (n == -1) {
+ 	    Dif (isinreg (i)) {
+ 		printf ("Register %d unexpectedly in nreg %d\n", i, live.state[i].realreg);
+ 		abort ();
+ 	    }
+ 	} else {
+ 	    switch (live.state[i].status) {
+ 	    case CLEAN:
+ 	    case DIRTY:
+ 		Dif (n != live.state[i].realreg)
+ 		    abort ();
+ 		break;
+ 	    case INMEM:
+ 		Dif (live.nat[n].nholds) {
+ 		    printf ("natreg %d holds %d vregs, should be empty\n", n, live.nat[n].nholds);
+ 		}
+ 		raw_mov_l_rm (n, (uae_u32) live.state[i].mem);
+ 		live.state[i].validsize = 4;
+ 		live.state[i].dirtysize = 0;
+ 		live.state[i].realreg = n;
+ 		live.state[i].realind = 0;
+ 		live.state[i].val = 0;
+ 		live.state[i].is_swapped = 0;
+ 		live.nat[n].nholds = 1;
+ 		live.nat[n].holds[0] = i;
+ 
+ 		set_status (i, CLEAN);
+ 		break;
+ 	    case ISCONST:
+ 		if (i != PC_P) {
+ 		    printf ("Got constant in matchstate for reg %d. Bad!\n", i);
+ 		    abort ();
+ 		}
+ 		break;
+ 	    case UNDEF:
+ 		break;
+ 	    }
+ 	}
+     }
+ 
+     /* One last consistency check, and adjusting the states in live
+        to those in s */
+     for (i = 0; i < VREGS; i++) {
+ 	int n = vton[i];
+ 	switch (live.state[i].status) {
+ 	case INMEM:
+ 	    if (n != -1)
+ 		abort ();
+ 	    break;
+ 	case ISCONST:
+ 	    if (i != PC_P)
+ 		abort ();
+ 	    break;
+ 	case CLEAN:
+ 	case DIRTY:
+ 	    if (n == -1)
+ 		abort ();
+ 	    if (live.state[i].dirtysize > s->nat[n].dirtysize)
+ 		abort;
+ 	    if (live.state[i].validsize < s->nat[n].validsize)
+ 		abort;
+ 	    live.state[i].dirtysize = s->nat[n].dirtysize;
+ 	    live.state[i].validsize = s->nat[n].validsize;
+ 	    if (live.state[i].dirtysize)
+ 		set_status (i, DIRTY);
+ 	    break;
+ 	case UNDEF:
+ 	    break;
+ 	}
+ 	if (n != -1)
+ 	    live.nat[n].touched = touchcnt++;
+     }
+ }
+ #else
+ static __inline__ void match_states (smallstate * s)
+ {
+     flush (1);
+ }
+ #endif
+ 
+ /* Only do this if you really mean it! The next call should be to init!*/
+ void flush (int save_regs)
+ {
+     int fi, i;
+ 
+     log_flush ();
+     flush_flags ();		/* low level */
+     sync_m68k_pc ();		/* mid level */
+ 
+     if (save_regs) {
+ 	for (i = 0; i < VFREGS; i++) {
+ 	    if (live.fate[i].needflush == NF_SCRATCH || live.fate[i].status == CLEAN) {
+ 		f_disassociate (i);
+ 	    }
+ 	}
+ 	for (i = 0; i < VREGS; i++) {
+ 	    if (live.state[i].needflush == NF_TOMEM) {
+ 		switch (live.state[i].status) {
+ 		case INMEM:
+ 		    if (live.state[i].val) {
+ 			raw_add_l_mi ((uae_u32) live.state[i].mem, live.state[i].val);
+ 			live.state[i].val = 0;
+ 		    }
+ 		    break;
+ 		case CLEAN:
+ 		case DIRTY:
+ 		    remove_offset (i, -1);
+ 		    tomem (i);
+ 		    break;
+ 		case ISCONST:
+ 		    if (i != PC_P)
+ 			writeback_const (i);
+ 		    break;
+ 		default:
+ 		    break;
+ 		}
+ 		Dif (live.state[i].val && i != PC_P) {
+ 		    printf ("Register %d still has val %x\n", i, live.state[i].val);
+ 		}
+ 	    }
+ 	}
+ 	for (i = 0; i < VFREGS; i++) {
+ 	    if (live.fate[i].needflush == NF_TOMEM && live.fate[i].status == DIRTY) {
+ 		f_evict (i);
+ 	    }
+ 	}
+ 	raw_fp_cleanup_drop ();
+     }
+     if (needflags) {
+ 	printf ("Warning! flush with needflags=1!\n");
+     }
+ 
+     lopt_emit_all ();
+ }
+ 
+ static void flush_keepflags (void)
+ {
+     int fi, i;
+ 
+     for (i = 0; i < VFREGS; i++) {
+ 	if (live.fate[i].needflush == NF_SCRATCH || live.fate[i].status == CLEAN) {
+ 	    f_disassociate (i);
+ 	}
+     }
+     for (i = 0; i < VREGS; i++) {
+ 	if (live.state[i].needflush == NF_TOMEM) {
+ 	    switch (live.state[i].status) {
+ 	    case INMEM:
+ 		/* Can't adjust the offset here --- that needs "add" */
+ 		break;
+ 	    case CLEAN:
+ 	    case DIRTY:
+ 		remove_offset (i, -1);
+ 		tomem (i);
+ 		break;
+ 	    case ISCONST:
+ 		if (i != PC_P)
+ 		    writeback_const (i);
+ 		break;
+ 	    default:
+ 		break;
+ 	    }
+ 	}
+     }
+     for (i = 0; i < VFREGS; i++) {
+ 	if (live.fate[i].needflush == NF_TOMEM && live.fate[i].status == DIRTY) {
+ 	    f_evict (i);
+ 	}
+     }
+     raw_fp_cleanup_drop ();
+     lopt_emit_all ();
+ }
+ 
+ void freescratch (void)
+ {
+     int i;
+     for (i = 0; i < N_REGS; i++)
+ 	if (live.nat[i].locked && i != 4)
+ 	    printf ("Warning! %d is locked\n", i);
+ 
+     for (i = 0; i < VREGS; i++)
+ 	if (live.state[i].needflush == NF_SCRATCH) {
+ 	    forget_about (i);
+ 	}
+ 
+     for (i = 0; i < VFREGS; i++)
+ 	if (live.fate[i].needflush == NF_SCRATCH) {
+ 	    f_forget_about (i);
+ 	}
+ }
+ 
+ /********************************************************************
+  * Support functions, internal                                      *
+  ********************************************************************/
+ 
+ 
+ static void align_target (uae_u32 a)
+ {
+     lopt_emit_all ();
+     /* Fill with NOPs --- makes debugging with gdb easier */
+     while ((uae_u32) target & (a - 1))
+ 	*target++ = 0x90;
+ }
+ 
+ extern uae_u8 *kickmemory;
+ static __inline__ int isinrom (uae_u32 addr)
+ {
+     return (addr >= (uae_u32) kickmemory && addr < (uae_u32) kickmemory + 8 * 65536);
+ }
+ 
+ static void flush_all (void)
+ {
+     int i;
+ 
+     log_flush ();
+     for (i = 0; i < VREGS; i++)
+ 	if (live.state[i].status == DIRTY) {
+ 	    if (!call_saved[live.state[i].realreg]) {
+ 		tomem (i);
+ 	    }
+ 	}
+     for (i = 0; i < VFREGS; i++)
+ 	if (f_isinreg (i))
+ 	    f_evict (i);
+     raw_fp_cleanup_drop ();
+ }
+ 
+ /* Make sure all registers that will get clobbered by a call are
+    save and sound in memory */
+ static void prepare_for_call_1 (void)
+ {
+     flush_all ();		/* If there are registers that don't get clobbered,
+ 				 * we should be a bit more selective here */
+ }
+ 
+ /* We will call a C routine in a moment. That will clobber all registers,
+    so we need to disassociate everything */
+ static void prepare_for_call_2 (void)
+ {
+     int i;
+     for (i = 0; i < N_REGS; i++)
+ 	if (!call_saved[i] && live.nat[i].nholds > 0)
+ 	    free_nreg (i);
+ 
+     for (i = 0; i < N_FREGS; i++)
+ 	if (live.fat[i].nholds > 0)
+ 	    f_free_nreg (i);
+ 
+     live.flags_in_flags = TRASH;	/* Note: We assume we already rescued the
+ 					   flags at the very start of the call_r
+ 					   functions! */
+ }
+ 
+ 
+ /********************************************************************
+  * Memory access and related functions, CREATE time                 *
+  ********************************************************************/
+ 
+ void register_branch (uae_u32 not_taken, uae_u32 taken, uae_u8 cond)
+ {
+     next_pc_p = not_taken;
+     taken_pc_p = taken;
+     branch_cc = cond;
+ }
+ 
+ 
+ static uae_u32 get_handler_address (uae_u32 addr)
+ {
+     uae_u32 cl = cacheline (addr);
+     blockinfo *bi = get_blockinfo_addr_new ((void *) addr, 0);
+ 
+ #if USE_OPTIMIZER
+     if (!bi && reg_alloc_run)
+ 	return 0;
+ #endif
+     return (uae_u32) & (bi->direct_handler_to_use);
+ }
+ 
+ static uae_u32 get_handler (uae_u32 addr)
+ {
+     uae_u32 cl = cacheline (addr);
+     blockinfo *bi = get_blockinfo_addr_new ((void *) addr, 0);
+ 
+ #if USE_OPTIMIZER
+     if (!bi && reg_alloc_run)
+ 	return 0;
+ #endif
+     return (uae_u32) bi->direct_handler_to_use;
+ }
+ 
+ static void load_handler (int reg, uae_u32 addr)
+ {
+     mov_l_rm (reg, get_handler_address (addr));
+ }
+ 
+ /* This version assumes that it is writing *real* memory, and *will* fail
+  *  if that assumption is wrong! No branches, no second chances, just
+  *  straight go-for-it attitude */
+ 
+ static void writemem_real (int address, int source, int offset, int size, int tmp, int clobber)
+ {
+     int f = tmp;
+ 
+ #ifdef NATMEM_OFFSET
+     if (canbang) {		/* Woohoo! go directly at the memory! */
+ 	if (clobber)
+ 	    f = source;
+ 	switch (size) {
+ 	case 1:
+ 	    use_gs_seg = 1;
+ 	    mov_b_bRr (address, source, GS_NATMEM_OFFSET);
+ 	    break;
+ 	case 2:
+ 	    mov_w_rr (f, source);
+ 	    bswap_16 (f);
+ 	    use_gs_seg = 1;
+ 	    mov_w_bRr (address, f, GS_NATMEM_OFFSET);
+ 	    break;
+ 	case 4:
+ 	    mov_l_rr (f, source);
+ 	    bswap_32 (f);
+ 	    use_gs_seg = 1;
+ 	    mov_l_bRr (address, f, GS_NATMEM_OFFSET);
+ 	    break;
+ 	}
+ 	use_gs_seg = 0;
+ 	forget_about (tmp);
+ 	forget_about (f);
+ 	return;
+     }
+ #endif
+ 
+     mov_l_rr (f, address);
+     shrl_l_ri (f, 16);		/* The index into the baseaddr table */
+     mov_l_rm_indexed (f, (uae_u32) (baseaddr), f, 4);
+ 
+     if (address == source && size > 1) {	/* IBrowse does this! */
+ 	add_l (f, address);	/* f now has the final address */
+ 	switch (size) {
+ 	case 2:
+ 	    bswap_16 (source);
+ 	    mov_w_Rr (f, source, 0);
+ 	    bswap_16 (source);
+ 	    break;
+ 	case 4:
+ 	    bswap_32 (source);
+ 	    mov_l_Rr (f, source, 0);
+ 	    bswap_32 (source);
+ 	    break;
+ 	}
+     } else {
+ 	/* f now holds the offset */
+ 	switch (size) {
+ 	case 1:
+ 	    mov_b_mrr_indexed (address, f, 1, source);
+ 	    break;
+ 	case 2:
+ 	    bswap_16 (source);
+ 	    mov_w_mrr_indexed (address, f, 1, source);
+ 	    bswap_16 (source);
+ 	    break;
+ 	case 4:
+ 	    bswap_32 (source);
+ 	    mov_l_mrr_indexed (address, f, 1, source);
+ 	    bswap_32 (source);
+ 	    break;
+ 	}
+     }
+ }
+ 
+ static __inline__ void writemem (int address, int source, int offset, int size, int tmp)
+ {
+     int f = tmp;
+ 
+     mov_l_rr (f, address);
+     shrl_l_ri (f, 16);		/* The index into the mem bank table */
+     mov_l_rm_indexed (f, (uae_u32) mem_banks, f, 4);
+     /* Now f holds a pointer to the actual membank */
+     mov_l_rR (f, f, offset);
+     /* Now f holds the address of the b/w/lput function */
+     call_r_02 (f, address, source, 4, size);
+     forget_about (tmp);
+ }
+ 
+ void writebyte (int address, int source, int tmp)
+ {
+     int distrust;
+     switch (currprefs.comptrustbyte) {
+     case 0:
+ 	distrust = 0;
+ 	break;
+     case 1:
+ 	distrust = 1;
+ 	break;
+     case 2:
+ 	distrust = ((start_pc & 0xF80000) == 0xF80000);
+ 	break;
+     case 3:
+ 	distrust = !have_done_picasso;
+ 	break;
+     default:
+ 	abort ();
+     }
+ 
+     if ((special_mem & S_WRITE) || distrust)
+ 	writemem_special (address, source, 20, 1, tmp);
+     else
+ 	writemem_real (address, source, 20, 1, tmp, 0);
+ }
+ 
+ static __inline__ void writeword_general (int address, int source, int tmp, int clobber)
+ {
+     int distrust;
+     switch (currprefs.comptrustword) {
+     case 0:
+ 	distrust = 0;
+ 	break;
+     case 1:
+ 	distrust = 1;
+ 	break;
+     case 2:
+ 	distrust = ((start_pc & 0xF80000) == 0xF80000);
+ 	break;
+     case 3:
+ 	distrust = !have_done_picasso;
+ 	break;
+     default:
+ 	abort ();
+     }
+ 
+     if ((special_mem & S_WRITE) || distrust)
+ 	writemem_special (address, source, 16, 2, tmp);
+     else
+ 	writemem_real (address, source, 16, 2, tmp, clobber);
+ }
+ 
+ void writeword_clobber (int address, int source, int tmp)
+ {
+     writeword_general (address, source, tmp, 1);
+ }
+ 
+ void writeword (int address, int source, int tmp)
+ {
+     writeword_general (address, source, tmp, 0);
+ }
+ 
+ static __inline__ void writelong_general (int address, int source, int tmp, int clobber)
+ {
+     int distrust;
+     switch (currprefs.comptrustlong) {
+     case 0:
+ 	distrust = 0;
+ 	break;
+     case 1:
+ 	distrust = 1;
+ 	break;
+     case 2:
+ 	distrust = ((start_pc & 0xF80000) == 0xF80000);
+ 	break;
+     case 3:
+ 	distrust = !have_done_picasso;
+ 	break;
+     default:
+ 	abort ();
+     }
+ 
+     if ((special_mem & S_WRITE) || distrust)
+ 	writemem_special (address, source, 12, 4, tmp);
+     else
+ 	writemem_real (address, source, 12, 4, tmp, clobber);
+ }
+ 
+ void writelong_clobber (int address, int source, int tmp)
+ {
+     writelong_general (address, source, tmp, 1);
+ }
+ 
+ void writelong (int address, int source, int tmp)
+ {
+     writelong_general (address, source, tmp, 0);
+ }
+ 
+ /* This version assumes that it is reading *real* memory, and *will* fail
+  *  if that assumption is wrong! No branches, no second chances, just
+  *  straight go-for-it attitude */
+ 
+ static void readmem_real (int address, int dest, int offset, int size, int tmp)
+ {
+     int f = tmp;
+ 
+     if (size == 4 && address != dest)
+ 	f = dest;
+ 
+ #ifdef NATMEM_OFFSET
+     if (canbang) {		/* Woohoo! go directly at the memory! */
+ 	switch (size) {
+ 	case 1:
+ 	    use_gs_seg = 1;
+ 	    mov_b_brR (dest, address, GS_NATMEM_OFFSET);
+ 	    break;
+ 	case 2:
+ 	    use_gs_seg = 1;
+ 	    mov_w_brR (dest, address, GS_NATMEM_OFFSET);
+ 	    bswap_16 (dest);
+ 	    break;
+ 	case 4:
+ 	    use_gs_seg = 1;
+ 	    mov_l_brR (dest, address, GS_NATMEM_OFFSET);
+ 	    bswap_32 (dest);
+ 	    break;
+ 	}
+ 	use_gs_seg = 0;
+ 
+ 	forget_about (tmp);
+ 	return;
+     }
+ #endif
+ 
+     mov_l_rr (f, address);
+     shrl_l_ri (f, 16);		/* The index into the baseaddr table */
+     mov_l_rm_indexed (f, (uae_u32) baseaddr, f, 4);
+     /* f now holds the offset */
+ 
+     switch (size) {
+     case 1:
+ 	mov_b_rrm_indexed (dest, address, f, 1);
+ 	break;
+     case 2:
+ 	mov_w_rrm_indexed (dest, address, f, 1);
+ 	bswap_16 (dest);
+ 	break;
+     case 4:
+ 	mov_l_rrm_indexed (dest, address, f, 1);
+ 	bswap_32 (dest);
+ 	break;
+     }
+     forget_about (tmp);
+ }
+ 
+ static __inline__ void readmem (int address, int dest, int offset, int size, int tmp)
+ {
+     int f = tmp;
+ 
+     mov_l_rr (f, address);
+     shrl_l_ri (f, 16);		/* The index into the mem bank table */
+     mov_l_rm_indexed (f, (uae_u32) mem_banks, f, 4);
+     /* Now f holds a pointer to the actual membank */
+     mov_l_rR (f, f, offset);
+     /* Now f holds the address of the b/w/lget function */
+     call_r_11 (dest, f, address, size, 4);
+     forget_about (tmp);
+ }
+ 
+ void readbyte (int address, int dest, int tmp)
+ {
+     int distrust;
+     switch (currprefs.comptrustbyte) {
+     case 0:
+ 	distrust = 0;
+ 	break;
+     case 1:
+ 	distrust = 1;
+ 	break;
+     case 2:
+ 	distrust = ((start_pc & 0xF80000) == 0xF80000);
+ 	break;
+     case 3:
+ 	distrust = !have_done_picasso;
+ 	break;
+     default:
+ 	abort ();
+     }
+ 
+     if ((special_mem & S_READ) || distrust)
+ 	readmem_special (address, dest, 8, 1, tmp);
+     else
+ 	readmem_real (address, dest, 8, 1, tmp);
+ }
+ 
+ void readword (int address, int dest, int tmp)
+ {
+     int distrust;
+     switch (currprefs.comptrustword) {
+     case 0:
+ 	distrust = 0;
+ 	break;
+     case 1:
+ 	distrust = 1;
+ 	break;
+     case 2:
+ 	distrust = ((start_pc & 0xF80000) == 0xF80000);
+ 	break;
+     case 3:
+ 	distrust = !have_done_picasso;
+ 	break;
+     default:
+ 	abort ();
+     }
+ 
+     if ((special_mem & S_READ) || distrust)
+ 	readmem_special (address, dest, 4, 2, tmp);
+     else
+ 	readmem_real (address, dest, 4, 2, tmp);
+ }
+ 
+ void readlong (int address, int dest, int tmp)
+ {
+     int distrust;
+     switch (currprefs.comptrustlong) {
+     case 0:
+ 	distrust = 0;
+ 	break;
+     case 1:
+ 	distrust = 1;
+ 	break;
+     case 2:
+ 	distrust = ((start_pc & 0xF80000) == 0xF80000);
+ 	break;
+     case 3:
+ 	distrust = !have_done_picasso;
+ 	break;
+     default:
+ 	abort ();
+     }
+ 
+     if ((special_mem & S_READ) || distrust)
+ 	readmem_special (address, dest, 0, 4, tmp);
+     else
+ 	readmem_real (address, dest, 0, 4, tmp);
+ }
+ 
+ 
+ 
+ /* This one might appear a bit odd... */
+ static __inline__ void get_n_addr_old (int address, int dest, int tmp)
+ {
+     readmem (address, dest, 24, 4, tmp);
+ }
+ 
+ static __inline__ void get_n_addr_real (int address, int dest, int tmp)
+ {
+     int f = tmp;
+     if (address != dest)
+ 	f = dest;
+ 
+ #ifdef NATMEM_OFFSET
+     if (canbang) {
+ 	lea_l_brr (dest, address, GS_NATMEM_OFFSET);
+ 	forget_about (tmp);
+ 	return;
+     }
+ #endif
+     mov_l_rr (f, address);
+     mov_l_rr (dest, address);	// gb-- nop if dest==address
+     shrl_l_ri (f, 16);
+     mov_l_rm_indexed (f, (uae_u32) baseaddr, f, 4);
+     add_l (dest, f);
+     forget_about (tmp);
+ }
+ 
+ void get_n_addr (int address, int dest, int tmp)
+ {
+     int distrust;
+     switch (currprefs.comptrustnaddr) {
+     case 0:
+ 	distrust = 0;
+ 	break;
+     case 1:
+ 	distrust = 1;
+ 	break;
+     case 2:
+ 	distrust = ((start_pc & 0xF80000) == 0xF80000);
+ 	break;
+     case 3:
+ 	distrust = !have_done_picasso;
+ 	break;
+     default:
+ 	abort ();
+     }
+ 
+     if (special_mem || distrust)
+ 	get_n_addr_old (address, dest, tmp);
+     else
+ 	get_n_addr_real (address, dest, tmp);
+ }
+ 
+ void get_n_addr_jmp (int address, int dest, int tmp)
+ {
+ #if 0				/* For this, we need to get the same address as the rest of UAE
+ 				   would --- otherwise we end up translating everything twice */
+     get_n_addr (address, dest, tmp);
+ #else
+     int f = tmp;
+     if (address != dest)
+ 	f = dest;
+     mov_l_rr (f, address);
+     shrl_l_ri (f, 16);		/* The index into the baseaddr bank table */
+     mov_l_rm_indexed (dest, (uae_u32) baseaddr, f, 4);
+     add_l (dest, address);
+     and_l_ri (dest, ~1);
+     forget_about (tmp);
+ #endif
+ }
+ 
+ 
+ /* base is a register, but dp is an actual value. 
+    target is a register, as is tmp */
+ void calc_disp_ea_020 (int base, uae_u32 dp, int target, int tmp)
+ {
+     int reg = (dp >> 12) & 15;
+     int regd_shift = (dp >> 9) & 3;
+ 
+     if (dp & 0x100) {
+ 	int ignorebase = (dp & 0x80);
+ 	int ignorereg = (dp & 0x40);
+ 	int addbase = 0;
+ 	int outer = 0;
+ 
+ 	if ((dp & 0x30) == 0x20)
+ 	    addbase = (uae_s32) (uae_s16) comp_get_iword ((m68k_pc_offset += 2) - 2);
+ 	if ((dp & 0x30) == 0x30)
+ 	    addbase = comp_get_ilong ((m68k_pc_offset += 4) - 4);
+ 
+ 	if ((dp & 0x3) == 0x2)
+ 	    outer = (uae_s32) (uae_s16) comp_get_iword ((m68k_pc_offset += 2) - 2);
+ 	if ((dp & 0x3) == 0x3)
+ 	    outer = comp_get_ilong ((m68k_pc_offset += 4) - 4);
+ 
+ 	if ((dp & 0x4) == 0) {	/* add regd *before* the get_long */
+ 	    if (!ignorereg) {
+ 		if ((dp & 0x800) == 0)
+ 		    sign_extend_16_rr (target, reg);
+ 		else
+ 		    mov_l_rr (target, reg);
+ 		shll_l_ri (target, regd_shift);
+ 	    } else
+ 		mov_l_ri (target, 0);
+ 
+ 	    /* target is now regd */
+ 	    if (!ignorebase)
+ 		add_l (target, base);
+ 	    add_l_ri (target, addbase);
+ 	    if (dp & 0x03)
+ 		readlong (target, target, tmp);
+ 	} else {		/* do the getlong first, then add regd */
+ 	    if (!ignorebase) {
+ 		mov_l_rr (target, base);
+ 		add_l_ri (target, addbase);
+ 	    } else
+ 		mov_l_ri (target, addbase);
+ 	    if (dp & 0x03)
+ 		readlong (target, target, tmp);
+ 
+ 	    if (!ignorereg) {
+ 		if ((dp & 0x800) == 0)
+ 		    sign_extend_16_rr (tmp, reg);
+ 		else
+ 		    mov_l_rr (tmp, reg);
+ 		shll_l_ri (tmp, regd_shift);
+ 		/* tmp is now regd */
+ 		add_l (target, tmp);
+ 	    }
+ 	}
+ 	add_l_ri (target, outer);
+     } else {			/* 68000 version */
+ 	if ((dp & 0x800) == 0) {	/* Sign extend */
+ 	    sign_extend_16_rr (target, reg);
+ 	    lea_l_brr_indexed (target, base, target, 1 << regd_shift, (uae_s32) ((uae_s8) dp));
+ 	} else {
+ 	    lea_l_brr_indexed (target, base, reg, 1 << regd_shift, (uae_s32) ((uae_s8) dp));
+ 	}
+     }
+     forget_about (tmp);
+ }
+ 
+ static __inline__ unsigned int cft_map (unsigned int f)
+ {
+     return ((f >> 8) & 255) | ((f & 255) << 8);
+ }
+ 
+ void set_cache_state (int enabled)
+ {
+     if (enabled != letit)
+ 	flush_icache_hard (77);
+     letit = enabled;
+ }
+ 
+ int get_cache_state (void)
+ {
+     return letit;
+ }
+ 
+ uae_u32 get_jitted_size (void)
+ {
+     if (compiled_code)
+ 	return current_compile_p - compiled_code;
+     return 0;
+ }
+ 
+ void alloc_cache (void)
+ {
+     if (compiled_code) {
+ 	flush_icache_hard (6);
+ 	free (compiled_code);
+     }
+     compiled_code = NULL;
+     if (currprefs.cachesize == 0)
+ 	return;
+ 
+     while (!compiled_code && currprefs.cachesize) {
+ 	compiled_code = malloc (currprefs.cachesize * 1024);
+ 	if (!compiled_code)
+ 	    currprefs.cachesize /= 2;
+     }
+     if (compiled_code) {
+ 	mprotect (compiled_code, currprefs.cachesize * 1024, PROT_READ | PROT_WRITE | PROT_EXEC);
+ 	max_compile_start = compiled_code + currprefs.cachesize * 1024 - BYTES_PER_INST;
+ 	current_compile_p = compiled_code;
+     }
+ }
+ 
+ extern unsigned long op_illg_1 (uae_u32 opcode) REGPARAM;
+ 
+ static void calc_checksum (blockinfo * bi, uae_u32 * c1, uae_u32 * c2)
+ {
+     uae_u32 k1 = 0;
+     uae_u32 k2 = 0;
+     uae_s32 len = bi->len;
+     uae_u32 tmp = bi->min_pcp;
+     uae_u32 *pos;
+ 
+     len += (tmp & 3);
+     tmp &= (~3);
+     pos = (uae_u32 *) tmp;
+ 
+     if (len < 0 || len > MAX_CHECKSUM_LEN) {
+ 	*c1 = 0;
+ 	*c2 = 0;
+     } else {
+ 	while (len > 0) {
+ 	    k1 += *pos;
+ 	    k2 ^= *pos;
+ 	    pos++;
+ 	    len -= 4;
+ 	}
+ 	*c1 = k1;
+ 	*c2 = k2;
+     }
+ }
+ 
+ static void show_checksum (blockinfo * bi)
+ {
+     uae_u32 k1 = 0;
+     uae_u32 k2 = 0;
+     uae_s32 len = bi->len;
+     uae_u32 tmp = (uae_u32) bi->pc_p;
+     uae_u32 *pos;
+ 
+     len += (tmp & 3);
+     tmp &= (~3);
+     pos = (uae_u32 *) tmp;
+ 
+     if (len < 0 || len > MAX_CHECKSUM_LEN) {
+ 	return;
+     } else {
+ 	while (len > 0) {
+ 	    printf ("%08x ", *pos);
+ 	    pos++;
+ 	    len -= 4;
+ 	}
+ 	printf (" bla\n");
+     }
+ }
+ 
+ 
+ int check_for_cache_miss (void)
+ {
+     blockinfo *bi = get_blockinfo_addr (regs.pc_p);
+ 
+     if (bi) {
+ 	int cl = cacheline (regs.pc_p);
+ 	if (bi != cache_tags[cl + 1].bi) {
+ 	    raise_in_cl_list (bi);
+ 	    return 1;
+ 	}
+     }
+     return 0;
+ }
+ 
+ 
+ static void recompile_block (void)
+ {
+     /* An existing block's countdown code has expired. We need to make
+        sure that execute_normal doesn't refuse to recompile due to a
+        perceived cache miss... */
+     blockinfo *bi = get_blockinfo_addr (regs.pc_p);
+ 
+     Dif (!bi)
+ 	abort ();
+     raise_in_cl_list (bi);
+     execute_normal ();
+     return;
+ }
+ 
+ static void cache_miss (void)
+ {
+     blockinfo *bi = get_blockinfo_addr (regs.pc_p);
+     uae_u32 cl = cacheline (regs.pc_p);
+     blockinfo *bi2 = get_blockinfo (cl);
+ 
+     if (!bi) {
+ 	execute_normal ();	/* Compile this block now */
+ 	return;
+     }
+     Dif (!bi2 || bi == bi2) {
+ 	fprintf (stderr, "Unexplained cache miss %p %p\n", bi, bi2);
+ 	abort ();
+     }
+     raise_in_cl_list (bi);
+     return;
+ }
+ 
+ static void check_checksum (void)
+ {
+     blockinfo *bi = get_blockinfo_addr (regs.pc_p);
+     uae_u32 cl = cacheline (regs.pc_p);
+     blockinfo *bi2 = get_blockinfo (cl);
+ 
+     uae_u32 c1, c2;
+ 
+     checksum_count++;
+     /* These are not the droids you are looking for...  */
+     if (!bi) {
+ 	/* Whoever is the primary target is in a dormant state, but
+ 	   calling it was accidental, and we should just compile this
+ 	   new block */
+ 	execute_normal ();
+ 	return;
+     }
+     if (bi != bi2) {
+ 	/* The block was hit accidentally, but it does exist. Cache miss */
+ 	cache_miss ();
+ 	return;
+     }
+ 
+     if (bi->c1 || bi->c2)
+ 	calc_checksum (bi, &c1, &c2);
+     else {
+ 	c1 = c2 = 1;		/* Make sure it doesn't match */
+     }
+     if (c1 == bi->c1 && c2 == bi->c2) {
+ 	/* This block is still OK. So we reactivate. Of course, that
+ 	   means we have to move it into the needs-to-be-flushed list */
+ 	bi->handler_to_use = bi->handler;
+ 	set_dhtu (bi, bi->direct_handler);
+ 
+ 	/*      printf("reactivate %p/%p (%x %x/%x %x)\n",bi,bi->pc_p,
+ 	   c1,c2,bi->c1,bi->c2); */
+ 	remove_from_list (bi);
+ 	add_to_active (bi);
+ 	raise_in_cl_list (bi);
+     } else {
+ 	/* This block actually changed. We need to invalidate it,
+ 	   and set it up to be recompiled */
+ 	/* printf("discard %p/%p (%x %x/%x %x)\n",bi,bi->pc_p,
+ 	   c1,c2,bi->c1,bi->c2); */
+ 	invalidate_block (bi);
+ 	raise_in_cl_list (bi);
+ 	execute_normal ();
+     }
+ }
+ 
+ 
+ static uae_u8 popallspace[1024];	/* That should be enough space */
+ 
+ static __inline__ void create_popalls (void)
+ {
+     int i, r;
+ 
+     current_compile_p = popallspace;
+     set_target (current_compile_p);
+ #if USE_PUSH_POP
+     /* If we can't use gcc inline assembly, we need to pop some
+        registers before jumping back to the various get-out routines.
+        This generates the code for it.
+      */
+     popall_do_nothing = current_compile_p;
+     for (i = 0; i < N_REGS; i++) {
+ 	if (need_to_preserve[i])
+ 	    raw_pop_l_r (i);
+     }
+     raw_jmp ((uae_u32) do_nothing);
+     align_target (32);
+ 
+     popall_execute_normal = get_target ();
+     for (i = 0; i < N_REGS; i++) {
+ 	if (need_to_preserve[i])
+ 	    raw_pop_l_r (i);
+     }
+     raw_jmp ((uae_u32) execute_normal);
+     align_target (32);
+ 
+     popall_cache_miss = get_target ();
+     for (i = 0; i < N_REGS; i++) {
+ 	if (need_to_preserve[i])
+ 	    raw_pop_l_r (i);
+     }
+     raw_jmp ((uae_u32) cache_miss);
+     align_target (32);
+ 
+     popall_recompile_block = get_target ();
+     for (i = 0; i < N_REGS; i++) {
+ 	if (need_to_preserve[i])
+ 	    raw_pop_l_r (i);
+     }
+     raw_jmp ((uae_u32) recompile_block);
+     align_target (32);
+ 
+     popall_exec_nostats = get_target ();
+     for (i = 0; i < N_REGS; i++) {
+ 	if (need_to_preserve[i])
+ 	    raw_pop_l_r (i);
+     }
+     raw_jmp ((uae_u32) exec_nostats);
+     align_target (32);
+ 
+     popall_check_checksum = get_target ();
+     for (i = 0; i < N_REGS; i++) {
+ 	if (need_to_preserve[i])
+ 	    raw_pop_l_r (i);
+     }
+     raw_jmp ((uae_u32) check_checksum);
+     align_target (32);
+ 
+     current_compile_p = get_target ();
+ #else
+     popall_exec_nostats = exec_nostats;
+     popall_execute_normal = execute_normal;
+     popall_cache_miss = cache_miss;
+     popall_recompile_block = recompile_block;
+     popall_do_nothing = do_nothing;
+     popall_check_checksum = check_checksum;
+ #endif
+ 
+     /* And now, the code to do the matching pushes and then jump
+        into a handler routine */
+     pushall_call_handler = get_target ();
+ #if USE_PUSH_POP
+     for (i = N_REGS; i--;) {
+ 	if (need_to_preserve[i])
+ 	    raw_push_l_r (i);
+     }
+ #endif
+     r = REG_PC_TMP;
+     raw_mov_l_rm (r, (uae_u32) & regs.pc_p);
+     raw_and_l_ri (r, TAGMASK);
+     raw_jmp_m_indexed ((uae_u32) cache_tags, r, 4);
+ }
+ 
+ static __inline__ void reset_lists (void)
+ {
+     int i;
+ 
+     for (i = 0; i < MAX_HOLD_BI; i++)
+ 	hold_bi[i] = NULL;
+     active = NULL;
+     dormant = NULL;
+ }
+ 
+ static void prepare_block (blockinfo * bi)
+ {
+     int i;
+ 
+     set_target (current_compile_p);
+     align_target (32);
+     bi->direct_pen = (void *) get_target ();
+     raw_mov_l_rm (0, (uae_u32) & (bi->pc_p));
+     raw_mov_l_mr ((uae_u32) & regs.pc_p, 0);
+     raw_jmp ((uae_u32) popall_execute_normal);
+ 
+     align_target (32);
+     bi->direct_pcc = (void *) get_target ();
+     raw_mov_l_rm (0, (uae_u32) & (bi->pc_p));
+     raw_mov_l_mr ((uae_u32) & regs.pc_p, 0);
+     raw_jmp ((uae_u32) popall_check_checksum);
+ 
+     align_target (32);
+     current_compile_p = get_target ();
+ 
+     bi->deplist = NULL;
+     for (i = 0; i < 2; i++) {
+ 	bi->dep[i].prev_p = NULL;
+ 	bi->dep[i].next = NULL;
+     }
+     bi->env = default_ss;
+     bi->status = BI_NEW;
+     bi->havestate = 0;
+     //bi->env=empty_ss;
+ }
+ 
+ void compemu_reset (void)
+ {
+     int i;
+ 
+     set_cache_state (0);
+ }
+ 
+ void build_comp (void)
+ {
+     int i;
+     int jumpcount = 0;
+     unsigned long opcode;
+     struct cputbl *tbl = op_smalltbl_0_comp_ff;
+     struct cputbl *nftbl = op_smalltbl_0_comp_nf;
+     int count;
+ #ifdef NOFLAGS_SUPPORT
+     struct cputbl *nfctbl = (currprefs.cpu_level == 4 ? op_smalltbl_0_nf
+ 			     : currprefs.cpu_level == 3 ? op_smalltbl_1_nf
+ 			     : currprefs.cpu_level == 2 ? op_smalltbl_2_nf
+ 			     : currprefs.cpu_level == 1 ? op_smalltbl_3_nf
+ 			     : !currprefs.cpu_compatible ? op_smalltbl_4_nf : op_smalltbl_5_nf);
+ #endif
+     raw_init_cpu ();
+ #ifdef NATMEM_OFFSET
+     write_log ("Setting signal handler\n");
+ #ifndef _WIN32
+     act.sa_sigaction = vec;
+     
+ 	sigemptyset (&act.sa_mask);
+ 	act.sa_flags = SA_SIGINFO;
+ 	sigaction (SIGSEGV, &act, NULL);
+ #endif
+ #endif
+     write_log ("Building Compiler function table\n");
+     for (opcode = 0; opcode < 65536; opcode++) {
+ #ifdef NOFLAGS_SUPPORT
+ 	nfcpufunctbl[opcode] = op_illg_1;
+ #endif
+ 	compfunctbl[opcode] = NULL;
+ 	nfcompfunctbl[opcode] = NULL;
+ 	prop[opcode].use_flags = 0x1f;
+ 	prop[opcode].set_flags = 0x1f;
+ 	prop[opcode].is_jump = 1;
+     }
+ 
+     for (i = 0; tbl[i].opcode < 65536; i++) {
+ 	int isjmp = (tbl[i].specific & 1);
+ 	int isaddx = (tbl[i].specific & 8);
+ 	int iscjmp = (tbl[i].specific & 16);
+ 
+ 	prop[tbl[i].opcode].is_jump = isjmp;
+ 	prop[tbl[i].opcode].is_const_jump = iscjmp;
+ 	prop[tbl[i].opcode].is_addx = isaddx;
+ 	compfunctbl[tbl[i].opcode] = tbl[i].handler;
+     }
+     for (i = 0; nftbl[i].opcode < 65536; i++) {
+ 	nfcompfunctbl[nftbl[i].opcode] = nftbl[i].handler;
+ #ifdef NOFLAGS_SUPPORT
+ 	nfcpufunctbl[nftbl[i].opcode] = nfctbl[i].handler;
+ #endif
+     }
+ 
+ #ifdef NOFLAGS_SUPPORT
+     for (i = 0; nfctbl[i].handler; i++) {
+ 	nfcpufunctbl[nfctbl[i].opcode] = nfctbl[i].handler;
+     }
+ #endif
+ 
+     for (opcode = 0; opcode < 65536; opcode++) {
+ 	cpuop_func *f;
+ 	cpuop_func *nff;
+ #ifdef NOFLAGS_SUPPORT
+ 	cpuop_func *nfcf;
+ #endif
+ 	int isjmp, isaddx, iscjmp;
+ 
+ 	if (table68k[opcode].mnemo == i_ILLG || table68k[opcode].clev > currprefs.cpu_level)
+ 	    continue;
+ 
+ 	if (table68k[opcode].handler != -1) {
+ 	    f = compfunctbl[table68k[opcode].handler];
+ 	    nff = nfcompfunctbl[table68k[opcode].handler];
+ #ifdef NOFLAGS_SUPPORT
+ 	    nfcf = nfcpufunctbl[table68k[opcode].handler];
+ #endif
+ 	    isjmp = prop[table68k[opcode].handler].is_jump;
+ 	    iscjmp = prop[table68k[opcode].handler].is_const_jump;
+ 	    isaddx = prop[table68k[opcode].handler].is_addx;
+ 	    prop[opcode].is_jump = isjmp;
+ 	    prop[opcode].is_const_jump = iscjmp;
+ 	    prop[opcode].is_addx = isaddx;
+ 	    compfunctbl[opcode] = f;
+ 	    nfcompfunctbl[opcode] = nff;
+ #ifdef NOFLAGS_SUPPORT
+ 	    Dif (nfcf == op_illg_1)
+ 		abort ();
+ 	    nfcpufunctbl[opcode] = nfcf;
+ #endif
+ 	}
+ 	prop[opcode].set_flags = table68k[opcode].flagdead;
+ 	prop[opcode].use_flags = table68k[opcode].flaglive;
+ 	/* Unconditional jumps don't evaluate condition codes, so they
+ 	   don't actually use any flags themselves */
+ 	if (prop[opcode].is_const_jump)
+ 	    prop[opcode].use_flags = 0;
+     }
+ #ifdef NOFLAGS_SUPPORT
+     for (i = 0; nfctbl[i].handler != NULL; i++) {
+ 	if (nfctbl[i].specific)
+ 	    nfcpufunctbl[tbl[i].opcode] = nfctbl[i].handler;
+     }
+ #endif
+ 
+     count = 0;
+     for (opcode = 0; opcode < 65536; opcode++) {
+ 	if (compfunctbl[opcode])
+ 	    count++;
+     }
+     fprintf (stderr, "Supposedly %d compileable opcodes!\n", count);
+ 
+     /* Initialise state */
+     create_popalls ();
+     alloc_cache ();
+     reset_lists ();
+ 
+     for (i = 0; i < TAGSIZE; i += 2) {
+ 	cache_tags[i].handler = (void *) popall_execute_normal;
+ 	cache_tags[i + 1].bi = NULL;
+     }
+     compemu_reset ();
+ 
+     for (i = 0; i < N_REGS; i++) {
+ 	empty_ss.nat[i].holds = -1;
+ 	empty_ss.nat[i].validsize = 0;
+ 	empty_ss.nat[i].dirtysize = 0;
+     }
+     default_ss = empty_ss;
+ #if 0
+     default_ss.nat[6].holds = 11;
+     default_ss.nat[6].validsize = 4;
+     default_ss.nat[5].holds = 12;
+     default_ss.nat[5].validsize = 4;
+ #endif
+ }
+ 
+ 
+ static void flush_icache_hard (int n)
+ {
+     uae_u32 i;
+     blockinfo *bi;
+ 
+     hard_flush_count++;
+ #if 0
+     printf ("Flush Icache_hard(%d/%x/%p), %u instruction bytes\n", n, regs.pc, regs.pc_p, current_compile_p - compiled_code);
+ #endif
+     bi = active;
+     while (bi) {
+ 	cache_tags[cacheline (bi->pc_p)].handler = (void *) popall_execute_normal;
+ 	cache_tags[cacheline (bi->pc_p) + 1].bi = NULL;
+ 	bi = bi->next;
+     }
+     bi = dormant;
+     while (bi) {
+ 	cache_tags[cacheline (bi->pc_p)].handler = (void *) popall_execute_normal;
+ 	cache_tags[cacheline (bi->pc_p) + 1].bi = NULL;
+ 	bi = bi->next;
+     }
+ 
+     reset_lists ();
+     if (!compiled_code)
+ 	return;
+     current_compile_p = compiled_code;
+     set_special (0);		/* To get out of compiled code */
+ }
+ 
+ 
+ /* "Soft flushing" --- instead of actually throwing everything away,
+    we simply mark everything as "needs to be checked". 
+ */
+ 
+ void flush_icache (int n)
+ {
+     uae_u32 i;
+     blockinfo *bi;
+     blockinfo *bi2;
+ 
+     if (currprefs.comp_hardflush) {
+ 	flush_icache_hard (n);
+ 	return;
+     }
+     soft_flush_count++;
+     if (!active)
+ 	return;
+ 
+     bi = active;
+     while (bi) {
+ 	uae_u32 cl = cacheline (bi->pc_p);
+ 	if (!bi->handler) {
+ 	    /* invalidated block */
+ 	    if (bi == cache_tags[cl + 1].bi)
+ 		cache_tags[cl].handler = popall_execute_normal;
+ 	    bi->handler_to_use = popall_execute_normal;
+ 	    set_dhtu (bi, bi->direct_pen);
+ 	} else {
+ 	    if (bi == cache_tags[cl + 1].bi)
+ 		cache_tags[cl].handler = popall_check_checksum;
+ 	    bi->handler_to_use = popall_check_checksum;
+ 	    set_dhtu (bi, bi->direct_pcc);
+ 	}
+ 	bi2 = bi;
+ 	bi = bi->next;
+     }
+     /* bi2 is now the last entry in the active list */
+     bi2->next = dormant;
+     if (dormant)
+ 	dormant->prev_p = &(bi2->next);
+ 
+     dormant = active;
+     active->prev_p = &dormant;
+     active = NULL;
+ }
+ 
+ 
+ static void catastrophe (void)
+ {
+     abort ();
+ }
+ 
+ int failure;
+ 
+ static int *pa, *pb;
+ 
+ static void foobar (void *a, void *b)
+ {
+     /* breakpoint me! */
+     pa = a; pb = b;
+ }
+ 
+ void compile_block (cpu_history * pc_hist, int blocklen, int totcycles)
+ {
+     if (letit && compiled_code && currprefs.cpu_level >= 2) {
+ 
+ 	/* OK, here we need to 'compile' a block */
+ 	int i;
+ 	int r;
+ 	int was_comp = 0;
+ 	uae_u8 liveflags[MAXRUN + 1];
+ 	uae_u32 max_pcp = (uae_u32) pc_hist[0].location;
+ 	uae_u32 min_pcp = max_pcp;
+ 	uae_u32 cl = cacheline (pc_hist[0].location);
+ 	void *specflags = (void *) &regs.spcflags;
+ 	blockinfo *bi = NULL;
+ 	blockinfo *bi2;
+ 	int extra_len = 0;
+ 
+ 	compile_count++;
+ 	if (current_compile_p >= max_compile_start)
+ 	    flush_icache_hard (7);
+ 
+ 	alloc_blockinfos ();
+ 
+ 	bi = get_blockinfo_addr_new (pc_hist[0].location, 0);
+ 	bi2 = get_blockinfo (cl);
+ 
+ 	optlev = bi->optlevel;
+ 	if (bi->handler) {
+ 	    Dif (bi != bi2) {
+ 		/* I don't think it can happen anymore. Shouldn't, in 
+ 		   any case. So let's make sure... */
+ 		printf ("WOOOWOO count=%d, ol=%d %p %p\n", bi->count, bi->optlevel, bi->handler_to_use, cache_tags[cl].handler);
+ 		abort ();
+ 	    }
+ 
+ 	    Dif (bi->count != -1 && bi->status != BI_TARGETTED) {
+ 		/* What the heck? We are not supposed to be here! */
+ 		abort ();
+ 	    }
+ 	}
+ 	if (bi->count == -1) {
+ 	    optlev++;
+ 	    while (!currprefs.optcount[optlev])
+ 		optlev++;
+ 	    bi->count = currprefs.optcount[optlev] - 1;
+ 	}
+ 	current_block_pc_p = (uae_u32) pc_hist[0].location;
+ 
+ 	remove_deps (bi);	/* We are about to create new code */
+ 	bi->optlevel = optlev;
+ 	bi->pc_p = (uae_u8 *) pc_hist[0].location;
+ 
+ 	liveflags[blocklen] = 0x1f;	/* All flags needed afterwards */
+ 	i = blocklen;
+ 	while (i--) {
+ 	    uae_u16 *currpcp = pc_hist[i].location;
+ 	    int op = cft_map (*currpcp);
+ 
+ 	    if ((uae_u32) currpcp < min_pcp)
+ 		min_pcp = (uae_u32) currpcp;
+ 	    if ((uae_u32) currpcp > max_pcp)
+ 		max_pcp = (uae_u32) currpcp;
+ 
+ 	    if (currprefs.compnf) {
+ 		liveflags[i] = ((liveflags[i + 1] & (~prop[op].set_flags)) | prop[op].use_flags);
+ 		if (prop[op].is_addx && (liveflags[i + 1] & FLAG_Z) == 0)
+ 		    liveflags[i] &= ~FLAG_Z;
+ 	    } else {
+ 		liveflags[i] = 0x1f;
+ 	    }
+ 	}
+ 
+ 	bi->needed_flags = liveflags[0];
+ 
+ 	/* This is the non-direct handler */
+ 	align_target (32);
+ 	set_target (get_target () + 1);
+ 	align_target (16);
+ 	/* Now aligned at n*32+16 */
+ 
+ 	bi->handler = bi->handler_to_use = (void *) get_target ();
+ 	raw_cmp_l_mi ((uae_u32) & regs.pc_p, (uae_u32) pc_hist[0].location);
+ 	raw_jnz ((uae_u32) popall_cache_miss);
+ 	/* This was 16 bytes on the x86, so now aligned on (n+1)*32 */
+ 
+ 	was_comp = 0;
+ 
+ #if USE_MATCHSTATE
+ 	comp_pc_p = (uae_u8 *) pc_hist[0].location;
+ 	init_comp ();
+ 	match_states (&(bi->env));
+ 	was_comp = 1;
+ #endif
+ 
+ 	bi->direct_handler = (void *) get_target ();
+ 	set_dhtu (bi, bi->direct_handler);
+ 	current_block_start_target = (uae_u32) get_target ();
+ 
+ 	if (bi->count >= 0) {	/* Need to generate countdown code */
+ 	    raw_mov_l_mi ((uae_u32) & regs.pc_p, (uae_u32) pc_hist[0].location);
+ 	    raw_sub_l_mi ((uae_u32) & (bi->count), 1);
+ 	    raw_jl ((uae_u32) popall_recompile_block);
+ 	}
+ 	if (optlev == 0) {	/* No need to actually translate */
+ 	    /* Execute normally without keeping stats */
+ 	    raw_mov_l_mi ((uae_u32) & regs.pc_p, (uae_u32) pc_hist[0].location);
+ 	    raw_jmp ((uae_u32) popall_exec_nostats);
+ 	} else {
+ 	    reg_alloc_run = 0;
+ 	    next_pc_p = 0;
+ 	    taken_pc_p = 0;
+ 	    branch_cc = 0;
+ 
+ 	    log_startblock ();
+ 	    for (i = 0; i < blocklen && get_target_noopt () < max_compile_start; i++) {
+ 		cpuop_func **cputbl;
+ 		cpuop_func **comptbl;
+ 		uae_u16 opcode;
+ 
+ 		opcode = cft_map ((uae_u16) * pc_hist[i].location);
+ 		special_mem = pc_hist[i].specmem;
+ 		needed_flags = (liveflags[i + 1] & prop[opcode].set_flags);
+ 		if (!needed_flags && currprefs.compnf) {
+ #ifdef NOFLAGS_SUPPORT
+ 		    cputbl = nfcpufunctbl;
+ #else
+ 		    cputbl = cpufunctbl;
+ #endif
+ 		    comptbl = nfcompfunctbl;
+ 		} else {
+ 		    cputbl = cpufunctbl;
+ 		    comptbl = compfunctbl;
+ 		}
+ 
+ 		if (comptbl[opcode] && optlev > 1) {
+ 		    failure = 0;
+ 		    if (!was_comp) {
+ 			comp_pc_p = (uae_u8 *) pc_hist[i].location;
+ 			init_comp ();
+ 		    }
+ 		    was_comp++;
+ 
+ 		    comptbl[opcode] (opcode);
+ 		    freescratch ();
+ 		    if (!(liveflags[i + 1] & FLAG_CZNV)) {
+ 			/* We can forget about flags */
+ 			dont_care_flags ();
+ 		    }
+ #if INDIVIDUAL_INST
+ 		    flush (1);
+ 		    nop ();
+ 		    flush (1);
+ 		    was_comp = 0;
+ #endif
+ 		} else
+ 		    failure = 1;
+ 		if (failure) {
+ 		    if (was_comp) {
+ 			flush (1);
+ 			was_comp = 0;
+ 		    }
+ 		    raw_mov_l_ri (REG_PAR1, (uae_u32) opcode);
+ #if USE_NORMAL_CALLING_CONVENTION
+ 		    raw_push_l_r (REG_PAR1);
+ #endif
+ 		    raw_mov_l_mi ((uae_u32) & regs.pc_p, (uae_u32) pc_hist[i].location);
+ 		    raw_call ((uae_u32) cputbl[opcode]);
+ 		    //raw_add_l_mi((uae_u32)&oink,1); // FIXME
+ #if USE_NORMAL_CALLING_CONVENTION
+ 		    raw_inc_sp (4);
+ #endif
+ 		    if (needed_flags) {
+ 			//raw_mov_l_mi((uae_u32)&foink3,(uae_u32)opcode+65536);
+ 		    } else {
+ 			//raw_mov_l_mi((uae_u32)&foink3,(uae_u32)opcode);
+ 		    }
+ 
+ 		    if (i < blocklen - 1) {
+ 			uae_s8 *branchadd;
+ 
+ 			raw_mov_l_rm (0, (uae_u32) specflags);
+ 			raw_test_l_rr (0, 0);
+ 			raw_jz_b_oponly ();
+ 			branchadd = get_target ();
+ 			emit_byte (0);
+ 			raw_sub_l_mi ((uae_u32) & countdown, scaled_cycles (totcycles));
+ 			raw_jmp ((uae_u32) popall_do_nothing);
+ 			*branchadd = (uae_u32) get_target () - (uae_u32) branchadd - 1;
+ 		    }
+ 		}
+ 	    }
+ #if 0				/* This isn't completely kosher yet; It really needs to be
+ 				   be integrated into a general inter-block-dependency scheme */
+ 	    if (next_pc_p && taken_pc_p && was_comp && taken_pc_p == current_block_pc_p) {
+ 		blockinfo *bi1 = get_blockinfo_addr_new ((void *) next_pc_p, 0);
+ 		blockinfo *bi2 = get_blockinfo_addr_new ((void *) taken_pc_p, 0);
+ 		uae_u8 x = bi1->needed_flags;
+ 
+ 		if (x == 0xff || 1) {	/* To be on the safe side */
+ 		    uae_u16 *next = (uae_u16 *) next_pc_p;
+ 		    uae_u16 op = cft_map (*next);
+ 
+ 		    x = 0x1f;
+ 		    x &= (~prop[op].set_flags);
+ 		    x |= prop[op].use_flags;
+ 		}
+ 
+ 		x |= bi2->needed_flags;
+ 		if (!(x & FLAG_CZNV)) {
+ 		    /* We can forget about flags */
+ 		    dont_care_flags ();
+ 		    extra_len += 2;	/* The next instruction now is part of this
+ 					   block */
+ 		}
+ 
+ 	    }
+ #endif
+ 
+ 	    if (next_pc_p) {	/* A branch was registered */
+ 		uae_u32 t1 = next_pc_p;
+ 		uae_u32 t2 = taken_pc_p;
+ 		int cc = branch_cc;
+ 
+ 		uae_u32 *branchadd;
+ 		uae_u32 *tba;
+ 		bigstate tmp;
+ 		blockinfo *tbi;
+ 
+ 		if (taken_pc_p < next_pc_p) {
+ 		    /* backward branch. Optimize for the "taken" case ---
+ 		       which means the raw_jcc should fall through when
+ 		       the 68k branch is taken. */
+ 		    t1 = taken_pc_p;
+ 		    t2 = next_pc_p;
+ 		    cc = branch_cc ^ 1;
+ 		}
+ #if !USE_MATCHSTATE
+ 		flush_keepflags ();
+ #endif
+ 		tmp = live;	/* ouch! This is big... */
+ 		raw_jcc_l_oponly (cc);
+ 		branchadd = (uae_u32 *) get_target ();
+ 		emit_long (0);
+ 		/* predicted outcome */
+ 		tbi = get_blockinfo_addr_new ((void *) t1, 1);
+ 		match_states (&(tbi->env));
+ 		//flush(1); /* Can only get here if was_comp==1 */
+ 		raw_sub_l_mi ((uae_u32) & countdown, scaled_cycles (totcycles));
+ 		raw_jcc_l_oponly (9);
+ 		tba = (uae_u32 *) get_target ();
+ 		emit_long (get_handler (t1) - ((uae_u32) tba + 4));
+ 		raw_mov_l_mi ((uae_u32) & regs.pc_p, t1);
+ 		raw_jmp ((uae_u32) popall_do_nothing);
+ 		create_jmpdep (bi, 0, tba, t1);
+ 
+ 		align_target (16);
+ 		/* not-predicted outcome */
+ 		*branchadd = (uae_u32) get_target () - ((uae_u32) branchadd + 4);
+ 		live = tmp;	/* Ouch again */
+ 		tbi = get_blockinfo_addr_new ((void *) t2, 1);
+ 		match_states (&(tbi->env));
+ 
+ 		//flush(1); /* Can only get here if was_comp==1 */
+ 		raw_sub_l_mi ((uae_u32) & countdown, scaled_cycles (totcycles));
+ 		raw_jcc_l_oponly (9);
+ 		tba = (uae_u32 *) get_target ();
+ 		emit_long (get_handler (t2) - ((uae_u32) tba + 4));
+ 		raw_mov_l_mi ((uae_u32) & regs.pc_p, t2);
+ 		raw_jmp ((uae_u32) popall_do_nothing);
+ 		create_jmpdep (bi, 1, tba, t2);
+ 	    } else {
+ 		if (was_comp) {
+ 		    flush (1);
+ 		}
+ 
+ 		/* Let's find out where next_handler is... */
+ 		if (was_comp && isinreg (PC_P)) {
+ 		    int r2;
+ 
+ 		    r = live.state[PC_P].realreg;
+ 
+ 		    if (r == 0)
+ 			r2 = 1;
+ 		    else
+ 			r2 = 0;
+ 
+ 		    raw_and_l_ri (r, TAGMASK);
+ 		    raw_mov_l_ri (r2, (uae_u32) popall_do_nothing);
+ 		    raw_sub_l_mi ((uae_u32) & countdown, scaled_cycles (totcycles));
+ 		    raw_cmov_l_rm_indexed (r2, (uae_u32) cache_tags, r, 4, 9);
+ 		    raw_jmp_r (r2);
+ 		} else if (was_comp && isconst (PC_P)) {
+ 		    uae_u32 v = live.state[PC_P].val;
+ 		    uae_u32 *tba;
+ 		    blockinfo *tbi;
+ 
+ 		    tbi = get_blockinfo_addr_new ((void *) v, 1);
+ 		    match_states (&(tbi->env));
+ 
+ 		    raw_sub_l_mi ((uae_u32) & countdown, scaled_cycles (totcycles));
+ 		    raw_jcc_l_oponly (9);
+ 		    tba = (uae_u32 *) get_target ();
+ 		    emit_long (get_handler (v) - ((uae_u32) tba + 4));
+ 		    raw_mov_l_mi ((uae_u32) & regs.pc_p, v);
+ 		    raw_jmp ((uae_u32) popall_do_nothing);
+ 		    create_jmpdep (bi, 0, tba, v);
+ 		} else {
+ 		    int r2;
+ 
+ 		    r = REG_PC_TMP;
+ 		    raw_mov_l_rm (r, (uae_u32) & regs.pc_p);
+ 		    if (r == 0)
+ 			r2 = 1;
+ 		    else
+ 			r2 = 0;
+ 
+ 		    raw_and_l_ri (r, TAGMASK);
+ 		    raw_mov_l_ri (r2, (uae_u32) popall_do_nothing);
+ 		    raw_sub_l_mi ((uae_u32) & countdown, scaled_cycles (totcycles));
+ 		    raw_cmov_l_rm_indexed (r2, (uae_u32) cache_tags, r, 4, 9);
+ 		    raw_jmp_r (r2);
+ 		}
+ 	    }
+ 	    if (bi->len > 80)
+ 		foobar (bi->direct_handler, get_target ());
+ 	}
+ 
+ 	if (next_pc_p + extra_len >= max_pcp && next_pc_p + extra_len < max_pcp + LONGEST_68K_INST)
+ 	    max_pcp = next_pc_p + extra_len;	/* extra_len covers flags magic */
+ 	else
+ 	    max_pcp += LONGEST_68K_INST;
+ 	bi->len = max_pcp - min_pcp;
+ 	bi->min_pcp = min_pcp;
+ 
+ 	remove_from_list (bi);
+ 	if (isinrom (min_pcp) && isinrom (max_pcp))
+ 	    add_to_dormant (bi);	/* No need to checksum it on cache flush.
+ 					   Please don't start changing ROMs in
+ 					   flight! */
+ 	else {
+ 	    calc_checksum (bi, &(bi->c1), &(bi->c2));
+ 	    add_to_active (bi);
+ 	}
+ 
+ 	log_dump ();
+ 	align_target (32);
+ 	current_compile_p = get_target ();
+ 
+ 	raise_in_cl_list (bi);
+ 	bi->nexthandler = current_compile_p;
+ 
+ 	/* We will flush soon, anyway, so let's do it now */
+ 	if (current_compile_p >= max_compile_start)
+ 	    flush_icache_hard (7);
+ 
+ 	do_extra_cycles (totcycles);	/* for the compilation time */
+     }
+ }
diff -crB --new-file ./uae-0.8.21/src/config.h ../uae_jit_cleaning/uae-0.8.21/src/config.h
*** ./uae-0.8.21/src/config.h	1970-01-01 02:00:00.000000000 +0200
--- ../uae_jit_cleaning/uae-0.8.21/src/config.h	2021-01-10 13:54:02.642591684 +0200
***************
*** 0 ****
--- 1 ----
+ #include "/home/osboxes/uae_Archives/build_0_8_21_jit/uae_jit_cleaning/uae-0.8.21/config.h"
diff -crB --new-file ./uae-0.8.21/src/custom.c ../uae_jit_cleaning/uae-0.8.21/src/custom.c
*** ./uae-0.8.21/src/custom.c	2002-02-16 16:18:13.000000000 +0200
--- ../uae_jit_cleaning/uae-0.8.21/src/custom.c	2021-01-10 13:10:29.874591684 +0200
***************
*** 20,28 ****
  #include "uae.h"
  #include "gensound.h"
  #include "sounddep/sound.h"
- #include "events.h"
  #include "memory.h"
  #include "custom.h"
  #include "newcpu.h"
  #include "cia.h"
  #include "disk.h"
--- 20,28 ----
  #include "uae.h"
  #include "gensound.h"
  #include "sounddep/sound.h"
  #include "memory.h"
  #include "custom.h"
+ #include "events.h"
  #include "newcpu.h"
  #include "cia.h"
  #include "disk.h"
***************
*** 54,63 ****
  /* Events */
  
  unsigned long int currcycle, nextevent, is_lastline;
  static int rpt_did_reset;
  struct ev eventtab[ev_max];
  
! frame_time_t vsynctime, vsyncmintime;
  
  static int vpos;
  static uae_u16 lof;
--- 54,67 ----
  /* Events */
  
  unsigned long int currcycle, nextevent, is_lastline;
+ long cycles_to_next_event;
+ long max_cycles_to_next_event;
+ long cycles_to_hsync_event;
+ 
  static int rpt_did_reset;
  struct ev eventtab[ev_max];
  
! volatile frame_time_t vsynctime, vsyncmintime;
  
  static int vpos;
  static uae_u16 lof;
***************
*** 3643,3669 ****
  
  static void do_savestate(void);
  
! static void vsync_handler (void)
  {
! #if 0
!     static int old_clxdat;
!     if (clxdat != old_clxdat) {
! 	printf ("CLXDAT %04x\n", clxdat);
! 	old_clxdat = clxdat;
!     }
! #endif
!     n_frames++;
  
      if (currprefs.m68k_speed == -1) {
  	frame_time_t curr_time = read_processor_time ();
! 	vsyncmintime += vsynctime;
  	/* @@@ Mathias? How do you think we should do this? */
  	/* If we are too far behind, or we just did a reset, adjust the
  	 * needed time. */
! 	if ((long int)(curr_time - vsyncmintime) > 0 || rpt_did_reset)
  	    vsyncmintime = curr_time + vsynctime;
! 	rpt_did_reset = 0;
      }
  
      handle_events ();
  
--- 3647,3698 ----
  
  static void do_savestate(void);
  
! #define N_LINES 8
! 
! STATIC_INLINE int trigger_frh (int v)
  {
!     return (v & (N_LINES - 1)) == 0;
! }
! 
! extern int gonebad;
  
+ static void frh_handler(void)
+ {
      if (currprefs.m68k_speed == -1) {
  	frame_time_t curr_time = read_processor_time ();
! #if 0
! 	printf("now=%lu, target=%lu, diff=%ld\n", curr_time, vsyncmintime,
! 	       diff32 (curr_time, vsyncmintime));
! #endif
! 
! 	vsyncmintime += vsynctime*N_LINES/625*2;
  	/* @@@ Mathias? How do you think we should do this? */
  	/* If we are too far behind, or we just did a reset, adjust the
  	 * needed time. */
! 	if (rpt_did_reset) {
  	    vsyncmintime = curr_time + vsynctime;
! 	    rpt_did_reset = 0;
! 	}
! 
! 	/* Allow this to be one frame's worth of cycles out */
! 	while (diff32 (curr_time, vsyncmintime + vsynctime) > 0) {
! 	    vsyncmintime += vsynctime*N_LINES/625*2;
! 	    gonebad++;
!  	}
      }
+ }
+ 
+ static void vsync_handler (void)
+ {
+     static int count=50;
+     
+     if (--count == 0) {
+ 	int i;
+ 	count=50;
+ 	newcpu_showstate();
+     }
+ 
+     n_frames++;
  
      handle_events ();
  
***************
*** 3811,3817 ****
  
      DISK_update ();
  
!     is_lastline = vpos + 1 == maxvpos + (lof != 0) && currprefs.m68k_speed == -1 && ! rpt_did_reset;
  
      if ((bplcon0 & 4) && currprefs.gfx_linedbl)
  	notice_interlace_seen ();
--- 3840,3856 ----
  
      DISK_update ();
  
!     if (currprefs.m68k_speed == -1) {
! 	static int count=0;
! 
! 	count++;
! 	if (trigger_frh(count)) {
! 	    frh_handler();
! 	}
! 	is_lastline = trigger_frh(count+1) && ! rpt_did_reset;
!     }
!     else
! 	is_lastline=0;
  
      if ((bplcon0 & 4) && currprefs.gfx_linedbl)
  	notice_interlace_seen ();
***************
*** 3898,3904 ****
  {
      int i;
  
!     currcycle = 0;
      for (i = 0; i < ev_max; i++) {
  	eventtab[i].active = 0;
  	eventtab[i].oldcycles = 0;
--- 3937,3944 ----
  {
      int i;
  
!     nextevent = 0;
!     set_cycles (0);
      for (i = 0; i < ev_max; i++) {
  	eventtab[i].active = 0;
  	eventtab[i].oldcycles = 0;
***************
*** 3968,3973 ****
--- 4008,4016 ----
  
      DISK_reset ();
      CIA_reset ();
+ #ifdef JIT
+     compemu_reset ();
+ #endif
      unset_special (~(SPCFLAG_BRK | SPCFLAG_MODE_CHANGE));
  
      vpos = 0;
***************
*** 3998,4004 ****
      cop_state.state = COP_stop;
      diwstate = DIW_waiting_start;
      hdiwstate = DIW_waiting_start;
!     currcycle = 0;
  
      new_beamcon0 = currprefs.ntscmode ? 0x00 : 0x20;
      init_hz ();
--- 4041,4047 ----
      cop_state.state = COP_stop;
      diwstate = DIW_waiting_start;
      hdiwstate = DIW_waiting_start;
!     set_cycles (0);
  
      new_beamcon0 = currprefs.ntscmode ? 0x00 : 0x20;
      init_hz ();
***************
*** 4076,4083 ****
      write_log ("DIWSTRT: %04x DIWSTOP: %04x DDFSTRT: %04x DDFSTOP: %04x\n",
  	       (unsigned int)diwstrt, (unsigned int)diwstop, (unsigned int)ddfstrt, (unsigned int)ddfstop);
      if (timeframes) {
! 	write_log ("Average frame time: %d ms [frames: %d time: %d]\n",
! 		   frametime / timeframes, timeframes, frametime);
  	if (total_skipped)
  	    write_log ("Skipped frames: %d\n", total_skipped);
      }
--- 4119,4126 ----
      write_log ("DIWSTRT: %04x DIWSTOP: %04x DDFSTRT: %04x DDFSTOP: %04x\n",
  	       (unsigned int)diwstrt, (unsigned int)diwstop, (unsigned int)ddfstrt, (unsigned int)ddfstop);
      if (timeframes) {
! 	write_log ("Average frame time: %f ms [frames: %d time: %d]\n",
! 		   (double)frametime / timeframes, timeframes, frametime);
  	if (total_skipped)
  	    write_log ("Skipped frames: %d\n", total_skipped);
      }
diff -crB --new-file ./uae-0.8.21/src/debug.c ../uae_jit_cleaning/uae-0.8.21/src/debug.c
*** ./uae-0.8.21/src/debug.c	2001-10-24 13:59:20.000000000 +0300
--- ../uae_jit_cleaning/uae-0.8.21/src/debug.c	2021-01-10 13:10:29.882591684 +0200
***************
*** 19,24 ****
--- 19,25 ----
  #include "uae.h"
  #include "memory.h"
  #include "custom.h"
+ #include "events.h"
  #include "newcpu.h"
  #include "debug.h"
  #include "cia.h"
diff -crB --new-file ./uae-0.8.21/src/disk.c ../uae_jit_cleaning/uae-0.8.21/src/disk.c
*** ./uae-0.8.21/src/disk.c	2002-01-31 16:09:52.000000000 +0200
--- ../uae_jit_cleaning/uae-0.8.21/src/disk.c	2021-01-10 13:10:29.882591684 +0200
***************
*** 1155,1161 ****
      {
  	int dr;
  	uaecptr pc = m68k_getpc ();
! 	if ((pc & 0xF80000) != 0xF80000)
  	    return;
  	for (dr = 0; dr < 4; dr++) {
  	    drive *drv = &floppy[dr];
--- 1155,1161 ----
      {
  	int dr;
  	uaecptr pc = m68k_getpc ();
! 	if ((munge24(pc) & 0xFFF80000) != 0xF80000)
  	    return;
  	for (dr = 0; dr < 4; dr++) {
  	    drive *drv = &floppy[dr];
diff -crB --new-file ./uae-0.8.21/src/drawing.c ../uae_jit_cleaning/uae-0.8.21/src/drawing.c
*** ./uae-0.8.21/src/drawing.c	2002-01-31 17:14:41.000000000 +0200
--- ../uae_jit_cleaning/uae-0.8.21/src/drawing.c	2021-01-10 13:10:29.882591684 +0200
***************
*** 38,49 ****
--- 38,51 ----
  #include "uae.h"
  #include "memory.h"
  #include "custom.h"
+ #include "events.h"
  #include "newcpu.h"
  #include "xwin.h"
  #include "autoconf.h"
  #include "gui.h"
  #include "picasso96.h"
  #include "drawing.h"
+ #include "compemu.h"
  #include "savestate.h"
  
  int lores_factor, lores_shift;
***************
*** 1725,1730 ****
--- 1727,1733 ----
  	check_picasso ();
  
  	check_prefs_changed_audio ();
+ 	check_prefs_changed_comp ();
  	check_prefs_changed_custom ();
  	check_prefs_changed_cpu ();
  	if (check_prefs_changed_gfx ()) {
diff -crB --new-file ./uae-0.8.21/src/ersatz.c ../uae_jit_cleaning/uae-0.8.21/src/ersatz.c
*** ./uae-0.8.21/src/ersatz.c	2001-12-17 20:38:37.000000000 +0200
--- ../uae_jit_cleaning/uae-0.8.21/src/ersatz.c	2021-01-10 13:10:29.882591684 +0200
***************
*** 15,20 ****
--- 15,21 ----
  #include "uae.h"
  #include "memory.h"
  #include "custom.h"
+ #include "events.h"
  #include "newcpu.h"
  #include "cia.h"
  #include "disk.h"
diff -crB --new-file ./uae-0.8.21/src/fpp.c ../uae_jit_cleaning/uae-0.8.21/src/fpp.c
*** ./uae-0.8.21/src/fpp.c	2001-11-19 19:53:29.000000000 +0200
--- ../uae_jit_cleaning/uae-0.8.21/src/fpp.c	2021-01-10 13:10:29.882591684 +0200
***************
*** 54,60 ****
      return src; /* Should never be reached */
  }
  
! static uae_u32 get_fpsr (void) 
  {
      uae_u32 answer = regs.fpsr & 0x00ffffff;
  #ifdef HAVE_ISNAN
--- 54,60 ----
      return src; /* Should never be reached */
  }
  
! uae_u32 get_fpsr (void) 
  {
      uae_u32 answer = regs.fpsr & 0x00ffffff;
  #ifdef HAVE_ISNAN
diff -crB --new-file ./uae-0.8.21/src/fsdb.c ../uae_jit_cleaning/uae-0.8.21/src/fsdb.c
*** ./uae-0.8.21/src/fsdb.c	2001-09-07 14:41:50.000000000 +0300
--- ../uae_jit_cleaning/uae-0.8.21/src/fsdb.c	2021-01-10 13:10:29.886591684 +0200
***************
*** 16,21 ****
--- 16,22 ----
  #include "uae.h"
  #include "memory.h"
  #include "custom.h"
+ #include "events.h"
  #include "newcpu.h"
  #include "filesys.h"
  #include "autoconf.h"
diff -crB --new-file ./uae-0.8.21/src/gencomp.c ../uae_jit_cleaning/uae-0.8.21/src/gencomp.c
*** ./uae-0.8.21/src/gencomp.c	1970-01-01 02:00:00.000000000 +0200
--- ../uae_jit_cleaning/uae-0.8.21/src/gencomp.c	2021-01-10 13:10:29.894591684 +0200
***************
*** 0 ****
--- 1,2977 ----
+ /*
+  * UAE - The Un*x Amiga Emulator
+  *
+  * MC68000 compilation generator
+  *
+  * Based on work Copyright 1995, 1996 Bernd Schmidt. Changes Copyright 2000
+  * Bernd Meyer
+  */
+ 
+ #include "sysconfig.h"
+ #include "sysdeps.h"
+ #include <ctype.h>
+ 
+ #include "readcpu.h"
+ 
+ #include <stdio.h>
+ #include <stdarg.h>
+ 
+ #define BOOL_TYPE "int"
+ #define failure global_failure=1
+ #define FAILURE global_failure=1
+ #define isjump  global_isjump=1
+ #define is_const_jump global_iscjump=1;
+ #define isaddx  global_isaddx=1
+ #define uses_cmov global_cmov=1
+ #define mayfail global_mayfail=1
+ 
+ int hack_opcode;
+ 
+ static int global_failure;
+ static int global_isjump;
+ static int global_iscjump;
+ static int global_isaddx;
+ static int global_cmov;
+ static int long_opcode;
+ static int global_mayfail;
+ 
+ static char endstr[1000];
+ static char lines[100000];
+ static int comp_index=0;
+ 
+ static int cond_codes_x86[]={-1,-1,7,6,3,2,5,4,-1,-1,9,8,13,12,15,14};
+ 
+ static void comprintf(const char* format, ...)
+ {
+     va_list args;
+ 
+     va_start(args,format);
+     comp_index+=vsprintf(lines+comp_index,format,args);
+ }
+ 
+ static void com_discard(void)
+ {
+     comp_index=0;
+ }
+ 
+ static void com_flush(void)
+ {
+     int i;
+     for (i=0;i<comp_index;i++)
+ 	putchar(lines[i]);
+     com_discard();
+ }
+ 
+ 
+ static FILE *headerfile;
+ static FILE *stblfile;
+ 
+ static int using_prefetch;
+ static int using_exception_3;
+ static int cpu_level;
+ static int noflags;
+ 
+ /* For the current opcode, the next lower level that will have different code.
+  * Initialized to -1 for each opcode. If it remains unchanged, indicates we
+  * are done with that opcode.  */
+ static int next_cpu_level;
+ 
+ void 
+ write_log (const char *s,...)
+ {
+     fprintf (stderr, "%s", s);
+ }
+ 
+ static int *opcode_map;
+ static int *opcode_next_clev;
+ static int *opcode_last_postfix;
+ static unsigned long *counts;
+ 
+ static void 
+ read_counts (void)
+ {
+     FILE *file;
+     unsigned long opcode, count, total;
+     char name[20];
+     int nr = 0;
+     memset (counts, 0, 65536 * sizeof *counts);
+ 
+     file = fopen ("frequent.68k", "r");
+     if (file)
+     {
+ 	fscanf (file, "Total: %lu\n", &total);
+ 	while (fscanf (file, "%lx: %lu %s\n", &opcode, &count, name) == 3)
+ 	{
+ 	    opcode_next_clev[nr] = 4;
+ 	    opcode_last_postfix[nr] = -1;
+ 	    opcode_map[nr++] = opcode;
+ 	    counts[opcode] = count;
+ 	}
+ 	fclose (file);
+     }
+     if (nr == nr_cpuop_funcs)
+ 	return;
+     for (opcode = 0; opcode < 0x10000; opcode++)
+     {
+ 	if (table68k[opcode].handler == -1 && table68k[opcode].mnemo != i_ILLG
+ 	    && counts[opcode] == 0)
+ 	{
+ 	    opcode_next_clev[nr] = 4;
+ 	    opcode_last_postfix[nr] = -1;
+ 	    opcode_map[nr++] = opcode;
+ 	    counts[opcode] = count;
+ 	}
+     }
+     if (nr != nr_cpuop_funcs)
+ 	abort ();
+ }
+ 
+ static int n_braces = 0;
+ static int insn_n_cycles;
+ 
+ static void 
+ start_brace (void)
+ {
+     n_braces++;
+     comprintf ("{");
+ }
+ 
+ static void 
+ close_brace (void)
+ {
+     assert (n_braces > 0);
+     n_braces--;
+     comprintf ("}");
+ }
+ 
+ static void 
+ finish_braces (void)
+ {
+     while (n_braces > 0)
+ 	close_brace ();
+ }
+ 
+ static void 
+ pop_braces (int to)
+ {
+     while (n_braces > to)
+ 	close_brace ();
+ }
+ 
+ static int 
+ bit_size (int size)
+ {
+     switch (size)
+     {
+      case sz_byte:
+ 	return 8;
+      case sz_word:
+ 	return 16;
+      case sz_long:
+ 	return 32;
+      default:
+ 	abort ();
+     }
+     return 0;
+ }
+ 
+ static const char *
+ bit_mask (int size)
+ {
+     switch (size)
+     {
+      case sz_byte:
+ 	return "0xff";
+      case sz_word:
+ 	return "0xffff";
+      case sz_long:
+ 	return "0xffffffff";
+      default:
+ 	abort ();
+     }
+     return 0;
+ }
+ 
+ static __inline__ void gen_update_next_handler(void)
+ {
+     return; /* Can anything clever be done here? */
+ }
+ 
+ static void gen_writebyte(char* address, char* source)
+ {
+     comprintf("\twritebyte(%s,%s,scratchie);\n",address,source);
+ }
+ 
+ static void gen_writeword(char* address, char* source)
+ {
+     comprintf("\twriteword(%s,%s,scratchie);\n",address,source);
+ }
+ 
+ static void gen_writelong(char* address, char* source)
+ {
+     comprintf("\twritelong(%s,%s,scratchie);\n",address,source);
+ }
+ 
+ static void gen_readbyte(char* address, char* dest)
+ {
+     comprintf("\treadbyte(%s,%s,scratchie);\n",address,dest);
+ }
+ 
+ static void gen_readword(char* address, char* dest)
+ {
+     comprintf("\treadword(%s,%s,scratchie);\n",address,dest);
+ }
+ 
+ static void gen_readlong(char* address, char* dest)
+ {
+     comprintf("\treadlong(%s,%s,scratchie);\n",address,dest);
+ }
+ 
+ 
+ 
+ static const char *
+ gen_nextilong (void)
+ {
+     static char buffer[80];
+ 
+     sprintf (buffer, "comp_get_ilong((m68k_pc_offset+=4)-4)");
+     insn_n_cycles += 4;
+   
+     long_opcode=1;
+     return buffer;
+ }
+ 
+ static const char *
+ gen_nextiword (void)
+ {
+     static char buffer[80];
+ 
+     sprintf (buffer, "comp_get_iword((m68k_pc_offset+=2)-2)");
+     insn_n_cycles+=2;
+ 
+     long_opcode=1;
+     return buffer;
+ }
+ 
+ static const char *
+ gen_nextibyte (void)
+ {
+     static char buffer[80];
+ 
+     sprintf (buffer, "comp_get_ibyte((m68k_pc_offset+=2)-2)");
+     insn_n_cycles += 2;
+ 
+     long_opcode=1;
+     return buffer;
+ }
+ 
+ static void 
+ sync_m68k_pc (void)
+ {
+     comprintf("\t if (m68k_pc_offset>100) sync_m68k_pc();\n"); 
+ }
+ 
+ 
+ /* getv == 1: fetch data; getv != 0: check for odd address. If movem != 0,
+  * the calling routine handles Apdi and Aipi modes. */
+ static void 
+ genamode (amodes mode, char *reg, wordsizes size, char *name, int getv, int movem)
+ {
+     start_brace ();
+     switch (mode)
+     {
+      case Dreg: /* Do we need to check dodgy here? */
+ 	if (movem)
+ 	    abort ();
+ 	if (getv == 1 || getv==2) { 
+ 	    /* We generate the variable even for getv==2, so we can use
+ 	       it as a destination for MOVE */
+ 	    comprintf ("\tint %s=%s;\n",name,reg);
+ 	}
+ 	return;
+ 
+      case Areg:
+ 	if (movem)
+ 	    abort ();
+ 	if (getv == 1 || getv==2) {
+ 	    /* see above */
+ 	    comprintf ("\tint %s=dodgy?scratchie++:%s+8;\n",name,reg);
+ 	    if (getv==1) {
+ 		comprintf ("\tif (dodgy) \n");
+ 		comprintf ("\t\tmov_l_rr(%s,%s+8);\n",name, reg);
+ 	    }
+ 	}
+ 	return;
+ 
+      case Aind:
+ 	comprintf ("\tint %sa=dodgy?scratchie++:%s+8;\n",name,reg);
+ 	comprintf ("\tif (dodgy) \n");
+ 	comprintf ("\t\tmov_l_rr(%sa,%s+8);\n",name, reg);
+ 	break;
+      case Aipi:
+ 	comprintf ("\tint %sa=scratchie++;\n",name,reg);
+ 	comprintf ("\tmov_l_rr(%sa,%s+8);\n",name, reg);
+ 	break;
+      case Apdi: 
+ 	switch (size)   
+ 	{
+ 	 case sz_byte:
+ 	    if (movem) {
+ 		comprintf ("\tint %sa=dodgy?scratchie++:%s+8;\n",name,reg);
+ 		comprintf ("\tif (dodgy) \n");
+ 		comprintf("\tmov_l_rr(%sa,8+%s);\n",name,reg);
+ 	    }
+ 	    else {
+ 		start_brace();
+ 		comprintf ("\tint %sa=dodgy?scratchie++:%s+8;\n",name,reg);
+ 		comprintf("\tlea_l_brr(%s+8,%s+8,(uae_s32)-areg_byteinc[%s]);\n",reg,reg,reg);
+ 		comprintf ("\tif (dodgy) \n");
+ 		comprintf("\tmov_l_rr(%sa,8+%s);\n",name,reg);
+ 	    }
+ 	    break;
+ 	 case sz_word:
+ 	    if (movem) {
+ 		comprintf ("\tint %sa=dodgy?scratchie++:%s+8;\n",name,reg);
+ 		comprintf ("\tif (dodgy) \n");
+ 		comprintf("\tmov_l_rr(%sa,8+%s);\n",name,reg);
+ 	    }
+ 	    else {
+ 		start_brace();
+ 		comprintf ("\tint %sa=dodgy?scratchie++:%s+8;\n",name,reg);
+ 		comprintf("\tlea_l_brr(%s+8,%s+8,-2);\n",reg,reg);
+ 		comprintf ("\tif (dodgy) \n");
+ 		comprintf("\tmov_l_rr(%sa,8+%s);\n",name,reg);
+ 	    }
+ 	    break;
+ 	 case sz_long:
+ 	    if (movem) {
+ 		comprintf ("\tint %sa=dodgy?scratchie++:%s+8;\n",name,reg);
+ 		comprintf ("\tif (dodgy) \n");
+ 		comprintf("\tmov_l_rr(%sa,8+%s);\n",name,reg);
+ 	    }
+ 	    else {
+ 		start_brace();
+ 		comprintf ("\tint %sa=dodgy?scratchie++:%s+8;\n",name,reg);
+ 		comprintf("\tlea_l_brr(%s+8,%s+8,-4);\n",reg,reg);
+ 		comprintf ("\tif (dodgy) \n");
+ 		comprintf("\tmov_l_rr(%sa,8+%s);\n",name,reg);
+ 	    }
+ 	    break;
+ 	 default:
+ 	    abort ();
+ 	}
+ 	break;
+      case Ad16:
+ 	comprintf("\tint %sa=scratchie++;\n",name);
+ 	comprintf("\tmov_l_rr(%sa,8+%s);\n",name,reg);
+ 	comprintf("\tlea_l_brr(%sa,%sa,(uae_s32)(uae_s16)%s);\n",name,name,gen_nextiword());
+ 	break;
+      case Ad8r:
+ 	comprintf("\tint %sa=scratchie++;\n",name);
+ 	comprintf("\tcalc_disp_ea_020(%s+8,%s,%sa,scratchie);\n",
+ 		  reg,gen_nextiword(),name);
+ 	break;
+ 
+      case PC16:
+ 	comprintf("\tint %sa=scratchie++;\n",name);
+ 	comprintf("\tuae_u32 address=start_pc+((char *)comp_pc_p-(char *)start_pc_p)+m68k_pc_offset;\n");
+ 	comprintf ("\tuae_s32 PC16off = (uae_s32)(uae_s16)%s;\n", gen_nextiword ());
+ 	comprintf("\tmov_l_ri(%sa,address+PC16off);\n",name);
+ 	break;
+ 
+      case PC8r:
+ 	comprintf("\tint pctmp=scratchie++;\n");
+ 	comprintf("\tint %sa=scratchie++;\n",name);
+ 	comprintf("\tuae_u32 address=start_pc+((char *)comp_pc_p-(char *)start_pc_p)+m68k_pc_offset;\n");
+ 	start_brace();
+ 	comprintf("\tmov_l_ri(pctmp,address);\n");
+ 
+ 	comprintf("\tcalc_disp_ea_020(pctmp,%s,%sa,scratchie);\n",
+ 		  gen_nextiword(),name);
+ 	break;
+      case absw:
+ 	comprintf ("\tint %sa = scratchie++;\n",name);
+ 	comprintf ("\tmov_l_ri(%sa,(uae_s32)(uae_s16)%s);\n", name, gen_nextiword ());
+ 	break;
+      case absl:
+ 	comprintf ("\tint %sa = scratchie++;\n",name);
+ 	comprintf ("\tmov_l_ri(%sa,%s); /* absl */\n", name, gen_nextilong ());
+ 	break;
+      case imm:
+ 	if (getv != 1)
+ 	    abort ();
+ 	switch (size)
+ 	{
+ 	 case sz_byte:
+ 	    comprintf ("\tint %s = scratchie++;\n",name);
+ 	    comprintf ("\tmov_l_ri(%s,(uae_s32)(uae_s8)%s);\n", name, gen_nextibyte ());
+ 	    break;
+ 	 case sz_word:
+ 	    comprintf ("\tint %s = scratchie++;\n",name);
+ 	    comprintf ("\tmov_l_ri(%s,(uae_s32)(uae_s16)%s);\n", name, gen_nextiword ());
+ 	    break;
+ 	 case sz_long:
+ 	    comprintf ("\tint %s = scratchie++;\n",name);
+ 	    comprintf ("\tmov_l_ri(%s,%s);\n", name, gen_nextilong ());
+ 	    break;
+ 	 default:
+ 	    abort ();
+ 	}
+ 	return;
+      case imm0:
+ 	if (getv != 1)
+ 	    abort ();
+ 	comprintf ("\tint %s = scratchie++;\n",name);
+ 	comprintf ("\tmov_l_ri(%s,(uae_s32)(uae_s8)%s);\n", name, gen_nextibyte ());
+ 	return;
+      case imm1:
+ 	if (getv != 1)
+ 	    abort ();
+ 	comprintf ("\tint %s = scratchie++;\n",name);
+ 	comprintf ("\tmov_l_ri(%s,(uae_s32)(uae_s16)%s);\n", name, gen_nextiword ());
+ 	return;
+      case imm2:
+ 	if (getv != 1)
+ 	    abort ();
+ 	comprintf ("\tint %s = scratchie++;\n",name);
+ 	comprintf ("\tmov_l_ri(%s,%s);\n", name, gen_nextilong ());
+ 	return;
+      case immi:
+ 	if (getv != 1)
+ 	    abort ();
+ 	comprintf ("\tint %s = scratchie++;\n",name);
+ 	comprintf ("\tmov_l_ri(%s,%s);\n", name, reg);
+ 	return;
+      default:
+ 	abort ();
+     }
+ 
+     /* We get here for all non-reg non-immediate addressing modes to
+      * actually fetch the value. */
+     if (getv == 1)
+     {
+ 	char astring[80];
+ 	sprintf(astring,"%sa",name);
+ 	switch (size)
+ 	{
+ 	 case sz_byte:
+ 	    insn_n_cycles += 2;
+ 	    break;
+ 	 case sz_word:
+ 	    insn_n_cycles += 2;
+ 	    break;
+ 	 case sz_long:
+ 	    insn_n_cycles += 4;
+ 	    break;
+ 	 default:
+ 	    abort ();
+ 	}
+ 	start_brace ();
+ 	comprintf("\tint %s=scratchie++;\n",name);
+ 	switch (size)
+ 	{
+ 	 case sz_byte:
+ 	    gen_readbyte(astring,name);
+ 	    break;
+ 	 case sz_word:
+ 	    gen_readword(astring,name);
+ 	    break;
+ 	 case sz_long:
+ 	    gen_readlong(astring,name);
+ 	    break;
+ 	 default:
+ 	    abort ();
+ 	}
+     }
+ 
+     /* We now might have to fix up the register for pre-dec or post-inc
+      * addressing modes. */
+     if (!movem) {
+ 	char x[160];
+ 	switch (mode)
+ 	{
+ 	 case Aipi:
+ 	    switch (size)
+ 	    {
+ 	     case sz_byte:
+ 		comprintf("\tlea_l_brr(%s+8,%s+8,areg_byteinc[%s]);\n",reg,reg,reg);
+ 		break;
+ 	     case sz_word:
+ 		comprintf("\tlea_l_brr(%s+8,%s+8,2);\n",reg,reg,reg);
+ 		break;
+ 	     case sz_long:
+ 		comprintf("\tlea_l_brr(%s+8,%s+8,4);\n",reg,reg);
+ 		break;
+ 	     default:
+ 		abort ();
+ 	    }
+ 	    break;
+ 	 case Apdi:
+ 	    break;
+ 	 default:
+ 	    break;
+ 	}
+     }
+ }
+ 
+ static void 
+ genastore (char *from, amodes mode, char *reg, wordsizes size, char *to)
+ {
+     switch (mode)
+     {
+      case Dreg:
+ 	switch (size)
+ 	{
+ 	 case sz_byte:
+ 	    comprintf("\tif(%s!=%s)\n",reg,from);
+ 	    comprintf ("\t\tmov_b_rr(%s,%s);\n", reg, from);
+ 	    break;
+ 	 case sz_word:
+ 	    comprintf("\tif(%s!=%s)\n",reg,from);
+ 	    comprintf ("\t\tmov_w_rr(%s,%s);\n", reg, from);
+ 	    break;
+ 	 case sz_long:
+ 	    comprintf("\tif(%s!=%s)\n",reg,from);
+ 	    comprintf ("\t\tmov_l_rr(%s,%s);\n", reg, from);
+ 	    break;
+ 	 default:
+ 	    abort ();
+ 	}
+ 	break;
+      case Areg:
+ 	switch (size)
+ 	{
+ 	 case sz_word:
+ 	    comprintf("\tif(%s+8!=%s)\n",reg,from);
+ 	    comprintf ("\t\tmov_w_rr(%s+8,%s);\n", reg, from);
+ 	    break;
+ 	 case sz_long:
+ 	    comprintf("\tif(%s+8!=%s)\n",reg,from);
+ 	    comprintf ("\t\tmov_l_rr(%s+8,%s);\n", reg, from);
+ 	    break;
+ 	 default:
+ 	    abort ();
+ 	}
+ 	break;
+ 
+      case Apdi:
+      case absw:
+      case PC16:
+      case PC8r:
+      case Ad16:
+      case Ad8r:
+      case Aipi:
+      case Aind:
+      case absl:
+      {
+ 	 char astring[80];
+ 	 sprintf(astring,"%sa",to);
+ 	
+ 	 switch (size)
+ 	 {
+ 	  case sz_byte:
+ 	     insn_n_cycles += 2;
+ 	     gen_writebyte(astring,from);
+ 	     break;
+ 	  case sz_word:
+ 	     insn_n_cycles += 2;
+ 	     gen_writeword(astring,from);
+ 	     break;
+ 	  case sz_long:
+ 	     insn_n_cycles += 4;
+ 	     gen_writelong(astring,from);
+ 	     break;
+ 	  default:
+ 	     abort ();
+ 	 }
+      }
+      break;
+      case imm:
+      case imm0:
+      case imm1:
+      case imm2:
+      case immi:
+ 	abort ();
+ 	break;
+      default:
+ 	abort ();
+     }
+ }
+ 
+ static void genmov16(void)
+ {
+     comprintf("\tint src=scratchie++;\n"
+ 	      "\tuae_u16 dstreg=((%s)>>12)&0x07;\n",gen_nextiword());
+     comprintf("\tint dst=scratchie++;\n"
+ 	      "\tint tmp=scratchie;\n"
+ 	      "\tscratchie+=4;\n"
+ 	      "\tmov_l_rr(src,8+srcreg);\n"
+ 	      "\tand_l_ri(src,~15);\n"
+ 	      "\tmov_l_rr(dst,8+dstreg);\n"
+ 	      "\tand_l_ri(dst,~15);\n"
+ 	      "\tadd_l_ri(srcreg+8,16);\n"
+ 	      "\tadd_l_ri(dstreg+8,16);\n");
+ 
+     comprintf("\tif (special_mem) {\n"
+ 	      "\treadlong(src,tmp,scratchie);\n"
+ 	      "\twritelong_clobber(dst,tmp,scratchie);\n"
+ 	      "\tadd_l_ri(src,4);\n"
+ 	      "\tadd_l_ri(dst,4);\n"
+ 	      "\treadlong(src,tmp,scratchie);\n"
+ 	      "\twritelong_clobber(dst,tmp,scratchie);\n"
+ 	      "\tadd_l_ri(src,4);\n"
+ 	      "\tadd_l_ri(dst,4);\n"
+ 	      "\treadlong(src,tmp,scratchie);\n"
+ 	      "\twritelong_clobber(dst,tmp,scratchie);\n"
+ 	      "\tadd_l_ri(src,4);\n"
+ 	      "\tadd_l_ri(dst,4);\n"
+ 	      "\treadlong(src,tmp,scratchie);\n"
+ 	      "\twritelong_clobber(dst,tmp,scratchie);\n");
+     comprintf("\t} else {\n");
+     comprintf("\tget_n_addr(src,src,scratchie);\n"
+ 	      "\tget_n_addr(dst,dst,scratchie);\n"
+ 	      "\tmov_l_rR_gs(tmp+0,src,0);\n"
+ 	      "\tmov_l_rR_gs(tmp+1,src,4);\n"
+ 	      "\tmov_l_rR_gs(tmp+2,src,8);\n"
+ 	      "\tmov_l_rR_gs(tmp+3,src,12);\n"
+ 	      "\tmov_l_Rr_gs(dst,tmp+0,0);\n"
+ 	      "\tforget_about(tmp+0);\n"
+ 	      "\tmov_l_Rr_gs(dst,tmp+1,4);\n"
+ 	      "\tforget_about(tmp+1);\n"
+ 	      "\tmov_l_Rr_gs(dst,tmp+2,8);\n"
+ 	      "\tforget_about(tmp+2);\n"
+ 	      "\tmov_l_Rr_gs(dst,tmp+3,12);\n"
+ 	      "\t}\n");
+ }
+ 
+ static void 
+ genmovemel (uae_u16 opcode)
+ {
+     comprintf ("\tuae_u16 mask = %s;\n", gen_nextiword ());
+     comprintf ("\tint native=scratchie++;\n");
+     comprintf ("\tint i;\n");
+     comprintf ("\tint offset=0;\n");
+     genamode (table68k[opcode].dmode, "dstreg", table68k[opcode].size, "src", 2, 1);
+ 
+     comprintf("\tif (1 && !special_mem) {\n");
+ 
+     /* Fast but unsafe...  */
+     comprintf("\tget_n_addr(srca,native,scratchie);\n");
+     comprintf("\tfor (i=0;i<16;i++) {\n"
+ 	      "\t\tif ((mask>>i)&1) {\n");
+     switch (table68k[opcode].size) {
+      case sz_long: 
+ 	comprintf("\t\t\tmov_l_rR_gs(i,native,offset);\n"
+ 		  "\t\t\tbswap_32(i);\n"
+ 		  "\t\t\toffset+=4;\n");
+ 	break;
+      case sz_word: 
+ 	comprintf("\t\t\tmov_w_rR_gs(i,native,offset);\n"
+ 		  "\t\t\tbswap_16(i);\n"
+ 		  "\t\t\tsign_extend_16_rr(i,i);\n"
+ 		  "\t\t\toffset+=2;\n");
+ 	break;
+      default: abort();
+     }
+     comprintf("\t\t}\n"
+ 	      "\t}");
+     if (table68k[opcode].dmode == Aipi) {
+ 	comprintf("\t\t\tlea_l_brr(8+dstreg,srca,offset);\n"); 
+     }
+     /* End fast but unsafe.   */
+ 
+     comprintf("\t} else {\n");
+ 
+     comprintf ("\tint tmp=scratchie++;\n");
+ 
+     comprintf("\tmov_l_rr(tmp,srca);\n");
+     comprintf("\tfor (i=0;i<16;i++) {\n"
+ 	      "\t\tif ((mask>>i)&1) {\n");
+     switch(table68k[opcode].size) {
+     case sz_long: 
+ 	comprintf("\t\t\treadlong(tmp,i,scratchie);\n"
+ 		  "\t\t\tadd_l_ri(tmp,4);\n");
+ 	break;
+     case sz_word:
+ 	comprintf("\t\t\treadword(tmp,i,scratchie);\n"
+ 		  "\t\t\tadd_l_ri(tmp,2);\n");
+ 	break;
+     default: abort();
+     }
+ 
+     comprintf("\t\t}\n"
+ 	      "\t}");
+     if (table68k[opcode].dmode == Aipi) {
+ 	comprintf("\t\t\tmov_l_rr(8+dstreg,tmp);\n");
+     }
+     comprintf("\t}\n");
+ 
+ }
+ 
+ 
+ static void 
+ genmovemle (uae_u16 opcode)
+ {
+     comprintf ("\tuae_u16 mask = %s;\n", gen_nextiword ());
+     comprintf ("\tint native=scratchie++;\n");
+     comprintf ("\tint i;\n");
+     comprintf ("\tint tmp=scratchie++;\n");
+     comprintf ("\tsigned char offset=0;\n");
+     genamode (table68k[opcode].dmode, "dstreg", table68k[opcode].size, "src", 2, 1);
+ 
+     /* *Sigh* Some clever geek realized that the fastest way to copy a
+        buffer from main memory to the gfx card is by using movmle. Good
+        on her, but unfortunately, gfx mem isn't "real" mem, and thus that
+        act of cleverness means that movmle must pay attention to special_mem,
+        or Genetic Species is a rather boring-looking game ;-) */
+     comprintf("\tif (1 && !special_mem) {\n");
+     comprintf("\tget_n_addr(srca,native,scratchie);\n");
+ 
+     if (table68k[opcode].dmode!=Apdi) {
+ 	comprintf("\tfor (i=0;i<16;i++) {\n"
+ 		  "\t\tif ((mask>>i)&1) {\n");
+ 	switch(table68k[opcode].size) {
+ 	 case sz_long: 
+ 	    comprintf("\t\t\tmov_l_rr(tmp,i);\n"
+ 		      "\t\t\tbswap_32(tmp);\n"
+ 		      "\t\t\tmov_l_Rr_gs(native,tmp,offset);\n"
+ 		      "\t\t\toffset+=4;\n");
+ 	    break;
+ 	 case sz_word: 
+ 	    comprintf("\t\t\tmov_l_rr(tmp,i);\n"
+ 		      "\t\t\tbswap_16(tmp);\n"
+ 		      "\t\t\tmov_w_Rr_gs(native,tmp,offset);\n"
+ 		      "\t\t\toffset+=2;\n");
+ 	    break;
+ 	 default: abort();
+ 	}
+     }
+     else {  /* Pre-decrement */
+ 	comprintf("\tfor (i=0;i<16;i++) {\n"
+ 		  "\t\tif ((mask>>i)&1) {\n");
+ 	switch(table68k[opcode].size) {
+ 	 case sz_long: 
+ 	    comprintf("\t\t\toffset-=4;\n"
+ 		      "\t\t\tmov_l_rr(tmp,15-i);\n"
+ 		      "\t\t\tbswap_32(tmp);\n"
+ 		      "\t\t\tmov_l_Rr_gs(native,tmp,offset);\n"
+ 		      );
+ 	    break;
+ 	 case sz_word: 
+ 	    comprintf("\t\t\toffset-=2;\n"
+ 		      "\t\t\tmov_l_rr(tmp,15-i);\n"
+ 		      "\t\t\tbswap_16(tmp);\n"
+ 		      "\t\t\tmov_w_Rr_gs(native,tmp,offset);\n"
+ 		      );
+ 	    break;
+ 	 default: abort();
+ 	}
+     }
+   
+ 
+     comprintf("\t\t}\n"
+ 	      "\t}");
+     if (table68k[opcode].dmode == Apdi) {
+ 	comprintf("\t\t\tlea_l_brr(8+dstreg,srca,(uae_s32)offset);\n");
+     }
+     comprintf("\t} else {\n");
+ 
+     if (table68k[opcode].dmode!=Apdi) {
+ 	comprintf("\tmov_l_rr(tmp,srca);\n");
+ 	comprintf("\tfor (i=0;i<16;i++) {\n"
+ 		  "\t\tif ((mask>>i)&1) {\n");
+ 	switch(table68k[opcode].size) {
+ 	 case sz_long: 
+ 	    comprintf("\t\t\twritelong(tmp,i,scratchie);\n"
+ 		      "\t\t\tadd_l_ri(tmp,4);\n");
+ 	    break;
+ 	 case sz_word: 
+ 	    comprintf("\t\t\twriteword(tmp,i,scratchie);\n"
+ 		      "\t\t\tadd_l_ri(tmp,2);\n");
+ 	    break;
+ 	 default: abort();
+ 	}
+     } else {  /* Pre-decrement */
+ 	comprintf("\tfor (i=0;i<16;i++) {\n"
+ 		  "\t\tif ((mask>>i)&1) {\n");
+ 	switch(table68k[opcode].size) {
+ 	 case sz_long: 
+ 	    comprintf("\t\t\tsub_l_ri(srca,4);\n"
+ 		      "\t\t\twritelong(srca,15-i,scratchie);\n");
+ 	    break;
+ 	 case sz_word: 
+ 	    comprintf("\t\t\tsub_l_ri(srca,2);\n"
+ 		      "\t\t\twriteword(srca,15-i,scratchie);\n");
+ 	    break;
+ 	 default: abort();
+ 	}
+     }
+ 
+     comprintf("\t\t}\n"
+ 	      "\t}");
+     if (table68k[opcode].dmode == Apdi) {
+ 	comprintf("\t\t\tmov_l_rr(8+dstreg,srca);\n");
+     }
+     comprintf("\t}\n");
+ }
+ 
+ 
+ static void 
+ duplicate_carry (void)
+ {
+     comprintf ("\tif (needed_flags&FLAG_X) duplicate_carry();\n");
+ }
+ 
+ typedef enum
+ {
+     flag_logical_noclobber, flag_logical, flag_add, flag_sub, flag_cmp, 
+     flag_addx, flag_subx, flag_zn, flag_av, flag_sv, flag_and, flag_or,
+     flag_eor, flag_mov
+ }
+ flagtypes;
+ 
+ 
+ static void 
+ genflags (flagtypes type, wordsizes size, char *value, char *src, char *dst)
+ {
+     if (noflags) {
+ 	switch(type) {
+ 	 case flag_cmp:
+ 	    comprintf("\tdont_care_flags();\n");
+ 	    comprintf("/* Weird --- CMP with noflags ;-) */\n");
+ 	    return;
+ 	 case flag_add:
+ 	 case flag_sub:
+ 	    comprintf("\tdont_care_flags();\n");
+ 	    {
+ 		char* op;
+ 		switch(type) {
+ 		 case flag_add: op="add"; break;
+ 		 case flag_sub: op="sub"; break;
+ 		 default: abort();
+ 		}
+ 		switch (size)
+ 		{
+ 		 case sz_byte:
+ 		    comprintf("\t%s_b(%s,%s);\n",op,dst,src);
+ 		    break;
+ 		 case sz_word:
+ 		    comprintf("\t%s_w(%s,%s);\n",op,dst,src);
+ 		    break;
+ 		 case sz_long:
+ 		    comprintf("\t%s_l(%s,%s);\n",op,dst,src);
+ 		    break;
+ 		}
+ 		return;
+ 	    }
+ 	    break;
+ 
+ 	 case flag_and:
+ 	    comprintf("\tdont_care_flags();\n");
+ 	    switch (size)
+ 	    {
+ 	     case sz_byte:
+ 		comprintf("if (kill_rodent(dst)) {\n");
+ 		comprintf("\tzero_extend_8_rr(scratchie,%s);\n",src);
+ 		comprintf("\tor_l_ri(scratchie,0xffffff00);\n");
+ 		comprintf("\tand_l(%s,scratchie);\n",dst);
+ 		comprintf("\tforget_about(scratchie);\n");
+ 		comprintf("\t} else \n"
+ 			  "\tand_b(%s,%s);\n",dst,src);
+ 		break;
+ 	     case sz_word:
+ 		comprintf("if (kill_rodent(dst)) {\n");
+ 		comprintf("\tzero_extend_16_rr(scratchie,%s);\n",src);
+ 		comprintf("\tor_l_ri(scratchie,0xffff0000);\n");
+ 		comprintf("\tand_l(%s,scratchie);\n",dst);
+ 		comprintf("\tforget_about(scratchie);\n");
+ 		comprintf("\t} else \n"
+ 			  "\tand_w(%s,%s);\n",dst,src);
+ 		break;
+ 	     case sz_long:
+ 		comprintf("\tand_l(%s,%s);\n",dst,src);
+ 		break;
+ 	    }
+ 	    return;
+ 
+ 	 case flag_mov:
+ 	    comprintf("\tdont_care_flags();\n");
+ 	    switch (size)
+ 	    {
+ 	     case sz_byte:
+ 		comprintf("if (kill_rodent(dst)) {\n");
+ 		comprintf("\tzero_extend_8_rr(scratchie,%s);\n",src);
+ 		comprintf("\tand_l_ri(%s,0xffffff00);\n",dst);
+ 		comprintf("\tor_l(%s,scratchie);\n",dst);
+ 		comprintf("\tforget_about(scratchie);\n");
+ 		comprintf("\t} else \n"
+ 			  "\tmov_b_rr(%s,%s);\n",dst,src);
+ 		break;
+ 	     case sz_word:
+ 		comprintf("if (kill_rodent(dst)) {\n");
+ 		comprintf("\tzero_extend_16_rr(scratchie,%s);\n",src);
+ 		comprintf("\tand_l_ri(%s,0xffff0000);\n",dst);
+ 		comprintf("\tor_l(%s,scratchie);\n",dst);
+ 		comprintf("\tforget_about(scratchie);\n");
+ 		comprintf("\t} else \n"
+ 			  "\tmov_w_rr(%s,%s);\n",dst,src);
+ 		break;
+ 	     case sz_long:
+ 		comprintf("\tmov_l_rr(%s,%s);\n",dst,src);
+ 		break;
+ 	    }
+ 	    return;
+ 
+ 	 case flag_or:
+ 	 case flag_eor:
+ 	    comprintf("\tdont_care_flags();\n");
+ 	    start_brace();
+ 	    {
+ 		char* op;
+ 		switch(type) {
+ 		 case flag_or:  op="or"; break;
+ 		 case flag_eor: op="xor"; break;
+ 		 default: abort();
+ 		}
+ 		switch (size)
+ 		{
+ 		 case sz_byte:
+ 		    comprintf("if (kill_rodent(dst)) {\n");
+ 		    comprintf("\tzero_extend_8_rr(scratchie,%s);\n",src);
+ 		    comprintf("\t%s_l(%s,scratchie);\n",op,dst);
+ 		    comprintf("\tforget_about(scratchie);\n");
+ 		    comprintf("\t} else \n"
+ 			      "\t%s_b(%s,%s);\n",op,dst,src);
+ 		    break;
+ 		 case sz_word:
+ 		    comprintf("if (kill_rodent(dst)) {\n");
+ 		    comprintf("\tzero_extend_16_rr(scratchie,%s);\n",src);
+ 		    comprintf("\t%s_l(%s,scratchie);\n",op,dst);
+ 		    comprintf("\tforget_about(scratchie);\n");
+ 		    comprintf("\t} else \n"
+ 			      "\t%s_w(%s,%s);\n",op,dst,src);
+ 		    break;
+ 		 case sz_long:
+ 		    comprintf("\t%s_l(%s,%s);\n",op,dst,src);
+ 		    break;
+ 		}
+ 		close_brace();
+ 		return;
+ 	    }
+       
+ 
+ 	 case flag_addx:
+ 	 case flag_subx:
+ 	    comprintf("\tdont_care_flags();\n");
+ 	    {
+ 		char* op;
+ 		switch(type) {
+ 		 case flag_addx: op="adc"; break;
+ 		 case flag_subx: op="sbb"; break;
+ 		 default: abort();
+ 		}
+ 		comprintf("\trestore_carry();\n"); /* Reload the X flag into C */
+ 		switch (size)
+ 		{
+ 		 case sz_byte:
+ 		    comprintf("\t%s_b(%s,%s);\n",op,dst,src);
+ 		    break;
+ 		 case sz_word:
+ 		    comprintf("\t%s_w(%s,%s);\n",op,dst,src);
+ 		    break;
+ 		 case sz_long:
+ 		    comprintf("\t%s_l(%s,%s);\n",op,dst,src);
+ 		    break;
+ 		}
+ 		return;
+ 	    }
+ 	    break;
+ 	 default: return;
+ 	}
+     }
+   
+     /* Need the flags, but possibly not all of them */
+     switch (type)
+     {
+      case flag_logical_noclobber:
+ 	failure;
+ 
+      case flag_and:
+      case flag_or:
+      case flag_eor:
+ 	comprintf("\tdont_care_flags();\n");
+ 	start_brace();
+ 	{
+ 	    char* op;
+ 	    switch(type) {
+ 	     case flag_and: op="and"; break;
+ 	     case flag_or:  op="or"; break;
+ 	     case flag_eor: op="xor"; break;
+ 	     default: abort();
+ 	    }
+ 	    switch (size)
+ 	    {
+ 	     case sz_byte:
+ 		comprintf("\tstart_needflags();\n"
+ 			  "\t%s_b(%s,%s);\n",op,dst,src);
+ 		break;
+ 	     case sz_word:
+ 		comprintf("\tstart_needflags();\n"
+ 			  "\t%s_w(%s,%s);\n",op,dst,src);
+ 		break;
+ 	     case sz_long:
+ 		comprintf("\tstart_needflags();\n"
+ 			  "\t%s_l(%s,%s);\n",op,dst,src);
+ 		break;
+ 	    }
+ 	    comprintf("\tlive_flags();\n");
+ 	    comprintf("\tend_needflags();\n");
+ 	    close_brace();
+ 	    return;
+ 	}
+ 
+      case flag_mov:
+ 	comprintf("\tdont_care_flags();\n");
+ 	start_brace();
+ 	{
+ 	    switch (size)
+ 	    {
+ 	     case sz_byte:
+ 		comprintf("\tif (%s!=%s) {\n",src,dst);
+ 		comprintf("\tmov_b_ri(%s,0);\n"
+ 			  "\tstart_needflags();\n",dst);
+ 		comprintf("\tor_b(%s,%s);\n",dst,src);
+ 		comprintf("\t} else {\n");
+ 		comprintf("\tmov_b_rr(%s,%s);\n",dst,src);
+ 		comprintf("\ttest_b_rr(%s,%s);\n",dst,dst);
+ 		comprintf("\t}\n");
+ 		break;
+ 	     case sz_word:
+ 		comprintf("\tif (%s!=%s) {\n",src,dst);
+ 		comprintf("\tmov_w_ri(%s,0);\n"
+ 			  "\tstart_needflags();\n",dst);
+ 		comprintf("\tor_w(%s,%s);\n",dst,src);
+ 		comprintf("\t} else {\n");
+ 		comprintf("\tmov_w_rr(%s,%s);\n",dst,src);
+ 		comprintf("\ttest_w_rr(%s,%s);\n",dst,dst);
+ 		comprintf("\t}\n");
+ 		break;
+ 	     case sz_long:
+ 		comprintf("\tif (%s!=%s) {\n",src,dst);
+ 		comprintf("\tmov_l_ri(%s,0);\n"
+ 			  "\tstart_needflags();\n",dst);
+ 		comprintf("\tor_l(%s,%s);\n",dst,src);
+ 		comprintf("\t} else {\n");
+ 		comprintf("\tmov_l_rr(%s,%s);\n",dst,src);
+ 		comprintf("\ttest_l_rr(%s,%s);\n",dst,dst);
+ 		comprintf("\t}\n");
+ 		break;
+ 	    }
+ 	    comprintf("\tlive_flags();\n");
+ 	    comprintf("\tend_needflags();\n");
+ 	    close_brace();
+ 	    return;
+ 	}
+ 
+      case flag_logical:
+ 	comprintf("\tdont_care_flags();\n");
+ 	start_brace();
+ 	switch (size)
+ 	{
+ 	 case sz_byte:
+ 	    comprintf("\tstart_needflags();\n"
+ 		      "\ttest_b_rr(%s,%s);\n",value,value);
+ 	    break;
+ 	 case sz_word:
+ 	    comprintf("\tstart_needflags();\n"
+ 		      "\ttest_w_rr(%s,%s);\n",value,value);
+ 	    break;
+ 	 case sz_long:
+ 	    comprintf("\tstart_needflags();\n"
+ 		      "\ttest_l_rr(%s,%s);\n",value,value);
+ 	    break;
+ 	}
+ 	comprintf("\tlive_flags();\n");
+ 	comprintf("\tend_needflags();\n");
+ 	close_brace();
+ 	return;
+ 
+ 
+      case flag_add:
+      case flag_sub:
+      case flag_cmp:
+ 	comprintf("\tdont_care_flags();\n");
+ 	{
+ 	    char* op;
+ 	    switch(type) {
+ 	     case flag_add: op="add"; break;
+ 	     case flag_sub: op="sub"; break;
+ 	     case flag_cmp: op="cmp"; break;
+ 	     default: abort();
+ 	    }
+ 	    switch (size)
+ 	    {
+ 	     case sz_byte:
+ 		comprintf("\tstart_needflags();\n"
+ 			  "\t%s_b(%s,%s);\n",op,dst,src);
+ 		break;
+ 	     case sz_word:
+ 		comprintf("\tstart_needflags();\n"
+ 			  "\t%s_w(%s,%s);\n",op,dst,src);
+ 		break;
+ 	     case sz_long:
+ 		comprintf("\tstart_needflags();\n"
+ 			  "\t%s_l(%s,%s);\n",op,dst,src);
+ 		break;
+ 	    }
+ 	    comprintf("\tlive_flags();\n");
+ 	    comprintf("\tend_needflags();\n");
+ 	    if (type!=flag_cmp) {
+ 		duplicate_carry();
+ 	    }
+ 	    comprintf("if (!(needed_flags & FLAG_CZNV)) dont_care_flags();\n");
+ 	    
+ 	    return;
+ 	}
+       
+      case flag_addx:
+      case flag_subx:
+ 	uses_cmov;
+ 	comprintf("\tdont_care_flags();\n");
+ 	{
+ 	    char* op;
+ 	    switch(type) {
+ 	     case flag_addx: op="adc"; break;
+ 	     case flag_subx: op="sbb"; break;
+ 	     default: abort();
+ 	    }
+ 	    start_brace();
+ 	    comprintf("\tint zero=scratchie++;\n"
+ 		      "\tint one=scratchie++;\n"
+ 		      "\tif (needed_flags&FLAG_Z) {\n"
+ 		      "\tmov_l_ri(zero,0);\n"
+ 		      "\tmov_l_ri(one,1);\n"
+ 		      "\tmake_flags_live();\n"
+ 		      "\tcmov_l_rr(zero,one,5);\n"
+ 		      "\t}\n");
+ 	    comprintf("\trestore_carry();\n"); /* Reload the X flag into C */
+ 	    switch (size)
+ 	    {
+ 	     case sz_byte:
+ 		comprintf("\tstart_needflags();\n"
+ 			  "\t%s_b(%s,%s);\n",op,dst,src);
+ 		break;
+ 	     case sz_word:
+ 		comprintf("\tstart_needflags();\n"
+ 			  "\t%s_w(%s,%s);\n",op,dst,src);
+ 		break;
+ 	     case sz_long:
+ 		comprintf("\tstart_needflags();\n"
+ 			  "\t%s_l(%s,%s);\n",op,dst,src);
+ 		break;
+ 	    }
+ 	    comprintf("\tif (needed_flags&FLAG_Z) {\n"
+ 		      "\tcmov_l_rr(zero,one,5);\n"
+ 		      "\tbsf_l_rr(zero,zero);\n"
+ 		      "\t}\n");
+ 	    comprintf("\tlive_flags();\n");
+ 	    comprintf("\tend_needflags();\n");
+ 	    duplicate_carry();
+ 	    comprintf("if (!(needed_flags & FLAG_CZNV)) dont_care_flags();\n");
+ 	    return;
+ 	}
+      default:
+ 	failure;
+ 	break;
+     }
+ }
+ 
+ static void 
+ force_range_for_rox (const char *var, wordsizes size)
+ {
+     /* Could do a modulo operation here... which one is faster? */
+     switch (size)
+     {
+      case sz_long:
+ 	comprintf ("\tif (%s >= 33) %s -= 33;\n", var, var);
+ 	break;
+      case sz_word:
+ 	comprintf ("\tif (%s >= 34) %s -= 34;\n", var, var);
+ 	comprintf ("\tif (%s >= 17) %s -= 17;\n", var, var);
+ 	break;
+      case sz_byte:
+ 	comprintf ("\tif (%s >= 36) %s -= 36;\n", var, var);
+ 	comprintf ("\tif (%s >= 18) %s -= 18;\n", var, var);
+ 	comprintf ("\tif (%s >= 9) %s -= 9;\n", var, var);
+ 	break;
+     }
+ }
+ 
+ static const char *
+ cmask (wordsizes size)
+ {
+     switch (size)
+     {
+      case sz_byte:
+ 	return "0x80";
+      case sz_word:
+ 	return "0x8000";
+      case sz_long:
+ 	return "0x80000000";
+      default:
+ 	abort ();
+     }
+ }
+ 
+ static int 
+ source_is_imm1_8 (struct instr *i)
+ {
+     return i->stype == 3;
+ }
+ 
+ static int  /* returns zero for success, non-zero for failure */
+ gen_opcode (unsigned long int opcode)
+ {
+     struct instr *curi = table68k + opcode;
+     char* ssize=NULL;
+ 
+     insn_n_cycles = 2;
+     global_failure=0;
+     long_opcode=0;
+     global_isjump=0;
+     global_iscjump=0;
+     global_isaddx=0;
+     global_cmov=0;
+     global_mayfail=0;
+     hack_opcode=opcode;
+     endstr[0]=0;
+ 
+     start_brace ();
+     comprintf("\tuae_u8 scratchie=S1;\n");
+     switch (curi->plev)
+     {
+      case 0:			/* not privileged */
+ 	break;
+      case 1:			/* unprivileged only on 68000 */
+ 	if (cpu_level == 0)
+ 	    break;
+ 	if (next_cpu_level < 0)
+ 	    next_cpu_level = 0;
+ 
+ 	/* fall through */
+      case 2:			/* priviledged */
+ 	failure;   /* Easy ones first */
+ 	break;
+      case 3:			/* privileged if size == word */
+ 	if (curi->size == sz_byte)
+ 	    break;
+ 	failure;
+ 	break;
+     }
+     switch (curi->size) {
+      case sz_byte: ssize="b"; break;
+      case sz_word: ssize="w"; break;
+      case sz_long: ssize="l"; break;
+      default: abort();
+     }
+ 
+     switch (curi->mnemo)
+     {
+      case i_OR:
+      case i_AND:
+      case i_EOR:
+ 	genamode (curi->smode, "srcreg", curi->size, "src", 1, 0);
+ 	genamode (curi->dmode, "dstreg", curi->size, "dst", 1, 0);
+ 	switch(curi->mnemo) {
+ 	 case i_OR: genflags (flag_or, curi->size, "", "src", "dst"); break;
+ 	 case i_AND: genflags (flag_and, curi->size, "", "src", "dst"); break;
+ 	 case i_EOR: genflags (flag_eor, curi->size, "", "src", "dst"); break;
+ 	}
+ 	genastore ("dst", curi->dmode, "dstreg", curi->size, "dst");
+ 	break;
+ 
+      case i_ORSR:
+      case i_EORSR:
+ 	failure;
+ 	isjump; 
+ 	break;
+      case i_ANDSR:
+ 	failure;
+ 	isjump; 
+ 	break;
+      case i_SUB:
+ 	genamode (curi->smode, "srcreg", curi->size, "src", 1, 0);
+ 	genamode (curi->dmode, "dstreg", curi->size, "dst", 1, 0);
+ 	genflags (flag_sub, curi->size, "", "src", "dst");
+ 	genastore ("dst", curi->dmode, "dstreg", curi->size, "dst");
+ 	break;
+      case i_SUBA:
+ 	genamode (curi->smode, "srcreg", curi->size, "src", 1, 0);
+ 	genamode (curi->dmode, "dstreg", sz_long, "dst", 1, 0);
+ 	start_brace();
+ 	comprintf("\tint tmp=scratchie++;\n");
+ 	switch(curi->size) {
+ 	 case sz_byte: comprintf("\tsign_extend_8_rr(tmp,src);\n"); break;
+ 	 case sz_word: comprintf("\tsign_extend_16_rr(tmp,src);\n"); break;
+ 	 case sz_long: comprintf("\ttmp=src;\n"); break;
+ 	 default: abort();
+ 	}
+ 	comprintf("\tsub_l(dst,tmp);\n");
+ 	genastore ("dst", curi->dmode, "dstreg", sz_long, "dst");
+ 	break;
+      case i_SUBX:
+ 	isaddx;
+ 	genamode (curi->smode, "srcreg", curi->size, "src", 1, 0);
+ 	genamode (curi->dmode, "dstreg", curi->size, "dst", 1, 0);
+ 	genflags (flag_subx, curi->size, "", "src", "dst");
+ 	genastore ("dst", curi->dmode, "dstreg", curi->size, "dst");
+ 	break;
+      case i_SBCD:
+ 	failure;
+ 	/* I don't think so! */
+ 	break;
+      case i_ADD:
+ 	genamode (curi->smode, "srcreg", curi->size, "src", 1, 0);
+ 	genamode (curi->dmode, "dstreg", curi->size, "dst", 1, 0);
+ 	genflags (flag_add, curi->size, "", "src", "dst");
+ 	genastore ("dst", curi->dmode, "dstreg", curi->size, "dst");
+ 	break;
+      case i_ADDA:
+ 	genamode (curi->smode, "srcreg", curi->size, "src", 1, 0);
+ 	genamode (curi->dmode, "dstreg", sz_long, "dst", 1, 0);
+ 	start_brace();
+ 	comprintf("\tint tmp=scratchie++;\n");
+ 	switch(curi->size) {
+ 	 case sz_byte: comprintf("\tsign_extend_8_rr(tmp,src);\n"); break;
+ 	 case sz_word: comprintf("\tsign_extend_16_rr(tmp,src);\n"); break;
+ 	 case sz_long: comprintf("\ttmp=src;\n"); break;
+ 	 default: abort();
+ 	}
+ 	comprintf("\tadd_l(dst,tmp);\n");
+ 	genastore ("dst", curi->dmode, "dstreg", sz_long, "dst");
+ 	break;
+      case i_ADDX:
+ 	isaddx;
+ 	genamode (curi->smode, "srcreg", curi->size, "src", 1, 0);
+ 	genamode (curi->dmode, "dstreg", curi->size, "dst", 1, 0);
+ 	start_brace();
+ 	genflags (flag_addx, curi->size, "", "src", "dst");
+ 	genastore ("dst", curi->dmode, "dstreg", curi->size, "dst");
+ 	break;
+      case i_ABCD:
+ 	failure;
+ 	/* No BCD maths for me.... */
+ 	break;
+      case i_NEG:
+ 	genamode (curi->smode, "srcreg", curi->size, "src", 1, 0);
+ 	start_brace ();
+ 	comprintf("\tint dst=scratchie++;\n");
+ 	comprintf("\tmov_l_ri(dst,0);\n");
+ 	genflags (flag_sub, curi->size, "", "src", "dst");
+ 	genastore ("dst", curi->smode, "srcreg", curi->size, "src");
+ 	break;
+      case i_NEGX:
+ 	genamode (curi->smode, "srcreg", curi->size, "src", 1, 0);
+ 	start_brace ();
+ 	comprintf("\tint dst=scratchie++;\n");
+ 	comprintf("\tmov_l_ri(dst,0);\n");
+ 	genflags (flag_subx, curi->size, "", "src", "dst");
+ 	genastore ("dst", curi->smode, "srcreg", curi->size, "src");
+ 	break;
+ 
+      case i_NBCD:
+ 	failure;
+ 	/* Nope! */
+ 	break;
+      case i_CLR:
+ 	genamode (curi->smode, "srcreg", curi->size, "src", 2, 0);
+ 	start_brace();
+ 	comprintf("\tint dst=scratchie++;\n");
+ 	comprintf("\tmov_l_ri(dst,0);\n");
+ 	genflags (flag_logical, curi->size, "dst", "", "");
+ 	genastore ("dst", curi->smode, "srcreg", curi->size, "src");
+ 	break;
+      case i_NOT:
+ 	genamode (curi->smode, "srcreg", curi->size, "src", 1, 0);
+ 	start_brace ();
+ 	comprintf("\tint dst=scratchie++;\n");
+ 	comprintf("\tmov_l_ri(dst,0xffffffff);\n");
+ 	genflags (flag_eor, curi->size, "", "src", "dst");
+ 	genastore ("dst", curi->smode, "srcreg", curi->size, "src");
+ 	break;
+      case i_TST:
+ 	genamode (curi->smode, "srcreg", curi->size, "src", 1, 0);
+ 	genflags (flag_logical, curi->size, "src", "", "");
+ 	break;
+      case i_BCHG:
+      case i_BCLR:
+      case i_BSET:
+      case i_BTST:
+ 	genamode (curi->smode, "srcreg", curi->size, "src", 1, 0);
+ 	genamode (curi->dmode, "dstreg", curi->size, "dst", 1, 0);
+ 	start_brace();
+ 	comprintf("\tint s=scratchie++;\n"
+ 		  "\tmov_l_rr(s,src);\n");
+ 	if (curi->size == sz_byte)
+ 	    comprintf("\tand_l_ri(s,7);\n");
+ 	else
+ 	    comprintf("\tand_l_ri(s,31);\n");
+ 
+ 	{
+ 	    char* op;
+ 	    int need_write=1;
+ 
+ 	    switch(curi->mnemo) {
+ 	     case i_BCHG: op="btc"; break;
+ 	     case i_BCLR: op="btr"; break;
+ 	     case i_BSET: op="bts"; break;
+ 	     case i_BTST: op="bt"; need_write=0; break;
+ 	    }
+ 	    comprintf("\t%s_l_rr(dst,s);\n"  /* Answer now in C */
+ 		      "\tsbb_l(s,s);\n" /* s is 0 if bit was 0, 
+ 					   -1 otherwise */
+ 		      "\tmake_flags_live();\n" /* Get the flags back */
+ 		      "\tdont_care_flags();\n" 
+ 		      "\tstart_needflags();\n"
+ 		      "\tbsf_l_rr(s,s);\n"
+ 		      "\tlive_flags();\n"
+ 		      "\tend_needflags();\n",op);
+ 	    if (need_write) 
+ 		genastore ("dst", curi->dmode, "dstreg", curi->size, "dst");
+ 	}
+ 	break;
+ 
+      case i_CMPM:
+      case i_CMP:
+ 	genamode (curi->smode, "srcreg", curi->size, "src", 1, 0);
+ 	genamode (curi->dmode, "dstreg", curi->size, "dst", 1, 0);
+ 	start_brace ();
+ 	genflags (flag_cmp, curi->size, "", "src", "dst");
+ 	break;
+      case i_CMPA:
+ 	genamode (curi->smode, "srcreg", curi->size, "src", 1, 0);
+ 	genamode (curi->dmode, "dstreg", sz_long, "dst", 1, 0);
+ 	start_brace();
+ 	comprintf("\tint tmps=scratchie++;\n");
+ 	switch(curi->size) {
+ 	 case sz_byte: comprintf("\tsign_extend_8_rr(tmps,src);\n"); break;
+ 	 case sz_word: comprintf("\tsign_extend_16_rr(tmps,src);\n"); break;
+ 	 case sz_long: comprintf("tmps=src;\n"); break;
+ 	 default: abort();
+ 	}
+ 	genflags (flag_cmp, sz_long, "", "tmps", "dst");
+ 	break;
+ 	/* The next two are coded a little unconventional, but they are doing
+ 	 * weird things... */
+      case i_MVPRM:
+ 	isjump; 
+ 	failure;
+ 	break;
+      case i_MVPMR:
+ 	isjump; 
+ 	failure;
+ 	break;
+      case i_MOVE:
+ 	switch(curi->dmode) {
+ 	 case Dreg:
+ 	 case Areg:
+ 	    genamode (curi->smode, "srcreg", curi->size, "src", 1, 0);
+ 	    genamode (curi->dmode, "dstreg", curi->size, "dst", 2, 0);
+ 	    genflags (flag_mov, curi->size, "", "src", "dst");
+ 	    genastore ("dst", curi->dmode, "dstreg", curi->size, "dst");
+ 	    break;
+ 	 default: /* It goes to memory, not a register */
+ 	    genamode (curi->smode, "srcreg", curi->size, "src", 1, 0);
+ 	    genamode (curi->dmode, "dstreg", curi->size, "dst", 2, 0);
+ 	    genflags (flag_logical, curi->size, "src", "", "");
+ 	    genastore ("src", curi->dmode, "dstreg", curi->size, "dst");
+ 	    break;
+ 	}
+ 	break;
+      case i_MOVEA:
+ 	genamode (curi->smode, "srcreg", curi->size, "src", 1, 0);
+ 	genamode (curi->dmode, "dstreg", curi->size, "dst", 2, 0);
+ 
+ 	start_brace();
+ 	comprintf("\tint tmps=scratchie++;\n");
+ 	switch(curi->size) {
+ 	 case sz_word: comprintf("\tsign_extend_16_rr(dst,src);\n"); break;
+ 	 case sz_long: comprintf("\tmov_l_rr(dst,src);\n"); break;
+ 	 default: abort();
+ 	}
+ 	genastore ("dst", curi->dmode, "dstreg", sz_long, "dst");
+ 	break;
+ 
+      case i_MVSR2:
+ 	isjump; 
+ 	failure;
+ 	break;
+      case i_MV2SR:
+ 	isjump; 
+ 	failure;
+ 	break;
+      case i_SWAP:
+ 	genamode (curi->smode, "srcreg", sz_long, "src", 1, 0);
+ 	comprintf("\tdont_care_flags();\n");
+ 	comprintf("\trol_l_ri(src,16);\n");
+ 	genflags (flag_logical, sz_long, "src", "", "");
+ 	genastore ("src", curi->smode, "srcreg", sz_long, "src");
+ 	break;
+      case i_EXG:
+ 	genamode (curi->smode, "srcreg", curi->size, "src", 1, 0);
+ 	genamode (curi->dmode, "dstreg", curi->size, "dst", 1, 0);
+ 	start_brace();
+ 	comprintf("\tint tmp=scratchie++;\n"
+ 		  "\tmov_l_rr(tmp,src);\n");
+ 	genastore ("dst", curi->smode, "srcreg", curi->size, "src");
+ 	genastore ("tmp", curi->dmode, "dstreg", curi->size, "dst");
+ 	break;
+      case i_EXT:
+ 	genamode (curi->smode, "srcreg", sz_long, "src", 1, 0);
+ 	comprintf("\tdont_care_flags();\n");
+ 	start_brace ();
+ 	switch (curi->size)
+ 	{
+ 	 case sz_byte:
+ 	    comprintf ("\tint dst = src;\n"
+ 		       "\tsign_extend_8_rr(src,src);\n");
+ 	    break;
+ 	 case sz_word:
+ 	    comprintf ("\tint dst = scratchie++;\n"
+ 		       "\tsign_extend_8_rr(dst,src);\n");
+ 	    break;
+ 	 case sz_long:
+ 	    comprintf ("\tint dst = src;\n"
+ 		       "\tsign_extend_16_rr(src,src);\n");
+ 	    break;
+ 	 default:
+ 	    abort ();
+ 	}
+ 	genflags (flag_logical,
+ 		  curi->size == sz_word ? sz_word : sz_long, "dst", "", "");
+ 	genastore ("dst", curi->smode, "srcreg",
+ 		   curi->size == sz_word ? sz_word : sz_long, "src");
+ 	break;
+      case i_MVMEL:
+ 	genmovemel (opcode);
+ 	break;
+      case i_MVMLE:
+ 	genmovemle (opcode);
+ 	break;
+      case i_TRAP:
+ 	isjump; 
+ 	failure;
+ 	break;
+      case i_MVR2USP:
+ 	isjump; 
+ 	failure;
+ 	break;
+      case i_MVUSP2R:
+ 	isjump; 
+ 	failure;
+ 	break;
+      case i_RESET:
+ 	isjump; 
+ 	failure;
+ 	break;
+      case i_NOP:
+ 	break;
+      case i_STOP:
+ 	isjump; 
+ 	failure;
+ 	break;
+      case i_RTE:
+ 	isjump; 
+ 	failure;
+ 	break;
+      case i_RTD:
+ 	genamode (curi->smode, "srcreg", curi->size, "offs", 1, 0);
+ 	/* offs is constant */
+ 	comprintf("\tadd_l_ri(offs,4);\n");
+ 	start_brace();
+ 	comprintf("\tint newad=scratchie++;\n"
+ 		  "\treadlong(15,newad,scratchie);\n"
+ 		  "\tand_l_ri(newad,~1);\n"
+ 		  "\tmov_l_mr((uae_u32)&regs.pc,newad);\n"
+ 		  "\tget_n_addr_jmp(newad,PC_P,scratchie);\n"
+ 		  "\tmov_l_mr((uae_u32)&regs.pc_oldp,PC_P);\n"
+ 		  "\tm68k_pc_offset=0;\n"
+ 		  "\tadd_l(15,offs);\n");
+ 	gen_update_next_handler();
+ 	isjump; 
+ 	break;
+      case i_LINK:
+ 	genamode (curi->smode, "srcreg", sz_long, "src", 1, 0);
+ 	genamode (curi->dmode, "dstreg", curi->size, "offs", 1, 0);
+ 	comprintf("\tsub_l_ri(15,4);\n"
+ 		  "\twritelong_clobber(15,src,scratchie);\n"
+ 		  "\tmov_l_rr(src,15);\n");
+ 	if (curi->size==sz_word)
+ 	    comprintf("\tsign_extend_16_rr(offs,offs);\n");
+ 	comprintf("\tadd_l(15,offs);\n");
+ 	genastore ("src", curi->smode, "srcreg", sz_long, "src");
+ 	break;
+      case i_UNLK:
+ 	genamode (curi->smode, "srcreg", curi->size, "src", 1, 0);
+ 	comprintf("\tmov_l_rr(15,src);\n"
+ 		  "\treadlong(15,src,scratchie);\n"
+ 		  "\tadd_l_ri(15,4);\n");
+ 	genastore ("src", curi->smode, "srcreg", curi->size, "src");
+ 	break;
+      case i_RTS:
+ 	comprintf("\tint newad=scratchie++;\n"
+ 		  "\treadlong(15,newad,scratchie);\n"
+ 		  "\tand_l_ri(newad,~1);\n"
+ 		  "\tmov_l_mr((uae_u32)&regs.pc,newad);\n"
+ 		  "\tget_n_addr_jmp(newad,PC_P,scratchie);\n"
+ 		  "\tmov_l_mr((uae_u32)&regs.pc_oldp,PC_P);\n"
+ 		  "\tm68k_pc_offset=0;\n"
+ 		  "\tlea_l_brr(15,15,4);\n");
+ 	gen_update_next_handler();
+ 	isjump; 
+ 	break;
+      case i_TRAPV:
+ 	isjump; 
+ 	failure;
+ 	break;
+      case i_RTR:
+ 	isjump; 
+ 	failure;
+ 	break;
+      case i_JSR:
+ 	isjump; 
+ 	genamode (curi->smode, "srcreg", curi->size, "src", 0, 0);
+ 	start_brace();
+ 	comprintf("\tuae_u32 retadd=start_pc+((char *)comp_pc_p-(char *)start_pc_p)+m68k_pc_offset;\n");
+ 	comprintf("\tint ret=scratchie++;\n"
+ 		  "\tmov_l_ri(ret,retadd);\n"
+ 		  "\tsub_l_ri(15,4);\n"
+ 		  "\twritelong_clobber(15,ret,scratchie);\n");
+ 	comprintf("\tand_l_ri(srca,~1);\n"
+ 		  "\tmov_l_mr((uae_u32)&regs.pc,srca);\n"
+ 		  "\tget_n_addr_jmp(srca,PC_P,scratchie);\n"
+ 		  "\tmov_l_mr((uae_u32)&regs.pc_oldp,PC_P);\n"
+ 		  "\tm68k_pc_offset=0;\n");
+ 	gen_update_next_handler();
+ 	break;
+      case i_JMP:
+ 	isjump;
+ 	genamode (curi->smode, "srcreg", curi->size, "src", 0, 0);
+ 	comprintf("\tand_l_ri(srca,~1);\n"
+ 		  "\tmov_l_mr((uae_u32)&regs.pc,srca);\n"
+ 		  "\tget_n_addr_jmp(srca,PC_P,scratchie);\n"
+ 		  "\tmov_l_mr((uae_u32)&regs.pc_oldp,PC_P);\n"
+ 		  "\tm68k_pc_offset=0;\n");
+ 	gen_update_next_handler();
+ 	break;
+      case i_BSR:
+ 	if (curi->size==sz_long)
+ 	    failure;
+ 	is_const_jump;
+ 	genamode (curi->smode, "srcreg", curi->size, "src", 1, 0);
+ 	comprintf("\tand_l_ri(src,~1);\n");
+ 	start_brace();
+ 	comprintf("\tuae_u32 retadd=start_pc+((char *)comp_pc_p-(char *)start_pc_p)+m68k_pc_offset;\n");
+ 	comprintf("\tint ret=scratchie++;\n"
+ 		  "\tmov_l_ri(ret,retadd);\n"
+ 		  "\tsub_l_ri(15,4);\n"
+ 		  "\twritelong_clobber(15,ret,scratchie);\n");
+ 	comprintf("\tadd_l_ri(src,m68k_pc_offset_thisinst+2);\n");
+ 	comprintf("\tm68k_pc_offset=0;\n");
+ 	comprintf("\tadd_l(PC_P,src);\n");
+ 
+ 	comprintf("\tcomp_pc_p=(void*)get_const(PC_P);\n");
+ 	break;
+      case i_Bcc:
+ 	comprintf("\tuae_u32 v,v1,v2;\n");
+ 	genamode (curi->smode, "srcreg", curi->size, "src", 1, 0);
+ 	/* That source is an immediate, so we can clobber it with abandon */
+ 	switch(curi->size) {
+ 	 case sz_byte: comprintf("\tsign_extend_8_rr(src,src);\n"); break;
+ 	 case sz_word: comprintf("\tsign_extend_16_rr(src,src);\n"); break;
+ 	 case sz_long: break;
+ 	}
+ 	comprintf("\tand_l_ri(src,~1);\n");
+ 	comprintf("\tsub_l_ri(src,m68k_pc_offset-m68k_pc_offset_thisinst-2);\n");
+ 	/* Leave the following as "add" --- it will allow it to be optimized
+ 	   away due to src being a constant ;-) */
+ 	comprintf("\tadd_l_ri(src,(uae_u32)comp_pc_p);\n");  
+ 	comprintf("\tmov_l_ri(PC_P,(uae_u32)comp_pc_p);\n");
+ 	/* Now they are both constant. Might as well fold in m68k_pc_offset */
+ 	comprintf("\tadd_l_ri(src,m68k_pc_offset);\n");
+ 	comprintf("\tadd_l_ri(PC_P,m68k_pc_offset);\n");
+ 	comprintf("\tm68k_pc_offset=0;\n");
+ 
+ 	if (curi->cc>=2) {
+ 	    comprintf("\tv1=get_const(PC_P);\n"
+ 		      "\tv2=get_const(src);\n"
+ 		      "\tregister_branch(v1,v2,%d);\n",
+ 		      cond_codes_x86[curi->cc]);
+ 	    comprintf("\tmake_flags_live();\n"); /* Load the flags */
+ 	    isjump; 
+ 	}
+ 	else {
+ 	    is_const_jump; 
+ 	}
+ 
+ 	switch(curi->cc) {
+ 	 case 0:  /* Unconditional jump */
+ 	    comprintf("\tmov_l_rr(PC_P,src);\n"); 
+ 	    comprintf("\tcomp_pc_p=(void*)get_const(PC_P);\n");
+ 	    break;
+ 	 case 1: break; /* This is silly! */
+ 	 case 8: failure; break;  /* Work out details! FIXME */
+ 	 case 9: failure; break;  /* Not critical, though! */
+ 
+ 	 case 2:
+ 	 case 3:
+ 	 case 4:
+ 	 case 5:
+ 	 case 6:
+ 	 case 7:
+ 	 case 10:
+ 	 case 11:
+ 	 case 12:
+ 	 case 13:
+ 	 case 14:
+ 	 case 15: 
+ 	    break;
+ 	 default: abort();
+ 	}
+ 	break;
+      case i_LEA:
+ 	genamode (curi->smode, "srcreg", curi->size, "src", 0, 0);
+ 	genamode (curi->dmode, "dstreg", curi->size, "dst", 2, 0);
+ 	genastore ("srca", curi->dmode, "dstreg", curi->size, "dst");
+ 	break;
+      case i_PEA:
+ 	if (table68k[opcode].smode==Areg || 
+ 	    table68k[opcode].smode==Aind || 
+ 	    table68k[opcode].smode==Aipi || 
+ 	    table68k[opcode].smode==Apdi || 
+ 	    table68k[opcode].smode==Ad16 || 
+ 	    table68k[opcode].smode==Ad8r) 
+ 	    comprintf("if (srcreg==7) dodgy=1;\n");
+ 
+ 	genamode (curi->smode, "srcreg", curi->size, "src", 0, 0);
+ 	genamode (Apdi, "7", sz_long, "dst", 2, 0);
+ 	genastore ("srca", Apdi, "7", sz_long, "dst");
+ 	break;
+      case i_DBcc:
+ 	isjump; 
+ 	uses_cmov;
+ 	genamode (curi->smode, "srcreg", curi->size, "src", 1, 0);
+ 	genamode (curi->dmode, "dstreg", curi->size, "offs", 1, 0);
+ 
+ 	/* That offs is an immediate, so we can clobber it with abandon */
+ 	switch(curi->size) {
+ 	 case sz_word: comprintf("\tsign_extend_16_rr(offs,offs);\n"); break;
+ 	 default: abort();  /* Seems this only comes in word flavour */
+ 	}
+ 	comprintf("\tsub_l_ri(offs,m68k_pc_offset-m68k_pc_offset_thisinst-2);\n"); 
+ 	comprintf("\tadd_l_ri(offs,(uae_u32)comp_pc_p);\n"); /* New PC, 
+ 								once the 
+ 								offset_68k is
+ 								* also added */
+ 	/* Let's fold in the m68k_pc_offset at this point */
+ 	comprintf("\tadd_l_ri(offs,m68k_pc_offset);\n");
+ 	comprintf("\tadd_l_ri(PC_P,m68k_pc_offset);\n");
+ 	comprintf("\tm68k_pc_offset=0;\n");
+ 
+ 	start_brace();
+ 	comprintf("\tint nsrc=scratchie++;\n");
+ 
+ 	if (curi->cc>=2) {
+ 	    comprintf("\tmake_flags_live();\n"); /* Load the flags */
+ 	}
+ 
+ 	if (curi->size!=sz_word) 
+ 	    abort();
+ 
+ 
+ 	switch(curi->cc) {
+ 	 case 0: /* This is an elaborate nop? */
+ 	    break;
+ 	 case 1: 
+ 	    comprintf("\tstart_needflags();\n");
+ 	    comprintf("\tsub_w_ri(src,1);\n");
+ 	    comprintf("\t end_needflags();\n");
+ 	    start_brace();
+ 	    comprintf("\tuae_u32 v2,v;\n"
+ 		      "\tuae_u32 v1=get_const(PC_P);\n");
+ 	    comprintf("\tv2=get_const(offs);\n"
+ 		      "\tregister_branch(v1,v2,3);\n");
+ 	    break;
+ 
+ 	 case 8: failure; break;  /* Work out details! FIXME */
+ 	 case 9: failure; break;  /* Not critical, though! */
+ 
+ 	 case 2:
+ 	 case 3:
+ 	 case 4:
+ 	 case 5:
+ 	 case 6:
+ 	 case 7:
+ 	 case 10:
+ 	 case 11:
+ 	 case 12:
+ 	 case 13:
+ 	 case 14:
+ 	 case 15:
+ 	    comprintf("\tmov_l_rr(nsrc,src);\n");
+ 	    comprintf("\tlea_l_brr(scratchie,src,(uae_s32)-1);\n"
+ 		      "\tmov_w_rr(src,scratchie);\n");
+ 	    comprintf("\tcmov_l_rr(offs,PC_P,%d);\n",
+ 		      cond_codes_x86[curi->cc]);
+ 	    comprintf("\tcmov_l_rr(src,nsrc,%d);\n",
+ 		      cond_codes_x86[curi->cc]);
+ 	    /* OK, now for cc=true, we have src==nsrc and offs==PC_P, 
+ 	       so whether we move them around doesn't matter. However,
+ 	       if cc=false, we have offs==jump_pc, and src==nsrc-1 */
+ 
+ 	    comprintf("\t start_needflags();\n");
+ 	    comprintf("\ttest_w_rr(nsrc,nsrc);\n"); 
+ 	    comprintf("\t end_needflags();\n");
+ 	    comprintf("\tcmov_l_rr(PC_P,offs,5);\n"); 
+ 	    break;
+ 	 default: abort();
+ 	}
+ 	genastore ("src", curi->smode, "srcreg", curi->size, "src");
+ 	gen_update_next_handler();
+ 	break;
+ 
+      case i_Scc:
+ 	genamode (curi->smode, "srcreg", curi->size, "src", 2, 0);
+ 	start_brace ();
+ 	comprintf ("\tint val = scratchie++;\n");
+ 
+ 	/* We set val to 0 if we really should use 255, and to 1 for real 0 */
+ 	switch(curi->cc) {
+ 	 case 0:  /* Unconditional set */
+ 	    comprintf("\tmov_l_ri(val,0);\n"); 
+ 	    break;
+ 	 case 1: 
+ 	    /* Unconditional not-set */
+ 	    comprintf("\tmov_l_ri(val,1);\n"); 
+ 	    break;
+ 	 case 8: failure; break;  /* Work out details! FIXME */
+ 	 case 9: failure; break;  /* Not critical, though! */
+ 
+ 	 case 2:
+ 	 case 3:
+ 	 case 4:
+ 	 case 5:
+ 	 case 6:
+ 	 case 7:
+ 	 case 10:
+ 	 case 11:
+ 	 case 12:
+ 	 case 13:
+ 	 case 14:
+ 	 case 15:
+ 	    comprintf("\tmake_flags_live();\n"); /* Load the flags */
+ 	    /* All condition codes can be inverted by changing the LSB */
+ 	    comprintf("\tsetcc(val,%d);\n",
+ 		      cond_codes_x86[curi->cc]^1); break;
+ 	 default: abort();
+ 	}
+ 	comprintf("\tsub_b_ri(val,1);\n");
+ 	genastore ("val", curi->smode, "srcreg", curi->size, "src");
+ 	break;
+      case i_DIVU:
+ 	isjump; 
+ 	failure;
+ 	break;
+      case i_DIVS:
+ 	isjump; 
+ 	failure;
+ 	break;
+      case i_MULU:
+ 	comprintf("\tdont_care_flags();\n");
+ 	genamode (curi->smode, "srcreg", sz_word, "src", 1, 0);
+ 	genamode (curi->dmode, "dstreg", sz_word, "dst", 1, 0);
+ 	/* To do 16x16 unsigned multiplication, we actually use 
+ 	   32x32 signed, and zero-extend the registers first.
+ 	   That solves the problem of MUL needing dedicated registers
+ 	   on the x86 */
+ 	comprintf("\tzero_extend_16_rr(scratchie,src);\n"
+ 		  "\tzero_extend_16_rr(dst,dst);\n"
+ 		  "\timul_32_32(dst,scratchie);\n");
+ 	genflags (flag_logical, sz_long, "dst", "", "");
+ 	genastore ("dst", curi->dmode, "dstreg", sz_long, "dst");
+ 	break;
+      case i_MULS:
+ 	comprintf("\tdont_care_flags();\n");
+ 	genamode (curi->smode, "srcreg", sz_word, "src", 1, 0);
+ 	genamode (curi->dmode, "dstreg", sz_word, "dst", 1, 0);
+ 	comprintf("\tsign_extend_16_rr(scratchie,src);\n"
+ 		  "\tsign_extend_16_rr(dst,dst);\n"
+ 		  "\timul_32_32(dst,scratchie);\n");
+ 	genflags (flag_logical, sz_long, "dst", "", "");
+ 	genastore ("dst", curi->dmode, "dstreg", sz_long, "dst");
+ 	break;
+      case i_CHK:
+ 	isjump; 
+ 	failure;
+ 	break;
+ 
+      case i_CHK2:
+ 	isjump; 
+ 	failure;
+ 	break;
+ 
+      case i_ASR:
+ 	comprintf("\tdont_care_flags();\n");
+ 
+ 	genamode (curi->smode, "srcreg", curi->size, "cnt", 1, 0);
+ 	genamode (curi->dmode, "dstreg", curi->size, "data", 1, 0);
+ 	if (curi->smode!=immi) {
+ 	    if (!noflags) {
+ 		uses_cmov;
+ 		start_brace();
+ 		comprintf("\tint highmask;\n"
+ 			  "\tint width;\n"
+ 			  "\tint cdata=scratchie++;\n"
+ 			  "\tint tmpcnt=scratchie++;\n"
+ 			  "\tint highshift=scratchie++;\n");
+ 		comprintf("\tmov_l_rr(tmpcnt,cnt);\n"
+ 			  "\tand_l_ri(tmpcnt,63);\n"
+ 			  "\tmov_l_ri(cdata,0);\n"
+ 			  "\tcmov_l_rr(cdata,data,5);\n");
+ 		/* cdata is now either data (for shift count!=0) or
+ 		   0 (for shift count==0) */
+ 		switch(curi->size) {
+ 		 case sz_byte: comprintf("\tshra_b_rr(data,cnt);\n"
+ 					 "\thighmask=0x38;\n"
+ 					 "\twidth=8;\n"); 
+ 		 break;
+ 		 case sz_word: comprintf("\tshra_w_rr(data,cnt);\n"
+ 					 "\thighmask=0x30;\n"
+ 					 "\twidth=16;\n"); 
+ 		 break;
+ 		 case sz_long: comprintf("\tshra_l_rr(data,cnt);\n"
+ 					 "\thighmask=0x20;\n"
+ 					 "\twidth=32;\n"); 
+ 		 break;
+ 		 default: abort();
+ 		}
+ 		comprintf("test_l_ri(cnt,highmask);\n"
+ 			  "mov_l_ri(highshift,0);\n"
+ 			  "mov_l_ri(scratchie,width/2);\n"
+ 			  "cmov_l_rr(highshift,scratchie,5);\n");
+ 		/* The x86 masks out bits, so we now make sure that things
+ 		   really get shifted as much as planned */
+ 		switch(curi->size) {
+ 		 case sz_byte: comprintf("\tshra_b_rr(data,highshift);\n");break;
+ 		 case sz_word: comprintf("\tshra_w_rr(data,highshift);\n");break;
+ 		 case sz_long: comprintf("\tshra_l_rr(data,highshift);\n");break;
+ 		 default: abort();
+ 		}
+ 		/* And again */
+ 		switch(curi->size) {
+ 		 case sz_byte: comprintf("\tshra_b_rr(data,highshift);\n");break;
+ 		 case sz_word: comprintf("\tshra_w_rr(data,highshift);\n");break;
+ 		 case sz_long: comprintf("\tshra_l_rr(data,highshift);\n");break;
+ 		 default: abort();
+ 		}
+ 		
+ 		/* Result of shift is now in data. Now we need to determine
+ 		   the carry by shifting cdata one less */
+ 		comprintf("\tsub_l_ri(tmpcnt,1);\n");
+ 		switch(curi->size) {
+ 		 case sz_byte: comprintf("\tshra_b_rr(cdata,tmpcnt);\n");break;
+ 		 case sz_word: comprintf("\tshra_w_rr(cdata,tmpcnt);\n");break;
+ 		 case sz_long: comprintf("\tshra_l_rr(cdata,tmpcnt);\n");break;
+ 		 default: abort();
+ 		}
+ 		/* If the shift count was higher than the width, we need
+ 		   to pick up the sign from data */
+ 		comprintf("test_l_ri(tmpcnt,highmask);\n"
+ 			  "cmov_l_rr(cdata,data,5);\n");
+ 		/* And create the flags */
+ 		comprintf("\tstart_needflags();\n");
+ 		comprintf("\tif (needed_flags & FLAG_ZNV)\n");
+ 		switch(curi->size) {
+ 		 case sz_byte: comprintf("\t  test_b_rr(data,data);\n"); break;
+ 		 case sz_word: comprintf("\t  test_w_rr(data,data);\n"); break;
+ 		 case sz_long: comprintf("\t  test_l_rr(data,data);\n"); break;
+ 		}
+ 		comprintf("\t bt_l_ri(cdata,0);\n"); /* Set C */
+ 		comprintf("\t live_flags();\n");
+ 		comprintf("\t end_needflags();\n");
+ 		comprintf("\t duplicate_carry();\n");
+ 		comprintf("if (!(needed_flags & FLAG_CZNV)) dont_care_flags();\n");
+ 		genastore ("data", curi->dmode, "dstreg", curi->size, "data");
+ 	    }
+ 	    else {
+ 		uses_cmov;
+ 		start_brace();
+ 		comprintf("\tint highmask;\n"
+ 			  "\tint width;\n"
+ 			  "\tint highshift=scratchie++;\n");
+ 		switch(curi->size) {
+ 		 case sz_byte: comprintf("\tshra_b_rr(data,cnt);\n"
+ 					 "\thighmask=0x38;\n"
+ 					 "\twidth=8;\n"); 
+ 		 break;
+ 		 case sz_word: comprintf("\tshra_w_rr(data,cnt);\n"
+ 					 "\thighmask=0x30;\n"
+ 					 "\twidth=16;\n"); 
+ 		 break;
+ 		 case sz_long: comprintf("\tshra_l_rr(data,cnt);\n"
+ 					 "\thighmask=0x20;\n"
+ 					 "\twidth=32;\n"); 
+ 		 break;
+ 		 default: abort();
+ 		}
+ 		comprintf("test_l_ri(cnt,highmask);\n"
+ 			  "mov_l_ri(highshift,0);\n"
+ 			  "mov_l_ri(scratchie,width/2);\n"
+ 			  "cmov_l_rr(highshift,scratchie,5);\n");
+ 		/* The x86 masks out bits, so we now make sure that things
+ 		   really get shifted as much as planned */
+ 		switch(curi->size) {
+ 		 case sz_byte: comprintf("\tshra_b_rr(data,highshift);\n");break;
+ 		 case sz_word: comprintf("\tshra_w_rr(data,highshift);\n");break;
+ 		 case sz_long: comprintf("\tshra_l_rr(data,highshift);\n");break;
+ 		 default: abort();
+ 		}
+ 		/* And again */
+ 		switch(curi->size) {
+ 		 case sz_byte: comprintf("\tshra_b_rr(data,highshift);\n");break;
+ 		 case sz_word: comprintf("\tshra_w_rr(data,highshift);\n");break;
+ 		 case sz_long: comprintf("\tshra_l_rr(data,highshift);\n");break;
+ 		 default: abort();
+ 		}
+ 		genastore ("data", curi->dmode, "dstreg", curi->size, "data");
+ 	    }
+ 	}
+ 	else {
+ 	    start_brace();
+ 	    comprintf("\tint tmp=scratchie++;\n"
+ 		      "\tint bp;\n"
+ 		      "\tmov_l_rr(tmp,data);\n");
+ 	    switch(curi->size) {
+ 	     case sz_byte: comprintf("\tshra_b_ri(data,srcreg);\n"
+ 				     "\tbp=srcreg-1;\n"); break;
+ 	     case sz_word: comprintf("\tshra_w_ri(data,srcreg);\n"
+ 				     "\tbp=srcreg-1;\n"); break;
+ 	     case sz_long: comprintf("\tshra_l_ri(data,srcreg);\n"
+ 				     "\tbp=srcreg-1;\n"); break;
+ 	     default: abort();
+ 	    }
+ 
+ 	    if (!noflags) {
+ 		comprintf("\tstart_needflags();\n");
+ 		comprintf("\tif (needed_flags & FLAG_ZNV)\n");
+ 		switch(curi->size) {
+ 		 case sz_byte: comprintf("\t  test_b_rr(data,data);\n"); break;
+ 		 case sz_word: comprintf("\t  test_w_rr(data,data);\n"); break;
+ 		 case sz_long: comprintf("\t  test_l_rr(data,data);\n"); break;
+ 		}
+ 		comprintf("\t bt_l_ri(tmp,bp);\n"); /* Set C */
+ 		comprintf("\t live_flags();\n");
+ 		comprintf("\t end_needflags();\n");
+ 		comprintf("\t duplicate_carry();\n");
+ 		comprintf("if (!(needed_flags & FLAG_CZNV)) dont_care_flags();\n");
+ 	    }
+ 	    genastore ("data", curi->dmode, "dstreg", curi->size, "data");
+ 	}
+ 	break;
+ 
+      case i_ASL:
+ 	comprintf("\tdont_care_flags();\n");
+ 	mayfail;
+ 	/* Except for the handling of the V flag, this is identical to
+ 	   LSL. The handling of V is, uhm, unpleasant, so if it's needed,
+ 	   let the normal emulation handle it. Shoulders of giants kinda
+ 	   thing ;-) */
+ 	comprintf("if (needed_flags & FLAG_V) {\n"
+ 		  "  FAIL(1);\n"
+ 		  "  return 0;\n"
+ 		  "} \n");
+ 	
+ 	genamode (curi->smode, "srcreg", curi->size, "cnt", 1, 0);
+ 	genamode (curi->dmode, "dstreg", curi->size, "data", 1, 0);
+ 	if (curi->smode!=immi) {
+ 	    if (!noflags) {
+ 		uses_cmov;
+ 		start_brace();
+ 		comprintf("\tint highmask;\n"
+ 			  "\tint cdata=scratchie++;\n"
+ 			  "\tint tmpcnt=scratchie++;\n");
+ 		comprintf("\tmov_l_rr(tmpcnt,cnt);\n"
+ 			  "\tand_l_ri(tmpcnt,63);\n"
+ 			  "\tmov_l_ri(cdata,0);\n"
+ 			  "\tcmov_l_rr(cdata,data,5);\n");
+ 		/* cdata is now either data (for shift count!=0) or
+ 		   0 (for shift count==0) */
+ 		switch(curi->size) {
+ 		 case sz_byte: comprintf("\tshll_b_rr(data,cnt);\n"
+ 					 "\thighmask=0x38;\n"); 
+ 		 break;
+ 		 case sz_word: comprintf("\tshll_w_rr(data,cnt);\n"
+ 					 "\thighmask=0x30;\n"); 
+ 		 break;
+ 		 case sz_long: comprintf("\tshll_l_rr(data,cnt);\n"
+ 					 "\thighmask=0x20;\n"); 
+ 		 break;
+ 		 default: abort();
+ 		}
+ 		comprintf("test_l_ri(cnt,highmask);\n"
+ 			  "mov_l_ri(scratchie,0);\n"
+ 			  "cmov_l_rr(scratchie,data,4);\n");
+ 		switch(curi->size) {
+ 		 case sz_byte: comprintf("\tmov_b_rr(data,scratchie);\n");break;
+ 		 case sz_word: comprintf("\tmov_w_rr(data,scratchie);\n");break;
+ 		 case sz_long: comprintf("\tmov_l_rr(data,scratchie);\n");break;
+ 		 default: abort();
+ 		}
+ 		/* Result of shift is now in data. Now we need to determine
+ 		   the carry by shifting cdata one less */
+ 		comprintf("\tsub_l_ri(tmpcnt,1);\n");
+ 		switch(curi->size) {
+ 		 case sz_byte: comprintf("\tshll_b_rr(cdata,tmpcnt);\n");break;
+ 		 case sz_word: comprintf("\tshll_w_rr(cdata,tmpcnt);\n");break;
+ 		 case sz_long: comprintf("\tshll_l_rr(cdata,tmpcnt);\n");break;
+ 		 default: abort();
+ 		}
+ 		comprintf("test_l_ri(tmpcnt,highmask);\n"
+ 			  "mov_l_ri(scratchie,0);\n"
+ 			  "cmov_l_rr(cdata,scratchie,5);\n");
+ 		/* And create the flags */
+ 		comprintf("\tstart_needflags();\n");
+ 
+ 		comprintf("\tif (needed_flags & FLAG_ZNV)\n");
+ 		switch(curi->size) {
+ 		 case sz_byte: comprintf("\t  test_b_rr(data,data);\n"); 
+ 		    comprintf("\t bt_l_ri(cdata,7);\n"); break;
+ 		 case sz_word: comprintf("\t  test_w_rr(data,data);\n"); 
+ 		    comprintf("\t bt_l_ri(cdata,15);\n"); break;
+ 		 case sz_long: comprintf("\t  test_l_rr(data,data);\n"); 
+ 		    comprintf("\t bt_l_ri(cdata,31);\n"); break;
+ 		}
+ 		comprintf("\t live_flags();\n");
+ 		comprintf("\t end_needflags();\n");
+ 		comprintf("\t duplicate_carry();\n");
+ 		comprintf("if (!(needed_flags & FLAG_CZNV)) dont_care_flags();\n");
+ 		genastore ("data", curi->dmode, "dstreg", curi->size, "data");
+ 	    }
+ 	    else {
+ 		uses_cmov;
+ 		start_brace();
+ 		comprintf("\tint highmask;\n");
+ 		switch(curi->size) {
+ 		 case sz_byte: comprintf("\tshll_b_rr(data,cnt);\n"
+ 					 "\thighmask=0x38;\n"); 
+ 		    break;
+ 		 case sz_word: comprintf("\tshll_w_rr(data,cnt);\n"
+ 					 "\thighmask=0x30;\n"); 
+ 		    break;
+ 		 case sz_long: comprintf("\tshll_l_rr(data,cnt);\n"
+ 					 "\thighmask=0x20;\n"); 
+ 		    break;
+ 		 default: abort();
+ 		}
+ 		comprintf("test_l_ri(cnt,highmask);\n"
+ 			  "mov_l_ri(scratchie,0);\n"
+ 			  "cmov_l_rr(scratchie,data,4);\n");
+ 		switch(curi->size) {
+ 		 case sz_byte: comprintf("\tmov_b_rr(data,scratchie);\n");break;
+ 		 case sz_word: comprintf("\tmov_w_rr(data,scratchie);\n");break;
+ 		 case sz_long: comprintf("\tmov_l_rr(data,scratchie);\n");break;
+ 		 default: abort();
+ 		}
+ 		genastore ("data", curi->dmode, "dstreg", curi->size, "data");
+ 	    }
+ 	}
+ 	else {
+ 	    start_brace();
+ 	    comprintf("\tint tmp=scratchie++;\n"
+ 		      "\tint bp;\n"
+ 		      "\tmov_l_rr(tmp,data);\n");
+ 	    switch(curi->size) {
+ 	     case sz_byte: comprintf("\tshll_b_ri(data,srcreg);\n"
+ 				     "\tbp=8-srcreg;\n"); break;
+ 	     case sz_word: comprintf("\tshll_w_ri(data,srcreg);\n"
+ 				     "\tbp=16-srcreg;\n"); break;
+ 	     case sz_long: comprintf("\tshll_l_ri(data,srcreg);\n"
+ 				     "\tbp=32-srcreg;\n"); break;
+ 	     default: abort();
+ 	    }
+ 
+ 	    if (!noflags) {
+ 		comprintf("\tstart_needflags();\n");
+ 		comprintf("\tif (needed_flags & FLAG_ZNV)\n");
+ 		switch(curi->size) {
+ 		 case sz_byte: comprintf("\t  test_b_rr(data,data);\n"); break;
+ 		 case sz_word: comprintf("\t  test_w_rr(data,data);\n"); break;
+ 		 case sz_long: comprintf("\t  test_l_rr(data,data);\n"); break;
+ 		}
+ 		comprintf("\t bt_l_ri(tmp,bp);\n"); /* Set C */
+ 		comprintf("\t live_flags();\n");
+ 		comprintf("\t end_needflags();\n");
+ 		comprintf("\t duplicate_carry();\n");
+ 		comprintf("if (!(needed_flags & FLAG_CZNV)) dont_care_flags();\n");
+ 	    }
+ 	    genastore ("data", curi->dmode, "dstreg", curi->size, "data");
+ 	}
+ 	break;
+     
+      case i_LSR:
+ 	comprintf("\tdont_care_flags();\n");
+ 
+ 	genamode (curi->smode, "srcreg", curi->size, "cnt", 1, 0);
+ 	genamode (curi->dmode, "dstreg", curi->size, "data", 1, 0);
+ 	if (curi->smode!=immi) {
+ 	    if (!noflags) {
+ 		uses_cmov;
+ 		start_brace();
+ 		comprintf("\tint highmask;\n"
+ 			  "\tint cdata=scratchie++;\n"
+ 			  "\tint tmpcnt=scratchie++;\n");
+ 		comprintf("\tmov_l_rr(tmpcnt,cnt);\n"
+ 			  "\tand_l_ri(tmpcnt,63);\n"
+ 			  "\tmov_l_ri(cdata,0);\n"
+ 			  "\tcmov_l_rr(cdata,data,5);\n");
+ 		/* cdata is now either data (for shift count!=0) or
+ 		   0 (for shift count==0) */
+ 		switch(curi->size) {
+ 		 case sz_byte: comprintf("\tshrl_b_rr(data,cnt);\n"
+ 					 "\thighmask=0x38;\n"); 
+ 		 break;
+ 		 case sz_word: comprintf("\tshrl_w_rr(data,cnt);\n"
+ 					 "\thighmask=0x30;\n"); 
+ 		 break;
+ 		 case sz_long: comprintf("\tshrl_l_rr(data,cnt);\n"
+ 					 "\thighmask=0x20;\n"); 
+ 		 break;
+ 		 default: abort();
+ 		}
+ 		comprintf("test_l_ri(cnt,highmask);\n"
+ 			  "mov_l_ri(scratchie,0);\n"
+ 			  "cmov_l_rr(scratchie,data,4);\n");
+ 		switch(curi->size) {
+ 		 case sz_byte: comprintf("\tmov_b_rr(data,scratchie);\n");break;
+ 		 case sz_word: comprintf("\tmov_w_rr(data,scratchie);\n");break;
+ 		 case sz_long: comprintf("\tmov_l_rr(data,scratchie);\n");break;
+ 		 default: abort();
+ 		}
+ 		/* Result of shift is now in data. Now we need to determine
+ 		   the carry by shifting cdata one less */
+ 		comprintf("\tsub_l_ri(tmpcnt,1);\n");
+ 		switch(curi->size) {
+ 		 case sz_byte: comprintf("\tshrl_b_rr(cdata,tmpcnt);\n");break;
+ 		 case sz_word: comprintf("\tshrl_w_rr(cdata,tmpcnt);\n");break;
+ 		 case sz_long: comprintf("\tshrl_l_rr(cdata,tmpcnt);\n");break;
+ 		 default: abort();
+ 		}
+ 		comprintf("test_l_ri(tmpcnt,highmask);\n"
+ 			  "mov_l_ri(scratchie,0);\n"
+ 			  "cmov_l_rr(cdata,scratchie,5);\n");
+ 		/* And create the flags */
+ 		comprintf("\tstart_needflags();\n");
+ 		comprintf("\tif (needed_flags & FLAG_ZNV)\n");
+ 		switch(curi->size) {
+ 		 case sz_byte: comprintf("\t  test_b_rr(data,data);\n"); break;
+ 		 case sz_word: comprintf("\t  test_w_rr(data,data);\n"); break;
+ 		 case sz_long: comprintf("\t  test_l_rr(data,data);\n"); break;
+ 		}
+ 		comprintf("\t bt_l_ri(cdata,0);\n"); /* Set C */
+ 		comprintf("\t live_flags();\n");
+ 		comprintf("\t end_needflags();\n");
+ 		comprintf("\t duplicate_carry();\n");
+ 		comprintf("if (!(needed_flags & FLAG_CZNV)) dont_care_flags();\n");
+ 		genastore ("data", curi->dmode, "dstreg", curi->size, "data");
+ 	    }
+ 	    else {
+ 		uses_cmov;
+ 		start_brace();
+ 		comprintf("\tint highmask;\n");
+ 		switch(curi->size) {
+ 		 case sz_byte: comprintf("\tshrl_b_rr(data,cnt);\n"
+ 					 "\thighmask=0x38;\n"); 
+ 		    break;
+ 		 case sz_word: comprintf("\tshrl_w_rr(data,cnt);\n"
+ 					 "\thighmask=0x30;\n"); 
+ 		    break;
+ 		 case sz_long: comprintf("\tshrl_l_rr(data,cnt);\n"
+ 					 "\thighmask=0x20;\n"); 
+ 		    break;
+ 		 default: abort();
+ 		}
+ 		comprintf("test_l_ri(cnt,highmask);\n"
+ 			  "mov_l_ri(scratchie,0);\n"
+ 			  "cmov_l_rr(scratchie,data,4);\n");
+ 		switch(curi->size) {
+ 		 case sz_byte: comprintf("\tmov_b_rr(data,scratchie);\n");break;
+ 		 case sz_word: comprintf("\tmov_w_rr(data,scratchie);\n");break;
+ 		 case sz_long: comprintf("\tmov_l_rr(data,scratchie);\n");break;
+ 		 default: abort();
+ 		}
+ 		genastore ("data", curi->dmode, "dstreg", curi->size, "data");
+ 	    }
+ 	}
+ 	else {
+ 	    start_brace();
+ 	    comprintf("\tint tmp=scratchie++;\n"
+ 		      "\tint bp;\n"
+ 		      "\tmov_l_rr(tmp,data);\n");
+ 	    switch(curi->size) {
+ 	     case sz_byte: comprintf("\tshrl_b_ri(data,srcreg);\n"
+ 				     "\tbp=srcreg-1;\n"); break;
+ 	     case sz_word: comprintf("\tshrl_w_ri(data,srcreg);\n"
+ 				     "\tbp=srcreg-1;\n"); break;
+ 	     case sz_long: comprintf("\tshrl_l_ri(data,srcreg);\n"
+ 				     "\tbp=srcreg-1;\n"); break;
+ 	     default: abort();
+ 	    }
+ 
+ 	    if (!noflags) {
+ 		comprintf("\tstart_needflags();\n");
+ 		comprintf("\tif (needed_flags & FLAG_ZNV)\n");
+ 		switch(curi->size) {
+ 		 case sz_byte: comprintf("\t  test_b_rr(data,data);\n"); break;
+ 		 case sz_word: comprintf("\t  test_w_rr(data,data);\n"); break;
+ 		 case sz_long: comprintf("\t  test_l_rr(data,data);\n"); break;
+ 		}
+ 		comprintf("\t bt_l_ri(tmp,bp);\n"); /* Set C */
+ 		comprintf("\t live_flags();\n");
+ 		comprintf("\t end_needflags();\n");
+ 		comprintf("\t duplicate_carry();\n");
+ 		comprintf("if (!(needed_flags & FLAG_CZNV)) dont_care_flags();\n");
+ 	    }
+ 	    genastore ("data", curi->dmode, "dstreg", curi->size, "data");
+ 	}
+ 	break;
+ 
+      case i_LSL:
+ 	comprintf("\tdont_care_flags();\n");
+ 
+ 	genamode (curi->smode, "srcreg", curi->size, "cnt", 1, 0);
+ 	genamode (curi->dmode, "dstreg", curi->size, "data", 1, 0);
+ 	if (curi->smode!=immi) {
+ 	    if (!noflags) {
+ 		uses_cmov;
+ 		start_brace();
+ 		comprintf("\tint highmask;\n"
+ 			  "\tint cdata=scratchie++;\n"
+ 			  "\tint tmpcnt=scratchie++;\n");
+ 		comprintf("\tmov_l_rr(tmpcnt,cnt);\n"
+ 			  "\tand_l_ri(tmpcnt,63);\n"
+ 			  "\tmov_l_ri(cdata,0);\n"
+ 			  "\tcmov_l_rr(cdata,data,5);\n");
+ 		/* cdata is now either data (for shift count!=0) or
+ 		   0 (for shift count==0) */
+ 		switch(curi->size) {
+ 		 case sz_byte: comprintf("\tshll_b_rr(data,cnt);\n"
+ 					 "\thighmask=0x38;\n"); 
+ 		 break;
+ 		 case sz_word: comprintf("\tshll_w_rr(data,cnt);\n"
+ 					 "\thighmask=0x30;\n"); 
+ 		 break;
+ 		 case sz_long: comprintf("\tshll_l_rr(data,cnt);\n"
+ 					 "\thighmask=0x20;\n"); 
+ 		 break;
+ 		 default: abort();
+ 		}
+ 		comprintf("test_l_ri(cnt,highmask);\n"
+ 			  "mov_l_ri(scratchie,0);\n"
+ 			  "cmov_l_rr(scratchie,data,4);\n");
+ 		switch(curi->size) {
+ 		 case sz_byte: comprintf("\tmov_b_rr(data,scratchie);\n");break;
+ 		 case sz_word: comprintf("\tmov_w_rr(data,scratchie);\n");break;
+ 		 case sz_long: comprintf("\tmov_l_rr(data,scratchie);\n");break;
+ 		 default: abort();
+ 		}
+ 		/* Result of shift is now in data. Now we need to determine
+ 		   the carry by shifting cdata one less */
+ 		comprintf("\tsub_l_ri(tmpcnt,1);\n");
+ 		switch(curi->size) {
+ 		 case sz_byte: comprintf("\tshll_b_rr(cdata,tmpcnt);\n");break;
+ 		 case sz_word: comprintf("\tshll_w_rr(cdata,tmpcnt);\n");break;
+ 		 case sz_long: comprintf("\tshll_l_rr(cdata,tmpcnt);\n");break;
+ 		 default: abort();
+ 		}
+ 		comprintf("test_l_ri(tmpcnt,highmask);\n"
+ 			  "mov_l_ri(scratchie,0);\n"
+ 			  "cmov_l_rr(cdata,scratchie,5);\n");
+ 		/* And create the flags */
+ 		comprintf("\tstart_needflags();\n");
+ 		comprintf("\tif (needed_flags & FLAG_ZNV)\n");
+ 		switch(curi->size) {
+ 		 case sz_byte: comprintf("\t  test_b_rr(data,data);\n"); 
+ 		    comprintf("\t bt_l_ri(cdata,7);\n"); break;
+ 		 case sz_word: comprintf("\t  test_w_rr(data,data);\n"); 
+ 		    comprintf("\t bt_l_ri(cdata,15);\n"); break;
+ 		 case sz_long: comprintf("\t  test_l_rr(data,data);\n"); 
+ 		    comprintf("\t bt_l_ri(cdata,31);\n"); break;
+ 		}
+ 		comprintf("\t live_flags();\n");
+ 		comprintf("\t end_needflags();\n");
+ 		comprintf("\t duplicate_carry();\n");
+ 		comprintf("if (!(needed_flags & FLAG_CZNV)) dont_care_flags();\n");
+ 		genastore ("data", curi->dmode, "dstreg", curi->size, "data");
+ 	    }
+ 	    else {
+ 		uses_cmov;
+ 		start_brace();
+ 		comprintf("\tint highmask;\n");
+ 		switch(curi->size) {
+ 		 case sz_byte: comprintf("\tshll_b_rr(data,cnt);\n"
+ 					 "\thighmask=0x38;\n"); 
+ 		    break;
+ 		 case sz_word: comprintf("\tshll_w_rr(data,cnt);\n"
+ 					 "\thighmask=0x30;\n"); 
+ 		    break;
+ 		 case sz_long: comprintf("\tshll_l_rr(data,cnt);\n"
+ 					 "\thighmask=0x20;\n"); 
+ 		    break;
+ 		 default: abort();
+ 		}
+ 		comprintf("test_l_ri(cnt,highmask);\n"
+ 			  "mov_l_ri(scratchie,0);\n"
+ 			  "cmov_l_rr(scratchie,data,4);\n");
+ 		switch(curi->size) {
+ 		 case sz_byte: comprintf("\tmov_b_rr(data,scratchie);\n");break;
+ 		 case sz_word: comprintf("\tmov_w_rr(data,scratchie);\n");break;
+ 		 case sz_long: comprintf("\tmov_l_rr(data,scratchie);\n");break;
+ 		 default: abort();
+ 		}
+ 		genastore ("data", curi->dmode, "dstreg", curi->size, "data");
+ 	    }
+ 	}
+ 	else {
+ 	    start_brace();
+ 	    comprintf("\tint tmp=scratchie++;\n"
+ 		      "\tint bp;\n"
+ 		      "\tmov_l_rr(tmp,data);\n");
+ 	    switch(curi->size) {
+ 	     case sz_byte: comprintf("\tshll_b_ri(data,srcreg);\n"
+ 				     "\tbp=8-srcreg;\n"); break;
+ 	     case sz_word: comprintf("\tshll_w_ri(data,srcreg);\n"
+ 				     "\tbp=16-srcreg;\n"); break;
+ 	     case sz_long: comprintf("\tshll_l_ri(data,srcreg);\n"
+ 				     "\tbp=32-srcreg;\n"); break;
+ 	     default: abort();
+ 	    }
+ 
+ 	    if (!noflags) {
+ 		comprintf("\tstart_needflags();\n");
+ 		comprintf("\tif (needed_flags & FLAG_ZNV)\n");
+ 		switch(curi->size) {
+ 		 case sz_byte: comprintf("\t  test_b_rr(data,data);\n"); break;
+ 		 case sz_word: comprintf("\t  test_w_rr(data,data);\n"); break;
+ 		 case sz_long: comprintf("\t  test_l_rr(data,data);\n"); break;
+ 		}
+ 		comprintf("\t bt_l_ri(tmp,bp);\n"); /* Set C */
+ 		comprintf("\t live_flags();\n");
+ 		comprintf("\t end_needflags();\n");
+ 		comprintf("\t duplicate_carry();\n");
+ 		comprintf("if (!(needed_flags & FLAG_CZNV)) dont_care_flags();\n");
+ 	    }
+ 	    genastore ("data", curi->dmode, "dstreg", curi->size, "data");
+ 	}
+ 	break;
+ 
+      case i_ROL:
+ 	comprintf("\tdont_care_flags();\n");
+ 	genamode (curi->smode, "srcreg", curi->size, "cnt", 1, 0);
+ 	genamode (curi->dmode, "dstreg", curi->size, "data", 1, 0);
+ 	start_brace ();
+ 
+ 	switch(curi->size) {
+ 	 case sz_long: comprintf("\t rol_l_rr(data,cnt);\n"); break;
+ 	 case sz_word: comprintf("\t rol_w_rr(data,cnt);\n"); break;
+ 	 case sz_byte: comprintf("\t rol_b_rr(data,cnt);\n"); break;
+ 	}
+       
+ 	if (!noflags) {
+ 	    comprintf("\tstart_needflags();\n");
+ 	    comprintf("\tif (needed_flags & FLAG_ZNV)\n");
+ 	    switch(curi->size) {
+ 	     case sz_byte: comprintf("\t  test_b_rr(data,data);\n"); break;
+ 	     case sz_word: comprintf("\t  test_w_rr(data,data);\n"); break;
+ 	     case sz_long: comprintf("\t  test_l_rr(data,data);\n"); break;
+ 	    }
+ 	    comprintf("\t bt_l_ri(data,0x00);\n"); /* Set C */
+ 	    comprintf("\t live_flags();\n");
+ 	    comprintf("\t end_needflags();\n");
+ 	}
+ 	genastore ("data", curi->dmode, "dstreg", curi->size, "data");
+ 	break;
+ 
+      case i_ROR:
+ 	comprintf("\tdont_care_flags();\n");
+ 	genamode (curi->smode, "srcreg", curi->size, "cnt", 1, 0);
+ 	genamode (curi->dmode, "dstreg", curi->size, "data", 1, 0);
+ 	start_brace ();
+ 
+ 	switch(curi->size) {
+ 	 case sz_long: comprintf("\t ror_l_rr(data,cnt);\n"); break;
+ 	 case sz_word: comprintf("\t ror_w_rr(data,cnt);\n"); break;
+ 	 case sz_byte: comprintf("\t ror_b_rr(data,cnt);\n"); break;
+ 	}
+       
+ 	if (!noflags) {
+ 	    comprintf("\tstart_needflags();\n");
+ 	    comprintf("\tif (needed_flags & FLAG_ZNV)\n");
+ 	    switch(curi->size) {
+ 	     case sz_byte: comprintf("\t  test_b_rr(data,data);\n"); break;
+ 	     case sz_word: comprintf("\t  test_w_rr(data,data);\n"); break;
+ 	     case sz_long: comprintf("\t  test_l_rr(data,data);\n"); break;
+ 	    }
+ 	    switch(curi->size) {
+ 	     case sz_byte: comprintf("\t bt_l_ri(data,0x07);\n"); break;
+ 	     case sz_word: comprintf("\t bt_l_ri(data,0x0f);\n"); break;
+ 	     case sz_long: comprintf("\t bt_l_ri(data,0x1f);\n"); break;
+ 	    }
+ 	    comprintf("\t live_flags();\n");
+ 	    comprintf("\t end_needflags();\n");
+ 	}
+ 	genastore ("data", curi->dmode, "dstreg", curi->size, "data");
+ 	break;
+ 
+      case i_ROXL:
+ 	failure;
+ 	break;
+      case i_ROXR:
+ 	failure;
+ 	break;
+      case i_ASRW:
+ 	failure;
+ 	break;
+      case i_ASLW:
+ 	failure;
+ 	break;
+      case i_LSRW:
+ 	failure;
+ 	break;
+      case i_LSLW:
+ 	failure;
+ 	break;
+      case i_ROLW:
+ 	failure;
+ 	break;
+      case i_RORW:
+ 	failure;
+ 	break;
+      case i_ROXLW:
+ 	failure;
+ 	break;
+      case i_ROXRW:
+ 	failure;
+ 	break;
+      case i_MOVEC2:
+ 	isjump; 
+ 	failure;
+ 	break;
+      case i_MOVE2C:
+ 	isjump; 
+ 	failure;
+ 	break;
+      case i_CAS:
+ 	failure;
+ 	break;
+      case i_CAS2:
+ 	failure;
+ 	break;
+      case i_MOVES:		/* ignore DFC and SFC because we have no MMU */
+ 	isjump; 
+ 	failure;
+ 	break;
+      case i_BKPT:		/* only needed for hardware emulators */
+ 	isjump; 
+ 	failure;
+ 	break;
+      case i_CALLM:		/* not present in 68030 */
+ 	isjump; 
+ 	failure;
+ 	break;
+      case i_RTM:		/* not present in 68030 */
+ 	isjump; 
+ 	failure;
+ 	break;
+      case i_TRAPcc:
+ 	isjump; 
+ 	failure;
+ 	break;
+      case i_DIVL:
+ 	isjump; 
+ 	failure;
+ 	break;
+      case i_MULL:
+ 	if (!noflags) {
+ 	    failure;
+ 	    break;
+ 	}
+ 	comprintf("\tuae_u16 extra=%s;\n",gen_nextiword());
+ 	comprintf("\tint r2=(extra>>12)&7;\n"
+ 		  "\tint tmp=scratchie++;\n");
+        
+ 	genamode (curi->dmode, "dstreg", curi->size, "dst", 1, 0);
+ 	/* The two operands are in dst and r2 */
+ 	comprintf("\tif (extra&0x0400) {\n" /* Need full 64 bit result */
+ 		  "\tint r3=(extra&7);\n"
+ 		  "\tmov_l_rr(r3,dst);\n"); /* operands now in r3 and r2 */
+ 	comprintf("\tif (extra&0x0800) { \n" /* signed */
+ 		  "\t\timul_64_32(r2,r3);\n"
+ 		  "\t} else { \n"
+ 		  "\t\tmul_64_32(r2,r3);\n"
+ 		  "\t} \n");
+ 	/* The result is in r2/tmp, with r2 holding the lower 32 bits */
+ 	comprintf("\t} else {\n");  /* Only want 32 bit result */
+ 	/* operands in dst and r2, result foes into r2 */
+ 	/* shouldn't matter whether it's signed or unsigned?!? */
+ 	comprintf("\timul_32_32(r2,dst);\n"
+ 		  "\t}\n");
+ 	break;
+ 
+      case i_BFTST:
+      case i_BFEXTU:
+      case i_BFCHG:
+      case i_BFEXTS:
+      case i_BFCLR:
+      case i_BFFFO:
+      case i_BFSET:
+      case i_BFINS:
+ 	failure;
+ 	break;
+      case i_PACK:
+ 	failure;
+ 	break;
+      case i_UNPK:
+ 	failure;
+ 	break;
+      case i_TAS:
+ 	failure;
+ 	break;
+      case i_FPP:
+ 	mayfail;
+ 	comprintf("\tuae_u16 extra=%s;\n",gen_nextiword());
+ 	comprintf("\tcomp_fpp_opp(opcode,extra);\n");
+ 	break;
+      case i_FBcc:
+ 	isjump;
+ 	uses_cmov;
+ 	mayfail;
+ 	comprintf("\tcomp_fbcc_opp(opcode);\n");
+ 	break;
+      case i_FDBcc:
+ 	isjump; 
+ 	failure;
+ 	break;
+      case i_FScc:
+ 	mayfail;
+ 	uses_cmov;
+ 	comprintf("\tuae_u16 extra=%s;\n",gen_nextiword());
+ 	comprintf("\tcomp_fscc_opp(opcode,extra);\n");
+ 	break;
+      case i_FTRAPcc:
+ 	isjump; 
+ 	failure;
+ 	break;
+      case i_FSAVE:
+ 	failure;
+ 	break;
+      case i_FRESTORE:
+ 	failure;
+ 	break;
+ 
+      case i_CINVL:
+      case i_CINVP:
+      case i_CINVA:
+ 	isjump;  /* Not really, but it's probably a good idea to stop 
+ 		    translating at this point */
+ 	failure;
+ 	comprintf ("\tflush_icache();\n");  /* Differentiate a bit more? */
+ 	break;
+      case i_CPUSHL:
+      case i_CPUSHP:
+      case i_CPUSHA:
+ 	isjump;  /* Not really, but it's probably a good idea to stop 
+ 		    translating at this point */
+ 	failure;
+ 	break;
+      case i_MOVE16:
+ 	if ((opcode & 0xfff8) == 0xf620) {
+ 	    genmov16();
+ 	} else {
+ 	    isjump;
+ 	    failure;
+ 	}
+ 	break;
+ 
+      case i_MMUOP:
+ 	isjump; 
+ 	failure;
+ 	break;
+      default:
+ 	abort ();
+ 	break;
+     }
+     comprintf("%s",endstr);
+     finish_braces ();
+     sync_m68k_pc ();
+     if (global_mayfail)
+ 	comprintf("\tif (failure)  m68k_pc_offset=m68k_pc_offset_thisinst;\n");
+     return global_failure;
+ }
+ 
+ static void 
+ generate_includes (FILE * f)
+ {
+     fprintf (f, "#include \"sysconfig.h\"\n");
+     fprintf (f, "#include \"sysdeps.h\"\n");
+     fprintf (f, "#include \"config.h\"\n");
+     fprintf (f, "#include \"options.h\"\n");
+     fprintf (f, "#include \"memory.h\"\n");
+     fprintf (f, "#include \"custom.h\"\n");
+     fprintf (f, "#include \"events.h\"\n");
+     fprintf (f, "#include \"newcpu.h\"\n");
+     fprintf (f, "#include \"compiler.h\"\n");
+     fprintf (f, "#include \"comptbl.h\"\n");
+ }
+ 
+ static int postfix;
+ 
+ static void 
+ generate_one_opcode (int rp, int noflags)
+ {
+     int i;
+     uae_u16 smsk, dmsk;
+     long int opcode = opcode_map[rp];
+     int aborted=0;
+     int have_srcreg=0;
+     int have_dstreg=0;
+ 
+     if (table68k[opcode].mnemo == i_ILLG
+ 	|| table68k[opcode].clev > cpu_level)
+ 	return;
+ 
+     for (i = 0; lookuptab[i].name[0]; i++)
+     {
+ 	if (table68k[opcode].mnemo == lookuptab[i].mnemo)
+ 	    break;
+     }
+ 
+     if (table68k[opcode].handler != -1)
+ 	return;
+ 
+     switch (table68k[opcode].stype)
+     {
+     case 0: smsk = 7; break;
+     case 1: smsk = 255; break;
+     case 2: smsk = 15;	break;
+     case 3: smsk = 7; break;
+     case 4: smsk = 7; break;
+     case 5: smsk = 63; break;
+     case 7: smsk = 3; break;
+     default: abort ();
+     }
+     dmsk = 7;
+ 
+     next_cpu_level = -1;
+     if (table68k[opcode].suse
+ 	&& table68k[opcode].smode != imm && table68k[opcode].smode != imm0
+ 	&& table68k[opcode].smode != imm1 && table68k[opcode].smode != imm2
+ 	&& table68k[opcode].smode != absw && table68k[opcode].smode != absl
+ 	&& table68k[opcode].smode != PC8r && table68k[opcode].smode != PC16)
+     {
+ 	have_srcreg=1;
+ 	if (table68k[opcode].spos == -1)
+ 	{
+ 	    if (((int) table68k[opcode].sreg) >= 128)
+ 		comprintf ("\tuae_s32 srcreg = (uae_s32)(uae_s8)%d;\n", (int) table68k[opcode].sreg);
+ 	    else
+ 		comprintf ("\tuae_s32 srcreg = %d;\n", (int) table68k[opcode].sreg);
+ 	}
+ 	else
+ 	{
+ 	    char source[100];
+ 	    int pos = table68k[opcode].spos;
+ 	  
+ 	    if (pos)
+ 		sprintf (source, "((opcode >> %d) & %d)", pos, smsk);
+ 	    else
+ 		sprintf (source, "(opcode & %d)", smsk);
+ 
+ 	    if (table68k[opcode].stype == 3)
+ 		comprintf ("\tuae_s32 srcreg = imm8_table[%s];\n", source);
+ 	    else if (table68k[opcode].stype == 1)
+ 		comprintf ("\tuae_s32 srcreg = (uae_s32)(uae_s8)%s;\n", source);
+ 	    else
+ 		comprintf ("\tuae_s32 srcreg = %s;\n", source);
+ 	}
+     }
+     if (table68k[opcode].duse
+ 	/* Yes, the dmode can be imm, in case of LINK or DBcc */
+ 	&& table68k[opcode].dmode != imm && table68k[opcode].dmode != imm0
+ 	&& table68k[opcode].dmode != imm1 && table68k[opcode].dmode != imm2
+ 	&& table68k[opcode].dmode != absw && table68k[opcode].dmode != absl)
+     {
+ 	have_dstreg=1;
+ 	if (table68k[opcode].dpos == -1)
+ 	{
+ 	    if (((int) table68k[opcode].dreg) >= 128)
+ 		comprintf ("\tuae_s32 dstreg = (uae_s32)(uae_s8)%d;\n", (int) table68k[opcode].dreg);
+ 	    else
+ 		comprintf ("\tuae_s32 dstreg = %d;\n", (int) table68k[opcode].dreg);
+ 	}
+ 	else
+ 	{
+ 	    int pos = table68k[opcode].dpos;
+ 	  
+ 	    if (pos)
+ 		comprintf ("\tuae_u32 dstreg = (opcode >> %d) & %d;\n",
+ 			   pos, dmsk);
+ 	    else
+ 		comprintf ("\tuae_u32 dstreg = opcode & %d;\n", dmsk);
+ 	}
+     }
+ 
+     if (have_srcreg && have_dstreg &&
+ 	(table68k[opcode].dmode==Areg || 
+ 	 table68k[opcode].dmode==Aind || 
+ 	 table68k[opcode].dmode==Aipi || 
+ 	 table68k[opcode].dmode==Apdi || 
+ 	 table68k[opcode].dmode==Ad16 || 
+ 	 table68k[opcode].dmode==Ad8r) &&
+ 	(table68k[opcode].smode==Areg || 
+ 	 table68k[opcode].smode==Aind || 
+ 	 table68k[opcode].smode==Aipi || 
+ 	 table68k[opcode].smode==Apdi || 
+ 	 table68k[opcode].smode==Ad16 || 
+ 	 table68k[opcode].smode==Ad8r) 
+ 	) {
+ 	comprintf("\tuae_u32 dodgy=(srcreg==(uae_s32)dstreg);\n");
+     }
+     else {
+ 	comprintf("\tuae_u32 dodgy=0;\n");
+     }
+     comprintf("\tuae_u32 m68k_pc_offset_thisinst=m68k_pc_offset;\n");
+     comprintf("\tm68k_pc_offset+=2;\n");
+ 
+     aborted=gen_opcode (opcode);
+     {
+ 	int flags=0;
+ 	if (global_isjump) flags|=1;
+ 	if (long_opcode)   flags|=2;
+ 	if (global_cmov)   flags|=4;
+ 	if (global_isaddx) flags|=8;
+ 	if (global_iscjump) flags|=16;
+ 	comprintf ("return 0;\n");
+ 	comprintf ("}\n");
+     
+ 	if (aborted) {
+ 	    fprintf (stblfile, "{ NULL, 0x%08x, %ld }, /* %s */\n", flags, opcode, lookuptab[i].name);
+ 	    com_discard();
+ 	}
+ 	else {
+ 	    if (noflags) {
+ 		fprintf (stblfile, "{ op_%lx_%d_comp_nf, 0x%08x, %ld }, /* %s */\n", opcode, postfix, flags, opcode, lookuptab[i].name);
+ 		fprintf (headerfile, "extern cpuop_func op_%lx_%d_comp_nf;\n", opcode, postfix);
+ 		printf ("unsigned long REGPARAM2 op_%lx_%d_comp_nf(uae_u32 opcode) /* %s */\n{\n", opcode, postfix, lookuptab[i].name);
+ 	    }
+ 	    else {
+ 		fprintf (stblfile, "{ op_%lx_%d_comp_ff, 0x%08x, %ld }, /* %s */\n", opcode, postfix, flags, opcode, lookuptab[i].name);
+ 		fprintf (headerfile, "extern cpuop_func op_%lx_%d_comp_ff;\n", opcode, postfix);
+ 		printf ("unsigned long REGPARAM2 op_%lx_%d_comp_ff(uae_u32 opcode) /* %s */\n{\n", opcode, postfix, lookuptab[i].name);
+ 	    }
+ 	    com_flush();
+ 	}
+     }
+     opcode_next_clev[rp] = next_cpu_level;
+     opcode_last_postfix[rp] = postfix;
+ }
+ 
+ static void 
+ generate_func (int noflags)
+ {
+     int i, j, rp;
+ 
+     using_prefetch = 0;
+     using_exception_3 = 0;
+     for (i = 0; i < 1; i++) /* We only do one level! */
+     {
+ 	cpu_level = 4 - i;
+ 	postfix = i;
+ 
+ 	if (noflags)
+ 	    fprintf (stblfile, "struct cputbl op_smalltbl_%d_comp_nf[] = {\n", postfix);
+ 	else
+ 	    fprintf (stblfile, "struct cputbl op_smalltbl_%d_comp_ff[] = {\n", postfix);
+ 
+ 
+ 	/* sam: this is for people with low memory (eg. me :)) */
+ 	!printf ("\n"
+ 		 "#if !defined(PART_1) && !defined(PART_2) && "
+ 		 "!defined(PART_3) && !defined(PART_4) && "
+ 		 "!defined(PART_5) && !defined(PART_6) && "
+ 		 "!defined(PART_7) && !defined(PART_8)"
+ 		 "\n"
+ 		 "#define PART_1 1\n"
+ 		 "#define PART_2 1\n"
+ 		 "#define PART_3 1\n"
+ 		 "#define PART_4 1\n"
+ 		 "#define PART_5 1\n"
+ 		 "#define PART_6 1\n"
+ 		 "#define PART_7 1\n"
+ 		 "#define PART_8 1\n"
+ 		 "#endif\n\n");
+ 
+ 	rp = 0;
+ 	for (j = 1; j <= 8; ++j)
+ 	{
+ 	    int k = (j * nr_cpuop_funcs) / 8;
+ 	    printf ("#ifdef PART_%d\n", j);
+ 	    for (; rp < k; rp++)
+ 		generate_one_opcode (rp,noflags);
+ 	    printf ("#endif\n\n");
+ 	}
+ 
+ 	fprintf (stblfile, "{ 0, 0,65536 }};\n");
+     }
+ 
+ }
+ 
+ int 
+ main (int argc, char **argv)
+ {
+     read_table68k ();
+     do_merges ();
+ 
+     opcode_map = (int *) xmalloc (sizeof (int) * nr_cpuop_funcs);
+     opcode_last_postfix = (int *) xmalloc (sizeof (int) * nr_cpuop_funcs);
+     opcode_next_clev = (int *) xmalloc (sizeof (int) * nr_cpuop_funcs);
+     counts = (unsigned long *) xmalloc (65536 * sizeof (unsigned long));
+     read_counts ();
+ 
+     /* It would be a lot nicer to put all in one file (we'd also get rid of
+      * cputbl.h that way), but cpuopti can't cope.  That could be fixed, but
+      * I don't dare to touch the 68k version.  */
+ 
+     headerfile = fopen ("comptbl.h", "wb");
+     stblfile = fopen ("compstbl.c", "wb");
+     freopen ("compemu.c", "wb", stdout);
+ 
+     generate_includes (stdout);
+     generate_includes (stblfile);
+ 
+     printf("#include \"compemu.h\"\n");
+ 
+     noflags=0;
+     generate_func (noflags);
+ 
+ 
+     opcode_map = (int *) xmalloc (sizeof (int) * nr_cpuop_funcs);
+     opcode_last_postfix = (int *) xmalloc (sizeof (int) * nr_cpuop_funcs);
+     opcode_next_clev = (int *) xmalloc (sizeof (int) * nr_cpuop_funcs);
+     counts = (unsigned long *) xmalloc (65536 * sizeof (unsigned long));
+     read_counts ();
+     noflags=1;
+     generate_func (noflags);
+ 
+     free (table68k);
+     return 0;
+ }
diff -crB --new-file ./uae-0.8.21/src/gencpu.c ../uae_jit_cleaning/uae-0.8.21/src/gencpu.c
*** ./uae-0.8.21/src/gencpu.c	2001-12-17 20:38:37.000000000 +0200
--- ../uae_jit_cleaning/uae-0.8.21/src/gencpu.c	2021-01-10 13:10:29.902591684 +0200
***************
*** 1454,1460 ****
  	    abort ();
  	}
  	printf ("\tSET_ZFLG (upper == reg || lower == reg);\n");
! 	printf ("\tSET_CFLG (lower <= upper ? reg < lower || reg > upper : reg > upper || reg < lower);\n");
  	printf ("\tif ((extra & 0x800) && GET_CFLG) { Exception(6,oldpc); goto %s; }\n}\n", endlabelstr);
  	need_endlabel = 1;
  	break;
--- 1454,1460 ----
  	    abort ();
  	}
  	printf ("\tSET_ZFLG (upper == reg || lower == reg);\n");
! 	printf ("\tSET_CFLG_ALWAYS (lower <= upper ? reg < lower || reg > upper : reg > upper || reg < lower);\n");
  	printf ("\tif ((extra & 0x800) && GET_CFLG) { Exception(6,oldpc); goto %s; }\n}\n", endlabelstr);
  	need_endlabel = 1;
  	break;
***************
*** 1991,1997 ****
  	    printf ("\ttmp = (bf0 << (offset & 7)) | (bf1 >> (8 - (offset & 7)));\n");
  	}
  	printf ("\ttmp >>= (32 - width);\n");
! 	printf ("\tSET_NFLG (tmp & (1 << (width-1)) ? 1 : 0);\n");
  	printf ("\tSET_ZFLG (tmp == 0); SET_VFLG (0); SET_CFLG (0);\n");
  	switch (curi->mnemo) {
  	case i_BFTST:
--- 1991,1997 ----
  	    printf ("\ttmp = (bf0 << (offset & 7)) | (bf1 >> (8 - (offset & 7)));\n");
  	}
  	printf ("\ttmp >>= (32 - width);\n");
! 	printf ("\tSET_NFLG_ALWAYS (tmp & (1 << (width-1)) ? 1 : 0);\n");
  	printf ("\tSET_ZFLG (tmp == 0); SET_VFLG (0); SET_CFLG (0);\n");
  	switch (curi->mnemo) {
  	case i_BFTST:
***************
*** 2129,2139 ****
--- 2129,2156 ----
  	break;
  
       case i_CINVL:
+ 	printf ("\tif (opcode&0x80)\n"
+ 		"\t\tflush_icache(31);\n"); 
+ 	break;
       case i_CINVP:
+ 	printf ("\tif (opcode&0x80)\n"
+ 		"\t\tflush_icache(32);\n"); 
+ 	break;
       case i_CINVA:
+ 	printf ("\tif (opcode&0x80)\n"
+ 		"\t\tflush_icache(33);\n"); 
+ 	break;
       case i_CPUSHL:
+ 	printf ("\tif (opcode&0x80)\n"
+ 		"\t\tflush_icache(41);\n"); 
+ 	break;
       case i_CPUSHP:
+ 	printf ("\tif (opcode&0x80)\n"
+ 		"\t\tflush_icache(42);\n"); 
+ 	break;
       case i_CPUSHA:
+ 	printf ("\tif (opcode&0x80)\n"
+ 		"\t\tflush_icache(43);\n"); 
  	break;
       case i_MOVE16:
  	 if ((opcode & 0xfff8) == 0xf620) {
***************
*** 2186,2196 ****
--- 2203,2216 ----
      fprintf (f, "#include \"options.h\"\n");
      fprintf (f, "#include \"memory.h\"\n");
      fprintf (f, "#include \"custom.h\"\n");
+     fprintf (f, "#include \"events.h\"\n");
      fprintf (f, "#include \"newcpu.h\"\n");
      fprintf (f, "#include \"compiler.h\"\n");
      fprintf (f, "#include \"cputbl.h\"\n");
      
      fprintf (f, "#define CPUFUNC(x) x##_ff\n"
+ 	     "#define SET_CFLG_ALWAYS(x) SET_CFLG(x)\n"
+ 	     "#define SET_NFLG_ALWAYS(x) SET_NFLG(x)\n"
  	     "#ifdef NOFLAGS\n"
  	     "#include \"noflags.h\"\n"
  	     "#endif\n");
diff -crB --new-file ./uae-0.8.21/src/gtkui.c ../uae_jit_cleaning/uae-0.8.21/src/gtkui.c
*** ./uae-0.8.21/src/gtkui.c	2002-02-16 21:26:25.000000000 +0200
--- ../uae_jit_cleaning/uae-0.8.21/src/gtkui.c	2021-01-10 13:10:29.902591684 +0200
***************
*** 18,23 ****
--- 18,24 ----
  
  #include "config.h"
  #include "options.h"
+ #include "events.h"
  #include "uae.h"
  #include "memory.h"
  #include "custom.h"
***************
*** 27,32 ****
--- 28,34 ----
  #include "threaddep/thread.h"
  #include "sounddep/sound.h"
  #include "savestate.h"
+ #include "compemu.h"
  #include "debug.h"
  
  #include <gtk/gtk.h>
***************
*** 73,78 ****
--- 75,86 ----
  static GtkAdjustment *framerate_adj;
  static GtkWidget *bimm_widget, *b32_widget, *afscr_widget, *pfscr_widget;
  
+ static GtkWidget *compbyte_widget[4], *compword_widget[4], *complong_widget[4];
+ static GtkWidget *compaddr_widget[4], *compnf_widget[2], *comp_midopt_widget[2];
+ static GtkWidget *comp_lowopt_widget[2], *compfpu_widget[2], *comp_hardflush_widget[2];
+ static GtkWidget *comp_constjump_widget[2];
+ static GtkAdjustment *cachesize_adj;
+ 
  static GtkWidget *joy_widget[2][6];
  
  static GtkWidget *led_widgets[5];
***************
*** 230,235 ****
--- 238,262 ----
      gtk_label_set_text (GTK_LABEL (key_text_widget), currprefs.keyfile);
  }
  
+ static void set_comp_state (void)
+ {
+     gtk_toggle_button_set_active (GTK_TOGGLE_BUTTON (compbyte_widget[currprefs.comptrustbyte]), 1);
+     gtk_toggle_button_set_active (GTK_TOGGLE_BUTTON (compword_widget[currprefs.comptrustword]), 1);
+     gtk_toggle_button_set_active (GTK_TOGGLE_BUTTON (complong_widget[currprefs.comptrustlong]), 1);
+     gtk_toggle_button_set_active (GTK_TOGGLE_BUTTON (compaddr_widget[currprefs.comptrustnaddr]), 1);
+     gtk_toggle_button_set_active (GTK_TOGGLE_BUTTON (compnf_widget[currprefs.compnf]), 1);
+     gtk_toggle_button_set_active (GTK_TOGGLE_BUTTON (comp_hardflush_widget[currprefs.comp_hardflush]), 1);
+     gtk_toggle_button_set_active (GTK_TOGGLE_BUTTON (comp_constjump_widget[currprefs.comp_constjump]), 1);
+ 
+     gtk_toggle_button_set_active (GTK_TOGGLE_BUTTON (compfpu_widget[currprefs.compfpu]), 1);
+ #if USE_OPTIMIZER
+     gtk_toggle_button_set_active (GTK_TOGGLE_BUTTON (comp_midopt_widget[currprefs.comp_midopt]), 1);
+ #endif
+ #if USE_LOW_OPTIMIZER
+     gtk_toggle_button_set_active (GTK_TOGGLE_BUTTON (comp_lowopt_widget[currprefs.comp_lowopt]), 1);
+ #endif
+ }
+ 
  static void set_joy_state (void)
  {
      int j0t = changed_prefs.jport0;
***************
*** 337,342 ****
--- 364,370 ----
  	    set_gfx_state ();
  	    set_joy_state ();
  	    set_sound_state ();
+ 	    set_comp_state ();
  	    set_mem_state ();
  	    set_hd_state ();
  	    set_chipset_state ();
***************
*** 500,505 ****
--- 528,552 ----
      changed_prefs.sound_bits = (find_current_toggle (sound_bits_widget, 2) + 1) * 8;
  }
  
+ static void comp_changed (void)
+ {
+   changed_prefs.cachesize=cachesize_adj->value;
+   changed_prefs.comptrustbyte = find_current_toggle (compbyte_widget, 4);
+   changed_prefs.comptrustword = find_current_toggle (compword_widget, 4);
+   changed_prefs.comptrustlong = find_current_toggle (complong_widget, 4);
+   changed_prefs.comptrustnaddr = find_current_toggle (compaddr_widget, 4);
+   changed_prefs.compnf = find_current_toggle (compnf_widget, 2);
+   changed_prefs.comp_hardflush = find_current_toggle (comp_hardflush_widget, 2);
+   changed_prefs.comp_constjump = find_current_toggle (comp_constjump_widget, 2);
+   changed_prefs.compfpu= find_current_toggle (compfpu_widget, 2);
+ #if USE_OPTIMIZER
+   changed_prefs.comp_midopt = find_current_toggle (comp_midopt_widget, 2);
+ #endif
+ #if USE_LOW_OPTIMIZER
+   changed_prefs.comp_lowopt = find_current_toggle (comp_lowopt_widget, 2);
+ #endif
+ }
+ 
  static void did_reset (void)
  {
      if (quit_gui)
***************
*** 1271,1276 ****
--- 1318,1418 ----
      gtk_box_pack_start (GTK_BOX (hbox), frame, FALSE, TRUE, 0);
  }
  
+ static void make_comp_widgets (GtkWidget *vbox)
+ {
+     GtkWidget *frame, *newbox;
+     int i;
+     GtkWidget *hbox;
+     static const char *complabels1[] = {
+ 	"Direct", "Indirect", "Indirect for KS", "Direct after Picasso",
+ 	NULL
+     },*complabels2[] = {
+ 	"Direct", "Indirect", "Indirect for KS", "Direct after Picasso", 
+ 	NULL
+     },*complabels3[] = {
+ 	"Direct", "Indirect", "Indirect for KS", "Direct after Picasso", 
+ 	NULL
+     },*complabels3a[] = {
+ 	"Direct", "Indirect", "Indirect for KS", "Direct after Picasso", 
+ 	NULL
+     }, *complabels4[] = {
+       "Always generate", "Only generate when needed",
+ 	NULL
+     }, *complabels5[] = {
+       "Disable", "Enable",
+ 	NULL
+     }, *complabels6[] = {
+       "Disable", "Enable",
+ 	NULL
+     }, *complabels7[] = {
+       "Disable", "Enable",
+ 	NULL
+     }, *complabels8[] = {
+       "Soft", "Hard",
+ 	NULL
+     }, *complabels9[] = {
+       "Disable", "Enable", 
+ 	NULL
+     };
+     GtkWidget *thing;
+ 
+     add_empty_vbox (vbox);
+ 
+     newbox = make_radio_group_box ("Byte access", complabels1, compbyte_widget, 1, comp_changed);
+     gtk_widget_show (newbox);
+     add_centered_to_vbox (vbox, newbox);
+     newbox = make_radio_group_box ("Word access", complabels2, compword_widget, 1, comp_changed);
+     gtk_widget_show (newbox);
+     add_centered_to_vbox (vbox, newbox);
+     newbox = make_radio_group_box ("Long access", complabels3, complong_widget, 1, comp_changed);
+     gtk_widget_show (newbox);
+     add_centered_to_vbox (vbox, newbox);
+     newbox = make_radio_group_box ("Address lookup", complabels3a, compaddr_widget, 1, comp_changed);
+     gtk_widget_show (newbox);
+     add_centered_to_vbox (vbox, newbox);
+ 
+     newbox = make_radio_group_box ("Flags", complabels4, compnf_widget, 1, comp_changed);
+     gtk_widget_show (newbox);
+     add_centered_to_vbox (vbox, newbox);
+ 
+     newbox = make_radio_group_box ("Icache flushes", complabels8, comp_hardflush_widget, 1, comp_changed);
+     gtk_widget_show (newbox);
+     add_centered_to_vbox (vbox, newbox);
+ 
+     newbox = make_radio_group_box ("Compile through uncond branch", complabels9, comp_constjump_widget, 1, comp_changed);
+     gtk_widget_show (newbox);
+     add_centered_to_vbox (vbox, newbox);
+ 
+     newbox = make_radio_group_box ("JIT FPU compiler", complabels7, compfpu_widget, 1, comp_changed);
+     gtk_widget_show (newbox);
+     add_centered_to_vbox (vbox, newbox);
+ 
+ #if USE_OPTIMIZER
+     newbox = make_radio_group_box ("Mid Level Optimizer", complabels5, comp_midopt_widget, 1, comp_changed);
+     gtk_widget_show (newbox);
+     add_centered_to_vbox (vbox, newbox);
+ #endif
+ 
+ #if USE_LOW_OPTIMIZER
+     newbox = make_radio_group_box ("Low Level Optimizer", complabels6, comp_lowopt_widget, 1, comp_changed);
+     gtk_widget_show (newbox);
+     add_centered_to_vbox (vbox, newbox);
+ #endif
+ 
+     cachesize_adj = GTK_ADJUSTMENT (gtk_adjustment_new (currprefs.cachesize, 0.0, 16384.0, 1.0, 1.0, 1.0));
+     gtk_signal_connect (GTK_OBJECT (cachesize_adj), "value_changed",
+ 			GTK_SIGNAL_FUNC (comp_changed), NULL);
+ 
+     thing = gtk_hscale_new (cachesize_adj);
+     gtk_range_set_update_policy (GTK_RANGE (thing), GTK_UPDATE_DELAYED);
+     gtk_scale_set_digits (GTK_SCALE (thing), 0);
+     gtk_scale_set_value_pos (GTK_SCALE (thing), GTK_POS_RIGHT);
+     add_labelled_widget_centered ("Translation buffer(kB):", thing, vbox);
+ 
+     add_empty_vbox (vbox);
+ }
+ 
+ 
  static void make_joy_widgets (GtkWidget *dvbox)
  {
      int i;
***************
*** 1535,1540 ****
--- 1677,1683 ----
  	{ "Graphics", make_gfx_widgets },
  	{ "Chipset", make_chipset_widgets },
  	{ "Sound", make_sound_widgets },
+  	{ "JIT", make_comp_widgets },
  	{ "Game ports", make_joy_widgets },
  	{ "Harddisks", make_hd_widgets },
  	{ "About", make_about_widgets }
diff -crB --new-file ./uae-0.8.21/src/hardfile.c ../uae_jit_cleaning/uae-0.8.21/src/hardfile.c
*** ./uae-0.8.21/src/hardfile.c	2000-08-26 00:29:41.000000000 +0300
--- ../uae_jit_cleaning/uae-0.8.21/src/hardfile.c	2021-01-10 13:10:29.902591684 +0200
***************
*** 13,18 ****
--- 13,19 ----
  #include "options.h"
  #include "memory.h"
  #include "custom.h"
+ #include "events.h"
  #include "newcpu.h"
  #include "disk.h"
  #include "autoconf.h"
diff -crB --new-file ./uae-0.8.21/src/include/autoconf.h ../uae_jit_cleaning/uae-0.8.21/src/include/autoconf.h
*** ./uae-0.8.21/src/include/autoconf.h	2001-12-30 17:15:57.000000000 +0200
--- ../uae_jit_cleaning/uae-0.8.21/src/include/autoconf.h	2021-01-10 13:10:29.914591684 +0200
***************
*** 77,82 ****
--- 77,84 ----
  extern void expansion_init (void);
  extern void expansion_cleanup (void);
  
+ extern uae_u8* rtarea;
+ 
  #define TRAPFLAG_NO_REGSAVE 1
  #define TRAPFLAG_NO_RETVAL 2
  #define TRAPFLAG_EXTRA_STACK 4
diff -crB --new-file ./uae-0.8.21/src/include/compemu.h ../uae_jit_cleaning/uae-0.8.21/src/include/compemu.h
*** ./uae-0.8.21/src/include/compemu.h	1970-01-01 02:00:00.000000000 +0200
--- ../uae_jit_cleaning/uae-0.8.21/src/include/compemu.h	2021-01-10 13:10:29.914591684 +0200
***************
*** 0 ****
--- 1,530 ----
+ #define USE_OPTIMIZER 0
+ #define USE_LOW_OPTIMIZER 0
+ #define USE_ALIAS 1
+ #define USE_F_ALIAS 1
+ #define USE_SOFT_FLUSH 1
+ #define USE_OFFSET 1
+ #define COMP_DEBUG 1
+ 
+ #if COMP_DEBUG
+ #define Dif(x) if (x)
+ #else
+ #define Dif(x) if (0)
+ #endif
+ 
+ #define SCALE 2
+ #define MAXCYCLES (1000 * CYCLE_UNIT)
+ #define MAXREGOPT 65536
+ 
+ #define BYTES_PER_INST 10240  /* paranoid ;-) */
+ #define LONGEST_68K_INST 16 /* The number of bytes the longest possible
+ 			       68k instruction takes */
+ #define MAX_CHECKSUM_LEN 2048 /* The maximum size we calculate checksums
+ 				 for. Anything larger will be flushed
+ 				 unconditionally even with SOFT_FLUSH */
+ #define MAX_HOLD_BI 3  /* One for the current block, and up to two
+ 			  for jump targets */
+ 
+ #define INDIVIDUAL_INST 0
+ #define FLAG_C    0x0010
+ #define FLAG_V    0x0008
+ #define FLAG_Z    0x0004
+ #define FLAG_N    0x0002
+ #define FLAG_X    0x0001
+ #define FLAG_CZNV (FLAG_C | FLAG_Z | FLAG_N | FLAG_V)
+ #define FLAG_ZNV  (FLAG_Z | FLAG_N | FLAG_V)
+ 
+ #define KILLTHERAT 1  /* Set to 1 to avoid some partial_rat_stalls */
+ 
+ /* Whether to preserve registers across calls to JIT compiled routines */
+ #if defined X86_ASSEMBLY
+ #define USE_PUSH_POP 0
+ #else
+ #define USE_PUSH_POP 1
+ #endif
+ 
+ #define N_REGS 8  /* really only 7, but they are numbered 0,1,2,3,5,6,7 */
+ #define N_FREGS 6 /* That leaves us two positions on the stack to play with */
+ 
+ /* Functions exposed to newcpu, or to what was moved from newcpu.c to
+  * compemu_support.c */
+ extern void init_comp(void);
+ extern void flush(int save_regs);
+ extern void small_flush(int save_regs);
+ extern void set_target(uae_u8* t);
+ extern uae_u8* get_target(void);
+ extern void freescratch(void);
+ extern void build_comp(void);
+ extern void set_cache_state(int enabled);
+ extern int get_cache_state(void);
+ extern uae_u32 get_jitted_size(void);
+ #ifdef JIT
+ extern void flush_icache(int n);
+ #endif
+ extern void alloc_cache(void);
+ extern void compile_block(cpu_history* pc_hist, int blocklen, int totcyles);
+ extern void lopt_emit_all(void);
+ extern int check_for_cache_miss(void);
+ 
+ 
+ #define scaled_cycles(x) (currprefs.m68k_speed==-1?(((x)/SCALE)?(((x)/SCALE<MAXCYCLES?((x)/SCALE):MAXCYCLES)):1):(x))
+ 
+ 
+ extern uae_u32 needed_flags;
+ extern cacheline cache_tags[];
+ extern uae_u8* comp_pc_p;
+ extern void* pushall_call_handler;
+ 
+ #define VREGS 32
+ #define VFREGS 16
+ 
+ #define INMEM 1
+ #define CLEAN 2
+ #define DIRTY 3
+ #define UNDEF 4
+ #define ISCONST 5
+ 
+ typedef struct {
+   uae_u32* mem;
+   uae_u32 val;
+   uae_u8 is_swapped;
+   uae_u8 status;
+   uae_u8 realreg;
+   uae_u8 realind; /* The index in the holds[] array */
+   uae_u8 needflush;
+   uae_u8 validsize;
+   uae_u8 dirtysize;
+   uae_u8 dummy;
+ } reg_status;
+ 
+ typedef struct {
+   uae_u32* mem;
+   double val;
+   uae_u8 status;
+   uae_u8 realreg;
+   uae_u8 realind;  
+   uae_u8 needflush;
+ } freg_status;
+ 
+ typedef struct {
+     uae_u8 use_flags;
+     uae_u8 set_flags;
+     uae_u8 is_jump;
+     uae_u8 is_addx;
+     uae_u8 is_const_jump;
+ } op_properties;
+ extern op_properties prop[65536];
+ 
+ static __inline__ int end_block(uae_u16 opcode)
+ {
+     return prop[opcode].is_jump ||
+ 	(prop[opcode].is_const_jump && !currprefs.comp_constjump);
+ }
+ 
+ #define PC_P 16
+ #define FLAGX 17
+ #define FLAGTMP 18
+ #define NEXT_HANDLER 19
+ #define S1 20
+ #define S2 21
+ #define S3 22
+ #define S4 23
+ #define S5 24
+ #define S6 25
+ #define S7 26
+ #define S8 27
+ #define S9 28
+ #define S10 29
+ #define S11 30
+ #define S12 31
+ 
+ #define FP_RESULT 8
+ #define FS1 9
+ #define FS2 10
+ #define FS3 11
+ 
+ typedef struct {
+   uae_u32 touched;
+   uae_s8 holds[VREGS];
+   uae_u8 nholds;
+   uae_u8 canbyte;
+   uae_u8 canword;
+   uae_u8 locked;
+ } n_status;
+ 
+ typedef struct {
+     uae_s8 holds;
+     uae_u8 validsize;
+     uae_u8 dirtysize;
+ } n_smallstatus;
+ 
+ typedef struct {
+   uae_u32 touched;
+   uae_s8 holds[VFREGS];
+   uae_u8 nholds;
+   uae_u8 locked;
+ } fn_status;
+ 
+ /* For flag handling */
+ #define NADA 1
+ #define TRASH 2
+ #define VALID 3
+ 
+ /* needflush values */
+ #define NF_SCRATCH   0
+ #define NF_TOMEM     1
+ #define NF_HANDLER   2
+ 
+ typedef struct {
+     /* Integer part */
+     reg_status state[VREGS];
+     n_status   nat[N_REGS];
+     uae_u32 flags_on_stack;
+     uae_u32 flags_in_flags;
+     uae_u32 flags_are_important;
+     /* FPU part */
+     freg_status fate[VFREGS];
+     fn_status   fat[N_FREGS];
+ 
+     /* x86 FPU part */
+     uae_s8 spos[N_FREGS];
+     uae_s8 onstack[6];
+     uae_s8 tos;
+ } bigstate;
+ 
+ typedef struct {
+     /* Integer part */
+     n_smallstatus  nat[N_REGS];
+ } smallstate;
+ 
+ extern bigstate live;
+ extern int touchcnt;
+ 
+ 
+ #define IMM uae_u32
+ #define R1  uae_u32
+ #define R2  uae_u32
+ #define R4  uae_u32
+ #define W1  uae_u32
+ #define W2  uae_u32
+ #define W4  uae_u32
+ #define RW1 uae_u32
+ #define RW2 uae_u32
+ #define RW4 uae_u32
+ #define MEMR uae_u32
+ #define MEMW uae_u32
+ #define MEMRW uae_u32
+ 
+ #define FW   uae_u32
+ #define FR   uae_u32
+ #define FRW  uae_u32
+ 
+ #define MIDFUNC(nargs,func,args) void func args
+ #define MENDFUNC(nargs,func,args) 
+ #define COMPCALL(func) func
+ 
+ #define LOWFUNC(flags,mem,nargs,func,args) static __inline__ void func args
+ #define LENDFUNC(flags,mem,nargs,func,args) 
+ 
+ #if USE_OPTIMIZER
+ #define REGALLOC_O 2
+ #define PEEPHOLE_O 3 /* Has to be >= REGALLOC */
+ #define DECLARE(func) extern void func; extern void do_##func
+ #else
+ #define REGALLOC_O 2000000
+ #define PEEPHOLE_O 2000000
+ #define DECLARE(func) extern void func
+ #endif
+ 
+ 
+ /* What we expose to the outside */
+ DECLARE(bt_l_ri(R4 r, IMM i));
+ DECLARE(bt_l_rr(R4 r, R4 b));
+ DECLARE(btc_l_ri(RW4 r, IMM i));
+ DECLARE(btc_l_rr(RW4 r, R4 b));
+ DECLARE(bts_l_ri(RW4 r, IMM i));
+ DECLARE(bts_l_rr(RW4 r, R4 b));
+ DECLARE(btr_l_ri(RW4 r, IMM i));
+ DECLARE(btr_l_rr(RW4 r, R4 b));
+ DECLARE(mov_l_rm(W4 d, IMM s));
+ DECLARE(call_r(R4 r));
+ DECLARE(sub_l_mi(IMM d, IMM s));
+ DECLARE(mov_l_mi(IMM d, IMM s));
+ DECLARE(mov_w_mi(IMM d, IMM s));
+ DECLARE(mov_b_mi(IMM d, IMM s));
+ DECLARE(rol_b_ri(RW1 r, IMM i));
+ DECLARE(rol_w_ri(RW2 r, IMM i));
+ DECLARE(rol_l_ri(RW4 r, IMM i));
+ DECLARE(rol_l_rr(RW4 d, R1 r));
+ DECLARE(rol_w_rr(RW2 d, R1 r));
+ DECLARE(rol_b_rr(RW1 d, R1 r));
+ DECLARE(shll_l_rr(RW4 d, R1 r));
+ DECLARE(shll_w_rr(RW2 d, R1 r));
+ DECLARE(shll_b_rr(RW1 d, R1 r));
+ DECLARE(ror_b_ri(R1 r, IMM i));
+ DECLARE(ror_w_ri(R2 r, IMM i));
+ DECLARE(ror_l_ri(R4 r, IMM i));
+ DECLARE(ror_l_rr(R4 d, R1 r));
+ DECLARE(ror_w_rr(R2 d, R1 r));
+ DECLARE(ror_b_rr(R1 d, R1 r));
+ DECLARE(shrl_l_rr(RW4 d, R1 r));
+ DECLARE(shrl_w_rr(RW2 d, R1 r));
+ DECLARE(shrl_b_rr(RW1 d, R1 r));
+ DECLARE(shra_l_rr(RW4 d, R1 r));
+ DECLARE(shra_w_rr(RW2 d, R1 r));
+ DECLARE(shra_b_rr(RW1 d, R1 r));
+ DECLARE(shll_l_ri(RW4 r, IMM i));
+ DECLARE(shll_w_ri(RW2 r, IMM i));
+ DECLARE(shll_b_ri(RW1 r, IMM i));
+ DECLARE(shrl_l_ri(RW4 r, IMM i));
+ DECLARE(shrl_w_ri(RW2 r, IMM i));
+ DECLARE(shrl_b_ri(RW1 r, IMM i));
+ DECLARE(shra_l_ri(RW4 r, IMM i));
+ DECLARE(shra_w_ri(RW2 r, IMM i));
+ DECLARE(shra_b_ri(RW1 r, IMM i));
+ DECLARE(setcc(W1 d, IMM cc));
+ DECLARE(setcc_m(IMM d, IMM cc));
+ DECLARE(cmov_l_rr(RW4 d, R4 s, IMM cc));
+ DECLARE(cmov_l_rm(RW4 d, IMM s, IMM cc));
+ DECLARE(bsf_l_rr(W4 d, R4 s));
+ DECLARE(pop_m(IMM d));
+ DECLARE(push_m(IMM d));
+ DECLARE(pop_l(W4 d));
+ DECLARE(push_l_i(IMM i));
+ DECLARE(push_l(R4 s));
+ DECLARE(clear_16(RW4 r));
+ DECLARE(clear_8(RW4 r));
+ DECLARE(sign_extend_16_rr(W4 d, R2 s));
+ DECLARE(sign_extend_8_rr(W4 d, R1 s));
+ DECLARE(zero_extend_16_rr(W4 d, R2 s));
+ DECLARE(zero_extend_8_rr(W4 d, R1 s));
+ DECLARE(imul_64_32(RW4 d, RW4 s));
+ DECLARE(mul_64_32(RW4 d, RW4 s));
+ DECLARE(imul_32_32(RW4 d, R4 s));
+ DECLARE(mul_32_32(RW4 d, R4 s));
+ DECLARE(mov_b_rr(W1 d, R1 s));
+ DECLARE(mov_w_rr(W2 d, R2 s));
+ DECLARE(mov_l_rrm_indexed(W4 d,R4 baser, R4 index, IMM factor));
+ DECLARE(mov_w_rrm_indexed(W2 d, R4 baser, R4 index, IMM factor));
+ DECLARE(mov_b_rrm_indexed(W1 d, R4 baser, R4 index, IMM factor));
+ DECLARE(mov_l_mrr_indexed(R4 baser, R4 index, IMM factor, R4 s));
+ DECLARE(mov_w_mrr_indexed(R4 baser, R4 index, IMM factor, R2 s));
+ DECLARE(mov_b_mrr_indexed(R4 baser, R4 index, IMM factor, R1 s));
+ DECLARE(mov_l_bmrr_indexed(IMM base, R4 baser, R4 index, IMM factor, R4 s));
+ DECLARE(mov_w_bmrr_indexed(IMM base, R4 baser, R4 index, IMM factor, R2 s));
+ DECLARE(mov_b_bmrr_indexed(IMM base, R4 baser, R4 index, IMM factor, R1 s));
+ DECLARE(mov_l_brrm_indexed(W4 d, IMM base, R4 baser, R4 index, IMM factor));
+ DECLARE(mov_w_brrm_indexed(W2 d, IMM base, R4 baser, R4 index, IMM factor));
+ DECLARE(mov_b_brrm_indexed(W1 d, IMM base, R4 baser, R4 index, IMM factor));
+ DECLARE(mov_l_rm_indexed(W4 d, IMM base, R4 index, IMM factor));
+ DECLARE(mov_l_rR(W4 d, R4 s, IMM offset));
+ DECLARE(mov_w_rR(W2 d, R4 s, IMM offset));
+ DECLARE(mov_b_rR(W1 d, R4 s, IMM offset));
+ DECLARE(mov_l_rR_gs(W4 d, R4 s, IMM offset));
+ DECLARE(mov_w_rR_gs(W2 d, R4 s, IMM offset));
+ DECLARE(mov_b_rR_gs(W1 d, R4 s, IMM offset));
+ DECLARE(mov_l_brR(W4 d, R4 s, IMM offset));
+ DECLARE(mov_w_brR(W2 d, R4 s, IMM offset));
+ DECLARE(mov_b_brR(W1 d, R4 s, IMM offset));
+ DECLARE(mov_l_Rr_gs(R4 d, R4 s, IMM offset));
+ DECLARE(mov_w_Rr_gs(R4 d, R2 s, IMM offset));
+ DECLARE(mov_b_Rr_gs(R4 d, R1 s, IMM offset));
+ DECLARE(mov_l_Rr(R4 d, R4 s, IMM offset));
+ DECLARE(mov_w_Rr(R4 d, R2 s, IMM offset));
+ DECLARE(mov_b_Rr(R4 d, R1 s, IMM offset));
+ DECLARE(lea_l_brr(W4 d, R4 s, IMM offset));
+ DECLARE(lea_l_brr_indexed(W4 d, R4 s, R4 index, IMM factor, IMM offset));
+ DECLARE(lea_l_rr_indexed(W4 d, R4 s, R4 index, IMM factor));
+ DECLARE(mov_l_bRr(R4 d, R4 s, IMM offset));
+ DECLARE(mov_w_bRr(R4 d, R2 s, IMM offset));
+ DECLARE(mov_b_bRr(R4 d, R1 s, IMM offset));
+ DECLARE(bswap_32(RW4 r));
+ DECLARE(bswap_16(RW2 r));
+ DECLARE(mov_l_rr(W4 d, R4 s));
+ DECLARE(mov_l_mr(IMM d, R4 s));
+ DECLARE(mov_w_mr(IMM d, R2 s));
+ DECLARE(mov_w_rm(W2 d, IMM s));
+ DECLARE(mov_b_mr(IMM d, R1 s));
+ DECLARE(mov_b_rm(W1 d, IMM s));
+ DECLARE(mov_l_ri(W4 d, IMM s));
+ DECLARE(mov_w_ri(W2 d, IMM s));
+ DECLARE(mov_b_ri(W1 d, IMM s));
+ DECLARE(add_l_mi(IMM d, IMM s) );
+ DECLARE(add_w_mi(IMM d, IMM s) );
+ DECLARE(add_b_mi(IMM d, IMM s) );
+ DECLARE(test_l_ri(R4 d, IMM i));
+ DECLARE(test_l_rr(R4 d, R4 s));
+ DECLARE(test_w_rr(R2 d, R2 s));
+ DECLARE(test_b_rr(R1 d, R1 s));
+ DECLARE(and_l_ri(RW4 d, IMM i));
+ DECLARE(and_l(RW4 d, R4 s));
+ DECLARE(and_w(RW2 d, R2 s));
+ DECLARE(and_b(RW1 d, R1 s));
+ DECLARE(or_l_ri(RW4 d, IMM i));
+ DECLARE(or_l(RW4 d, R4 s));
+ DECLARE(or_w(RW2 d, R2 s));
+ DECLARE(or_b(RW1 d, R1 s));
+ DECLARE(adc_l(RW4 d, R4 s));
+ DECLARE(adc_w(RW2 d, R2 s));
+ DECLARE(adc_b(RW1 d, R1 s));
+ DECLARE(add_l(RW4 d, R4 s));
+ DECLARE(add_w(RW2 d, R2 s));
+ DECLARE(add_b(RW1 d, R1 s));
+ DECLARE(sub_l_ri(RW4 d, IMM i));
+ DECLARE(sub_w_ri(RW2 d, IMM i));
+ DECLARE(sub_b_ri(RW1 d, IMM i));
+ DECLARE(add_l_ri(RW4 d, IMM i));
+ DECLARE(add_w_ri(RW2 d, IMM i));
+ DECLARE(add_b_ri(RW1 d, IMM i));
+ DECLARE(sbb_l(RW4 d, R4 s));
+ DECLARE(sbb_w(RW2 d, R2 s));
+ DECLARE(sbb_b(RW1 d, R1 s));
+ DECLARE(sub_l(RW4 d, R4 s));
+ DECLARE(sub_w(RW2 d, R2 s));
+ DECLARE(sub_b(RW1 d, R1 s));
+ DECLARE(cmp_l(R4 d, R4 s));
+ DECLARE(cmp_l_ri(R4 r, IMM i));
+ DECLARE(cmp_w(R2 d, R2 s));
+ DECLARE(cmp_b(R1 d, R1 s));
+ DECLARE(xor_l(RW4 d, R4 s));
+ DECLARE(xor_w(RW2 d, R2 s));
+ DECLARE(xor_b(RW1 d, R1 s));
+ DECLARE(live_flags(void));
+ DECLARE(dont_care_flags(void));
+ DECLARE(duplicate_carry(void));
+ DECLARE(restore_carry(void));
+ DECLARE(start_needflags(void));
+ DECLARE(end_needflags(void));
+ DECLARE(make_flags_live(void));
+ DECLARE(call_r_11(R4 r, W4 out1, R4 in1, IMM osize, IMM isize));
+ DECLARE(call_r_02(R4 r, R4 in1, R4 in2, IMM isize1, IMM isize2));
+ DECLARE(readmem_new(R4 address, W4 dest, IMM offset, IMM size, W4 tmp));
+ DECLARE(writemem_new(R4 address, R4 source, IMM offset, IMM size, W4 tmp));
+ DECLARE(forget_about(W4 r));
+ DECLARE(nop(void));
+ 
+ DECLARE(f_forget_about(FW r));
+ DECLARE(fmov_pi(FW r));
+ DECLARE(fmov_log10_2(FW r));
+ DECLARE(fmov_log2_e(FW r));
+ DECLARE(fmov_loge_2(FW r));
+ DECLARE(fmov_1(FW r));
+ DECLARE(fmov_0(FW r));
+ DECLARE(fmov_rm(FW r, MEMR m));
+ DECLARE(fmovi_rm(FW r, MEMR m));
+ DECLARE(fmovi_mr(MEMW m, FR r));
+ DECLARE(fmovs_rm(FW r, MEMR m));
+ DECLARE(fmovs_mr(MEMW m, FR r));
+ DECLARE(fmov_mr(MEMW m, FR r));
+ DECLARE(fmov_ext_mr(MEMW m, FR r));
+ DECLARE(fmov_ext_rm(FW r, MEMR m));
+ DECLARE(fmov_rr(FW d, FR s));
+ DECLARE(fldcw_m_indexed(R4 index, IMM base));
+ DECLARE(ftst_r(FR r));
+ DECLARE(dont_care_fflags(void));
+ DECLARE(fsqrt_rr(FW d, FR s));
+ DECLARE(fabs_rr(FW d, FR s));
+ DECLARE(frndint_rr(FW d, FR s));
+ DECLARE(fsin_rr(FW d, FR s));
+ DECLARE(fcos_rr(FW d, FR s));
+ DECLARE(ftwotox_rr(FW d, FR s));
+ DECLARE(fetox_rr(FW d, FR s));
+ DECLARE(flog2_rr(FW d, FR s));
+ DECLARE(fneg_rr(FW d, FR s));
+ DECLARE(fadd_rr(FRW d, FR s));
+ DECLARE(fsub_rr(FRW d, FR s));
+ DECLARE(fmul_rr(FRW d, FR s));
+ DECLARE(frem_rr(FRW d, FR s));
+ DECLARE(frem1_rr(FRW d, FR s));
+ DECLARE(fdiv_rr(FRW d, FR s));
+ DECLARE(fcmp_rr(FR d, FR s));
+ DECLARE(fflags_into_flags(W2 tmp));
+ 
+ extern int failure;
+ #define FAIL(x) do { failure|=x; } while (0)
+ 
+ /* Convenience functions exposed to gencomp */
+ extern uae_u32 m68k_pc_offset;
+ extern void readbyte(int address, int dest, int tmp);
+ extern void readword(int address, int dest, int tmp);
+ extern void readlong(int address, int dest, int tmp);
+ extern void writebyte(int address, int source, int tmp);
+ extern void writeword(int address, int source, int tmp);
+ extern void writelong(int address, int source, int tmp);
+ extern void writeword_clobber(int address, int source, int tmp);
+ extern void writelong_clobber(int address, int source, int tmp);
+ extern void get_n_addr(int address, int dest, int tmp);
+ extern void get_n_addr_jmp(int address, int dest, int tmp);
+ extern void calc_disp_ea_020(int base, uae_u32 dp, int target, int tmp);
+ extern int kill_rodent(int r);
+ extern void sync_m68k_pc(void);
+ extern uae_u32 get_const(int r);
+ extern int  is_const(int r);
+ extern void register_branch(uae_u32 not_taken, uae_u32 taken, uae_u8 cond);
+ extern void empty_optimizer(void);
+ 
+ #define comp_get_ibyte(o) do_get_mem_byte((uae_u8 *)(comp_pc_p + (o) + 1))
+ #define comp_get_iword(o) do_get_mem_word((uae_u16 *)(comp_pc_p + (o)))
+ #define comp_get_ilong(o) do_get_mem_long((uae_u32 *)(comp_pc_p + (o)))
+ 
+ /* Preferences handling */
+ void check_prefs_changed_comp (void);
+ 
+ struct blockinfo_t;
+ 
+ typedef struct dep_t {
+   uae_u32*            jmp_off;
+   struct blockinfo_t* target;
+   struct dep_t**      prev_p;
+   struct dep_t*       next;
+ } dependency;
+ 
+ typedef struct blockinfo_t {
+     uae_s32 count;
+     cpuop_func* direct_handler_to_use;
+     cpuop_func* handler_to_use;
+     /* The direct handler does not check for the correct address */
+ 
+     cpuop_func* handler; 
+     cpuop_func* direct_handler;
+ 
+     cpuop_func* direct_pen;
+     cpuop_func* direct_pcc;
+ 
+     uae_u8* nexthandler;
+     uae_u8* pc_p;
+     
+     uae_u32 c1;     
+     uae_u32 c2;
+     uae_u32 len;
+ 
+     struct blockinfo_t* next_same_cl;
+     struct blockinfo_t** prev_same_cl_p;  
+     struct blockinfo_t* next;
+     struct blockinfo_t** prev_p; 
+ 
+     uae_u32 min_pcp; 
+     uae_u8 optlevel;  
+     uae_u8 needed_flags;  
+     uae_u8 status;  
+     uae_u8 havestate;
+     
+     dependency  dep[2];  /* Holds things we depend on */
+     dependency* deplist; /* List of things that depend on this */
+     smallstate  env;
+ } blockinfo;
+ 
+ #define BI_NEW 0
+ #define BI_COUNTING 1
+ #define BI_TARGETTED 2
+ 
+ typedef struct {
+     uae_u8 type;
+     uae_u8 reg;
+     uae_u32 next;
+ } regacc;
+ 
+ void execute_normal(void);
+ void exec_nostats(void);
+ void do_nothing(void);
+ 
diff -crB --new-file ./uae-0.8.21/src/include/custom.h ../uae_jit_cleaning/uae-0.8.21/src/include/custom.h
*** ./uae-0.8.21/src/include/custom.h	2001-10-24 13:59:20.000000000 +0300
--- ../uae_jit_cleaning/uae-0.8.21/src/include/custom.h	2021-01-10 13:10:29.914591684 +0200
***************
*** 61,66 ****
--- 61,67 ----
  #define SPCFLAG_BLTNASTY 512
  #define SPCFLAG_EXEC 1024
  #define SPCFLAG_MODE_CHANGE 8192
+ #define SPCFLAG_END_COMPILE 16384
  
  extern uae_u16 adkcon;
  
diff -crB --new-file ./uae-0.8.21/src/include/events.h ../uae_jit_cleaning/uae-0.8.21/src/include/events.h
*** ./uae-0.8.21/src/include/events.h	2001-07-29 12:47:03.000000000 +0300
--- ../uae_jit_cleaning/uae-0.8.21/src/include/events.h	2021-01-10 13:10:29.914591684 +0200
***************
*** 1,3 ****
--- 1,5 ----
+ #ifndef EVENTS_H
+ #define EVENTS_H
   /*
    * UAE - The Un*x Amiga Emulator
    *
***************
*** 11,22 ****
  
  #include "machdep/rpt.h"
  
! extern frame_time_t vsynctime, vsyncmintime;
  extern void reset_frame_rate_hack (void);
  extern int rpt_available;
  
- extern unsigned long currcycle, nextevent, is_lastline;
- extern unsigned long sample_evtime;
  typedef void (*evfunc)(void);
  
  struct ev
--- 13,25 ----
  
  #include "machdep/rpt.h"
  
! extern unsigned long currcycle, nextevent, is_lastline;
! extern unsigned long sample_evtime;
! 
! extern volatile frame_time_t vsynctime, vsyncmintime;
  extern void reset_frame_rate_hack (void);
  extern int rpt_available;
  
  typedef void (*evfunc)(void);
  
  struct ev
***************
*** 33,44 ****
  
  extern struct ev eventtab[ev_max];
  
  STATIC_INLINE void events_schedule (void)
  {
      int i;
  
      unsigned long int mintime = ~0L;
!     for (i = 0; i < ev_max; i++) {
  	if (eventtab[i].active) {
  	    unsigned long int eventtime = eventtab[i].evtime - currcycle;
  	    if (eventtime < mintime)
--- 36,54 ----
  
  extern struct ev eventtab[ev_max];
  
+ extern void init_eventtab (void);
+ 
+ #if 1
+ 
+ /* Let's see whether hiding this away somewhere where the compiler can't
+    see it will cure it of its silly urge to mis-optimize the comparison */ extern long int diff32(frame_time_t x, frame_time_t y);
+ 
  STATIC_INLINE void events_schedule (void)
  {
      int i;
  
      unsigned long int mintime = ~0L;
!     for(i = 0; i < ev_max; i++) {
  	if (eventtab[i].active) {
  	    unsigned long int eventtime = eventtab[i].evtime - currcycle;
  	    if (eventtime < mintime)
***************
*** 48,59 ****
      nextevent = currcycle + mintime;
  }
  
! STATIC_INLINE void do_cycles_slow (unsigned long cycles_to_add)
  {
!     if (is_lastline && eventtab[ev_hsync].evtime - currcycle <= cycles_to_add
! 	&& (long int)(read_processor_time () - vsyncmintime) < 0)
  	return;
  
      while ((nextevent - currcycle) <= cycles_to_add) {
          int i;
          cycles_to_add -= (nextevent - currcycle);
--- 58,99 ----
      nextevent = currcycle + mintime;
  }
  
! extern signed long pissoff;
! 
! STATIC_INLINE void cycles_do_special (void)
! {
!     if (pissoff >= 0)
! 	pissoff = -1;
! }
! 
! STATIC_INLINE void do_extra_cycles (unsigned long cycles_to_add) {
!     pissoff -= cycles_to_add;
! }
! 
! STATIC_INLINE unsigned long int get_cycles (void)
! {
!     return currcycle;
! }
! 
! STATIC_INLINE void set_cycles (unsigned long int x)
  {
!     currcycle = x;
! }
! 
! STATIC_INLINE void do_cycles_slow (unsigned long cycles_to_add) {
!     if ((pissoff -= cycles_to_add) >= 0)
  	return;
  
+     cycles_to_add = -pissoff;
+     pissoff = 0;
+ 
+     if (is_lastline && eventtab[ev_hsync].evtime-currcycle <= cycles_to_add) {
+ 	frame_time_t now=read_processor_time ();
+ 	if (diff32(now, vsyncmintime) < 0) {
+ 	    pissoff = 3000 * CYCLE_UNIT;
+ 	    return;
+ 	}
+     }
      while ((nextevent - currcycle) <= cycles_to_add) {
          int i;
          cycles_to_add -= (nextevent - currcycle);
***************
*** 66,100 ****
  	}
          events_schedule();
      }
      currcycle += cycles_to_add;
  }
  
! STATIC_INLINE void do_cycles_fast (void)
  {
!     if (is_lastline && eventtab[ev_hsync].evtime - currcycle <= 1
! 	&& (long int)(read_processor_time () - vsyncmintime) < 0)
  	return;
  
!     currcycle++;
!     if (nextevent == currcycle) {
  	int i;
  
  	for (i = 0; i < ev_max; i++) {
! 	    if (eventtab[i].active && eventtab[i].evtime == currcycle) {
  		(*eventtab[i].handler) ();
  	    }
  	}
  	events_schedule();
      }
! 
  }
  
  /* This is a special-case function.  Normally, all events should lie in the
     future; they should only ever be active at the current cycle during
     do_cycles.  However, a snapshot is saved during do_cycles, and so when
!    restoring it, we may have other events pending.  */
! STATIC_INLINE void handle_active_events (void)
! {
      int i;
      for (i = 0; i < ev_max; i++) {
  	if (eventtab[i].active && eventtab[i].evtime == currcycle) {
--- 106,223 ----
  	}
          events_schedule();
      }
+ 
      currcycle += cycles_to_add;
  }
  
! #define do_cycles do_cycles_slow
! #define countdown pissoff
! 
! #else
! 
! /* Let's see whether hiding this away somewhere where the compiler can't
!    see it will cure it of its silly urge to mis-optimize the comparison */ extern long int diff32(frame_time_t x, frame_time_t y);
! 
! extern long cycles_to_next_event;
! extern long max_cycles_to_next_event;
! extern long cycles_to_hsync_event;
! extern long pissoff;
! 
! STATIC_INLINE void cycles_do_special(void)
! {
!     if (cycles_to_next_event >= 0) {
! 	pissoff += cycles_to_next_event;
! 	cycles_to_next_event = 0;
!     }
! }
! 
! 
! STATIC_INLINE void do_extra_cycles (unsigned long cycles_to_add) {
!     pissoff -= cycles_to_add;
! }
! 
! STATIC_INLINE unsigned long int get_cycles (void)
  {
!     if (cycles_to_next_event <= max_cycles_to_next_event) {
! 	max_cycles_to_next_event = cycles_to_next_event;
! 	return nextevent - cycles_to_next_event;
!     } else {
! 	return nextevent - max_cycles_to_next_event;
!     }
! }
! 
! STATIC_INLINE void events_schedule (void)
! {
!     int i;
! 
!     unsigned long int curcycles = get_cycles();
!     unsigned long int mintime = ~0L;
! 
!     cycles_to_hsync_event=eventtab[ev_hsync].evtime - curcycles;
!     for (i = 0; i < ev_max; i++) {
! 	if (eventtab[i].active) {
! 	    unsigned long int eventtime = eventtab[i].evtime - curcycles;
! 	    if (eventtime < mintime) 
! 		mintime = eventtime;
! 	}
!     }
!     nextevent = curcycles + mintime;
!     max_cycles_to_next_event = mintime;
!     cycles_to_next_event = mintime;
!     cycles_to_hsync_event = mintime - cycles_to_hsync_event;
! }
! 
! STATIC_INLINE void set_cycles (unsigned long int x)
! {
!     cycles_to_next_event = nextevent - x;
!     events_schedule ();
! }
! 
! STATIC_INLINE void do_cycles_slow (long cycles_to_add)
! {
!     cycles_to_next_event -= cycles_to_add;
!     if (cycles_to_next_event > 0)
  	return;
  
!     cycles_to_next_event += pissoff;
!     pissoff=0;
! 
!     if (is_lastline
! 	&& /*cycles_to_next_event <= cycles_to_hsync_event*/
! 	eventtab[ev_hsync].evtime == nextevent) 
!     {
! 	frame_time_t now=read_processor_time();
! 	if (diff32(now, vsyncmintime)<0)
! 	{
! 	    cycles_to_next_event += 3000 * CYCLE_UNIT;
! 	    return;
! 	}
!     }
!     cycles_to_add=0;
!     while (cycles_to_next_event <= cycles_to_add) {
  	int i;
  
+ 	cycles_to_add-=cycles_to_next_event;
+ 	cycles_to_next_event=0;
  	for (i = 0; i < ev_max; i++) {
! 	    if (eventtab[i].active && eventtab[i].evtime == nextevent) {
  		(*eventtab[i].handler) ();
  	    }
  	}
  	events_schedule();
      }
!     cycles_to_next_event -= cycles_to_add;
  }
  
+ #define do_cycles do_cycles_slow
+ #define countdown cycles_to_next_event
+ 
+ #endif
+ 
  /* This is a special-case function.  Normally, all events should lie in the
     future; they should only ever be active at the current cycle during
     do_cycles.  However, a snapshot is saved during do_cycles, and so when
!    restoring it, we may have other events pending.  */ STATIC_INLINE void handle_active_events (void) {
      int i;
      for (i = 0; i < ev_max; i++) {
  	if (eventtab[i].active && eventtab[i].evtime == currcycle) {
***************
*** 103,117 ****
      }
  }
  
- STATIC_INLINE unsigned long get_cycles (void)
- {
-     return currcycle;
- }
- 
- extern void init_eventtab (void);
- 
- #if /* M68K_SPEED == 1 */  0
- #define do_cycles do_cycles_fast
- #else
- #define do_cycles do_cycles_slow
  #endif
--- 226,229 ----
diff -crB --new-file ./uae-0.8.21/src/include/newcpu.h ../uae_jit_cleaning/uae-0.8.21/src/include/newcpu.h
*** ./uae-0.8.21/src/include/newcpu.h	2001-12-17 20:38:38.000000000 +0200
--- ../uae_jit_cleaning/uae-0.8.21/src/include/newcpu.h	2021-01-10 13:10:29.914591684 +0200
***************
*** 51,57 ****
  struct cputbl {
      cpuop_func *handler;
      int specific;
!     uae_u16 opcode;
  };
  
  extern unsigned long op_illg (uae_u32) REGPARAM;
--- 51,57 ----
  struct cputbl {
      cpuop_func *handler;
      int specific;
!     uae_u32 opcode;
  };
  
  extern unsigned long op_illg (uae_u32) REGPARAM;
***************
*** 101,109 ****
--- 101,132 ----
      uae_u32 prefetch;
  } regs, lastint_regs;
  
+ typedef struct {
+   uae_u16* location;
+   uae_u8  cycles;
+   uae_u8  specmem;
+   uae_u8  dummy2;
+   uae_u8  dummy3;
+ } cpu_history;
+ 
+ struct blockinfo_t;
+ 
+ typedef union {
+     cpuop_func* handler;
+     struct blockinfo_t* bi;
+ } cacheline;
+ 
+ extern signed long pissoff;
+ 
+ STATIC_INLINE uae_u32 munge24(uae_u32 x)
+ {
+     return currprefs.address_space_24?(x&0x00ffffff):x;
+ }
+ 
  STATIC_INLINE void set_special (uae_u32 x)
  {
      regs.spcflags |= x;
+     cycles_do_special();
  }
  
  STATIC_INLINE void unset_special (uae_u32 x)
***************
*** 117,122 ****
--- 140,146 ----
  #if !defined USE_COMPILER
  STATIC_INLINE void m68k_setpc (uaecptr newpc)
  {
+     newpc &= ~1;
      regs.pc_p = regs.pc_oldp = get_real_address (newpc);
      regs.pc = newpc;
  }
***************
*** 242,248 ****
      /* A traced STOP instruction drops through immediately without
         actually stopping.  */
      if (stop && (regs.spcflags & SPCFLAG_DOTRACE) == 0)
! 	regs.spcflags |= SPCFLAG_STOP;
  }
  
  extern uae_u32 get_disp_ea_020 (uae_u32 base, uae_u32 dp);
--- 266,272 ----
      /* A traced STOP instruction drops through immediately without
         actually stopping.  */
      if (stop && (regs.spcflags & SPCFLAG_DOTRACE) == 0)
! 	set_special (SPCFLAG_STOP);
  }
  
  extern uae_u32 get_disp_ea_020 (uae_u32 base, uae_u32 dp);
***************
*** 298,303 ****
--- 322,341 ----
  
  extern cpuop_func *cpufunctbl[65536] ASM_SYM_FOR_FUNC ("cpufunctbl");
  
+   
+ /* Flags for Bernie during development/debugging. Should go away eventually */
+ #define DISTRUST_CONSISTENT_MEM 0
+ #define TAGMASK 0x000fffff
+ #define TAGSIZE (TAGMASK+1)
+ #define MAXRUN 1024
+ 
+ extern uae_u8* start_pc_p;
+ extern uae_u32 start_pc;
+ 
+ #define cacheline(x) (((uae_u32)x)&TAGMASK)
+ 
+ void newcpu_showstate(void);
+ 
  #ifdef JIT
  #else
  #define flush_icache(X) do {} while (0)
diff -crB --new-file ./uae-0.8.21/src/include/noflags.h ../uae_jit_cleaning/uae-0.8.21/src/include/noflags.h
*** ./uae-0.8.21/src/include/noflags.h	1970-01-01 02:00:00.000000000 +0200
--- ../uae_jit_cleaning/uae-0.8.21/src/include/noflags.h	2021-01-10 13:10:29.918591684 +0200
***************
*** 0 ****
--- 1,177 ----
+ #ifndef NOFLAGS_H
+ #define NOFLAGS_H
+ 
+ /* Undefine everything that will *set* flags. Note: Leave *reading*
+    flags alone ;-). We assume that nobody does something like 
+    SET_ZFLG(a=b+c), i.e. expect side effects of the macros. That would 
+    be a stupid thing to do when using macros.
+ */
+ 
+ /* Gwenole Beauchesne pointed out that CAS and CAS2 use flag_cmp to set
+    flags that are then used internally, and that thus the noflags versions
+    of those instructions were broken. Oops! 
+    Easy fix: Leave flag_cmp alone. It is only used by CMP* and CAS* 
+    instructions. For CAS*, noflags is a bad idea. For CMP*, which has
+    setting flags as its only function, the noflags version is kinda pointless,
+    anyway. 
+    Note that this will only work while using the optflag_* routines ---
+    as we do on all (one ;-) platforms that will ever use the noflags
+    versions, anyway.
+    However, if you try to compile without optimized flags, the "SET_ZFLAG"
+    macro will be left unchanged, to make CAS and CAS2 work right. Of course,
+    this is contrary to the whole idea of noflags, but better be right than
+    be fast.
+ 
+    Another problem exists with one of the bitfield operations. Once again,
+    one of the operations sets a flag, and looks at it later. And the CHK2
+    instruction does so as well. For those, a different solution is possible.
+    the *_ALWAYS versions of the SET_?FLG macros shall remain untouched by 
+    the redefinitions in this file.
+    Unfortunately, they are defined in terms of the macros we *do* redefine.
+    So here comes a bit of trickery....
+ */
+ #define NOFLAGS_CMP 0
+ 
+ #undef SET_NFLG_ALWAYS
+ static __inline__ void SET_NFLG_ALWAYS(uae_u32 x)
+ {
+     SET_NFLG(x);  /* This has not yet been redefined */
+ }
+ 
+ #undef SET_CFLG_ALWAYS
+ static __inline__ void SET_CFLG_ALWAYS(uae_u32 x)
+ {
+     SET_CFLG(x);  /* This has not yet been redefined */
+ }
+ 
+ #undef CPUFUNC
+ #define CPUFUNC(x) x##_nf
+ 
+ #ifndef OPTIMIZED_FLAGS
+ #undef SET_ZFLG
+ #define SET_ZFLG(y) do {uae_u32 dummy=(y); } while (0)
+ #endif
+ 
+ #undef SET_CFLG
+ #define SET_CFLG(y) do {uae_u32 dummy=(y); } while (0)
+ #undef SET_VFLG
+ #define SET_VFLG(y) do {uae_u32 dummy=(y); } while (0)
+ #undef SET_NFLG
+ #define SET_NFLG(y) do {uae_u32 dummy=(y); } while (0)
+ #undef SET_XFLG
+ #define SET_XFLG(y) do {uae_u32 dummy=(y); } while (0)
+ 
+ #undef CLEAR_CZNV
+ #define CLEAR_CZNV
+ #undef IOR_CZNV
+ #define IOR_CZNV(y) do {uae_u32 dummy=(y); } while (0)
+ #undef SET_CZNV
+ #define SET_CZNV(y) do {uae_u32 dummy=(y); } while (0)
+ #undef COPY_CARRY
+ #define COPY_CARRY 
+ 
+ #ifdef  optflag_testl
+ #undef  optflag_testl
+ #endif
+ 
+ #ifdef  optflag_testw
+ #undef  optflag_testw
+ #endif
+ 
+ #ifdef  optflag_testb
+ #undef  optflag_testb
+ #endif
+ 
+ #ifdef  optflag_addl
+ #undef  optflag_addl
+ #endif
+ 
+ #ifdef  optflag_addw
+ #undef  optflag_addw
+ #endif
+ 
+ #ifdef  optflag_addb
+ #undef  optflag_addb
+ #endif
+ 
+ #ifdef  optflag_subl
+ #undef  optflag_subl
+ #endif
+ 
+ #ifdef  optflag_subw
+ #undef  optflag_subw
+ #endif
+ 
+ #ifdef  optflag_subb
+ #undef  optflag_subb
+ #endif
+ 
+ #if NOFLAGS_CMP
+ #ifdef  optflag_cmpl
+ #undef  optflag_cmpl
+ #endif
+ 
+ #ifdef  optflag_cmpw
+ #undef  optflag_cmpw
+ #endif
+ 
+ #ifdef  optflag_cmpb
+ #undef  optflag_cmpb
+ #endif
+ #endif
+ 
+ 
+ #define optflag_testl(v) \
+ do { } while(0)
+ 
+ #define optflag_testw(v) \
+ do { } while(0)
+ 
+ #define optflag_testb(v) \
+ do { } while(0)
+ 
+ #define optflag_addl(v, s, d) do { \
+   __asm__ __volatile__ ("addl %k1,%k0\n\t" \
+ 			: "=r" (v) : "rmi" (s), "0" (d) : "cc"); \
+     } while (0)
+ #define optflag_addw(v, s, d) do { \
+   __asm__ __volatile__ ("addw %w1,%w0\n\t" \
+ 			: "=r" (v) : "rmi" (s), "0" (d) : "cc"); \
+     } while (0)
+ 
+ #define optflag_addb(v, s, d) do { \
+   __asm__ __volatile__ ("addb %b1,%b0\n\t" \
+ 			: "=q" (v) : "qmi" (s), "0" (d) : "cc"); \
+     } while (0)
+ 
+ #define optflag_subl(v, s, d) do { \
+   __asm__ __volatile__ ("subl %k1,%k0\n\t" \
+ 			: "=r" (v) : "rmi" (s), "0" (d) : "cc"); \
+     } while (0)
+ 
+ #define optflag_subw(v, s, d) do { \
+   __asm__ __volatile__ ("subw %w1,%w0\n\t" \
+ 			: "=r" (v) : "rmi" (s), "0" (d) : "cc"); \
+     } while (0)
+ 
+ #define optflag_subb(v, s, d) do { \
+   __asm__ __volatile__ ("subb %b1,%b0\n\t" \
+ 			: "=q" (v) : "qmi" (s), "0" (d) : "cc"); \
+     } while (0)
+ 
+ #if NOFLAGS_CMP
+ /* These are just for completeness sake */
+ #define optflag_cmpl(s, d) \
+ do {  __asm__ __volatile__ ("cmpl %k0,%k1\n\t" \
+ 			:: "rmi" (s), "r" (d) : "cc"); } while(0)
+ 
+ #define optflag_cmpw(s, d) \
+ do {  __asm__ __volatile__ ("cmpw %w0,%w1\n\t" \
+ 			:: "rmi" (s), "r" (d) : "cc");  } while(0)
+ 
+ #define optflag_cmpb(s, d) \
+ do {  __asm__ __volatile__ ("cmpb %b0,%b1\n\t" \
+ 			:: "qmi" (s), "q" (d) : "cc"); } while(0)
+ #endif
+ 
+ #endif
diff -crB --new-file ./uae-0.8.21/src/include/options.h ../uae_jit_cleaning/uae-0.8.21/src/include/options.h
*** ./uae-0.8.21/src/include/options.h	2002-02-16 21:27:08.000000000 +0200
--- ../uae_jit_cleaning/uae-0.8.21/src/include/options.h	2021-01-10 13:10:29.918591684 +0200
***************
*** 57,62 ****
--- 57,84 ----
      int sound_pri_cutoff;
      int sound_interpol;
  
+     int comptrustbyte;
+     int comptrustword;
+     int comptrustlong;
+     int comptrustnaddr;
+     int compnf;
+     int compforcesettings;
+     int compfpu;
+     int comp_midopt;
+     int comp_lowopt;
+ 
+     int comp_hardflush;
+     int comp_constjump;
+     int comp_oldsegv;
+ 
+     int cachesize;
+     int optcount[10];
+ 
+     int avoid_cmov;
+     int avoid_dga;
+     int avoid_vid;
+     uae_u32 override_dga_address;
+ 
      int gfx_framerate;
      int gfx_width;
      int gfx_height;
***************
*** 80,85 ****
--- 102,108 ----
      char romfile[256];
      char romextfile[256];
      char keyfile[256];
+     char pci_devices[256];
      char prtname[256];
      char sername[256];
  
diff -crB --new-file ./uae-0.8.21/src/include/picasso96.h ../uae_jit_cleaning/uae-0.8.21/src/include/picasso96.h
*** ./uae-0.8.21/src/include/picasso96.h	2001-11-25 14:41:51.000000000 +0200
--- ../uae_jit_cleaning/uae-0.8.21/src/include/picasso96.h	2021-01-10 13:10:29.918591684 +0200
***************
*** 10,15 ****
--- 10,20 ----
  
  #define PICASSO96
  
+ 
+ /* Seems the same routines copy back and forth ;-) */
+ #define PIC_READ (S_READ|S_WRITE)
+ #define PIC_WRITE (S_READ|S_WRITE)
+ 
  #define JAM1 0
  #define JAM2 1
  #define COMP 2
***************
*** 282,287 ****
--- 287,293 ----
      uae_s16 BytesPerRow;
      uae_s16 pad;
      RGBFTYPE RGBFormat;
+     uaecptr AMemory;
  };
  
  #define PSSO_Pattern_Memory 0
***************
*** 555,558 ****
--- 561,576 ----
  extern int picasso_nr_resolutions (void);
  extern void picasso_clip_mouse (int *, int *);
  
+ extern int NDX_InvertRect(struct RenderInfo* ri, unsigned long X, unsigned long Y, unsigned long Width, unsigned long Height, uae_u32 mask, int Bpp);
+ extern int NDX_BlitPattern(struct RenderInfo* ri,struct Pattern* pat,unsigned long X, unsigned long Y, unsigned long W, unsigned long H, uae_u8 Mask, uae_u32 RGBFmt);
+ extern int NDX_BlitTemplate(struct RenderInfo* ri, struct Template* tmp, unsigned long X, unsigned long Y, unsigned long W, unsigned long H, uae_u16 Mask);
+ extern int NDX_BlitPlanar2Chunky(struct RenderInfo* ri, struct BitMap* bm, unsigned long srcx, unsigned long srcy, unsigned long dstx, unsigned long dsty, unsigned long width, unsigned long height, uae_u8 minterm, uae_u8 mask);
+ extern int NDX_BlitPlanar2Direct(struct RenderInfo* ri, struct BitMap* bm, unsigned long srcx, unsigned long srcy, unsigned long dstx, unsigned long dsty, unsigned long width, unsigned long height, uae_u8 minterm, uae_u8 Mask);
+ extern int NDX_FillRect(struct RenderInfo* ri, unsigned long X, unsigned long Y, unsigned long Width, unsigned long Height, uae_u32 Pen, uae_u8 Mask, uae_u32 RGBFormat);
+ extern int NDX_BlitRect(struct RenderInfo* ri, unsigned long srcx, unsigned long srcy, unsigned long dstx, unsigned long dsty, unsigned long width, unsigned long height, uae_u8 Mask);
+ extern int NDX_BlitRectNoMaskComplete(struct RenderInfo* sri,struct RenderInfo* dri, unsigned long srcx, unsigned long srcy, unsigned long dstx, unsigned long dsty, unsigned long width, unsigned long height, uae_u8 OpCode, uae_u32 RGBFmt);
+ 
+ extern int picasso_is_special;
+ extern int picasso_is_special_read;
+ 
  #endif
diff -crB --new-file ./uae-0.8.21/src/include/sysdeps.h ../uae_jit_cleaning/uae-0.8.21/src/include/sysdeps.h
*** ./uae-0.8.21/src/include/sysdeps.h	2001-11-19 19:58:46.000000000 +0200
--- ../uae_jit_cleaning/uae-0.8.21/src/include/sysdeps.h	2021-01-10 13:10:29.918591684 +0200
***************
*** 235,241 ****
  /* While we're here, make abort more useful.  */
  #define abort() \
    do { \
!     write_log ("Internal error; file %s, line %d\n", __FILE__, __LINE__); \
      (abort) (); \
  } while (0)
  #else
--- 235,241 ----
  /* While we're here, make abort more useful.  */
  #define abort() \
    do { \
!     fprintf (stderr, "Internal error; file %s, line %d\n", __FILE__, __LINE__); \
      (abort) (); \
  } while (0)
  #else
diff -crB --new-file ./uae-0.8.21/src/machdep/m68k.h ../uae_jit_cleaning/uae-0.8.21/src/machdep/m68k.h
*** ./uae-0.8.21/src/machdep/m68k.h	1970-01-01 02:00:00.000000000 +0200
--- ../uae_jit_cleaning/uae-0.8.21/src/machdep/m68k.h	2021-01-10 13:10:29.918591684 +0200
***************
*** 0 ****
--- 1,206 ----
+ #ifndef M68K_H
+ #define M68K_H
+ 
+  /* 
+   * UAE - The Un*x Amiga Emulator
+   * 
+   * MC68000 emulation - machine dependent bits
+   *
+   * Copyright 1996 Bernd Schmidt
+   */
+ 
+ #if 0 
+ struct flag_struct {
+     unsigned int c:1; /* first byte */
+     int :5;
+     unsigned int z:1;
+     unsigned int n:1;
+     int :3;           /* second, third & fourth byte */
+     unsigned int v:1; 
+     int :20;
+     unsigned int x:1; /* fifth */
+     int :31;
+ };
+ 
+ #define ZFLG (regflags.z)
+ #define NFLG (regflags.n)
+ #define CFLG (regflags.c)
+ #define VFLG (regflags.v)
+ #define XFLG (regflags.x)
+ 
+ #else
+ 
+ struct flag_struct {
+     unsigned int cznv;
+     unsigned int x;
+ };
+ 
+ #define FLAGVAL_Z 0x4000
+ #define FLAGVAL_N 0x8000
+ 
+ #define SET_ZFLG(y) (regflags.cznv = (regflags.cznv & ~0x4000) | (((y) & 1) << 14))
+ #define SET_CFLG(y) (regflags.cznv = (regflags.cznv & ~0x100) | (((y) & 1) << 8))
+ #define SET_VFLG(y) (regflags.cznv = (regflags.cznv & ~0x1) | (((y) & 1)))
+ #define SET_NFLG(y) (regflags.cznv = (regflags.cznv & ~0x8000) | (((y) & 1) << 15))
+ #define SET_XFLG(y) (regflags.x = (y))
+ 
+ #define GET_ZFLG ((regflags.cznv >> 14) & 1)
+ #define GET_CFLG ((regflags.cznv >> 8) & 1)
+ #define GET_VFLG ((regflags.cznv >> 0) & 1)
+ #define GET_NFLG ((regflags.cznv >> 15) & 1)
+ #define GET_XFLG (regflags.x & 1)
+ 
+ #define CLEAR_CZNV (regflags.cznv = 0)
+ #define GET_CZNV (regflags.cznv)
+ #define IOR_CZNV(X) (regflags.cznv |= (X))
+ #define SET_CZNV(X) (regflags.cznv = (X))
+ 
+ #define COPY_CARRY (regflags.x = (regflags.cznv)>>8)
+ 
+ 
+ #endif
+ 
+ extern struct flag_struct regflags __asm__ ("regflags");
+ 
+ static __inline__ int cctrue(int cc)
+ {
+     uae_u32 cznv = regflags.cznv;
+     switch(cc){
+      case 0: return 1;                       /* T */
+      case 1: return 0;                       /* F */
+      case 2: return (cznv & 0x4100) == 0; /* !GET_CFLG && !GET_ZFLG;  HI */
+      case 3: return (cznv & 0x4100) != 0; /* GET_CFLG || GET_ZFLG;    LS */
+      case 4: return (cznv & 0x100) == 0;  /* !GET_CFLG;               CC */
+      case 5: return (cznv & 0x100) != 0;  /* GET_CFLG;                CS */
+      case 6: return (cznv & 0x4000) == 0; /* !GET_ZFLG;               NE */
+      case 7: return (cznv & 0x4000) != 0; /* GET_ZFLG;                EQ */
+      case 8: return (cznv & 0x01) == 0;   /* !GET_VFLG;               VC */
+      case 9: return (cznv & 0x01) != 0;   /* GET_VFLG;                VS */
+      case 10:return (cznv & 0x8000) == 0; /* !GET_NFLG;               PL */
+      case 11:return (cznv & 0x8000) != 0; /* GET_NFLG;                MI */
+      case 12:return (((cznv << 15) ^ cznv) & 0x8000) == 0; /* GET_NFLG == GET_VFLG;             GE */
+      case 13:return (((cznv << 15) ^ cznv) & 0x8000) != 0;/* GET_NFLG != GET_VFLG;             LT */
+      case 14:
+ 	cznv &= 0xc001;
+ 	return (((cznv << 15) ^ cznv) & 0xc000) == 0; /* !GET_ZFLG && (GET_NFLG == GET_VFLG);  GT */
+      case 15:
+ 	cznv &= 0xc001;
+ 	return (((cznv << 15) ^ cznv) & 0xc000) != 0; /* GET_ZFLG || (GET_NFLG != GET_VFLG);   LE */
+     }
+     abort();
+     return 0;
+ }
+ 
+ /* Is there any way to do this without declaring *all* memory clobbered?
+    I.e. any way to tell gcc that some byte-sized value is in %al? */
+ #define optflag_testl(v) \
+   __asm__ __volatile__ ("andl %0,%0\n\t" \
+ 			"lahf\n\t" \
+ 			"seto %%al\n\t" \
+                         "movb %%al,regflags\n\t" \
+ 			"movb %%ah,regflags+1\n\t" \
+ 			:: "r" (v) : "%eax","cc","memory")
+ #define optflag_testw(v) \
+   __asm__ __volatile__ ("andw %w0,%w0\n\t" \
+ 			"lahf\n\t" \
+ 			"seto %%al\n\t" \
+                         "movb %%al,regflags\n\t" \
+ 			"movb %%ah,regflags+1\n\t" \
+ 			:: "r" (v) : "%eax","cc","memory")
+ 
+ #define optflag_testb(v) \
+   __asm__ __volatile__ ("andb %b0,%b0\n\t" \
+ 			"lahf\n\t" \
+ 			"seto %%al\n\t" \
+                         "movb %%al,regflags\n\t" \
+ 			"movb %%ah,regflags+1\n\t" \
+ 			:: "q" (v) : "%eax","cc","memory")
+ 
+ #define optflag_addl(v, s, d) do { \
+   __asm__ __volatile__ ("addl %k1,%k0\n\t" \
+ 			"lahf\n\t" \
+ 			"seto %%al\n\t" \
+                         "movb %%al,regflags\n\t" \
+ 			"movb %%ah,regflags+1\n\t" \
+ 			:"=r" (v) : "rmi" (s), "0" (d) : "%eax","cc","memory"); \
+     COPY_CARRY; \
+     } while (0)
+ #define optflag_addw(v, s, d) do { \
+   __asm__ __volatile__ ("addw %w1,%w0\n\t" \
+ 			"lahf\n\t" \
+ 			"seto %%al\n\t" \
+                         "movb %%al,regflags\n\t" \
+ 			"movb %%ah,regflags+1\n\t" \
+ 			: "=r" (v) : "rmi" (s), "0" (d) : "%eax","cc","memory"); \
+     COPY_CARRY; \
+     } while (0)
+ 
+ #define optflag_addb(v, s, d) do { \
+   __asm__ __volatile__ ("addb %b1,%b0\n\t" \
+ 			"lahf\n\t" \
+ 			"seto %%al\n\t" \
+                         "movb %%al,regflags\n\t" \
+ 			"movb %%ah,regflags+1\n\t" \
+ 			:"=q" (v) : "qmi" (s), "0" (d) : "%eax","cc","memory"); \
+     COPY_CARRY; \
+     } while (0)
+ 
+ #define optflag_subl(v, s, d) do { \
+   __asm__ __volatile__ ("subl %k1,%k0\n\t" \
+ 			"lahf\n\t" \
+ 			"seto %%al\n\t" \
+                         "movb %%al,regflags\n\t" \
+ 			"movb %%ah,regflags+1\n\t" \
+ 			: "=r" (v) : "rmi" (s), "0" (d) : "%eax","cc","memory"); \
+     COPY_CARRY; \
+     } while (0)
+ 
+ #define optflag_subw(v, s, d) do { \
+   __asm__ __volatile__ ("subw %w1,%w0\n\t" \
+ 			"lahf\n\t" \
+ 			"seto %%al\n\t" \
+                         "movb %%al,regflags\n\t" \
+ 			"movb %%ah,regflags+1\n\t" \
+ 			: "=r" (v) : "rmi" (s), "0" (d) : "%eax","cc","memory"); \
+     COPY_CARRY; \
+     } while (0)
+ 
+ #define optflag_subb(v, s, d) do { \
+    __asm__ __volatile__ ("subb %b1,%b0\n\t" \
+ 			"lahf\n\t" \
+ 			"seto %%al\n\t" \
+                         "movb %%al,regflags\n\t" \
+ 			"movb %%ah,regflags+1\n\t" \
+ 			: "=q" (v) : "qmi" (s), "0" (d) : "%eax","cc","memory"); \
+     COPY_CARRY; \
+     } while (0)
+ 
+ #define optflag_cmpl(s, d) \
+   __asm__ __volatile__ ("cmpl %k0,%k1\n\t" \
+ 			"lahf\n\t" \
+ 			"seto %%al\n\t" \
+                         "movb %%al,regflags\n\t" \
+ 			"movb %%ah,regflags+1\n\t" \
+ 			:: "rmi" (s), "r" (d) : "%eax","cc","memory")
+ 
+ #define optflag_cmpw(s, d) \
+   __asm__ __volatile__ ("cmpw %w0,%w1\n\t" \
+ 			"lahf\n\t" \
+ 			"seto %%al\n\t" \
+                         "movb %%al,regflags\n\t" \
+ 			"movb %%ah,regflags+1\n\t" \
+ 			:: "rmi" (s), "r" (d) : "%eax","cc","memory");
+ 
+ #define optflag_cmpb(s, d) \
+   __asm__ __volatile__ ("cmpb %b0,%b1\n\t" \
+ 			"lahf\n\t" \
+ 			"seto %%al\n\t" \
+                         "movb %%al,regflags\n\t" \
+ 			"movb %%ah,regflags+1\n\t" \
+ 			:: "qmi" (s), "q" (d) : "%eax","cc","memory")
+ 
+ 
+ #endif
+ 
+ 
+ 
diff -crB --new-file ./uae-0.8.21/src/machdep/maccess.h ../uae_jit_cleaning/uae-0.8.21/src/machdep/maccess.h
*** ./uae-0.8.21/src/machdep/maccess.h	1970-01-01 02:00:00.000000000 +0200
--- ../uae_jit_cleaning/uae-0.8.21/src/machdep/maccess.h	1999-12-29 16:26:05.000000000 +0200
***************
*** 0 ****
--- 1,168 ----
+  /* 
+   * UAE - The Un*x Amiga Emulator
+   * 
+   * Memory access functions
+   *
+   * Copyright 1996 Bernd Schmidt
+   */
+ 
+ static __inline__ uae_u32 do_get_mem_long (uae_u32 *a)
+ {
+     uae_u32 retval;
+ 
+     __asm__ ("bswap %0" : "=r" (retval) : "0" (*a) : "cc");
+     return retval;
+ }
+ 
+ static __inline__ uae_u32 do_get_mem_word (uae_u16 *a)
+ {
+     uae_u32 retval;
+ 
+ #ifdef X86_PPRO_OPT
+     __asm__ ("movzwl %w1,%k0\n\tshll $16,%k0\n\tbswap %k0\n" : "=&r" (retval) : "m" (*a) : "cc");
+ #else
+     __asm__ ("xorl %k0,%k0\n\tmovw %w1,%w0\n\trolw $8,%w0" : "=&r" (retval) : "m" (*a) : "cc");
+ #endif
+     return retval;
+ }
+ 
+ #define do_get_mem_byte(a) ((uae_u32)*((uae_u8 *)a))
+ 
+ static __inline__ void do_put_mem_long (uae_u32 *a, uae_u32 v)
+ {
+     __asm__ ("bswap %0" : "=r" (v) : "0" (v) : "cc");
+     *a = v;
+ }
+ 
+ static __inline__ void do_put_mem_word (uae_u16 *a, uae_u32 v)
+ {
+ #ifdef X86_PPRO_OPT
+     __asm__ ("bswap %0" : "=&r" (v) : "0" (v << 16) : "cc");
+ #else
+     __asm__ ("rolw $8,%w0" : "=r" (v) : "0" (v) : "cc");
+ #endif
+     *a = v;
+ }
+ 
+ #define do_put_mem_byte(a,v) (*(uae_u8 *)(a) = (v))
+ 
+ #if 0
+ static __inline__ uae_u32 call_mem_get_func(mem_get_func func, uae_cptr addr)
+ {
+     uae_u32 result;
+     __asm__("call %1"
+ 	    : "=a" (result) : "r" (func), "a" (addr) : "cc", "edx", "ecx");
+     return result;
+ }
+ 
+ static __inline__ void call_mem_put_func(mem_put_func func, uae_cptr addr, uae_u32 v)
+ {
+     __asm__("call %2"
+ 	    : : "a" (addr), "d" (v), "r" (func) : "cc", "eax", "edx", "ecx", "memory");
+ }
+ #else
+ 
+ #define call_mem_get_func(func,addr) ((*func)(addr))
+ #define call_mem_put_func(func,addr,v) ((*func)(addr,v))
+ 
+ #endif
+ 
+ #undef NO_INLINE_MEMORY_ACCESS
+ #undef MD_HAVE_MEM_1_FUNCS
+ 
+ #ifdef MD_HAVE_MEM_1_FUNCS
+ static __inline__ uae_u32 longget_1 (uae_cptr addr)
+ {
+     uae_u32 result;
+ 
+     __asm__ ("andl $0x00FFFFFF,%1\n"
+ 	     "\tcmpb $0,(%1,%3)\n"
+ 	     "\tleal 1f,%%ecx\n"
+ 	     "\tje longget_stub\n"
+ 	     "\taddl address_space,%1\n"
+ 	     "\tmovl (%1),%0\n"
+ 	     "\tbswap %0\n"
+ 	     "\t1:"
+ 	     : "=c" (result), "=d" (addr) : "1" (addr), "r" (good_address_map) : "cc");
+     return result;
+ }
+ static __inline__ uae_u32 wordget_1 (uae_cptr addr)
+ {
+     uae_u32 result;
+ 
+     __asm__ ("andl $0x00FFFFFF,%1\n"
+ 	     "\tcmpb $0,(%1,%3)\n"
+ 	     "\tleal 1f,%%ecx\n"
+ 	     "\tje wordget_stub\n"
+ 	     "\taddl address_space,%1\n"
+ 	     "\tmovzwl (%1),%0\n"
+ 	     "\trolw $8,%w0\n"
+ 	     "\t1:"
+ 	     : "=c" (result), "=d" (addr) : "1" (addr), "r" (good_address_map) : "cc");
+     return result;
+ }
+ static __inline__ uae_u32 byteget_1 (uae_cptr addr) 
+ {
+     uae_u32 result;
+ 
+     __asm__ ("andl $0x00FFFFFF,%1\n"
+ 	     "\tcmpb $0,(%1,%3)\n"
+ 	     "\tleal 1f,%%ecx\n"
+ 	     "\tje byteget_stub\n"
+ 	     "\taddl address_space,%1\n"
+ 	     "\tmovzbl (%1),%0\n"
+ 	     "\t1:"
+ 	     : "=c" (result), "=d" (addr) : "1" (addr), "r" (good_address_map) : "cc");
+     return result;
+ }
+ static __inline__ void longput_1 (uae_cptr addr, uae_u32 l)
+ {
+     __asm__ __volatile__("andl $0x00FFFFFF,%0\n"
+ 	     "\tcmpb $0,(%0,%3)\n"
+ 	     "\tleal 1f,%%ecx\n"
+ 	     "\tje longput_stub\n"
+ 	     "\taddl address_space,%0\n"
+ 	     "\tbswap %1\n"
+ 	     "\tmovl %1,(%0)\n"
+ 	     "\t1:"
+ 	     : "=d" (addr), "=b" (l) : "0" (addr), "r" (good_address_map), "1" (l) : "cc", "memory", "ecx");
+ }
+ static __inline__ void wordput_1 (uae_cptr addr, uae_u32 w)
+ {
+     __asm__ __volatile__("andl $0x00FFFFFF,%0\n"
+ 	     "\tcmpb $0,(%0,%3)\n"
+ 	     "\tleal 1f,%%ecx\n"
+ 	     "\tje wordput_stub\n"
+ 	     "\taddl address_space,%0\n"
+ 	     "\trolw $8,%1\n"
+ 	     "\tmovw %w1,(%0)\n"
+ 	     "\t1:"
+ 	     : "=d" (addr), "=b" (w) : "0" (addr), "r" (good_address_map), "1" (w) : "cc", "memory", "ecx");
+ }
+ static __inline__ void byteput_1 (uae_cptr addr, uae_u32 b)
+ {
+     __asm__ __volatile__("andl $0x00FFFFFF,%0\n"
+ 	     "\tcmpb $0,(%0,%3)\n"
+ 	     "\tleal 1f,%%ecx\n"
+ 	     "\tje byteput_stub\n"
+ 	     "\taddl address_space,%0\n"
+ 	     "\tmovb %b1,(%0)\n"
+ 	     "\t1:"
+ 	     : "=d" (addr), "=b" (b) : "0" (addr), "r" (good_address_map), "1" (b) : "cc", "memory", "ecx");
+ }
+ 
+ #endif
+ 
+ #define ALIGN_POINTER_TO32(p) ((~(unsigned long)(p)) & 3)
+ 
+ /* Not the best place for this, but then there's no good place for a kludge
+  * like this... */
+ #define HAVE_UAE_U24
+ typedef struct {
+     unsigned char a, b, c;
+ } __attribute__ ((packed)) uae_u24;
+ 
+ static __inline__ uae_u24 uae24_convert (uae_u32 v)
+ {
+     return *(uae_u24 *)&v;
+ }
diff -crB --new-file ./uae-0.8.21/src/machdep/rpt.h ../uae_jit_cleaning/uae-0.8.21/src/machdep/rpt.h
*** ./uae-0.8.21/src/machdep/rpt.h	1970-01-01 02:00:00.000000000 +0200
--- ../uae_jit_cleaning/uae-0.8.21/src/machdep/rpt.h	1999-06-21 22:16:31.000000000 +0300
***************
*** 0 ****
--- 1,18 ----
+ /*
+   * UAE - The Un*x Amiga Emulator
+   *
+   * Definitions for accessing cycle counters on a given machine, if possible.
+   *
+   * Copyright 1997, 1998 Bernd Schmidt
+   */
+ 
+ typedef unsigned long frame_time_t;
+ 
+ static inline frame_time_t read_processor_time (void)
+ {
+     frame_time_t foo;
+     int dummy;
+     /* Don't assume the assembler knows rdtsc */
+     __asm__ __volatile__ (".byte 0x0f,0x31" : "=a" (foo), "=d" (dummy) :);
+     return foo;
+ }
diff -crB --new-file ./uae-0.8.21/src/machdep/support.c ../uae_jit_cleaning/uae-0.8.21/src/machdep/support.c
*** ./uae-0.8.21/src/machdep/support.c	1970-01-01 02:00:00.000000000 +0200
--- ../uae_jit_cleaning/uae-0.8.21/src/machdep/support.c	2002-02-16 15:17:53.000000000 +0200
***************
*** 0 ****
--- 1,120 ----
+  /* 
+   * UAE - The Un*x Amiga Emulator
+   * 
+   * Miscellaneous machine dependent support functions and definitions
+   *
+   * Copyright 1996 Bernd Schmidt
+   */
+ 
+ 
+ #include "sysconfig.h"
+ #include "sysdeps.h"
+ 
+ #include "config.h"
+ #include "options.h"
+ #include "machdep/m68k.h"
+ #include "events.h"
+ #include "custom.h"
+ 
+ #ifndef USE_UNDERSCORE
+ #define LARGE_ALIGNMENT ".align 16\n"
+ #else
+ #define LARGE_ALIGNMENT ".align 4,0x90\n"
+ #endif
+ 
+ struct flag_struct regflags;
+ 
+ /* All the Win32 configurations handle this in od-win32/win32.c */
+ #ifndef _WIN32
+ 
+ #include <signal.h>
+ 
+ static volatile frame_time_t last_time, best_time;
+ static volatile int loops_to_go;
+ 
+ #ifndef HAVE_SETITIMER
+ #define TIME_UNIT 1000000
+ #else
+ #define TIME_UNIT 100000
+ #endif
+ 
+ static void set_alarm (void)
+ {
+ #ifndef HAVE_SETITIMER
+     alarm (1);
+ #else
+     struct itimerval t;
+     t.it_value.tv_sec = 0;
+     t.it_value.tv_usec = TIME_UNIT;
+     t.it_interval.tv_sec = 0;
+     t.it_interval.tv_usec = TIME_UNIT;
+     setitimer (ITIMER_REAL, &t, NULL);
+ #endif
+ }
+ 
+ static int first_loop = 1;
+ 
+ #ifdef __cplusplus
+ static RETSIGTYPE alarmhandler(...)
+ #else
+ static RETSIGTYPE alarmhandler(int foo)
+ #endif
+ {
+     frame_time_t bar;
+     bar = read_processor_time ();
+     if (! first_loop && bar - last_time < best_time)
+ 	best_time = bar - last_time;
+     first_loop = 0;
+     if (--loops_to_go > 0) {
+ 	signal (SIGALRM, alarmhandler);
+ 	last_time = read_processor_time();
+ 	set_alarm ();
+     } else {
+ 	alarm (0);
+ 	signal (SIGALRM, SIG_IGN);
+     }
+ }
+ 
+ #include <setjmp.h>
+ jmp_buf catch_test;
+ 
+ #ifdef __cplusplus
+ static RETSIGTYPE illhandler(...)
+ #else
+ static RETSIGTYPE illhandler(int foo)
+ #endif
+ {
+     rpt_available = 0;
+     longjmp(catch_test,1);
+ }
+ 
+ void machdep_init (void)
+ {
+     rpt_available = 1;
+     write_log ("Testing the RDTSC instruction ... ");
+     signal (SIGILL, illhandler);
+     if (setjmp (catch_test) == 0)
+ 	read_processor_time ();
+     signal (SIGILL, SIG_DFL);
+     write_log ("done.\n");
+     if (! rpt_available) {
+ 	write_log ("Your processor does not support the RDTSC instruction.\n");
+ 	return;
+     }
+     write_log ("Calibrating delay loop.. ");
+     fflush (stderr);
+     best_time = (frame_time_t)-1;
+     loops_to_go = 5;
+     signal (SIGALRM, alarmhandler);
+     /* We want exact values... */
+     sync (); sync (); sync ();
+     last_time = read_processor_time();
+     set_alarm ();
+     while (loops_to_go != 0)
+ 	usleep (10000);
+     write_log ("ok - %.2f BogoMIPS\n",
+ 	     ((double)best_time / TIME_UNIT), best_time);
+     syncbase = best_time * (1000000 / TIME_UNIT);
+ }
+ 
+ #endif
diff -crB --new-file ./uae-0.8.21/src/machdep/X86.S ../uae_jit_cleaning/uae-0.8.21/src/machdep/X86.S
*** ./uae-0.8.21/src/machdep/X86.S	1970-01-01 02:00:00.000000000 +0200
--- ../uae_jit_cleaning/uae-0.8.21/src/machdep/X86.S	2000-02-09 17:19:41.000000000 +0200
***************
*** 0 ****
--- 1,243 ----
+ /* These are optimized x86 assembly versions of pfield_linetoscr.
+  * Feel free to send me Sparc/PPC/Alpha versions of this... :)
+  * [it's not necessarily a win to code these in assembler, though - Paul
+  * Liss says this code is slower than the generic C stuff in custom.c on
+  * a PPro]
+  */
+ 
+ #include "config.h"
+ 
+ /*#define X86_PPRO_OPT*/
+ #ifdef X86_PPRO_OPT
+ #define PARTIAL_REG(a,b) a
+ #define BYTE_MOVE movzbl
+ #define WORD_MOVE movzwl
+ #define CLEAR_FOR_BYTE_MOVE(a)
+ #else
+ #define PARTIAL_REG(a,b) b
+ #define BYTE_MOVE movb
+ #define WORD_MOVE movw
+ #define CLEAR_FOR_BYTE_MOVE(a) xorl a,a
+ #endif
+ 
+ #ifndef USE_UNDERSCORE
+ #define SYM(NAME) NAME
+ #define FUNCTION_ALIGN .align 16
+ #define FUNCTYPE(NAME) .type NAME,@function
+ #else
+ #define SYM(NAME) _##NAME
+ #define FUNCTION_ALIGN .align 4
+ #define FUNCTYPE(NAME)
+ #endif
+ 
+  	.text
+ 
+         .globl DitherLine
+ #ifndef USE_UNDERSCORE
+ 	.type	 DitherLine,@function
+ #endif
+ 	FUNCTION_ALIGN
+ DitherLine:
+ 	pushl %ebp
+ 	pushl %edi
+ 	pushl %esi
+ 	pushl %ebx
+ 	movl 20(%esp),%edi
+ 	xorl %ebx,%ebx
+ 	movw 36(%esp),%bx
+ 	movl 32(%esp),%edx
+ 	andl $3,%edx
+ 	sall $15,%edx
+ 	movl 28(%esp),%eax
+ 	andl $3,%eax
+ 	sall $12,%eax
+ 	leal SYM(cidx)(%edx,%eax),%ebp
+ 	xorb %dl,%dl
+ 	movl $8,%ecx
+ 	testl %ebx,%ebx
+ 	je .Li_end
+ 	cmpl $8,40(%esp)
+ 	je .Li_fast
+ 
+ 	movl 24(%esp),%esi
+ .Li_loop:
+ 	movzwl (%esi),%eax
+ 	movzbl (%eax,%ebp),%eax
+ 	subl 40(%esp),%ecx
+ 	sall %cl,%eax
+ 	orb %al,%dl
+ 	testl %ecx,%ecx
+ 	jne .Li_1
+ 	movb %dl,(%edi)
+ 	incl %edi
+ 	movl $8,%ecx
+ 	xorb %dl,%dl
+ .Li_1:
+ 	movzwl 2(%esi),%eax
+ 	movzbl 4096(%ebp,%eax),%eax
+ 	subl 40(%esp),%ecx
+ 	sall %cl,%eax
+ 	orb %al,%dl
+ 	testl %ecx,%ecx
+ 	jne .Li_2
+ 	movb %dl,(%edi)
+ 	incl %edi
+ 	movl $8,%ecx
+ 	xorb %dl,%dl
+ .Li_2:
+ 	movzwl 4(%esi),%eax
+ 	movzbl 8192(%ebp,%eax),%eax
+ 	subl 40(%esp),%ecx
+ 	sall %cl,%eax
+ 	orb %al,%dl
+ 	testl %ecx,%ecx
+ 	jne .Li_3
+ 	movb %dl,(%edi)
+ 	incl %edi
+ 	movl $8,%ecx
+ 	xorb %dl,%dl
+ .Li_3:
+ 	movzwl 6(%esi),%eax
+ 	movzbl 12288(%ebp,%eax),%eax
+ 	addl $8,%esi
+ 	subl 40(%esp),%ecx
+ 	sall %cl,%eax
+ 	orb %al,%dl
+ 	testl %ecx,%ecx
+ 	jne .Li_4
+ 	movb %dl,(%edi)
+ 	incl %edi
+ 	movl $8,%ecx
+ 	xorb %dl,%dl
+ .Li_4:
+ 	subl $4,%ebx
+ 	jne .Li_loop
+ 	jmp .Li_end
+ 	
+ 	/* Fast 8-bit version */
+ .Li_fast:
+ 	movl 24(%esp),%esi
+ 	xorl %edx,%edx
+ 	xorl %ecx,%ecx
+ 	FUNCTION_ALIGN
+ .Li_fast_loop:
+ 	movw (%esi),%dx
+ 	movw 2(%esi),%cx
+ 	movb (%edx,%ebp),%al	
+ 	movw 4(%esi),%dx
+ 	movb 4096(%ebp,%ecx),%ah
+ 	
+ 	movw 6(%esi),%cx
+ 	sall $16,%eax
+ 	movb 8192(%ebp,%edx),%al
+ 	
+ 	movb 12288(%ebp,%ecx),%ah
+ 	
+ 	roll $16,%eax
+ 	movl %eax,(%edi)
+ 	addl $4,%edi
+ 	addl $8,%esi
+ 	
+ 	subl $4,%ebx
+ 	jne .Li_fast_loop
+ 
+ .Li_end:
+ 	popl %ebx
+ 	popl %esi
+ 	popl %edi
+ 	popl %ebp
+ 	ret
+ #if 0	
+ .globl compiler_do_rts
+         /* Entry: EDX == regs.regs + 15 */
+ compiler_do_rts:
+         movl (%edx),%esi
+         addl address_space,%esi
+ 	movl jsr_num,%ecx
+ 	movl (%esi),%esi
+ 	orl %ecx,%ecx
+ 	bswap %esi
+ 	jz cdrts_noway
+ 	decl %ecx
+ 	cmpl jsr_rets(,%ecx,4),%esi
+ 	jne cdrts_noway
+ 	movl jsr_hash(,%ecx,4),%ebx
+ 	movl (%ebx),%ebx
+ 	orl %ebx,%ebx
+ 	jz cdrts_noway
+ 	addl $4,(%edx)
+ 	movl %ecx,jsr_num
+ 	jmp %ebx
+ cdrts_noway:
+         ret
+ #endif
+ #if 0
+ .globl longget_stub
+ longget_stub:
+         pushl %ecx
+         pushl %eax
+ 	pushl %edx
+ 	call SYM(longget)
+ 	popl %ecx
+ 	movl %eax,%ecx
+ 	popl %eax
+         ret
+ 
+ .globl wordget_stub
+ wordget_stub:
+         pushl %ecx
+         pushl %eax
+ 	pushl %edx
+ 	call SYM(wordget)
+ 	popl %ecx
+ 	movl %eax,%ecx
+ 	popl %eax
+         ret
+ 
+ .globl byteget_stub
+ byteget_stub:
+         pushl %ecx
+         pushl %eax
+ 	pushl %edx
+ 	call SYM(byteget)
+ 	popl %ecx
+ 	movl %eax,%ecx
+ 	popl %eax
+         ret
+ 
+ .globl longput_stub
+ longput_stub:
+         pushl %ecx
+         pushl %eax
+ 	pushl %ebx
+ 	pushl %edx
+ 	call SYM(longput)
+ 	movl %eax,%ecx
+ 	addl $8,%esp
+ 	popl %eax
+         ret
+ 
+ .globl wordput_stub
+ wordput_stub:
+         pushl %ecx
+         pushl %eax
+ 	pushl %ebx
+ 	pushl %edx
+ 	call SYM(wordput)
+ 	movl %eax,%ecx
+ 	addl $8,%esp
+ 	popl %eax
+         ret
+ 
+ .globl byteput_stub
+ byteput_stub:
+         pushl %ecx
+         pushl %eax
+ 	pushl %ebx
+ 	pushl %edx
+ 	call SYM(byteput)
+ 	movl %eax,%ecx
+ 	addl $8,%esp
+ 	popl %eax
+         ret
+ #endif
diff -crB --new-file ./uae-0.8.21/src/main.c ../uae_jit_cleaning/uae-0.8.21/src/main.c
*** ./uae-0.8.21/src/main.c	2001-12-17 20:38:38.000000000 +0200
--- ../uae_jit_cleaning/uae-0.8.21/src/main.c	2021-01-10 13:10:29.906591684 +0200
***************
*** 17,26 ****
  #include "gensound.h"
  #include "audio.h"
  #include "sounddep/sound.h"
- #include "events.h"
  #include "memory.h"
  #include "custom.h"
  #include "serial.h"
  #include "newcpu.h"
  #include "disk.h"
  #include "debug.h"
--- 17,26 ----
  #include "gensound.h"
  #include "audio.h"
  #include "sounddep/sound.h"
  #include "memory.h"
  #include "custom.h"
  #include "serial.h"
+ #include "events.h"
  #include "newcpu.h"
  #include "disk.h"
  #include "debug.h"
***************
*** 119,124 ****
--- 119,153 ----
      p->sound_maxbsiz = DEFAULT_SOUND_MAXB;
      p->sound_interpol = 0;
  
+     p->comptrustbyte = 0;
+     p->comptrustword = 0;
+     p->comptrustlong = 0;
+     p->comptrustnaddr= 0;
+     p->compnf=1;
+     p->comp_hardflush=0;
+     p->comp_constjump=1;
+     p->comp_oldsegv=0;
+     p->compfpu=1;
+     p->compforcesettings=0;
+     p->cachesize=4096;
+     p->avoid_cmov=0;
+     p->avoid_dga=0;
+     p->avoid_vid=0;
+     p->comp_midopt=0;
+     p->comp_lowopt=0;
+     p->override_dga_address=0;
+     {
+ 	int i;
+ 	for (i=0;i<10;i++)
+ 	    p->optcount[i]=-1;
+ 	p->optcount[0]=4; /* How often a block has to be executed before it
+ 			     is translated */
+ 	p->optcount[1]=0; /* How often to use the naive translation */
+ 	p->optcount[2]=0; 
+ 	p->optcount[3]=0;
+ 	p->optcount[4]=0;
+ 	p->optcount[5]=0;
+     }
      p->gfx_framerate = 1;
      p->gfx_width = 800;
      p->gfx_height = 600;
***************
*** 261,266 ****
--- 290,341 ----
  	currprefs.produce_sound = 0;
  	err = 1;
      }
+     if (currprefs.comptrustbyte < 0 || currprefs.comptrustbyte > 3) {
+ 	fprintf (stderr, "Bad value for comptrustbyte parameter: value must be within 0..2\n");
+ 	currprefs.comptrustbyte = 1;
+ 	err = 1;
+     }
+     if (currprefs.comptrustword < 0 || currprefs.comptrustword > 3) {
+ 	fprintf (stderr, "Bad value for comptrustword parameter: value must be within 0..2\n");
+ 	currprefs.comptrustword = 1;
+ 	err = 1;
+     }
+     if (currprefs.comptrustlong < 0 || currprefs.comptrustlong > 3) {
+ 	fprintf (stderr, "Bad value for comptrustlong parameter: value must be within 0..2\n");
+ 	currprefs.comptrustlong = 1;
+ 	err = 1;
+     }
+     if (currprefs.comptrustnaddr < 0 || currprefs.comptrustnaddr > 3) {
+ 	fprintf (stderr, "Bad value for comptrustnaddr parameter: value must be within 0..2\n");
+ 	currprefs.comptrustnaddr = 1;
+ 	err = 1;
+     }
+     if (currprefs.compnf < 0 || currprefs.compnf > 1) {
+ 	fprintf (stderr, "Bad value for compnf parameter: value must be within 0..1\n");
+ 	currprefs.compnf = 1;
+ 	err = 1;
+     }
+     if (currprefs.comp_hardflush < 0 || currprefs.comp_hardflush > 1) {
+ 	fprintf (stderr, "Bad value for comp_hardflush parameter: value must be within 0..1\n");
+ 	currprefs.comp_hardflush = 1;
+ 	err = 1;
+     }
+     if (currprefs.comp_constjump < 0 || currprefs.comp_constjump > 1) {
+ 	fprintf (stderr, "Bad value for comp_constjump parameter: value must be within 0..1\n");
+ 	currprefs.comp_constjump = 1;
+ 	err = 1;
+     }
+     if (currprefs.comp_oldsegv < 0 || currprefs.comp_oldsegv > 1) {
+ 	fprintf (stderr, "Bad value for comp_oldsegv parameter: value must be within 0..1\n");
+ 	currprefs.comp_oldsegv = 1;
+ 	err = 1;
+     }
+     if (currprefs.cachesize < 0 || currprefs.cachesize > 16384) {
+ 	fprintf (stderr, "Bad value for cachesize parameter: value must be within 0..16384\n");
+ 	currprefs.cachesize = 2048;
+ 	err = 1;
+     }
+ 
      if (currprefs.cpu_level < 2 && currprefs.z3fastmem_size > 0) {
  	write_log ("Z3 fast memory can't be used with a 68000/68010 emulation. It\n"
  		 "requires a 68020 emulation. Turning off Z3 fast memory.\n");
diff -crB --new-file ./uae-0.8.21/src/Makefile ../uae_jit_cleaning/uae-0.8.21/src/Makefile
*** ./uae-0.8.21/src/Makefile	1970-01-01 02:00:00.000000000 +0200
--- ../uae_jit_cleaning/uae-0.8.21/src/Makefile	2021-01-10 13:54:01.218591684 +0200
***************
*** 0 ****
--- 1,302 ----
+ # Generated automatically from Makefile.in by configure.
+ #
+ # Makefile.in for UAE
+ #
+ 
+ 
+ CC        = gcc
+ WRC       = not-found
+ CPP       = gcc -E
+ LDFLAGS   =  -L.
+ CFLAGS    = -O2 -fomit-frame-pointer  -Wall -Wno-unused -Wno-format -W -Wmissing-prototypes -Wstrict-prototypes   -DJIT -DNATMEM_OFFSET=0x50000000 -DGCCCONSTFUNC="__attribute__((const))" -mpreferred-stack-boundary=2 -fno-exceptions -DUNALIGNED_PROFITABLE -fno-strength-reduce -DREGPARAM="__attribute__((regparm(3)))" -DX86_ASSEMBLY -DOPTIMIZED_FLAGS -DUSE_ZFILE -D__inline__=inline
+ X_CFLAGS  =   -DSHM_SUPPORT_LINKS=1
+ TARGET    = x11
+ LIBRARIES =   -lSM -lICE -lXext -lX11   
+ MATHLIB   = -lm
+ RESOBJS   = 
+ 
+ NO_SCHED_CFLAGS = -mno-schedule-prologue
+ 
+ INSTALL         = @INSTALL@
+ INSTALL_PROGRAM = @INSTALL_PROGRAM@
+ INSTALL_DATA    = @INSTALL_DATA@
+ prefix          = /usr/local
+ exec_prefix     = ${prefix}
+ bindir          = ${exec_prefix}/bin
+ libdir          = ${exec_prefix}/lib
+ sysconfdir      = ${prefix}/etc
+ 
+ 
+ .SUFFIXES: .o .c .h .m .i .S .rc .res
+ 
+ #.SECONDARY: cpuemu.c cpustbl.c cputbl.h
+ 
+ INCLUDES=-I. -I../src/include/
+ 
+ OBJS = main.o newcpu.o memory.o cpufast.o custom.o cia.o serial.o blitter.o \
+        autoconf.o ersatz.o filesys.o hardfile.o keybuf.o expansion.o zfile.o \
+        fpp.o readcpu.o cpudefs.o gfxutil.o gfxlib.o blitfunc.o blittable.o \
+        disk.o audio.o compiler.o uaelib.o drawing.o picasso96.o cpustbl.o \
+        uaeexe.o bsdsocket.o missing.o sd-sound.o od-joy.o md-support.o \
+        fsusage.o cfgfile.o native2amiga.o fsdb_unix.o fsdb.o identify.o \
+        savestate.o writelog.o md-X86.o xwin.o nogui.o debug.o scsi-none.o \
+        compstbl.o compemu.o compemu_support.o compemu_fpp.o cpustbl_nf.o cpufast_nf.o
+ 
+ all: $(TARGET)
+ 
+ x11: progs
+ 
+ svgalib: progs
+ 
+ win32: progs $(RESOBJS)
+ 	$(WRC) $(RESOBJS) uae.exe
+ 
+ ggilib: progs
+ 
+ asciiart: progs
+ 
+ amigaos: progs
+ 
+ p_os: progs
+ 
+ beos: progs
+ 
+ next: progs
+ 	cp uae ../Uae.app/Uae
+ 
+ progs: uae readdisk
+ 
+ install:
+ 
+ readdisk: readdisk.o missing.o
+ 	$(CC) readdisk.o missing.o -o readdisk $(LDFLAGS) $(DEBUGFLAGS)
+ 
+ uae: $(OBJS)
+ 	$(CC) $(OBJS) -o uae $(GFXLDFLAGS) $(LDFLAGS) $(DEBUGFLAGS) $(LIBRARIES) $(MATHLIB)
+ 
+ clean:
+ 	$(MAKE) -C tools clean
+ 	-rm -f $(OBJS) *.o uae readdisk
+ 	-rm -f blit.h cpudefs.c
+ 	-rm -f cpuemu.c build68k cputmp.s cpufast*.s cpustbl.c cputbl.h
+ 	-rm -f blitfunc.c blitfunc.h blittable.c
+ 	-rm -f compemu.c compstbl.c comptbl.h
+ 
+ halfclean:
+ 	-rm -f $(OBJS)
+ 
+ streifenfrei: clean
+ 	-rm -f Makefile sysconfig.h
+ 	-rm -f od-joy.c md-X86.S sd-sound.c md-support.c
+ 	-rm -f machdep osdep threaddep sounddep target.h config.h
+ 
+ blit.h: tools/genblitter
+ 	./tools/genblitter i >blit.h
+ blitfunc.c: tools/genblitter blitfunc.h
+ 	./tools/genblitter f >blitfunc.c
+ blitfunc.h: tools/genblitter
+ 	./tools/genblitter h >blitfunc.h
+ blittable.c: tools/genblitter blitfunc.h
+ 	./tools/genblitter t >blittable.c
+ 
+ tools/genblitter:
+ 	$(MAKE) -C tools genblitter
+ tools/build68k:
+ 	$(MAKE) -C tools build68kc
+ tools/cpuopti:
+ 	$(MAKE) -C tools cpuopti
+ tools/gencpu: 
+ 	$(MAKE) -C tools gencpu
+ tools/gencomp:
+ 	$(MAKE) -C tools gencomp
+ 
+ custom.o: blit.h
+ drawing.o: linetoscr.c
+ 
+ cpudefs.c: tools/build68k ../src/table68k
+ 	./tools/build68k <../src/table68k >cpudefs.c
+ 
+ cpuemu.c: tools/gencpu
+ 	./tools/gencpu
+ 
+ compemu.c: tools/gencomp
+ 	./tools/gencomp
+ 
+ # gencpu also creates cpustbl.c and cputbl.h
+ cpustbl.c: cpuemu.c
+ cputbl.h: cpuemu.c
+ compstbl.c: compemu.c
+ comptbl.h: compemu.c
+ compemu_support.o: compemu_optimizer.c compemu_raw_x86.c
+ 
+ cpufast.s: cpuemu.c tools/cpuopti
+ 	$(CC) $(INCLUDES) -S $(INCDIRS) $(CFLAGS) $(X_CFLAGS) $(DEBUGFLAGS) $(NO_SCHED_CFLAGS) $< -o cputmp.s
+ 	./tools/cpuopti <cputmp.s >$@
+ 	rm cputmp.s
+ 
+ cpufast_nf.s: cpuemu.c tools/cpuopti
+ 	$(CC) $(INCLUDES) -S $(INCDIRS) $(CFLAGS) $(X_CFLAGS) $(DEBUGFLAGS) $(NO_SCHED_CFLAGS) -DNOFLAGS $< -o cputmp_nf.s
+ 	./tools/cpuopti <cputmp_nf.s >$@
+ 	rm cputmp_nf.s
+ 
+ cpuemu_nf.o: cpuemu.c ./tools/cpuopti
+ 	$(CC) $(INCLUDES) -c $(INCDIRS) $(CFLAGS) $(X_CFLAGS) $(DEBUGFLAGS) $(NO_SCHED_CFLAGS) -DNOFLAGS $< -o $@
+ 
+ cpustbl_nf.o: cpustbl.c
+ 	$(CC) $(INCLUDES) -c $(INCDIRS) $(CFLAGS) $(X_CFLAGS) $(DEBUGFLAGS) $(NO_SCHED_CFLAGS) -DNOFLAGS cpustbl.c -o $@
+ 
+ comptest: compemu_support.o compemu.o comptest.o readcpu.o missing.o cpudefs.o compstbl.o 
+ 	$(CC) -o compemu_support.o comptest compemu.o comptest.o readcpu.o \
+ 		missing.o cpudefs.o compstbl.o \
+ 		$(GFXLDFLAGS) $(LDFLAGS) $(DEBUGFLAGS) $(LIBRARIES) $(MATHLIB)
+ 
+ 
+ console_missing.o: missing.c
+ 	$(CC) $(INCLUDES) -c $(INCDIRS) $(CFLAGS) $(X_CFLAGS) $(DEBUGFLAGS) $(CFLAGS_$@) $< -o $@
+ 
+ osdep/beos.o: osdep/beos.cpp
+ 	$(CC) $(INCLUDES) -c $(INCDIRS) $(CFLAGS) $(X_CFLAGS) $(DEBUGFLAGS) osdep/beos.cpp -o osdep/beos.o
+ 
+ .rc.res:
+ 	$(WRC) $(INCLUDES) $<
+ .m.o:
+ 	$(CC) $(INCLUDES) -c $(INCDIRS) $(CFLAGS) $(X_CFLAGS) $(DEBUGFLAGS) $<
+ .c.o:
+ 	$(CC) $(INCLUDES) -c $(INCDIRS) $(CFLAGS) $(X_CFLAGS) $(DEBUGFLAGS) $(CFLAGS_$@) $< -o $@
+ .c.s:
+ 	$(CC) $(INCLUDES) -S $(INCDIRS) $(CFLAGS) $(X_CFLAGS) $(DEBUGFLAGS) $< -o $@
+ .c.i:
+ 	$(CC) $(INCLUDES) -E $(INCDIRS) $(CFLAGS) $(X_CFLAGS) $(DEBUGFLAGS) $< > $@
+ .S.o:
+ 	$(CC) $(INCLUDES) -c $(INCDIRS) $(CFLAGS) $(X_CFLAGS) $(DEBUGFLAGS) $< -o $@
+ .s.o:
+ 	$(CC) $(INCLUDES) -c $(INCDIRS) $(CFLAGS) $(X_CFLAGS) $(DEBUGFLAGS) $< -o $@
+ 
+ # Saves recompiling...
+ touch:
+ 	touch *.o; touch build68k; touch cpudefs.c; touch cpudefs.o; touch gencpu; touch cpuemu.c; touch cpuopti.o cpuopti cpuemu.o cpufast.s cpufast.o
+ 
+ build68k.o: include/readcpu.h
+ readcpu.o: include/readcpu.h
+ 
+ main.o: config.h
+ cia.o: config.h include/events.h
+ custom.o: config.h include/events.h blit.h
+ newcpu.o: config.h include/events.h
+ autoconf.o: config.h
+ expansion.o: config.h
+ xwin.o: config.h
+ svga.o: config.h
+ audio.o: config.h include/events.h
+ memory.o: config.h
+ debug.o: config.h
+ identify.o: config.h
+ fpp.o: config.h
+ ersatz.o: config.h
+ filesys.o: config.h
+ execlib.o: config.h
+ disk.o: config.h include/events.h
+ blitter.o: config.h include/events.h blit.h
+ 
+ # sam: this is for people with low memory. (is there a way do do this with a single rule ?)
+ cpufast1.s: cpuemu.c cpuopti
+ 	$(CC) -DPART_1 $(INCLUDES) -S $(INCDIRS) $(CFLAGS) $(X_CFLAGS) $(DEBUGFLAGS) $(NO_SCHED_CFLAGS) $< -o cputmp1.s
+ 	./tools/cpuopti <cputmp1.s >$@
+ 	rm cputmp1.s
+ cpufast2.s: cpuemu.c cpuopti
+ 	$(CC) -DPART_2 $(INCLUDES) -S $(INCDIRS) $(CFLAGS) $(X_CFLAGS) $(DEBUGFLAGS) $(NO_SCHED_CFLAGS) $< -o cputmp2.s
+ 	./tools/cpuopti <cputmp2.s >$@
+ 	rm cputmp2.s
+ cpufast3.s: cpuemu.c cpuopti
+ 	$(CC) -DPART_3 $(INCLUDES) -S $(INCDIRS) $(CFLAGS) $(X_CFLAGS) $(DEBUGFLAGS) $(NO_SCHED_CFLAGS) $< -o cputmp3.s
+ 	./tools/cpuopti <cputmp3.s >$@
+ 	rm cputmp3.s
+ cpufast4.s: cpuemu.c cpuopti
+ 	$(CC) -DPART_4 $(INCLUDES) -S $(INCDIRS) $(CFLAGS) $(X_CFLAGS) $(DEBUGFLAGS) $(NO_SCHED_CFLAGS) $< -o cputmp4.s
+ 	./tools/cpuopti <cputmp4.s >$@
+ 	rm cputmp4.s
+ cpufast5.s: cpuemu.c cpuopti
+ 	$(CC) -DPART_5 $(INCLUDES) -S $(INCDIRS) $(CFLAGS) $(X_CFLAGS) $(DEBUGFLAGS) $(NO_SCHED_CFLAGS) $< -o cputmp5.s
+ 	./tools/cpuopti <cputmp5.s >$@
+ 	rm cputmp5.s
+ cpufast6.s: cpuemu.c cpuopti
+ 	$(CC) -DPART_6 $(INCLUDES) -S $(INCDIRS) $(CFLAGS) $(X_CFLAGS) $(DEBUGFLAGS) $(NO_SCHED_CFLAGS) $< -o cputmp6.s
+ 	./tools/cpuopti <cputmp6.s >$@
+ 	rm cputmp6.s
+ cpufast7.s: cpuemu.c cpuopti
+ 	$(CC) -DPART_7 $(INCLUDES) -S $(INCDIRS) $(CFLAGS) $(X_CFLAGS) $(DEBUGFLAGS) $(NO_SCHED_CFLAGS) $< -o cputmp7.s
+ 	./tools/cpuopti <cputmp7.s >$@
+ 	rm cputmp7.s
+ cpufast8.s: cpuemu.c cpuopti
+ 	$(CC) -DPART_8 $(INCLUDES) -S $(INCDIRS) $(CFLAGS) $(X_CFLAGS) $(DEBUGFLAGS) $(NO_SCHED_CFLAGS) $< -o cputmp8.s
+ 	./tools/cpuopti <cputmp8.s >$@
+ 	rm cputmp8.s
+ 
+ cpufast1_nf.s: cpuemu.c cpuopti
+ 	$(CC) -DPART_1 $(INCLUDES) -S $(INCDIRS) $(CFLAGS) $(X_CFLAGS) $(DEBUGFLAGS) $(NO_SCHED_CFLAGS) -DNOFLAGS -g0 $< -o cputmp_nf1.s
+ 	./tools/cpuopti <cputmp_nf1.s >$@
+ 	rm cputmp_nf1.s
+ cpufast2_nf.s: cpuemu.c cpuopti
+ 	$(CC) -DPART_2 $(INCLUDES) -S $(INCDIRS) $(CFLAGS) $(X_CFLAGS) $(DEBUGFLAGS) $(NO_SCHED_CFLAGS) -DNOFLAGS -g0 $< -o cputmp_nf2.s
+ 	./tools/cpuopti <cputmp_nf2.s >$@
+ 	rm cputmp_nf2.s
+ cpufast3_nf.s: cpuemu.c cpuopti
+ 	$(CC) -DPART_3 $(INCLUDES) -S $(INCDIRS) $(CFLAGS) $(X_CFLAGS) $(DEBUGFLAGS) $(NO_SCHED_CFLAGS) -DNOFLAGS -g0 $< -o cputmp_nf3.s
+ 	./tools/cpuopti <cputmp_nf3.s >$@
+ 	rm cputmp_nf3.s
+ cpufast4_nf.s: cpuemu.c cpuopti
+ 	$(CC) -DPART_4 $(INCLUDES) -S $(INCDIRS) $(CFLAGS) $(X_CFLAGS) $(DEBUGFLAGS) $(NO_SCHED_CFLAGS) -DNOFLAGS -g0 $< -o cputmp_nf4.s
+ 	./tools/cpuopti <cputmp_nf4.s >$@
+ 	rm cputmp_nf4.s
+ cpufast5_nf.s: cpuemu.c cpuopti
+ 	$(CC) -DPART_5 $(INCLUDES) -S $(INCDIRS) $(CFLAGS) $(X_CFLAGS) $(DEBUGFLAGS) $(NO_SCHED_CFLAGS) -DNOFLAGS -g0 $< -o cputmp_nf5.s
+ 	./tools/cpuopti <cputmp_nf5.s >$@
+ 	rm cputmp_nf5.s
+ cpufast6_nf.s: cpuemu.c cpuopti
+ 	$(CC) -DPART_6 $(INCLUDES) -S $(INCDIRS) $(CFLAGS) $(X_CFLAGS) $(DEBUGFLAGS) $(NO_SCHED_CFLAGS) -DNOFLAGS -g0 $< -o cputmp_nf6.s
+ 	./tools/cpuopti <cputmp_nf6.s >$@
+ 	rm cputmp_nf6.s
+ cpufast7_nf.s: cpuemu.c cpuopti
+ 	$(CC) -DPART_7 $(INCLUDES) -S $(INCDIRS) $(CFLAGS) $(X_CFLAGS) $(DEBUGFLAGS) $(NO_SCHED_CFLAGS) -DNOFLAGS -g0 $< -o cputmp_nf7.s
+ 	./tools/cpuopti <cputmp_nf7.s >$@
+ 	rm cputmp_nf7.s
+ cpufast8_nf.s: cpuemu.c cpuopti
+ 	$(CC) -DPART_8 $(INCLUDES) -S $(INCDIRS) $(CFLAGS) $(X_CFLAGS) $(DEBUGFLAGS) $(NO_SCHED_CFLAGS) -DNOFLAGS -g0 $< -o cputmp_nf8.s
+ 	./tools/cpuopti <cputmp_nf8.s >$@
+ 	rm cputmp_nf8.s
+ 
+ cpuemu1.o: cpuemu.c
+ 	$(CC) -DPART_1 $(INCLUDES) -c $(INCDIRS) $(CFLAGS) $(X_CFLAGS) $(DEBUGFLAGS) $< -o $@
+ cpuemu2.o: cpuemu.c
+ 	$(CC) -DPART_2 $(INCLUDES) -c $(INCDIRS) $(CFLAGS) $(X_CFLAGS) $(DEBUGFLAGS) $< -o $@
+ cpuemu3.o: cpuemu.c
+ 	$(CC) -DPART_3 $(INCLUDES) -c $(INCDIRS) $(CFLAGS) $(X_CFLAGS) $(DEBUGFLAGS) $< -o $@
+ cpuemu4.o: cpuemu.c
+ 	$(CC) -DPART_4 $(INCLUDES) -c $(INCDIRS) $(CFLAGS) $(X_CFLAGS) $(DEBUGFLAGS) $< -o $@
+ cpuemu5.o: cpuemu.c
+ 	$(CC) -DPART_5 $(INCLUDES) -c $(INCDIRS) $(CFLAGS) $(X_CFLAGS) $(DEBUGFLAGS) $< -o $@
+ cpuemu6.o: cpuemu.c
+ 	$(CC) -DPART_6 $(INCLUDES) -c $(INCDIRS) $(CFLAGS) $(X_CFLAGS) $(DEBUGFLAGS) $< -o $@
+ cpuemu7.o: cpuemu.c
+ 	$(CC) -DPART_7 $(INCLUDES) -c $(INCDIRS) $(CFLAGS) $(X_CFLAGS) $(DEBUGFLAGS) $< -o $@
+ cpuemu8.o: cpuemu.c
+ 	$(CC) -DPART_8 $(INCLUDES) -c $(INCDIRS) $(CFLAGS) $(X_CFLAGS) $(DEBUGFLAGS) $< -o $@
+ 
+ 
+ cpuemu1_nf.o: cpuemu.c
+ 	$(CC) -DPART_1 $(INCLUDES) -c $(INCDIRS) $(CFLAGS) $(X_CFLAGS) $(DEBUGFLAGS) -DNOFLAGS $< -o $@
+ cpuemu2_nf.o: cpuemu.c
+ 	$(CC) -DPART_2 $(INCLUDES) -c $(INCDIRS) $(CFLAGS) $(X_CFLAGS) $(DEBUGFLAGS) -DNOFLAGS $< -o $@
+ cpuemu3_nf.o: cpuemu.c
+ 	$(CC) -DPART_3 $(INCLUDES) -c $(INCDIRS) $(CFLAGS) $(X_CFLAGS) $(DEBUGFLAGS) -DNOFLAGS $< -o $@
+ cpuemu4_nf.o: cpuemu.c
+ 	$(CC) -DPART_4 $(INCLUDES) -c $(INCDIRS) $(CFLAGS) $(X_CFLAGS) $(DEBUGFLAGS) -DNOFLAGS $< -o $@
+ cpuemu5_nf.o: cpuemu.c
+ 	$(CC) -DPART_5 $(INCLUDES) -c $(INCDIRS) $(CFLAGS) $(X_CFLAGS) $(DEBUGFLAGS) -DNOFLAGS $< -o $@
+ cpuemu6_nf.o: cpuemu.c
+ 	$(CC) -DPART_6 $(INCLUDES) -c $(INCDIRS) $(CFLAGS) $(X_CFLAGS) $(DEBUGFLAGS) -DNOFLAGS $< -o $@
+ cpuemu7_nf.o: cpuemu.c
+ 	$(CC) -DPART_7 $(INCLUDES) -c $(INCDIRS) $(CFLAGS) $(X_CFLAGS) $(DEBUGFLAGS) -DNOFLAGS $< -o $@
+ cpuemu8_nf.o: cpuemu.c
+ 	$(CC) -DPART_8 $(INCLUDES) -c $(INCDIRS) $(CFLAGS) $(X_CFLAGS) $(DEBUGFLAGS) -DNOFLAGS $< -o $@
+ 
diff -crB --new-file ./uae-0.8.21/src/Makefile.in ../uae_jit_cleaning/uae-0.8.21/src/Makefile.in
*** ./uae-0.8.21/src/Makefile.in	2001-11-19 14:34:18.000000000 +0200
--- ../uae_jit_cleaning/uae-0.8.21/src/Makefile.in	2021-01-10 13:10:29.826591684 +0200
***************
*** 39,46 ****
         disk.o audio.o compiler.o uaelib.o drawing.o picasso96.o cpustbl.o \
         uaeexe.o bsdsocket.o missing.o sd-sound.o od-joy.o md-support.o \
         fsusage.o cfgfile.o native2amiga.o @FSDBOBJS@ fsdb.o identify.o \
!        savestate.o writelog.o @ASMOBJS@ @GFXOBJS@ @DEBUGOBJS@ @SCSIOBJS@
! 
  
  all: $(TARGET)
  
--- 39,46 ----
         disk.o audio.o compiler.o uaelib.o drawing.o picasso96.o cpustbl.o \
         uaeexe.o bsdsocket.o missing.o sd-sound.o od-joy.o md-support.o \
         fsusage.o cfgfile.o native2amiga.o @FSDBOBJS@ fsdb.o identify.o \
!        savestate.o writelog.o @ASMOBJS@ @GFXOBJS@ @DEBUGOBJS@ @SCSIOBJS@ \
!        @JITOBJS@
  
  all: $(TARGET)
  
***************
*** 80,85 ****
--- 80,86 ----
  	-rm -f blit.h cpudefs.c
  	-rm -f cpuemu.c build68k cputmp.s cpufast*.s cpustbl.c cputbl.h
  	-rm -f blitfunc.c blitfunc.h blittable.c
+ 	-rm -f compemu.c compstbl.c comptbl.h
  
  halfclean:
  	-rm -f $(OBJS)
***************
*** 106,111 ****
--- 107,114 ----
  	$(MAKE) -C tools cpuopti
  tools/gencpu: 
  	$(MAKE) -C tools gencpu
+ tools/gencomp:
+ 	$(MAKE) -C tools gencomp
  
  custom.o: blit.h
  drawing.o: linetoscr.c
***************
*** 116,130 ****
--- 119,156 ----
  cpuemu.c: tools/gencpu
  	./tools/gencpu
  
+ compemu.c: tools/gencomp
+ 	./tools/gencomp
+ 
  # gencpu also creates cpustbl.c and cputbl.h
  cpustbl.c: cpuemu.c
  cputbl.h: cpuemu.c
+ compstbl.c: compemu.c
+ comptbl.h: compemu.c
+ compemu_support.o: compemu_optimizer.c compemu_raw_x86.c
  
  cpufast.s: cpuemu.c tools/cpuopti
  	$(CC) $(INCLUDES) -S $(INCDIRS) $(CFLAGS) $(X_CFLAGS) $(DEBUGFLAGS) $(NO_SCHED_CFLAGS) $< -o cputmp.s
  	./tools/cpuopti <cputmp.s >$@
  	rm cputmp.s
  
+ cpufast_nf.s: cpuemu.c tools/cpuopti
+ 	$(CC) $(INCLUDES) -S $(INCDIRS) $(CFLAGS) $(X_CFLAGS) $(DEBUGFLAGS) $(NO_SCHED_CFLAGS) -DNOFLAGS $< -o cputmp_nf.s
+ 	./tools/cpuopti <cputmp_nf.s >$@
+ 	rm cputmp_nf.s
+ 
+ cpuemu_nf.o: cpuemu.c ./tools/cpuopti
+ 	$(CC) $(INCLUDES) -c $(INCDIRS) $(CFLAGS) $(X_CFLAGS) $(DEBUGFLAGS) $(NO_SCHED_CFLAGS) -DNOFLAGS $< -o $@
+ 
+ cpustbl_nf.o: cpustbl.c
+ 	$(CC) $(INCLUDES) -c $(INCDIRS) $(CFLAGS) $(X_CFLAGS) $(DEBUGFLAGS) $(NO_SCHED_CFLAGS) -DNOFLAGS cpustbl.c -o $@
+ 
+ comptest: compemu_support.o compemu.o comptest.o readcpu.o missing.o cpudefs.o compstbl.o 
+ 	$(CC) -o compemu_support.o comptest compemu.o comptest.o readcpu.o \
+ 		missing.o cpudefs.o compstbl.o \
+ 		$(GFXLDFLAGS) $(LDFLAGS) $(DEBUGFLAGS) $(LIBRARIES) $(MATHLIB)
+ 
+ 
  console_missing.o: missing.c
  	$(CC) $(INCLUDES) -c $(INCDIRS) $(CFLAGS) $(X_CFLAGS) $(DEBUGFLAGS) $(CFLAGS_$@) $< -o $@
  
***************
*** 206,211 ****
--- 232,270 ----
  	./tools/cpuopti <cputmp8.s >$@
  	rm cputmp8.s
  
+ cpufast1_nf.s: cpuemu.c cpuopti
+ 	$(CC) -DPART_1 $(INCLUDES) -S $(INCDIRS) $(CFLAGS) $(X_CFLAGS) $(DEBUGFLAGS) $(NO_SCHED_CFLAGS) -DNOFLAGS -g0 $< -o cputmp_nf1.s
+ 	./tools/cpuopti <cputmp_nf1.s >$@
+ 	rm cputmp_nf1.s
+ cpufast2_nf.s: cpuemu.c cpuopti
+ 	$(CC) -DPART_2 $(INCLUDES) -S $(INCDIRS) $(CFLAGS) $(X_CFLAGS) $(DEBUGFLAGS) $(NO_SCHED_CFLAGS) -DNOFLAGS -g0 $< -o cputmp_nf2.s
+ 	./tools/cpuopti <cputmp_nf2.s >$@
+ 	rm cputmp_nf2.s
+ cpufast3_nf.s: cpuemu.c cpuopti
+ 	$(CC) -DPART_3 $(INCLUDES) -S $(INCDIRS) $(CFLAGS) $(X_CFLAGS) $(DEBUGFLAGS) $(NO_SCHED_CFLAGS) -DNOFLAGS -g0 $< -o cputmp_nf3.s
+ 	./tools/cpuopti <cputmp_nf3.s >$@
+ 	rm cputmp_nf3.s
+ cpufast4_nf.s: cpuemu.c cpuopti
+ 	$(CC) -DPART_4 $(INCLUDES) -S $(INCDIRS) $(CFLAGS) $(X_CFLAGS) $(DEBUGFLAGS) $(NO_SCHED_CFLAGS) -DNOFLAGS -g0 $< -o cputmp_nf4.s
+ 	./tools/cpuopti <cputmp_nf4.s >$@
+ 	rm cputmp_nf4.s
+ cpufast5_nf.s: cpuemu.c cpuopti
+ 	$(CC) -DPART_5 $(INCLUDES) -S $(INCDIRS) $(CFLAGS) $(X_CFLAGS) $(DEBUGFLAGS) $(NO_SCHED_CFLAGS) -DNOFLAGS -g0 $< -o cputmp_nf5.s
+ 	./tools/cpuopti <cputmp_nf5.s >$@
+ 	rm cputmp_nf5.s
+ cpufast6_nf.s: cpuemu.c cpuopti
+ 	$(CC) -DPART_6 $(INCLUDES) -S $(INCDIRS) $(CFLAGS) $(X_CFLAGS) $(DEBUGFLAGS) $(NO_SCHED_CFLAGS) -DNOFLAGS -g0 $< -o cputmp_nf6.s
+ 	./tools/cpuopti <cputmp_nf6.s >$@
+ 	rm cputmp_nf6.s
+ cpufast7_nf.s: cpuemu.c cpuopti
+ 	$(CC) -DPART_7 $(INCLUDES) -S $(INCDIRS) $(CFLAGS) $(X_CFLAGS) $(DEBUGFLAGS) $(NO_SCHED_CFLAGS) -DNOFLAGS -g0 $< -o cputmp_nf7.s
+ 	./tools/cpuopti <cputmp_nf7.s >$@
+ 	rm cputmp_nf7.s
+ cpufast8_nf.s: cpuemu.c cpuopti
+ 	$(CC) -DPART_8 $(INCLUDES) -S $(INCDIRS) $(CFLAGS) $(X_CFLAGS) $(DEBUGFLAGS) $(NO_SCHED_CFLAGS) -DNOFLAGS -g0 $< -o cputmp_nf8.s
+ 	./tools/cpuopti <cputmp_nf8.s >$@
+ 	rm cputmp_nf8.s
+ 
  cpuemu1.o: cpuemu.c
  	$(CC) -DPART_1 $(INCLUDES) -c $(INCDIRS) $(CFLAGS) $(X_CFLAGS) $(DEBUGFLAGS) $< -o $@
  cpuemu2.o: cpuemu.c
***************
*** 222,224 ****
--- 281,302 ----
  	$(CC) -DPART_7 $(INCLUDES) -c $(INCDIRS) $(CFLAGS) $(X_CFLAGS) $(DEBUGFLAGS) $< -o $@
  cpuemu8.o: cpuemu.c
  	$(CC) -DPART_8 $(INCLUDES) -c $(INCDIRS) $(CFLAGS) $(X_CFLAGS) $(DEBUGFLAGS) $< -o $@
+ 
+ 
+ cpuemu1_nf.o: cpuemu.c
+ 	$(CC) -DPART_1 $(INCLUDES) -c $(INCDIRS) $(CFLAGS) $(X_CFLAGS) $(DEBUGFLAGS) -DNOFLAGS $< -o $@
+ cpuemu2_nf.o: cpuemu.c
+ 	$(CC) -DPART_2 $(INCLUDES) -c $(INCDIRS) $(CFLAGS) $(X_CFLAGS) $(DEBUGFLAGS) -DNOFLAGS $< -o $@
+ cpuemu3_nf.o: cpuemu.c
+ 	$(CC) -DPART_3 $(INCLUDES) -c $(INCDIRS) $(CFLAGS) $(X_CFLAGS) $(DEBUGFLAGS) -DNOFLAGS $< -o $@
+ cpuemu4_nf.o: cpuemu.c
+ 	$(CC) -DPART_4 $(INCLUDES) -c $(INCDIRS) $(CFLAGS) $(X_CFLAGS) $(DEBUGFLAGS) -DNOFLAGS $< -o $@
+ cpuemu5_nf.o: cpuemu.c
+ 	$(CC) -DPART_5 $(INCLUDES) -c $(INCDIRS) $(CFLAGS) $(X_CFLAGS) $(DEBUGFLAGS) -DNOFLAGS $< -o $@
+ cpuemu6_nf.o: cpuemu.c
+ 	$(CC) -DPART_6 $(INCLUDES) -c $(INCDIRS) $(CFLAGS) $(X_CFLAGS) $(DEBUGFLAGS) -DNOFLAGS $< -o $@
+ cpuemu7_nf.o: cpuemu.c
+ 	$(CC) -DPART_7 $(INCLUDES) -c $(INCDIRS) $(CFLAGS) $(X_CFLAGS) $(DEBUGFLAGS) -DNOFLAGS $< -o $@
+ cpuemu8_nf.o: cpuemu.c
+ 	$(CC) -DPART_8 $(INCLUDES) -c $(INCDIRS) $(CFLAGS) $(X_CFLAGS) $(DEBUGFLAGS) -DNOFLAGS $< -o $@
+ 
diff -crB --new-file ./uae-0.8.21/src/md-fpp.h ../uae_jit_cleaning/uae-0.8.21/src/md-fpp.h
*** ./uae-0.8.21/src/md-fpp.h	1970-01-01 02:00:00.000000000 +0200
--- ../uae_jit_cleaning/uae-0.8.21/src/md-fpp.h	2021-01-10 13:54:02.642591684 +0200
***************
*** 0 ****
--- 1 ----
+ #include "/home/osboxes/uae_Archives/build_0_8_21_jit/uae_jit_cleaning/uae-0.8.21/src/include/fpp-unknown.h"
diff -crB --new-file ./uae-0.8.21/src/md-i386-gcc/m68k.h ../uae_jit_cleaning/uae-0.8.21/src/md-i386-gcc/m68k.h
*** ./uae-0.8.21/src/md-i386-gcc/m68k.h	2000-08-16 01:21:41.000000000 +0300
--- ../uae_jit_cleaning/uae-0.8.21/src/md-i386-gcc/m68k.h	2021-01-10 13:10:29.918591684 +0200
***************
*** 1,3 ****
--- 1,6 ----
+ #ifndef M68K_H
+ #define M68K_H
+ 
   /* 
    * UAE - The Un*x Amiga Emulator
    * 
***************
*** 32,50 ****
      unsigned int x;
  };
  
! #define FLAGVAL_Z 0x40
! #define FLAGVAL_N 0x80
  
! #define SET_ZFLG(y) (regflags.cznv = (regflags.cznv & ~0x40) | (((y) & 1) << 6))
! #define SET_CFLG(y) (regflags.cznv = (regflags.cznv & ~1) | ((y) & 1))
! #define SET_VFLG(y) (regflags.cznv = (regflags.cznv & ~0x800) | (((y) & 1) << 11))
! #define SET_NFLG(y) (regflags.cznv = (regflags.cznv & ~0x80) | (((y) & 1) << 7))
  #define SET_XFLG(y) (regflags.x = (y))
  
! #define GET_ZFLG ((regflags.cznv >> 6) & 1)
! #define GET_CFLG (regflags.cznv & 1)
! #define GET_VFLG ((regflags.cznv >> 11) & 1)
! #define GET_NFLG ((regflags.cznv >> 7) & 1)
  #define GET_XFLG (regflags.x & 1)
  
  #define CLEAR_CZNV (regflags.cznv = 0)
--- 35,53 ----
      unsigned int x;
  };
  
! #define FLAGVAL_Z 0x4000
! #define FLAGVAL_N 0x8000
  
! #define SET_ZFLG(y) (regflags.cznv = (regflags.cznv & ~0x4000) | (((y) & 1) << 14))
! #define SET_CFLG(y) (regflags.cznv = (regflags.cznv & ~0x100) | (((y) & 1) << 8))
! #define SET_VFLG(y) (regflags.cznv = (regflags.cznv & ~0x1) | (((y) & 1)))
! #define SET_NFLG(y) (regflags.cznv = (regflags.cznv & ~0x8000) | (((y) & 1) << 15))
  #define SET_XFLG(y) (regflags.x = (y))
  
! #define GET_ZFLG ((regflags.cznv >> 14) & 1)
! #define GET_CFLG ((regflags.cznv >> 8) & 1)
! #define GET_VFLG ((regflags.cznv >> 0) & 1)
! #define GET_NFLG ((regflags.cznv >> 15) & 1)
  #define GET_XFLG (regflags.x & 1)
  
  #define CLEAR_CZNV (regflags.cznv = 0)
***************
*** 52,58 ****
  #define IOR_CZNV(X) (regflags.cznv |= (X))
  #define SET_CZNV(X) (regflags.cznv = (X))
  
! #define COPY_CARRY (regflags.x = regflags.cznv)
  
  
  #endif
--- 55,61 ----
  #define IOR_CZNV(X) (regflags.cznv |= (X))
  #define SET_CZNV(X) (regflags.cznv = (X))
  
! #define COPY_CARRY (regflags.x = (regflags.cznv)>>8)
  
  
  #endif
***************
*** 65,173 ****
      switch(cc){
       case 0: return 1;                       /* T */
       case 1: return 0;                       /* F */
!      case 2: return (cznv & 0x41) == 0; /* !GET_CFLG && !GET_ZFLG;  HI */
!      case 3: return (cznv & 0x41) != 0; /* GET_CFLG || GET_ZFLG;    LS */
!      case 4: return (cznv & 1) == 0;        /* !GET_CFLG;               CC */
!      case 5: return (cznv & 1) != 0;           /* GET_CFLG;                CS */
!      case 6: return (cznv & 0x40) == 0; /* !GET_ZFLG;               NE */
!      case 7: return (cznv & 0x40) != 0; /* GET_ZFLG;                EQ */
!      case 8: return (cznv & 0x800) == 0;/* !GET_VFLG;               VC */
!      case 9: return (cznv & 0x800) != 0;/* GET_VFLG;                VS */
!      case 10:return (cznv & 0x80) == 0; /* !GET_NFLG;               PL */
!      case 11:return (cznv & 0x80) != 0; /* GET_NFLG;                MI */
!      case 12:return (((cznv << 4) ^ cznv) & 0x800) == 0; /* GET_NFLG == GET_VFLG;             GE */
!      case 13:return (((cznv << 4) ^ cznv) & 0x800) != 0;/* GET_NFLG != GET_VFLG;             LT */
       case 14:
! 	cznv &= 0x8c0;
! 	return (((cznv << 4) ^ cznv) & 0x840) == 0; /* !GET_ZFLG && (GET_NFLG == GET_VFLG);  GT */
       case 15:
! 	cznv &= 0x8c0;
! 	return (((cznv << 4) ^ cznv) & 0x840) != 0; /* GET_ZFLG || (GET_NFLG != GET_VFLG);   LE */
      }
      abort();
      return 0;
  }
  
  #define optflag_testl(v) \
!   __asm__ __volatile__ ("testl %1,%1\n\t" \
! 			"pushfl\n\t" \
! 			"popl %0\n\t" \
! 			: "=r" (regflags.cznv) : "r" (v) : "cc")
! 
  #define optflag_testw(v) \
!   __asm__ __volatile__ ("testw %w1,%w1\n\t" \
! 			"pushfl\n\t" \
! 			"popl %0\n\t" \
! 			: "=r" (regflags.cznv) : "r" (v) : "cc")
  
  #define optflag_testb(v) \
!   __asm__ __volatile__ ("testb %b1,%b1\n\t" \
! 			"pushfl\n\t" \
! 			"popl %0\n\t" \
! 			: "=r" (regflags.cznv) : "q" (v) : "cc")
  
  #define optflag_addl(v, s, d) do { \
!   __asm__ __volatile__ ("addl %k2,%k1\n\t" \
! 			"pushfl\n\t" \
! 			"popl %0\n\t" \
! 			: "=r" (regflags.cznv), "=r" (v) : "rmi" (s), "1" (d) : "cc"); \
      COPY_CARRY; \
      } while (0)
  #define optflag_addw(v, s, d) do { \
!   __asm__ __volatile__ ("addw %w2,%w1\n\t" \
! 			"pushfl\n\t" \
! 			"popl %0\n\t" \
! 			: "=r" (regflags.cznv), "=r" (v) : "rmi" (s), "1" (d) : "cc"); \
      COPY_CARRY; \
      } while (0)
  
  #define optflag_addb(v, s, d) do { \
!   __asm__ __volatile__ ("addb %b2,%b1\n\t" \
! 			"pushfl\n\t" \
! 			"popl %0\n\t" \
! 			: "=r" (regflags.cznv), "=q" (v) : "qmi" (s), "1" (d) : "cc"); \
      COPY_CARRY; \
      } while (0)
  
  #define optflag_subl(v, s, d) do { \
!   __asm__ __volatile__ ("subl %k2,%k1\n\t" \
! 			"pushfl\n\t" \
! 			"popl %0\n\t" \
! 			: "=r" (regflags.cznv), "=r" (v) : "rmi" (s), "1" (d) : "cc"); \
      COPY_CARRY; \
      } while (0)
  
  #define optflag_subw(v, s, d) do { \
!   __asm__ __volatile__ ("subw %w2,%w1\n\t" \
! 			"pushfl\n\t" \
! 			"popl %0\n\t" \
! 			: "=r" (regflags.cznv), "=r" (v) : "rmi" (s), "1" (d) : "cc"); \
      COPY_CARRY; \
      } while (0)
  
  #define optflag_subb(v, s, d) do { \
!   __asm__ __volatile__ ("subb %b2,%b1\n\t" \
! 			"pushfl\n\t" \
! 			"popl %0\n\t" \
! 			: "=r" (regflags.cznv), "=q" (v) : "qmi" (s), "1" (d) : "cc"); \
      COPY_CARRY; \
      } while (0)
  
  #define optflag_cmpl(s, d) \
!   __asm__ __volatile__ ("cmpl %k1,%k2\n\t" \
! 			"pushfl\n\t" \
! 			"popl %0\n\t" \
! 			: "=r" (regflags.cznv) : "rmi" (s), "r" (d) : "cc")
  
  #define optflag_cmpw(s, d) \
!   __asm__ __volatile__ ("cmpw %w1,%w2\n\t" \
! 			"pushfl\n\t" \
! 			"popl %0\n\t" \
! 			: "=r" (regflags.cznv) : "rmi" (s), "r" (d) : "cc")
  
  #define optflag_cmpb(s, d) \
!   __asm__ __volatile__ ("cmpb %b1,%b2\n\t" \
! 			"pushfl\n\t" \
! 			"popl %0\n\t" \
! 			: "=r" (regflags.cznv) : "qmi" (s), "q" (d) : "cc")
  
--- 68,206 ----
      switch(cc){
       case 0: return 1;                       /* T */
       case 1: return 0;                       /* F */
!      case 2: return (cznv & 0x4100) == 0; /* !GET_CFLG && !GET_ZFLG;  HI */
!      case 3: return (cznv & 0x4100) != 0; /* GET_CFLG || GET_ZFLG;    LS */
!      case 4: return (cznv & 0x100) == 0;  /* !GET_CFLG;               CC */
!      case 5: return (cznv & 0x100) != 0;  /* GET_CFLG;                CS */
!      case 6: return (cznv & 0x4000) == 0; /* !GET_ZFLG;               NE */
!      case 7: return (cznv & 0x4000) != 0; /* GET_ZFLG;                EQ */
!      case 8: return (cznv & 0x01) == 0;   /* !GET_VFLG;               VC */
!      case 9: return (cznv & 0x01) != 0;   /* GET_VFLG;                VS */
!      case 10:return (cznv & 0x8000) == 0; /* !GET_NFLG;               PL */
!      case 11:return (cznv & 0x8000) != 0; /* GET_NFLG;                MI */
!      case 12:return (((cznv << 15) ^ cznv) & 0x8000) == 0; /* GET_NFLG == GET_VFLG;             GE */
!      case 13:return (((cznv << 15) ^ cznv) & 0x8000) != 0;/* GET_NFLG != GET_VFLG;             LT */
       case 14:
! 	cznv &= 0xc001;
! 	return (((cznv << 15) ^ cznv) & 0xc000) == 0; /* !GET_ZFLG && (GET_NFLG == GET_VFLG);  GT */
       case 15:
! 	cznv &= 0xc001;
! 	return (((cznv << 15) ^ cznv) & 0xc000) != 0; /* GET_ZFLG || (GET_NFLG != GET_VFLG);   LE */
      }
      abort();
      return 0;
  }
  
+ /* Is there any way to do this without declaring *all* memory clobbered?
+    I.e. any way to tell gcc that some byte-sized value is in %al? */
  #define optflag_testl(v) \
!   __asm__ __volatile__ ("andl %0,%0\n\t" \
! 			"lahf\n\t" \
! 			"seto %%al\n\t" \
!                         "movb %%al,regflags\n\t" \
! 			"movb %%ah,regflags+1\n\t" \
! 			:: "r" (v) : "%eax","cc","memory")
  #define optflag_testw(v) \
!   __asm__ __volatile__ ("andw %w0,%w0\n\t" \
! 			"lahf\n\t" \
! 			"seto %%al\n\t" \
!                         "movb %%al,regflags\n\t" \
! 			"movb %%ah,regflags+1\n\t" \
! 			:: "r" (v) : "%eax","cc","memory")
  
  #define optflag_testb(v) \
!   __asm__ __volatile__ ("andb %b0,%b0\n\t" \
! 			"lahf\n\t" \
! 			"seto %%al\n\t" \
!                         "movb %%al,regflags\n\t" \
! 			"movb %%ah,regflags+1\n\t" \
! 			:: "q" (v) : "%eax","cc","memory")
  
  #define optflag_addl(v, s, d) do { \
!   __asm__ __volatile__ ("addl %k1,%k0\n\t" \
! 			"lahf\n\t" \
! 			"seto %%al\n\t" \
!                         "movb %%al,regflags\n\t" \
! 			"movb %%ah,regflags+1\n\t" \
! 			:"=r" (v) : "rmi" (s), "0" (d) : "%eax","cc","memory"); \
      COPY_CARRY; \
      } while (0)
  #define optflag_addw(v, s, d) do { \
!   __asm__ __volatile__ ("addw %w1,%w0\n\t" \
! 			"lahf\n\t" \
! 			"seto %%al\n\t" \
!                         "movb %%al,regflags\n\t" \
! 			"movb %%ah,regflags+1\n\t" \
! 			: "=r" (v) : "rmi" (s), "0" (d) : "%eax","cc","memory"); \
      COPY_CARRY; \
      } while (0)
  
  #define optflag_addb(v, s, d) do { \
!   __asm__ __volatile__ ("addb %b1,%b0\n\t" \
! 			"lahf\n\t" \
! 			"seto %%al\n\t" \
!                         "movb %%al,regflags\n\t" \
! 			"movb %%ah,regflags+1\n\t" \
! 			:"=q" (v) : "qmi" (s), "0" (d) : "%eax","cc","memory"); \
      COPY_CARRY; \
      } while (0)
  
  #define optflag_subl(v, s, d) do { \
!   __asm__ __volatile__ ("subl %k1,%k0\n\t" \
! 			"lahf\n\t" \
! 			"seto %%al\n\t" \
!                         "movb %%al,regflags\n\t" \
! 			"movb %%ah,regflags+1\n\t" \
! 			: "=r" (v) : "rmi" (s), "0" (d) : "%eax","cc","memory"); \
      COPY_CARRY; \
      } while (0)
  
  #define optflag_subw(v, s, d) do { \
!   __asm__ __volatile__ ("subw %w1,%w0\n\t" \
! 			"lahf\n\t" \
! 			"seto %%al\n\t" \
!                         "movb %%al,regflags\n\t" \
! 			"movb %%ah,regflags+1\n\t" \
! 			: "=r" (v) : "rmi" (s), "0" (d) : "%eax","cc","memory"); \
      COPY_CARRY; \
      } while (0)
  
  #define optflag_subb(v, s, d) do { \
!    __asm__ __volatile__ ("subb %b1,%b0\n\t" \
! 			"lahf\n\t" \
! 			"seto %%al\n\t" \
!                         "movb %%al,regflags\n\t" \
! 			"movb %%ah,regflags+1\n\t" \
! 			: "=q" (v) : "qmi" (s), "0" (d) : "%eax","cc","memory"); \
      COPY_CARRY; \
      } while (0)
  
  #define optflag_cmpl(s, d) \
!   __asm__ __volatile__ ("cmpl %k0,%k1\n\t" \
! 			"lahf\n\t" \
! 			"seto %%al\n\t" \
!                         "movb %%al,regflags\n\t" \
! 			"movb %%ah,regflags+1\n\t" \
! 			:: "rmi" (s), "r" (d) : "%eax","cc","memory")
  
  #define optflag_cmpw(s, d) \
!   __asm__ __volatile__ ("cmpw %w0,%w1\n\t" \
! 			"lahf\n\t" \
! 			"seto %%al\n\t" \
!                         "movb %%al,regflags\n\t" \
! 			"movb %%ah,regflags+1\n\t" \
! 			:: "rmi" (s), "r" (d) : "%eax","cc","memory");
  
  #define optflag_cmpb(s, d) \
!   __asm__ __volatile__ ("cmpb %b0,%b1\n\t" \
! 			"lahf\n\t" \
! 			"seto %%al\n\t" \
!                         "movb %%al,regflags\n\t" \
! 			"movb %%ah,regflags+1\n\t" \
! 			:: "qmi" (s), "q" (d) : "%eax","cc","memory")
! 
! 
! #endif
! 
! 
  
diff -crB --new-file ./uae-0.8.21/src/md-support.c ../uae_jit_cleaning/uae-0.8.21/src/md-support.c
*** ./uae-0.8.21/src/md-support.c	1970-01-01 02:00:00.000000000 +0200
--- ../uae_jit_cleaning/uae-0.8.21/src/md-support.c	2021-01-10 13:54:02.642591684 +0200
***************
*** 0 ****
--- 1 ----
+ #include "/home/osboxes/uae_Archives/build_0_8_21_jit/uae_jit_cleaning/uae-0.8.21/src/md-i386-gcc/support.c"
diff -crB --new-file ./uae-0.8.21/src/md-X86.S ../uae_jit_cleaning/uae-0.8.21/src/md-X86.S
*** ./uae-0.8.21/src/md-X86.S	1970-01-01 02:00:00.000000000 +0200
--- ../uae_jit_cleaning/uae-0.8.21/src/md-X86.S	2021-01-10 13:54:02.642591684 +0200
***************
*** 0 ****
--- 1 ----
+ #include "machdep/X86.S"
diff -crB --new-file ./uae-0.8.21/src/memory.c ../uae_jit_cleaning/uae-0.8.21/src/memory.c
*** ./uae-0.8.21/src/memory.c	2002-02-16 16:29:42.000000000 +0200
--- ../uae_jit_cleaning/uae-0.8.21/src/memory.c	2021-01-10 14:05:52.970591684 +0200
***************
*** 1032,1038 ****
      if (!canbang)
  	return malloc (s);
  
!     id = shmget (IPC_PRIVATE, s, 0x1ff, file);
      if (id == 1) {
  	canbang = 0;
  	return mapped_malloc (s, file);
--- 1032,1038 ----
      if (!canbang)
  	return malloc (s);
  
!     id = shmget (IPC_PRIVATE, s, 0x1ff);
      if (id == 1) {
  	canbang = 0;
  	return mapped_malloc (s, file);
***************
*** 1187,1193 ****
  	map_banks (&bogomem_bank, 0xC0, t, allocated_bogomem);
      }
      if (a3000memory != 0)
! 	map_banks (&a3000mem_bank, a3000mem_start >> 16, allocated_a3000mem >> 16, allocated_a3000mem);
  
      map_banks (&rtarea_bank, RTAREA_BASE >> 16, 1, 0);
  
--- 1187,1194 ----
  	map_banks (&bogomem_bank, 0xC0, t, allocated_bogomem);
      }
      if (a3000memory != 0)
! 	map_banks (&a3000mem_bank, a3000mem_start >> 16, allocated_a3000mem >> 16,
! 		   allocated_a3000mem);
  
      map_banks (&rtarea_bank, RTAREA_BASE >> 16, 1, 0);
  
***************
*** 1207,1214 ****
--- 1208,1270 ----
  	if (cloanto_rom)
  	    map_banks (&kickmem_bank, 0xE0, 8, 0);
      }
+ 
+     {
+ 	int dummy;
+ 	__asm__ __volatile__ ("mov %%gs:0,%0" : "=r" (dummy));
+     }
+ }
+ 
+ #if defined __i386__ && defined __linux__
+ 
+ #include <sys/syscall.h>
+ 
+ struct modify_ldt_ldt_s {
+     unsigned int  entry_number;
+     unsigned long base_addr;
+     unsigned int  limit;
+     unsigned int  seg_32bit:1;
+     unsigned int  contents:2;
+     unsigned int  read_exec_only:1;
+     unsigned int  limit_in_pages:1;
+     unsigned int  seg_not_present:1;
+     unsigned int  useable:1;
+ };
+ 
+ static inline int modify_ldt( int func, struct modify_ldt_ldt_s *ptr,
+                                   unsigned long count )
+ {
+     int res;
+     __asm__ __volatile__("int $0x80"
+                          : "=a" (res)
+                          : "0" (SYS_modify_ldt),
+                            "b" (func),
+                            "c" (ptr),
+                            "d" (count) );
+     return res;
  }
  
+ #define MODIFY_LDT_CONTENTS_DATA        0
+ #define MODIFY_LDT_CONTENTS_STACK       1
+ #define MODIFY_LDT_CONTENTS_CODE        2
+ 
+ static void setup_ldt (void)
+ {
+     struct modify_ldt_ldt_s entry;
+     entry.entry_number = 1;
+     entry.base_addr = NATMEM_OFFSET;
+     entry.limit = 0x80000000 >> 12;
+     entry.contents = MODIFY_LDT_CONTENTS_DATA;
+     entry.read_exec_only = 0;
+     entry.limit_in_pages = 1;
+     entry.seg_not_present = 0;
+     entry.useable = 1;
+     modify_ldt (1, &entry, sizeof entry);
+     __asm__ __volatile__ ("mov %0,%%gs" : : "r" (15));
+ }
+ 
+ #endif
+ 
  void memory_init (void)
  {
      allocated_chipmem = 0;
***************
*** 1229,1234 ****
--- 1285,1293 ----
  	ersatzkickfile = 1;
      }
  
+     // Crashes emulator at start
+     //setup_ldt ();
+ 
      init_mem_banks ();
      memory_reset ();
  
diff -crB --new-file ./uae-0.8.21/src/native2amiga.c ../uae_jit_cleaning/uae-0.8.21/src/native2amiga.c
*** ./uae-0.8.21/src/native2amiga.c	2001-11-19 19:58:46.000000000 +0200
--- ../uae_jit_cleaning/uae-0.8.21/src/native2amiga.c	2021-01-10 13:10:29.906591684 +0200
***************
*** 17,22 ****
--- 17,23 ----
  #include "options.h"
  #include "memory.h"
  #include "custom.h"
+ #include "events.h"
  #include "newcpu.h"
  #include "disk.h"
  #include "autoconf.h"
diff -crB --new-file ./uae-0.8.21/src/newcpu.c ../uae_jit_cleaning/uae-0.8.21/src/newcpu.c
*** ./uae-0.8.21/src/newcpu.c	2002-02-16 16:18:13.000000000 +0200
--- ../uae_jit_cleaning/uae-0.8.21/src/newcpu.c	2021-01-10 14:06:32.838591684 +0200
***************
*** 6,11 ****
--- 6,18 ----
    * (c) 1995 Bernd Schmidt
    */
  
+ /* Lots of workarounds for gcc 2.95.* compiler problems tagged as "FIXME".
+    The compiler should be fixed, not the app! */
+ 
+ extern unsigned long foink;
+ extern unsigned long foink2;
+ extern unsigned long foink3;
+ 
  #include "sysconfig.h"
  #include "sysdeps.h"
  
***************
*** 24,29 ****
--- 31,53 ----
  #include "savestate.h"
  #include "blitter.h"
  
+ #ifdef JIT
+ #include "compemu.h"
+ #include <signal.h>
+ static void vec(int x, struct siginfo* si, struct sigcontext* sc);
+ #else
+ /* Need to have these somewhere */
+ static void build_comp(void) {}
+ void check_prefs_changed_comp (void) {}
+ #endif
+ 
+ static int stop_compile;
+ int oink=0;
+ /* For faster cycles handling */
+ signed long pissoff=0;
+ /* Counter for missed vsyncmintime deadlines */
+ int gonebad=0;
+ 
  /* Opcode of faulting instruction */
  uae_u16 last_op_for_exception_3;
  /* PC at fault time */
***************
*** 44,49 ****
--- 68,75 ----
  
  cpuop_func *cpufunctbl[65536];
  
+ extern uae_u32 get_fpsr(void);
+ 
  #define COUNT_INSTRS 0
  
  #if COUNT_INSTRS
***************
*** 96,106 ****
  }
  #endif
  
  int broken_in;
  
! static unsigned long op_illg_1 (uae_u32 opcode) REGPARAM;
  
! static unsigned long REGPARAM2 op_illg_1 (uae_u32 opcode)
  {
      op_illg (opcode);
      return 4;
--- 122,133 ----
  }
  #endif
  
+ 
  int broken_in;
  
! unsigned long op_illg_1 (uae_u32 opcode) REGPARAM;
  
! unsigned long REGPARAM2 op_illg_1 (uae_u32 opcode)
  {
      op_illg (opcode);
      return 4;
***************
*** 143,148 ****
--- 170,176 ----
  	if (tbl[i].specific)
  	    cpufunctbl[tbl[i].opcode] = tbl[i].handler;
      }
+     build_comp();
  }
  
  unsigned long cycles_mask, cycles_val;
***************
*** 681,692 ****
  	unset_special (SPCFLAG_TRACE);
  }
  
! void Exception(int nr, uaecptr oldpc)
  {
      uae_u32 currpc = m68k_getpc ();
  
!     compiler_flush_jsr_stack();
!     MakeSR();
  
      if (!regs.s) {
  	regs.usp = m68k_areg(regs, 7);
--- 709,721 ----
  	unset_special (SPCFLAG_TRACE);
  }
  
! void Exception (int nr, uaecptr oldpc)
  {
      uae_u32 currpc = m68k_getpc ();
  
!     stop_compile = 1;
!     compiler_flush_jsr_stack ();
!     MakeSR ();
  
      if (!regs.s) {
  	regs.usp = m68k_areg(regs, 7);
***************
*** 746,751 ****
--- 775,781 ----
      m68k_areg(regs, 7) -= 2;
      put_word (m68k_areg(regs, 7), regs.sr);
      m68k_setpc (get_long (regs.vbr + 4*nr));
+     set_special(SPCFLAG_END_COMPILE);
      fill_prefetch_0 ();
      regs.t1 = regs.t0 = regs.m = 0;
      unset_special (SPCFLAG_TRACE | SPCFLAG_DOTRACE);
***************
*** 776,782 ****
  	switch (regno) {
  	case 0: regs.sfc = *regp & 7; break;
  	case 1: regs.dfc = *regp & 7; break;
! 	case 2: cacr = *regp & (currprefs.cpu_level < 4 ? 0x3 : 0x80008000); break;
  	case 3: tc = *regp & 0xc000; break;
  	    /* Mask out fields that should be zero.  */
  	case 4: itt0 = *regp & 0xffffe364; break;
--- 806,828 ----
  	switch (regno) {
  	case 0: regs.sfc = *regp & 7; break;
  	case 1: regs.dfc = *regp & 7; break;
! 	 case 2: 
! 	    cacr = *regp & (currprefs.cpu_level < 4 ? 0x3 : 0x80008000);
! #ifdef JIT
! 	    if (currprefs.cpu_level<4) {
! 		set_cache_state(cacr&1);
! 		if (*regp&0x08) {
! 		    flush_icache(1);
! 		}
! 	    }
! 	    else {
! 		set_cache_state((cacr&0x8000)||0);
! 		if (*regp&0x08) {   /* Just to be on the safe side */
! 		    flush_icache(2);
! 		}
! 	    }
! #endif
! 	    break;
  	case 3: tc = *regp & 0xc000; break;
  	    /* Mask out fields that should be zero.  */
  	case 4: itt0 = *regp & 0xffffe364; break;
***************
*** 1123,1128 ****
--- 1169,1185 ----
      regs.intmask = 7;
      regs.vbr = regs.sfc = regs.dfc = 0;
      regs.fpcr = regs.fpsr = regs.fpiar = 0;
+     regs.fp_result=1;
+ }
+ 
+ STATIC_INLINE int in_rom (uaecptr pc)
+ {
+     return (munge24 (pc) & 0xFFF80000) == 0xF80000;
+ }
+ 
+ STATIC_INLINE int in_rtarea (uaecptr pc)
+ {
+     return (munge24 (pc) & 0xFFFF0000) == RTAREA_BASE;
  }
  
  unsigned long REGPARAM2 op_illg (uae_u32 opcode)
***************
*** 1137,1164 ****
      }
  
      compiler_flush_jsr_stack ();
!     if (opcode == 0x4E7B && get_long (0x10) == 0 && (pc & 0xF80000) == 0xF80000) {
  	write_log ("Your Kickstart requires a 68020 CPU. Giving up.\n");
  	broken_in = 1;
  	set_special (SPCFLAG_BRK);
  	quit_program = 1;
      }
      if (opcode == 0xFF0D) {
! 	if ((pc & 0xF80000) == 0xF80000) {
  	    /* This is from the dummy Kickstart replacement */
  	    uae_u16 arg = get_iword (2);
  	    m68k_incpc (4);
  	    ersatz_perform (arg);
  	    fill_prefetch_0 ();
  	    return 4;
! 	} else if ((pc & 0xFFFF0000) == RTAREA_BASE) {
  	    /* User-mode STOP replacement */
  	    m68k_setstopped (1);
  	    return 4;
  	}
      }
  
!     if ((opcode & 0xF000) == 0xA000 && (pc & 0xFFFF0000) == RTAREA_BASE) {
  	/* Calltrap. */
  	m68k_incpc(2);
  	call_calltrap (opcode & 0xFFF);
--- 1194,1221 ----
      }
  
      compiler_flush_jsr_stack ();
!     if (opcode == 0x4E7B && get_long (0x10) == 0 && in_rom (pc)) {
  	write_log ("Your Kickstart requires a 68020 CPU. Giving up.\n");
  	broken_in = 1;
  	set_special (SPCFLAG_BRK);
  	quit_program = 1;
      }
      if (opcode == 0xFF0D) {
! 	if (in_rom (pc)) {
  	    /* This is from the dummy Kickstart replacement */
  	    uae_u16 arg = get_iword (2);
  	    m68k_incpc (4);
  	    ersatz_perform (arg);
  	    fill_prefetch_0 ();
  	    return 4;
! 	} else if (in_rtarea (pc)) {
  	    /* User-mode STOP replacement */
  	    m68k_setstopped (1);
  	    return 4;
  	}
      }
  
!     if ((opcode & 0xF000) == 0xA000 && in_rtarea (pc)) {
  	/* Calltrap. */
  	m68k_incpc(2);
  	call_calltrap (opcode & 0xFFF);
***************
*** 1167,1177 ****
      }
  
      if ((opcode & 0xF000) == 0xF000) {
  	Exception(0xB,0);
  	return 4;
      }
      if ((opcode & 0xF000) == 0xA000) {
! 	if ((pc & 0xFFFF0000) == RTAREA_BASE) {
  	    /* Calltrap. */
  	    call_calltrap (opcode & 0xFFF);
  	}
--- 1224,1235 ----
      }
  
      if ((opcode & 0xF000) == 0xF000) {
+  	write_log ("B-Trap %x at %x (%p)\n", opcode, m68k_getpc () + m68kpc_offset, regs.pc_p);
  	Exception(0xB,0);
  	return 4;
      }
      if ((opcode & 0xF000) == 0xA000) {
! 	if (in_rtarea (pc)) {
  	    /* Calltrap. */
  	    call_calltrap (opcode & 0xFFF);
  	}
***************
*** 1243,1248 ****
--- 1301,1307 ----
  	do_copper ();
  
      /*n_spcinsns++;*/
+     unset_special(SPCFLAG_END_COMPILE);   /* has done its job */
      while (regs.spcflags & SPCFLAG_BLTNASTY) {
  	int c = blitnasty();
  	if (!c)
***************
*** 1301,1307 ****
      uae_u16 *oldpcp;
  #endif
      for (;;) {
! 	int cycles;
  	uae_u32 opcode = get_iword_prefetch (0);
  #ifdef DEBUG_PREFETCH
  	if (get_ilong (0) != do_get_mem_long (&regs.prefetch)) {
--- 1360,1366 ----
      uae_u16 *oldpcp;
  #endif
      for (;;) {
! 	int local_cycles;
  	uae_u32 opcode = get_iword_prefetch (0);
  #ifdef DEBUG_PREFETCH
  	if (get_ilong (0) != do_get_mem_long (&regs.prefetch)) {
***************
*** 1321,1332 ****
  	instrcount[opcode]++;
  #endif
  #if defined X86_ASSEMBLY
! 	__asm__ __volatile__("\tcall *%%ebx"
! 			     : "=&a" (cycles) : "b" (cpufunctbl[opcode]), "0" (opcode)
  			     : "%edx", "%ecx",
  			     "%esi", "%edi", "%ebp", "memory", "cc");
  #else
! 	cycles = (*cpufunctbl[opcode])(opcode);
  #endif
  #ifdef DEBUG_PREFETCH
  	if (memcmp (saved_bytes, oldpcp, 20) != 0) {
--- 1380,1392 ----
  	instrcount[opcode]++;
  #endif
  #if defined X86_ASSEMBLY
! 	__asm__ __volatile__("\tpush %%ebp\n\tcall *%%ebx\n\tpop %%ebp" /* FIXME */
! 			     : "=&a" (local_cycles) 
! 			     : "b" (cpufunctbl[opcode]), "0" (opcode)
  			     : "%edx", "%ecx",
  			     "%esi", "%edi", "%ebp", "memory", "cc");
  #else
! 	local_cycles = (*cpufunctbl[opcode])(opcode);
  #endif
  #ifdef DEBUG_PREFETCH
  	if (memcmp (saved_bytes, oldpcp, 20) != 0) {
***************
*** 1335,1344 ****
  	    debugging = 1;
  	}
  #endif
  	/*n_insns++;*/
! 	cycles &= cycles_mask;
! 	cycles |= cycles_val;
! 	do_cycles (cycles);
  	if (regs.spcflags) {
  	    if (do_specialties ())
  		return;
--- 1395,1405 ----
  	    debugging = 1;
  	}
  #endif
+ 
  	/*n_insns++;*/
! 	local_cycles &= cycles_mask;
! 	local_cycles |= cycles_val;
! 	do_cycles (local_cycles);
  	if (regs.spcflags) {
  	    if (do_specialties ())
  		return;
***************
*** 1348,1353 ****
--- 1409,1521 ----
  
  #define DEBUG_PREFETCH
  
+ #ifdef JIT  /* Completely different run_2 replacement */
+ 
+ void do_nothing(void)
+ {
+     /* What did you expect this to do? */
+     do_cycles(0);
+     /* I bet you didn't expect *that* ;-) */
+ }
+ 
+ void exec_nostats(void)
+ {
+     int new_cycles;
+ 
+     for (;;) 
+     { 
+ 	/* gcc bug! */
+ 	__volatile__ uae_u16 opcode=get_iword(0);
+ #if defined X86_ASSEMBLY
+ 	__asm__ __volatile__("\tpush %%ebp\n\tcall *%%ebx\n\tpop %%ebp" /* FIXME */
+ 			     : "=&a" (new_cycles) 
+ 			     : "b" (cpufunctbl[opcode]), "0" (opcode)
+ 			     : "%edx", "%ecx", "%esi", "%edi", 
+ 			     "%ebp", "memory", "cc");
+ #else
+ 	new_cycles = (*cpufunctbl[opcode])(opcode);
+ #endif
+ 
+ 	new_cycles &= cycles_mask;
+ 	new_cycles |= cycles_val;
+ 	do_cycles (new_cycles);
+ 	
+ 	if (end_block(opcode) ||
+ 	    regs.spcflags) {
+ 	    return; /* We will deal with the spcflags in the caller */
+ 	}
+     }
+ }
+ 
+ 
+ void execute_normal (void)
+ {
+     int blocklen;
+     cpu_history pc_hist[MAXRUN];
+     int new_cycles;
+     int total_cycles;
+ 
+     if (check_for_cache_miss())
+ 	return;
+     total_cycles=0;
+     blocklen=0;
+     start_pc_p=regs.pc_oldp;  
+     start_pc=regs.pc; 
+     for (;;) 
+     {    /* Take note: This is the do-it-normal loop */
+ 	uae_u16 opcode=get_iword(0);
+ 
+ 	special_mem = DISTRUST_CONSISTENT_MEM;
+ 	pc_hist[blocklen].location = (uae_u16*)regs.pc_p;
+ 	stop_compile = 0;
+ #if defined X86_ASSEMBLY
+ 	__asm__ __volatile__("\tpush %%ebp\n\tcall *%%ebx\n\tpop %%ebp" /* FIXME */
+ 			     : "=&a" (new_cycles) 
+ 			     : "b" (cpufunctbl[opcode]), "0" (opcode)
+ 			     : "%edx", "%ecx", "%esi", "%edi", 
+ 			     "%ebp", "memory", "cc");
+ #else
+ 	new_cycles = (*cpufunctbl[opcode])(opcode);
+ #endif
+ 	new_cycles &= cycles_mask;
+ 	new_cycles |= cycles_val;
+ 	do_cycles (new_cycles);
+ 	total_cycles+=new_cycles;
+ 	pc_hist[blocklen].specmem=special_mem;
+ 	blocklen++;
+ 	if (stop_compile || end_block(opcode) || blocklen >= MAXRUN || regs.spcflags) {
+ 	    compile_block(pc_hist,blocklen,total_cycles);
+ 	    return; /* We will deal with the spcflags in the caller */
+ 	}
+ 	/* No need to check regs.spcflags, because if they were set,
+ 	   we'd have ended up inside that "if" */
+     }
+ }
+ 
+ typedef void compiled_handler(void);
+ 
+ static void m68k_run_2a (void)
+ {
+     for (;;) {  
+ #if defined X86_ASSEMBLY 
+ 	__asm__ __volatile__(
+ 	    "\tpush %%ebp\n\tcall *%0\n\tpop %%ebp"  /* FIXME */
+ 	    :: "m" (cache_tags[cacheline(regs.pc_p)].handler) 
+ 	    : "%edx", "%ecx", "%eax",
+ 	    "%esi", "%ebx", "%edi", "%ebp", "memory", "cc");
+ #else
+ 	((compiled_handler*)(pushall_call_handler))();
+ #endif
+ 	/* Whenever we return from that, we should check spcflags */
+ 	if (regs.spcflags) {
+ 	    if (do_specialties ()) {
+ 		return;
+ 	    }
+ 	}
+     }
+ }
+ #endif
+ 
  /* Same thing, but don't use prefetch to get opcode.  */
  static void m68k_run_2 (void)
  {
***************
*** 1364,1370 ****
  	instrcount[opcode]++;
  #endif
  #if defined X86_ASSEMBLY
! 	__asm__ __volatile__("\tcall *%%ebx"
  			     : "=&a" (cycles) : "b" (cpufunctbl[opcode]), "0" (opcode)
  			     : "%edx", "%ecx",
  			     "%esi", "%edi", "%ebp", "memory", "cc");
--- 1532,1538 ----
  	instrcount[opcode]++;
  #endif
  #if defined X86_ASSEMBLY
! 	__asm__ __volatile__("\tpush %%ebp\n\tcall *%%ebx\n\tpop %%ebp" /* FIXME */
  			     : "=&a" (cycles) : "b" (cpufunctbl[opcode]), "0" (opcode)
  			     : "%edx", "%ecx",
  			     "%esi", "%edi", "%ebp", "memory", "cc");
***************
*** 1430,1436 ****
--- 1598,1609 ----
  
  	if (debugging)
  	    debug ();
+ #ifndef JIT
  	m68k_run1 (currprefs.cpu_compatible ? m68k_run_1 : m68k_run_2);
+ #else
+ 	m68k_run1 (currprefs.cpu_compatible ? m68k_run_1 : 
+ 		   currprefs.cpu_level>=2 ? m68k_run_2a : m68k_run_2);
+ #endif
      }
      in_m68k_go--;
  }
***************
*** 1525,1530 ****
--- 1698,1705 ----
  void m68k_dumpstate (FILE *f, uaecptr *nextpc)
  {
      int i;
+     uae_u32 fpsr;
+ 
      for (i = 0; i < 8; i++){
  	fprintf (f, "D%d: %08lx ", i, m68k_dreg(regs, i));
  	if ((i & 3) == 3) fprintf (f, "\n");
***************
*** 1545,1555 ****
  	fprintf (f, "FP%d: %g ", i, regs.fp[i]);
  	if ((i & 3) == 3) fprintf (f, "\n");
      }
      fprintf (f, "N=%d Z=%d I=%d NAN=%d\n",
! 	     (regs.fpsr & 0x8000000) != 0,
! 	     (regs.fpsr & 0x4000000) != 0,
! 	     (regs.fpsr & 0x2000000) != 0,
! 	     (regs.fpsr & 0x1000000) != 0);
      if (currprefs.cpu_compatible)
  	fprintf (f, "prefetch %08lx\n", (unsigned long)do_get_mem_long(&regs.prefetch));
  
--- 1720,1731 ----
  	fprintf (f, "FP%d: %g ", i, regs.fp[i]);
  	if ((i & 3) == 3) fprintf (f, "\n");
      }
+     fpsr=get_fpsr();
      fprintf (f, "N=%d Z=%d I=%d NAN=%d\n",
! 	     (fpsr & 0x8000000) != 0,
! 	     (fpsr & 0x4000000) != 0,
! 	     (fpsr & 0x2000000) != 0,
! 	     (fpsr & 0x1000000) != 0);
      if (currprefs.cpu_compatible)
  	fprintf (f, "prefetch %08lx\n", (unsigned long)do_get_mem_long(&regs.prefetch));
  
***************
*** 1654,1656 ****
--- 1830,1884 ----
      *len = dst - dstbak;
      return dstbak;
  }
+ 
+ extern int segvcount;
+ extern int soft_flush_count;
+ extern int hard_flush_count;
+ extern int compile_count;
+ extern int checksum_count;
+ extern int inhibit_frame;
+ 
+ void newcpu_showstate(void)
+ {
+     static time_t oldtime=0;
+     static int line=0;
+     time_t newtime=time(NULL);
+     
+     /* return; */
+ #if defined JIT 
+ 
+     if (!line) {
+ 	fprintf(stderr,"compiled segv soft hard trans check  lost   debug1   debug2   debug3   debug4\n");
+ 	line++;
+     }
+     if (oldtime && newtime!=oldtime+1) {
+ 	printf("Time difference was %d seconds, should be 1\n",(int)(newtime-oldtime));
+ 	line++;
+     }
+     oldtime=newtime;
+ 
+     fprintf(stderr,"%8lu %4d %4d %4d %5d %5d %5.3f",get_jitted_size(),segvcount,soft_flush_count,hard_flush_count,compile_count,checksum_count,(double)gonebad/15625*8);
+     /*    fprintf(stderr," %8d %8lu %8lu %8lu",oink,foink3,foink2,foink);*/
+     if (!inhibit_frame) {
+ 	fprintf(stderr," NAT");
+     }
+     fprintf(stderr,"\n");
+     oink=0; 
+     /*    foink3=foink2=foink=0;*/
+     checksum_count=soft_flush_count=hard_flush_count=compile_count=0;
+     gonebad=0;
+     line++;
+     if (line==25)
+ 	line=0;
+ #endif
+ }
+ 
+ /* Putting this here should stop the compiler from trying to work out
+    (wrongly!) what we *really* mean ;-) 
+ */
+ 
+ long int diff32(frame_time_t x, frame_time_t y)
+ {
+     return (long int)(x-y);
+ }
+ 
diff -crB --new-file ./uae-0.8.21/src/nogui.c ../uae_jit_cleaning/uae-0.8.21/src/nogui.c
*** ./uae-0.8.21/src/nogui.c	2001-12-30 16:41:47.000000000 +0200
--- ../uae_jit_cleaning/uae-0.8.21/src/nogui.c	2021-01-10 14:05:59.962591684 +0200
***************
*** 43,49 ****
  {
  }
  
! static void getline (char *p)
  {
  }
  
--- 43,49 ----
  {
  }
  
! static void gui_getline (char *p)
  {
  }
  
diff -crB --new-file ./uae-0.8.21/src/od-amiga/ami-rexx.c ../uae_jit_cleaning/uae-0.8.21/src/od-amiga/ami-rexx.c
*** ./uae-0.8.21/src/od-amiga/ami-rexx.c	2001-09-07 14:44:24.000000000 +0300
--- ../uae_jit_cleaning/uae-0.8.21/src/od-amiga/ami-rexx.c	2021-01-10 13:10:29.922591684 +0200
***************
*** 34,39 ****
--- 34,40 ----
  
  #include <rexx/storage.h>
  #include <rexx/errors.h>
+ #include "events.h"
  
  /* this prevent a conflict between <rexx/rexxio.h> and <sys/dirent.h> */
  #undef DT_DIR 
***************
*** 210,216 ****
  static void QUIT(void)
  {
      broken_in = 1;
!     regs.spcflags |= SPCFLAG_BRK;
      quit_program = 1;
  }
  
--- 211,217 ----
  static void QUIT(void)
  {
      broken_in = 1;
!     set_special(SPCFLAG_BRK);
      quit_program = 1;
  }
  
diff -crB --new-file ./uae-0.8.21/src/od-joy.c ../uae_jit_cleaning/uae-0.8.21/src/od-joy.c
*** ./uae-0.8.21/src/od-joy.c	1970-01-01 02:00:00.000000000 +0200
--- ../uae_jit_cleaning/uae-0.8.21/src/od-joy.c	2021-01-10 13:54:02.642591684 +0200
***************
*** 0 ****
--- 1 ----
+ #include "/home/osboxes/uae_Archives/build_0_8_21_jit/uae_jit_cleaning/uae-0.8.21/src/od-linux/joystick.c"
diff -crB --new-file ./uae-0.8.21/src/od-macos/mac.c ../uae_jit_cleaning/uae-0.8.21/src/od-macos/mac.c
*** ./uae-0.8.21/src/od-macos/mac.c	2001-09-07 14:44:25.000000000 +0300
--- ../uae_jit_cleaning/uae-0.8.21/src/od-macos/mac.c	2021-01-10 13:10:29.922591684 +0200
***************
*** 936,942 ****
  				
  				case 13:
  					broken_in = 1;
! 					regs.spcflags |= SPCFLAG_BRK;
  					quit_program=1;
  				break;
  			}
--- 936,942 ----
  				
  				case 13:
  					broken_in = 1;
! 					set_special(SPCFLAG_BRK);
  					quit_program=1;
  				break;
  			}
diff -crB --new-file ./uae-0.8.21/src/od-pOS/pos-rexx.c ../uae_jit_cleaning/uae-0.8.21/src/od-pOS/pos-rexx.c
*** ./uae-0.8.21/src/od-pOS/pos-rexx.c	1997-11-01 16:07:58.000000000 +0200
--- ../uae_jit_cleaning/uae-0.8.21/src/od-pOS/pos-rexx.c	2021-01-10 13:10:29.922591684 +0200
***************
*** 6,11 ****
--- 6,13 ----
    * Copyright 1997 Samuel Devulder.
    */
  
+ #include "events.h"
+ 
  int  rexx_init(void);
  void rexx_exit(void);
  void rexx_led(int led, int on);
***************
*** 189,195 ****
  static void QUIT(void)
  {
      broken_in = 1;
!     regs.spcflags |= SPCFLAG_BRK;
      quit_program = 1;
  }
  
--- 191,197 ----
  static void QUIT(void)
  {
      broken_in = 1;
!     set_special(SPCFLAG_BRK);
      quit_program = 1;
  }
  
diff -crB --new-file ./uae-0.8.21/src/od-win32/win32gui.c ../uae_jit_cleaning/uae-0.8.21/src/od-win32/win32gui.c
*** ./uae-0.8.21/src/od-win32/win32gui.c	2001-12-17 18:37:43.000000000 +0200
--- ../uae_jit_cleaning/uae-0.8.21/src/od-win32/win32gui.c	2021-01-10 13:10:29.926591684 +0200
***************
*** 3014,3020 ****
  	    case PSN_RESET:
  		if (allow_quit) {
  		    quit_program = 1;
! 		    regs.spcflags |= SPCFLAG_BRK;
  		}
  		break;
  	    }
--- 3014,3020 ----
  	    case PSN_RESET:
  		if (allow_quit) {
  		    quit_program = 1;
! 		    set_special(SPCFLAG_BRK);
  		}
  		break;
  	    }
***************
*** 3233,3239 ****
  	case PSN_RESET:
  	    if (allow_quit) {
  		quit_program = 1;
! 		regs.spcflags |= SPCFLAG_BRK;
  	    }
  	    break;
  	}
--- 3233,3239 ----
  	case PSN_RESET:
  	    if (allow_quit) {
  		quit_program = 1;
! 		set_special(SPCFLAG_BRK);
  	    }
  	    break;
  	}
***************
*** 3603,3609 ****
  	case PSN_RESET:
  	    if (allow_quit) {
  		quit_program = 1;
! 		regs.spcflags |= SPCFLAG_BRK;
  	    }
  	    break;
  	}
--- 3603,3609 ----
  	case PSN_RESET:
  	    if (allow_quit) {
  		quit_program = 1;
! 		set_special(SPCFLAG_BRK);
  	    }
  	    break;
  	}
diff -crB --new-file ./uae-0.8.21/src/osdep/exectasks.h ../uae_jit_cleaning/uae-0.8.21/src/osdep/exectasks.h
*** ./uae-0.8.21/src/osdep/exectasks.h	1970-01-01 02:00:00.000000000 +0200
--- ../uae_jit_cleaning/uae-0.8.21/src/osdep/exectasks.h	1997-06-01 20:56:32.000000000 +0300
***************
*** 0 ****
--- 1,49 ----
+  /*
+   * UAE - The Un*x Amiga Emulator
+   *
+   * Stack magic definitions for autoconf.c
+   *
+   * Copyright 1997 Bernd Schmidt
+   */
+ 
+ #include <setjmp.h>
+ 
+ #undef CAN_DO_STACK_MAGIC
+ 
+ #if defined __GNUC__ && defined __GNUC_MINOR__
+ #if defined __i386__ && (__GNUC__ > 2 || __GNUC_MINOR__ >= 7)
+ #define CAN_DO_STACK_MAGIC
+ #endif
+ #endif
+ 
+ #ifdef CAN_DO_STACK_MAGIC
+ static inline void transfer_control(void *, int, void *, void *, int) __attribute__((noreturn));
+ static inline void transfer_control(void *s, int size, void *pc, void *f, int has_retval)
+ {
+     unsigned long *stacktop = (unsigned long *)((char *)s + size - 20);
+     stacktop[0] = 0xC0DEDBAD; /* return address */
+     stacktop[1] = (int)s; /* function arg 1: stack */
+     stacktop[2] = (int)f; /* function arg 2: trap function */
+     stacktop[3] = (int)stacktop; /* function arg 3: return value address */
+     stacktop[4] = has_retval;
+     __asm__ __volatile__ ("movl %0,%%esp\n\tpushl %1\n\tret\n" : : "r" (stacktop), "r" (pc) : "memory");
+     /* Not reached. */
+     abort();
+ }
+ 
+ static inline uae_u32 get_retval_from_stack (void *s, int size)
+ {
+     return *(uae_u32 *)((char *)s + size - 20);
+ }
+ 
+ static inline int stack_has_retval (void *s, int size)
+ {
+     return *(int *)((char *)s + size - 4);
+ }
+ 
+ #define USE_EXECLIB
+ 
+ #else
+ 
+ #endif
+ 
diff -crB --new-file ./uae-0.8.21/src/osdep/joystick.c ../uae_jit_cleaning/uae-0.8.21/src/osdep/joystick.c
*** ./uae-0.8.21/src/osdep/joystick.c	1970-01-01 02:00:00.000000000 +0200
--- ../uae_jit_cleaning/uae-0.8.21/src/osdep/joystick.c	2002-01-31 16:09:52.000000000 +0200
***************
*** 0 ****
--- 1,134 ----
+  /* 
+   * UAE - The Un*x Amiga Emulator
+   * 
+   * Joystick emulation for Linux and BSD. They share too much code to
+   * split this file.
+   * 
+   * Copyright 1997 Bernd Schmidt
+   * Copyright 1998 Krister Walfridsson
+   */
+ 
+ #include "sysconfig.h"
+ #include "sysdeps.h"
+ 
+ #include "config.h"
+ #include "options.h"
+ #include "memory.h"
+ #include "custom.h"
+ #include "joystick.h"
+ 
+ #ifdef HAVE_MACHINE_JOYSTICK_H
+ 
+ /* The BSD way.  */
+ 
+ # include <machine/joystick.h>
+ typedef struct joystick uae_joystick_t;
+ 
+ #define JS_DEVNAME_PREFIX "joy"
+ 
+ #else
+ 
+ /* The Linux way.  */
+ 
+ /* There are too many different versions of <linux/joystick.h>.  Rather
+  * than trying to work correctly with all of them, we duplicate the
+  * necessary definitions here.  */
+ typedef struct
+ {
+     int buttons;
+     int x;
+     int y;
+ } uae_joystick_t;
+ 
+ #define JS_DEVNAME_PREFIX "js"
+ 
+ #endif
+ 
+ int nr_joysticks;
+ 
+ static int js0, js1;
+ 
+ struct joy_range
+ {
+     int minx, maxx, miny, maxy;
+ } range0, range1;
+ 
+ void read_joystick(int nr, unsigned int *dir, int *button)
+ {
+     static int minx = INT_MAX, maxx = INT_MIN;
+     static int miny = INT_MAX, maxy = INT_MIN;
+     int left = 0, right = 0, top = 0, bot = 0;
+     uae_joystick_t buffer;
+     int len;
+     int fd = nr == 0 ? js0 : js1;
+     struct joy_range *r = nr == 0 ? &range0 : &range1;
+ 
+     *dir = 0;
+     *button = 0;
+     if (nr >= nr_joysticks)
+     	return;
+     
+     len = read(fd, &buffer, sizeof(buffer));
+     if (len != sizeof(buffer)) 
+     	return;
+     
+     if (buffer.x < r->minx) r->minx = buffer.x;
+     if (buffer.y < r->miny) r->miny = buffer.y;
+     if (buffer.x > r->maxx) r->maxx = buffer.x;
+     if (buffer.y > r->maxy) r->maxy = buffer.y;
+     
+     if (buffer.x < (r->minx + (r->maxx - r->minx)/3))
+     	left = 1;
+     else if (buffer.x > (r->minx + 2*(r->maxx - r->minx)/3))
+     	right = 1;
+ 
+     if (buffer.y < (r->miny + (r->maxy - r->miny)/3))
+     	top = 1;
+     else if (buffer.y > (r->miny + 2*(r->maxy - r->miny)/3))
+     	bot = 1;
+     	
+     if (left) top = !top;
+     if (right) bot = !bot;
+     *dir = bot | (right << 1) | (top << 8) | (left << 9);
+ #ifdef HAVE_MACHINE_JOYSTICK_H
+     *button = buffer.b1 || buffer.b2;
+ #else
+     *button = buffer.buttons & 3;
+ #endif
+ }
+ 
+ void init_joystick(void)
+ {
+     nr_joysticks = 0;
+     js0 = -1; js1 = -1;
+     js0 = open("/dev/" JS_DEVNAME_PREFIX "0", O_RDONLY);
+     if (js0 < 0) {
+ 	write_log ("No joysticks found\n");
+     	return;
+     }
+     nr_joysticks = 1;
+     js1 = open("/dev/" JS_DEVNAME_PREFIX "1", O_RDONLY);
+     if (js1 < 0) {
+ 	write_log ("Found one joystick\n");
+     	return;
+     }
+     write_log ("Found two joysticks\n");
+     nr_joysticks = 2;
+ 
+     range0.minx = INT_MAX;
+     range0.maxx = INT_MIN;
+     range0.miny = INT_MAX;
+     range0.maxy = INT_MIN;
+     range1.minx = INT_MAX;
+     range1.maxx = INT_MIN;
+     range1.miny = INT_MAX;
+     range1.maxy = INT_MIN;
+ }
+ 
+ void close_joystick(void)
+ {
+     if (js0 >= 0)
+ 	close (js0);
+     if (js1 >= 0)
+ 	close (js1);
+ }
diff -crB --new-file ./uae-0.8.21/src/osdep/memory.h ../uae_jit_cleaning/uae-0.8.21/src/osdep/memory.h
*** ./uae-0.8.21/src/osdep/memory.h	1970-01-01 02:00:00.000000000 +0200
--- ../uae_jit_cleaning/uae-0.8.21/src/osdep/memory.h	1997-03-01 22:14:13.000000000 +0200
***************
*** 0 ****
--- 1,15 ----
+  /* 
+   * UAE - The Un*x Amiga Emulator
+   * 
+   * See if this OS has mmap.
+   *
+   * Copyright 1996 Bernd Schmidt
+   */
+ 
+ #undef USE_MAPPED_MEMORY
+ 
+ #if USER_PROGRAMS_BEHAVE > 0
+ #define USE_MAPPED_MEMORY
+ #endif
+ 
+ #define CAN_MAP_MEMORY
diff -crB --new-file ./uae-0.8.21/src/picasso96.c ../uae_jit_cleaning/uae-0.8.21/src/picasso96.c
*** ./uae-0.8.21/src/picasso96.c	2002-01-31 16:09:52.000000000 +0200
--- ../uae_jit_cleaning/uae-0.8.21/src/picasso96.c	2021-01-10 13:10:29.910591684 +0200
***************
*** 39,48 ****
--- 39,53 ----
  #include "uae.h"
  #include "memory.h"
  #include "custom.h"
+ #include "events.h"
  #include "newcpu.h"
  #include "xwin.h"
  #include "picasso96.h"
  
+ int have_done_picasso=0; /* For the JIT compiler */
+ int picasso_is_special=PIC_WRITE; /* ditto */
+ int picasso_is_special_read=PIC_READ; /* ditto */
+ 
  #ifdef PICASSO96
  
  /* #define P96TRACING_ENABLED */
***************
*** 248,253 ****
--- 253,259 ----
      uaecptr memp = get_long (amigamemptr + PSSO_RenderInfo_Memory);
  
      if (valid_address (memp, PSSO_RenderInfo_sizeof)) {
+ 	ri->AMemory=memp;
  	ri->Memory = get_real_address (memp);
  	ri->BytesPerRow = get_word (amigamemptr + PSSO_RenderInfo_BytesPerRow);
  	ri->RGBFormat = get_long (amigamemptr + PSSO_RenderInfo_RGBFormat);
***************
*** 696,701 ****
--- 702,709 ----
      if (!picasso_on)
  	return;
  
+     have_done_picasso=1;
+     
      /* Make sure that the first time we show a Picasso video mode, we don't blit any crap.
       * We can do this by checking if we have an Address yet.  */
      if (picasso96_state.Address) {
***************
*** 923,928 ****
--- 931,940 ----
  #if 0
      write_log ("SetSwitch() - trying to show %s screen\n", flag ? "picasso96" : "amiga");
  #endif
+ 
+     flush_icache(5);  /* Changing the screen mode might make gfx memory
+ 			 directly accessible, or no longer thus accessible */
+ 
      /* Put old switch-state in D0 */
      return !flag;
  }
***************
*** 2239,2244 ****
--- 2251,2258 ----
  
      addr += gfxmem_start;
      /* Check to see if this needs to be written through to the display, or was it an "offscreen" area? */
+     /* Shouldn't the "+4" be on the *first* addr, rather than the second?
+        and be a "+3" at  that? */
      if (addr < picasso96_state.Address || addr + 4 > picasso96_state.Extent)
  	return;
  
***************
*** 2335,2340 ****
--- 2349,2356 ----
  static uae_u32 REGPARAM2 gfxmem_lget (uaecptr addr)
  {
      uae_u32 *m;
+ 
+     special_mem|=picasso_is_special_read;  
      addr -= gfxmem_start & gfxmem_mask;
      addr &= gfxmem_mask;
      m = (uae_u32 *) (gfxmemory + addr);
***************
*** 2344,2349 ****
--- 2360,2367 ----
  static uae_u32 REGPARAM2 gfxmem_wget (uaecptr addr)
  {
      uae_u16 *m;
+ 
+     special_mem|=picasso_is_special_read;  
      addr -= gfxmem_start & gfxmem_mask;
      addr &= gfxmem_mask;
      m = (uae_u16 *) (gfxmemory + addr);
***************
*** 2352,2357 ****
--- 2370,2376 ----
  
  static uae_u32 REGPARAM2 gfxmem_bget (uaecptr addr)
  {
+     special_mem|=picasso_is_special_read;  
      addr -= gfxmem_start & gfxmem_mask;
      addr &= gfxmem_mask;
      return gfxmemory[addr];
***************
*** 2360,2365 ****
--- 2379,2386 ----
  static void REGPARAM2 gfxmem_lput (uaecptr addr, uae_u32 l)
  {
      uae_u32 *m;
+ 
+     special_mem|=picasso_is_special; 
      addr -= gfxmem_start & gfxmem_mask;
      addr &= gfxmem_mask;
      m = (uae_u32 *) (gfxmemory + addr);
***************
*** 2372,2377 ****
--- 2393,2399 ----
  static void REGPARAM2 gfxmem_wput (uaecptr addr, uae_u32 w)
  {
      uae_u16 *m;
+     special_mem|=picasso_is_special; 
      addr -= gfxmem_start & gfxmem_mask;
      addr &= gfxmem_mask;
      m = (uae_u16 *) (gfxmemory + addr);
***************
*** 2383,2388 ****
--- 2405,2411 ----
  
  static void REGPARAM2 gfxmem_bput (uaecptr addr, uae_u32 b)
  {
+     special_mem|=picasso_is_special; 
      addr -= gfxmem_start & gfxmem_mask;
      addr &= gfxmem_mask;
      gfxmemory[addr] = b;
diff -crB --new-file ./uae-0.8.21/src/sd-sound.c ../uae_jit_cleaning/uae-0.8.21/src/sd-sound.c
*** ./uae-0.8.21/src/sd-sound.c	1970-01-01 02:00:00.000000000 +0200
--- ../uae_jit_cleaning/uae-0.8.21/src/sd-sound.c	2021-01-10 13:54:02.642591684 +0200
***************
*** 0 ****
--- 1 ----
+ #include "/home/osboxes/uae_Archives/build_0_8_21_jit/uae_jit_cleaning/uae-0.8.21/src/sd-uss/sound.c"
diff -crB --new-file ./uae-0.8.21/src/sd-uss/sound.h ../uae_jit_cleaning/uae-0.8.21/src/sd-uss/sound.h
*** ./uae-0.8.21/src/sd-uss/sound.h	1997-11-25 18:27:52.000000000 +0200
--- ../uae_jit_cleaning/uae-0.8.21/src/sd-uss/sound.h	2021-01-10 13:10:29.926591684 +0200
***************
*** 13,20 ****
  
  static __inline__ void check_sound_buffers (void)
  {
!     if ((char *)sndbufpt - (char *)sndbuffer >= sndbufsize) {
! 	write (sound_fd, sndbuffer, sndbufsize);
  	sndbufpt = sndbuffer;
      }
  }
--- 13,41 ----
  
  static __inline__ void check_sound_buffers (void)
  {
!     int delay;
!     
!     int size=(char *)sndbufpt - (char *)sndbuffer;
!     if (size >= sndbufsize) {
! #if 0
! 	ioctl(sound_fd,SNDCTL_DSP_GETODELAY,&delay);
! 	if (delay<sndbufsize*1+size) {
! 	    /* We are still OK */
! 	}
! 	else {
! 	    unsigned long long x=sndbufsize;
! 	    x*=syncbase;
! 	    x/=currprefs.sound_freq;
! 	    x/=(currprefs.sound_bits/8);
! 	    x/=(currprefs.stereo+1);
! 	    x/=16;  
! 	    /* Skip one 1/16 buffer worth of time. That's 6% we can slow
! 	       things down --- that should be enough! */
! 	    vsyncmintime+=x;
! 	    // fprintf(stderr,"Adding %llu ticks in sound\n",x);
! 	}
! #endif
! 	write (sound_fd, sndbuffer, size);
  	sndbufpt = sndbuffer;
      }
  }
diff -crB --new-file ./uae-0.8.21/src/sounddep/sound.c ../uae_jit_cleaning/uae-0.8.21/src/sounddep/sound.c
*** ./uae-0.8.21/src/sounddep/sound.c	1970-01-01 02:00:00.000000000 +0200
--- ../uae_jit_cleaning/uae-0.8.21/src/sounddep/sound.c	2001-11-24 22:26:44.000000000 +0200
***************
*** 0 ****
--- 1,155 ----
+  /* 
+   * UAE - The Un*x Amiga Emulator
+   * 
+   * Support for Linux/USS sound
+   * 
+   * Copyright 1997 Bernd Schmidt
+   */
+ 
+ #include "sysconfig.h"
+ #include "sysdeps.h"
+ 
+ #include "config.h"
+ #include "options.h"
+ #include "memory.h"
+ #include "events.h"
+ #include "custom.h"
+ #include "gensound.h"
+ #include "sounddep/sound.h"
+ 
+ #include <sys/ioctl.h>
+ 
+ #ifdef HAVE_SYS_SOUNDCARD_H
+ #include <sys/soundcard.h>
+ #elif defined HAVE_MACHINE_SOUNDCARD_H
+ #include <machine/soundcard.h>
+ #else
+ #error "Something went wrong during configuration."
+ #endif
+ 
+ int sound_fd;
+ static int have_sound = 0;
+ static unsigned long formats;
+ 
+ uae_u16 sndbuffer[44100];
+ uae_u16 *sndbufpt;
+ int sndbufsize;
+ 
+ static int exact_log2 (int v)
+ {
+     int l = 0;
+     while ((v >>= 1) != 0)
+ 	l++;
+     return l;
+ }
+ 
+ void close_sound (void)
+ {
+     if (have_sound)
+ 	close (sound_fd);
+ }
+ 
+ /* Try to determine whether sound is available.  This is only for GUI purposes.  */
+ int setup_sound (void)
+ {
+     sound_fd = open ("/dev/dsp", O_WRONLY);
+ 
+     sound_available = 0;
+ 
+     if (sound_fd < 0) {
+ 	perror ("Can't open /dev/dsp");
+ 	if (errno == EBUSY) {
+ 	    /* We can hope, can't we ;) */
+ 	    sound_available = 1;
+ 	    return 1;
+ 	}
+ 	return 0;
+     }
+ 
+     if (ioctl (sound_fd, SNDCTL_DSP_GETFMTS, &formats) == -1) {
+ 	perror ("ioctl failed - can't use sound");
+ 	close (sound_fd);
+ 	return 0;
+     }
+ 
+     sound_available = 1;
+     close (sound_fd);
+     return 1;
+ }
+ 
+ int init_sound (void)
+ {
+     int tmp;
+     int rate;
+     int dspbits;
+ 
+     sound_fd = open ("/dev/dsp", O_WRONLY);
+     have_sound = !(sound_fd < 0);
+     if (! have_sound) {
+ 	perror ("Can't open /dev/dsp");
+ 	if (errno != EBUSY)
+ 	    sound_available = 0;
+ 	return 0;
+     }
+     if (ioctl (sound_fd, SNDCTL_DSP_GETFMTS, &formats) == -1) {
+ 	perror ("ioctl failed - can't use sound");
+ 	close (sound_fd);
+ 	have_sound = 0;
+ 	return 0;
+     }
+ 
+     if (currprefs.sound_maxbsiz < 128 || currprefs.sound_maxbsiz > 16384) {
+ 	fprintf (stderr, "Sound buffer size %d out of range.\n", currprefs.sound_maxbsiz);
+ 	currprefs.sound_maxbsiz = 8192;
+     }
+ 
+     tmp = 0x00040000 + exact_log2 (currprefs.sound_maxbsiz);
+     ioctl (sound_fd, SNDCTL_DSP_SETFRAGMENT, &tmp);
+     ioctl (sound_fd, SNDCTL_DSP_GETBLKSIZE, &sndbufsize);
+ 
+     dspbits = currprefs.sound_bits;
+     ioctl (sound_fd, SNDCTL_DSP_SAMPLESIZE, &dspbits);
+     ioctl (sound_fd, SOUND_PCM_READ_BITS, &dspbits);
+     if (dspbits != currprefs.sound_bits) {
+ 	fprintf (stderr, "Can't use sound with %d bits\n", currprefs.sound_bits);
+ 	return 0;
+     }
+ 
+     tmp = currprefs.stereo;
+     ioctl (sound_fd, SNDCTL_DSP_STEREO, &tmp);
+ 
+     rate = currprefs.sound_freq;
+     ioctl (sound_fd, SNDCTL_DSP_SPEED, &rate);
+     ioctl (sound_fd, SOUND_PCM_READ_RATE, &rate);
+     /* Some soundcards have a bit of tolerance here. */
+     if (rate < currprefs.sound_freq * 90 / 100 || rate > currprefs.sound_freq * 110 / 100) {
+ 	fprintf (stderr, "Can't use sound with desired frequency %d\n", currprefs.sound_freq);
+ 	return 0;
+     }
+ 
+     scaled_sample_evtime = (unsigned long)MAXHPOS_PAL * MAXVPOS_PAL * VBLANK_HZ_PAL * CYCLE_UNIT / rate;
+     scaled_sample_evtime_ok = 1;
+ 
+     if (dspbits == 16) {
+ 	/* Will this break horribly on bigendian machines? Possible... */
+ 	if (!(formats & AFMT_S16_LE))
+ 	    return 0;
+ 	init_sound_table16 ();
+ 	sample_handler = currprefs.stereo ? sample16s_handler : sample16_handler;
+     } else {
+ 	if (!(formats & AFMT_U8))
+ 	    return 0;
+ 	init_sound_table8 ();
+ 	sample_handler = currprefs.stereo ? sample8s_handler : sample8_handler;
+     }
+     sound_available = 1;
+     printf ("Sound driver found and configured for %d bits at %d Hz, buffer is %d bytes\n",
+ 	    dspbits, rate, sndbufsize);
+     sndbufpt = sndbuffer;
+     
+ #ifdef FRAME_RATE_HACK
+     vsynctime = vsynctime * 9 / 10;
+ #endif	
+ 
+     return 1;
+ }
diff -crB --new-file ./uae-0.8.21/src/sounddep/sound.h ../uae_jit_cleaning/uae-0.8.21/src/sounddep/sound.h
*** ./uae-0.8.21/src/sounddep/sound.h	1970-01-01 02:00:00.000000000 +0200
--- ../uae_jit_cleaning/uae-0.8.21/src/sounddep/sound.h	2021-01-10 13:10:29.926591684 +0200
***************
*** 0 ****
--- 1,56 ----
+  /* 
+   * UAE - The Un*x Amiga Emulator
+   * 
+   * Support for Linux/USS sound
+   * 
+   * Copyright 1997 Bernd Schmidt
+   */
+ 
+ extern int sound_fd;
+ extern uae_u16 sndbuffer[];
+ extern uae_u16 *sndbufpt;
+ extern int sndbufsize;
+ 
+ static __inline__ void check_sound_buffers (void)
+ {
+     int delay;
+     
+     int size=(char *)sndbufpt - (char *)sndbuffer;
+     if (size >= sndbufsize) {
+ #if 0
+ 	ioctl(sound_fd,SNDCTL_DSP_GETODELAY,&delay);
+ 	if (delay<sndbufsize*1+size) {
+ 	    /* We are still OK */
+ 	}
+ 	else {
+ 	    unsigned long long x=sndbufsize;
+ 	    x*=syncbase;
+ 	    x/=currprefs.sound_freq;
+ 	    x/=(currprefs.sound_bits/8);
+ 	    x/=(currprefs.stereo+1);
+ 	    x/=16;  
+ 	    /* Skip one 1/16 buffer worth of time. That's 6% we can slow
+ 	       things down --- that should be enough! */
+ 	    vsyncmintime+=x;
+ 	    // fprintf(stderr,"Adding %llu ticks in sound\n",x);
+ 	}
+ #endif
+ 	write (sound_fd, sndbuffer, size);
+ 	sndbufpt = sndbuffer;
+     }
+ }
+ 
+ #define PUT_SOUND_BYTE(b) do { *(uae_u8 *)sndbufpt = b; sndbufpt = (uae_u16 *)(((uae_u8 *)sndbufpt) + 1); } while (0)
+ #define PUT_SOUND_WORD(b) do { *(uae_u16 *)sndbufpt = b; sndbufpt = (uae_u16 *)(((uae_u8 *)sndbufpt) + 2); } while (0)
+ #define PUT_SOUND_BYTE_LEFT(b) PUT_SOUND_BYTE(b)
+ #define PUT_SOUND_WORD_LEFT(b) PUT_SOUND_WORD(b)
+ #define PUT_SOUND_BYTE_RIGHT(b) PUT_SOUND_BYTE(b)
+ #define PUT_SOUND_WORD_RIGHT(b) PUT_SOUND_WORD(b)
+ #define SOUND16_BASE_VAL 0
+ #define SOUND8_BASE_VAL 128
+ 
+ #define DEFAULT_SOUND_MAXB 8192
+ #define DEFAULT_SOUND_MINB 8192
+ #define DEFAULT_SOUND_BITS 16
+ #define DEFAULT_SOUND_FREQ 44100
+ #define HAVE_STEREO_SUPPORT
diff -crB --new-file ./uae-0.8.21/src/sysconfig.h ../uae_jit_cleaning/uae-0.8.21/src/sysconfig.h
*** ./uae-0.8.21/src/sysconfig.h	1970-01-01 02:00:00.000000000 +0200
--- ../uae_jit_cleaning/uae-0.8.21/src/sysconfig.h	2021-01-10 13:14:38.490591684 +0200
***************
*** 0 ****
--- 1,373 ----
+ /* src/sysconfig.h.  Generated automatically by configure.  */
+ /* src/sysconfig.h.in.  Generated automatically from configure.in by autoheader.  */
+ 
+ /* Define if on AIX 3.
+    System headers sometimes define this.
+    We just want to avoid a redefinition error message.  */
+ #ifndef _ALL_SOURCE
+ /* #undef _ALL_SOURCE */
+ #endif
+ 
+ /* Define to empty if the keyword does not work.  */
+ /* #undef const */
+ 
+ /* Define if you have the getmntent function.  */
+ #define HAVE_GETMNTENT 1
+ 
+ /* Define if your struct stat has st_blocks.  */
+ #define HAVE_ST_BLOCKS 1
+ 
+ /* Define if utime(file, NULL) sets file's timestamp to the present.  */
+ #define HAVE_UTIME_NULL 1
+ 
+ /* Define as __inline if that's what the C compiler calls it.  */
+ /* #undef inline */
+ 
+ /* Define to `int' if <sys/types.h> doesn't define.  */
+ /* #undef mode_t */
+ 
+ /* Define to `long' if <sys/types.h> doesn't define.  */
+ /* #undef off_t */
+ 
+ /* Define to `int' if <sys/types.h> doesn't define.  */
+ /* #undef pid_t */
+ 
+ /* Define if you need to in order for stat and other things to work.  */
+ /* #undef _POSIX_SOURCE */
+ 
+ /* Define as the return type of signal handlers (int or void).  */
+ #define RETSIGTYPE void
+ 
+ /* Define if you have the ANSI C header files.  */
+ #define STDC_HEADERS 1
+ 
+ /* Define if you can safely include both <sys/time.h> and <time.h>.  */
+ #define TIME_WITH_SYS_TIME 1
+ 
+ /* Define if your <sys/time.h> declares struct tm.  */
+ /* #undef TM_IN_SYS_TIME */
+ 
+ /* Define if the X Window System is missing or not being used.  */
+ /* #undef X_DISPLAY_MISSING */
+ 
+ /* Define if you have the Andrew File System.  */
+ /* #undef AFS */
+ 
+ /* Define if there is no specific function for reading the list of
+    mounted filesystems.  fread will be used to read /etc/mnttab.  [SVR2]  */
+ /* #undef MOUNTED_FREAD */
+ 
+ /* Define if (like SVR2) there is no specific function for reading the
+    list of mounted filesystems, and your system has these header files:
+    <sys/fstyp.h> and <sys/statfs.h>.  [SVR3]  */
+ /* #undef MOUNTED_FREAD_FSTYP */
+ 
+ /* Define if there is a function named getfsstat for reading the list
+    of mounted filesystems.  [DEC Alpha running OSF/1]  */
+ /* #undef MOUNTED_GETFSSTAT */
+ 
+ /* Define if there is a function named getmnt for reading the list of
+    mounted filesystems.  [Ultrix]  */
+ /* #undef MOUNTED_GETMNT */
+ 
+ /* Define if there is a function named getmntent for reading the list
+    of mounted filesystems, and that function takes a single argument.
+    [4.3BSD, SunOS, HP-UX, Dynix, Irix]  */
+ #define MOUNTED_GETMNTENT1 1
+ 
+ /* Define if there is a function named getmntent for reading the list of
+    mounted filesystems, and that function takes two arguments.  [SVR4]  */
+ /* #undef MOUNTED_GETMNTENT2 */
+ 
+ /* Define if there is a function named getmntinfo for reading the list
+    of mounted filesystems.  [4.4BSD]  */
+ /* #undef MOUNTED_GETMNTINFO */
+ 
+ /* Define if there is a function named listmntent that can be used to
+    list all mounted filesystems. [UNICOS] */
+ /* #undef MOUNTED_LISTMNTENT */
+ 
+ /* Define if there is a function named mntctl that can be used to read
+    the list of mounted filesystems, and there is a system header file
+    that declares `struct vmount.'  [AIX]  */
+ /* #undef MOUNTED_VMOUNT */
+ 
+ /*  Define if  statfs takes 3 args.  [DEC Alpha running OSF/1]  */
+ /* #undef STAT_STATFS3_OSF1 */
+ 
+ /* Define if there is no specific function for reading filesystems usage
+    information and you have the <sys/filsys.h> header file.  [SVR2]  */
+ /* #undef STAT_READ_FILSYS */
+ 
+ /* Define if statfs takes 2 args and struct statfs has a field named f_bsize.
+    [4.3BSD, SunOS 4, HP-UX, AIX PS/2]  */
+ /* #undef STAT_STATFS2_BSIZE */
+ 
+ /* Define if statfs takes 2 args and struct statfs has a field named f_fsize.
+    [4.4BSD, NetBSD]  */
+ /* #undef STAT_STATFS2_FSIZE */
+ 
+ /* Define if statfs takes 2 args and the second argument has
+    type struct fs_data.  [Ultrix]  */
+ /* #undef STAT_STATFS2_FS_DATA */
+ 
+ /* Define if statfs takes 4 args.  [SVR3, Dynix, Irix, Dolphin]  */
+ /* #undef STAT_STATFS4 */
+ 
+ /* Define if there is a function named statvfs.  [SVR4]  */
+ #define STAT_STATVFS 1
+ 
+ /* Define if the block counts reported by statfs may be truncated to 2GB
+    and the correct values may be stored in the f_spare array.
+    [SunOS 4.1.2, 4.1.3, and 4.1.3_U1 are reported to have this problem.
+    SunOS 4.1.1 seems not to be affected.]  */
+ /* #undef STATFS_TRUNCATES_BLOCK_COUNTS */
+ 
+ /* The number of bytes in a __int64.  */
+ #define SIZEOF___INT64 0
+ 
+ /* The number of bytes in a char.  */
+ #define SIZEOF_CHAR 1
+ 
+ /* The number of bytes in a int.  */
+ #define SIZEOF_INT 4
+ 
+ /* The number of bytes in a long.  */
+ #define SIZEOF_LONG 4
+ 
+ /* The number of bytes in a long long.  */
+ #define SIZEOF_LONG_LONG 8
+ 
+ /* The number of bytes in a short.  */
+ #define SIZEOF_SHORT 2
+ 
+ /* Define if you have the bcopy function.  */
+ #define HAVE_BCOPY 1
+ 
+ /* Define if you have the cfmakeraw function.  */
+ #define HAVE_CFMAKERAW 1
+ 
+ /* Define if you have the endgrent function.  */
+ #define HAVE_ENDGRENT 1
+ 
+ /* Define if you have the endpwent function.  */
+ #define HAVE_ENDPWENT 1
+ 
+ /* Define if you have the fchdir function.  */
+ #define HAVE_FCHDIR 1
+ 
+ /* Define if you have the ftime function.  */
+ #define HAVE_FTIME 1
+ 
+ /* Define if you have the ftruncate function.  */
+ #define HAVE_FTRUNCATE 1
+ 
+ /* Define if you have the getcwd function.  */
+ #define HAVE_GETCWD 1
+ 
+ /* Define if you have the getmntinfo function.  */
+ /* #undef HAVE_GETMNTINFO */
+ 
+ /* Define if you have the getopt function.  */
+ #define HAVE_GETOPT 1
+ 
+ /* Define if you have the gettimeofday function.  */
+ #define HAVE_GETTIMEOFDAY 1
+ 
+ /* Define if you have the isascii function.  */
+ #define HAVE_ISASCII 1
+ 
+ /* Define if you have the lchown function.  */
+ #define HAVE_LCHOWN 1
+ 
+ /* Define if you have the listmntent function.  */
+ /* #undef HAVE_LISTMNTENT */
+ 
+ /* Define if you have the memcpy function.  */
+ #define HAVE_MEMCPY 1
+ 
+ /* Define if you have the mkdir function.  */
+ #define HAVE_MKDIR 1
+ 
+ /* Define if you have the mkfifo function.  */
+ #define HAVE_MKFIFO 1
+ 
+ /* Define if you have the readdir_r function.  */
+ #define HAVE_READDIR_R 1
+ 
+ /* Define if you have the rmdir function.  */
+ #define HAVE_RMDIR 1
+ 
+ /* Define if you have the select function.  */
+ #define HAVE_SELECT 1
+ 
+ /* Define if you have the setitimer function.  */
+ #define HAVE_SETITIMER 1
+ 
+ /* Define if you have the sigaction function.  */
+ #define HAVE_SIGACTION 1
+ 
+ /* Define if you have the strchr function.  */
+ #define HAVE_STRCHR 1
+ 
+ /* Define if you have the strdup function.  */
+ #define HAVE_STRDUP 1
+ 
+ /* Define if you have the strerror function.  */
+ #define HAVE_STRERROR 1
+ 
+ /* Define if you have the strrchr function.  */
+ #define HAVE_STRRCHR 1
+ 
+ /* Define if you have the strstr function.  */
+ #define HAVE_STRSTR 1
+ 
+ /* Define if you have the tcgetattr function.  */
+ #define HAVE_TCGETATTR 1
+ 
+ /* Define if you have the vfprintf function.  */
+ #define HAVE_VFPRINTF 1
+ 
+ /* Define if you have the vprintf function.  */
+ #define HAVE_VPRINTF 1
+ 
+ /* Define if you have the vsprintf function.  */
+ #define HAVE_VSPRINTF 1
+ 
+ /* Define if you have the <SDL/SDL.h> header file.  */
+ /* #undef HAVE_SDL_SDL_H */
+ 
+ /* Define if you have the <curses.h> header file.  */
+ #define HAVE_CURSES_H 1
+ 
+ /* Define if you have the <cybergraphx/cybergraphics.h> header file.  */
+ /* #undef HAVE_CYBERGRAPHX_CYBERGRAPHICS_H */
+ 
+ /* Define if you have the <ddraw.h> header file.  */
+ /* #undef HAVE_DDRAW_H */
+ 
+ /* Define if you have the <devices/ahi.h> header file.  */
+ /* #undef HAVE_DEVICES_AHI_H */
+ 
+ /* Define if you have the <dirent.h> header file.  */
+ #define HAVE_DIRENT_H 1
+ 
+ /* Define if you have the <dmedia/audio.h> header file.  */
+ /* #undef HAVE_DMEDIA_AUDIO_H */
+ 
+ /* Define if you have the <fcntl.h> header file.  */
+ #define HAVE_FCNTL_H 1
+ 
+ /* Define if you have the <features.h> header file.  */
+ #define HAVE_FEATURES_H 1
+ 
+ /* Define if you have the <getopt.h> header file.  */
+ #define HAVE_GETOPT_H 1
+ 
+ /* Define if you have the <libraries/cybergraphics.h> header file.  */
+ /* #undef HAVE_LIBRARIES_CYBERGRAPHICS_H */
+ 
+ /* Define if you have the <machine/joystick.h> header file.  */
+ /* #undef HAVE_MACHINE_JOYSTICK_H */
+ 
+ /* Define if you have the <machine/soundcard.h> header file.  */
+ /* #undef HAVE_MACHINE_SOUNDCARD_H */
+ 
+ /* Define if you have the <mntent.h> header file.  */
+ #define HAVE_MNTENT_H 1
+ 
+ /* Define if you have the <mnttab.h> header file.  */
+ /* #undef HAVE_MNTTAB_H */
+ 
+ /* Define if you have the <ncurses.h> header file.  */
+ #define HAVE_NCURSES_H 1
+ 
+ /* Define if you have the <ndir.h> header file.  */
+ /* #undef HAVE_NDIR_H */
+ 
+ /* Define if you have the <posix_opt.h> header file.  */
+ /* #undef HAVE_POSIX_OPT_H */
+ 
+ /* Define if you have the <string.h> header file.  */
+ #define HAVE_STRING_H 1
+ 
+ /* Define if you have the <strings.h> header file.  */
+ #define HAVE_STRINGS_H 1
+ 
+ /* Define if you have the <sun/audioio.h> header file.  */
+ /* #undef HAVE_SUN_AUDIOIO_H */
+ 
+ /* Define if you have the <sys/audioio.h> header file.  */
+ /* #undef HAVE_SYS_AUDIOIO_H */
+ 
+ /* Define if you have the <sys/dir.h> header file.  */
+ /* #undef HAVE_SYS_DIR_H */
+ 
+ /* Define if you have the <sys/filsys.h> header file.  */
+ /* #undef HAVE_SYS_FILSYS_H */
+ 
+ /* Define if you have the <sys/fs/s5param.h> header file.  */
+ /* #undef HAVE_SYS_FS_S5PARAM_H */
+ 
+ /* Define if you have the <sys/fs_types.h> header file.  */
+ /* #undef HAVE_SYS_FS_TYPES_H */
+ 
+ /* Define if you have the <sys/fstyp.h> header file.  */
+ /* #undef HAVE_SYS_FSTYP_H */
+ 
+ /* Define if you have the <sys/ioctl.h> header file.  */
+ #define HAVE_SYS_IOCTL_H 1
+ 
+ /* Define if you have the <sys/ipc.h> header file.  */
+ #define HAVE_SYS_IPC_H 1
+ 
+ /* Define if you have the <sys/mount.h> header file.  */
+ #define HAVE_SYS_MOUNT_H 1
+ 
+ /* Define if you have the <sys/ndir.h> header file.  */
+ /* #undef HAVE_SYS_NDIR_H */
+ 
+ /* Define if you have the <sys/param.h> header file.  */
+ #define HAVE_SYS_PARAM_H 1
+ 
+ /* Define if you have the <sys/shm.h> header file.  */
+ #define HAVE_SYS_SHM_H 1
+ 
+ /* Define if you have the <sys/soundcard.h> header file.  */
+ #define HAVE_SYS_SOUNDCARD_H 1
+ 
+ /* Define if you have the <sys/stat.h> header file.  */
+ #define HAVE_SYS_STAT_H 1
+ 
+ /* Define if you have the <sys/statfs.h> header file.  */
+ #define HAVE_SYS_STATFS_H 1
+ 
+ /* Define if you have the <sys/statvfs.h> header file.  */
+ #define HAVE_SYS_STATVFS_H 1
+ 
+ /* Define if you have the <sys/termios.h> header file.  */
+ #define HAVE_SYS_TERMIOS_H 1
+ 
+ /* Define if you have the <sys/time.h> header file.  */
+ #define HAVE_SYS_TIME_H 1
+ 
+ /* Define if you have the <sys/types.h> header file.  */
+ #define HAVE_SYS_TYPES_H 1
+ 
+ /* Define if you have the <sys/utime.h> header file.  */
+ /* #undef HAVE_SYS_UTIME_H */
+ 
+ /* Define if you have the <sys/vfs.h> header file.  */
+ #define HAVE_SYS_VFS_H 1
+ 
+ /* Define if you have the <unistd.h> header file.  */
+ #define HAVE_UNISTD_H 1
+ 
+ /* Define if you have the <utime.h> header file.  */
+ #define HAVE_UTIME_H 1
+ 
+ /* Define if you have the <values.h> header file.  */
+ #define HAVE_VALUES_H 1
+ 
+ /* Define if you have the <windows.h> header file.  */
+ /* #undef HAVE_WINDOWS_H */
diff -crB --new-file ./uae-0.8.21/src/target.h ../uae_jit_cleaning/uae-0.8.21/src/target.h
*** ./uae-0.8.21/src/target.h	1970-01-01 02:00:00.000000000 +0200
--- ../uae_jit_cleaning/uae-0.8.21/src/target.h	2021-01-10 13:54:02.642591684 +0200
***************
*** 0 ****
--- 1 ----
+ #include "/home/osboxes/uae_Archives/build_0_8_21_jit/uae_jit_cleaning/uae-0.8.21/src/targets/t-x11.h"
diff -crB --new-file ./uae-0.8.21/src/threaddep/thread.h ../uae_jit_cleaning/uae-0.8.21/src/threaddep/thread.h
*** ./uae-0.8.21/src/threaddep/thread.h	1970-01-01 02:00:00.000000000 +0200
--- ../uae_jit_cleaning/uae-0.8.21/src/threaddep/thread.h	2001-09-21 17:41:19.000000000 +0300
***************
*** 0 ****
--- 1,28 ----
+  /*
+   * UAE - The Un*x Amiga Emulator
+   * 
+   * Generic thread support doesn't exist.
+   * 
+   * Copyright 1997 Bernd Schmidt
+   */
+ 
+ #undef SUPPORT_PENGUINS
+ #undef SUPPORT_THREADS
+ 
+ typedef int uae_sem_t;
+ #define uae_sem_init(a,b,c)
+ #define uae_sem_destroy(a)
+ #define uae_sem_post(a)
+ #define uae_sem_wait(a)
+ #define uae_sem_trywait(a) 0
+ #define uae_sem_getvalue(a,b) 0
+ 
+ typedef int smp_comm_pipe;
+ #define write_comm_pipe_int(a,b,c)
+ #define read_comm_pipe_int_blocking(a) 0
+ #define write_comm_pipe_pvoid(a,b,c)
+ #define read_comm_pipe_pvoid_blocking(a) 0
+ #define init_comm_pipe(a,b,c)
+ #define comm_pipe_has_data(a) 0
+ 
+ typedef int uae_thread_id;
diff -crB --new-file ./uae-0.8.21/src/tools/config.cache ../uae_jit_cleaning/uae-0.8.21/src/tools/config.cache
*** ./uae-0.8.21/src/tools/config.cache	1970-01-01 02:00:00.000000000 +0200
--- ../uae_jit_cleaning/uae-0.8.21/src/tools/config.cache	2021-01-10 13:14:46.166591684 +0200
***************
*** 0 ****
--- 1,97 ----
+ # This file is a shell script that caches the results of configure
+ # tests run on this system so they can be shared between configure
+ # scripts and configure runs.  It is not useful on other systems.
+ # If it contains results you don't want to keep, you may remove or edit it.
+ #
+ # By default, configure uses ./config.cache as the cache file,
+ # creating it if it does not exist already.  You can give configure
+ # the --cache-file=FILE option to use a different cache file; that is
+ # what configure does when it calls configure scripts in
+ # subdirectories, so they share the cache.
+ # Giving --cache-file=/dev/null disables caching, for debugging configure.
+ # config.status only pays attention to the cache file if you give it the
+ # --recheck option to rerun configure.
+ #
+ ac_cv_c_const=${ac_cv_c_const='yes'}
+ ac_cv_c_inline=${ac_cv_c_inline='inline'}
+ ac_cv_func_cfmakeraw=${ac_cv_func_cfmakeraw='yes'}
+ ac_cv_func_connect=${ac_cv_func_connect='yes'}
+ ac_cv_func_getcwd=${ac_cv_func_getcwd='yes'}
+ ac_cv_func_gethostbyname=${ac_cv_func_gethostbyname='yes'}
+ ac_cv_func_getopt=${ac_cv_func_getopt='yes'}
+ ac_cv_func_gettimeofday=${ac_cv_func_gettimeofday='yes'}
+ ac_cv_func_memcmp_clean=${ac_cv_func_memcmp_clean='yes'}
+ ac_cv_func_mkdir=${ac_cv_func_mkdir='yes'}
+ ac_cv_func_readdir_r=${ac_cv_func_readdir_r='yes'}
+ ac_cv_func_remove=${ac_cv_func_remove='yes'}
+ ac_cv_func_rmdir=${ac_cv_func_rmdir='yes'}
+ ac_cv_func_select=${ac_cv_func_select='yes'}
+ ac_cv_func_setitimer=${ac_cv_func_setitimer='yes'}
+ ac_cv_func_shmat=${ac_cv_func_shmat='yes'}
+ ac_cv_func_sigaction=${ac_cv_func_sigaction='yes'}
+ ac_cv_func_strdup=${ac_cv_func_strdup='yes'}
+ ac_cv_func_strerror=${ac_cv_func_strerror='yes'}
+ ac_cv_func_strstr=${ac_cv_func_strstr='yes'}
+ ac_cv_func_tcgetattr=${ac_cv_func_tcgetattr='yes'}
+ ac_cv_func_utime_null=${ac_cv_func_utime_null='yes'}
+ ac_cv_func_vfprintf=${ac_cv_func_vfprintf='yes'}
+ ac_cv_func_vprintf=${ac_cv_func_vprintf='yes'}
+ ac_cv_func_vsprintf=${ac_cv_func_vsprintf='yes'}
+ ac_cv_have_x=${ac_cv_have_x='have_x=yes 		ac_x_includes= ac_x_libraries='}
+ ac_cv_header_SDL_SDL_h=${ac_cv_header_SDL_SDL_h='yes'}
+ ac_cv_header_be_math_h=${ac_cv_header_be_math_h='no'}
+ ac_cv_header_curses_h=${ac_cv_header_curses_h='yes'}
+ ac_cv_header_cybergraphx_cybergraphics_h=${ac_cv_header_cybergraphx_cybergraphics_h='no'}
+ ac_cv_header_ddraw_h=${ac_cv_header_ddraw_h='no'}
+ ac_cv_header_devices_ahi_h=${ac_cv_header_devices_ahi_h='no'}
+ ac_cv_header_dmedia_audio_h=${ac_cv_header_dmedia_audio_h='no'}
+ ac_cv_header_fcntl_h=${ac_cv_header_fcntl_h='yes'}
+ ac_cv_header_features_h=${ac_cv_header_features_h='yes'}
+ ac_cv_header_getopt_h=${ac_cv_header_getopt_h='yes'}
+ ac_cv_header_libraries_cybergraphics_h=${ac_cv_header_libraries_cybergraphics_h='no'}
+ ac_cv_header_machine_joystick_h=${ac_cv_header_machine_joystick_h='no'}
+ ac_cv_header_machine_soundcard_h=${ac_cv_header_machine_soundcard_h='no'}
+ ac_cv_header_ncurses_h=${ac_cv_header_ncurses_h='yes'}
+ ac_cv_header_posix_opt_h=${ac_cv_header_posix_opt_h='no'}
+ ac_cv_header_stdc=${ac_cv_header_stdc='yes'}
+ ac_cv_header_string_h=${ac_cv_header_string_h='yes'}
+ ac_cv_header_strings_h=${ac_cv_header_strings_h='yes'}
+ ac_cv_header_sun_audioio_h=${ac_cv_header_sun_audioio_h='no'}
+ ac_cv_header_sys_audioio_h=${ac_cv_header_sys_audioio_h='no'}
+ ac_cv_header_sys_ioctl_h=${ac_cv_header_sys_ioctl_h='yes'}
+ ac_cv_header_sys_ipc_h=${ac_cv_header_sys_ipc_h='yes'}
+ ac_cv_header_sys_shm_h=${ac_cv_header_sys_shm_h='yes'}
+ ac_cv_header_sys_soundcard_h=${ac_cv_header_sys_soundcard_h='yes'}
+ ac_cv_header_sys_stat_h=${ac_cv_header_sys_stat_h='yes'}
+ ac_cv_header_sys_termios_h=${ac_cv_header_sys_termios_h='yes'}
+ ac_cv_header_sys_time_h=${ac_cv_header_sys_time_h='yes'}
+ ac_cv_header_sys_types_h=${ac_cv_header_sys_types_h='yes'}
+ ac_cv_header_sys_utime_h=${ac_cv_header_sys_utime_h='no'}
+ ac_cv_header_time=${ac_cv_header_time='yes'}
+ ac_cv_header_unistd_h=${ac_cv_header_unistd_h='yes'}
+ ac_cv_header_utime_h=${ac_cv_header_utime_h='yes'}
+ ac_cv_header_values_h=${ac_cv_header_values_h='yes'}
+ ac_cv_header_windows_h=${ac_cv_header_windows_h='no'}
+ ac_cv_lib_ICE_IceConnectionNumber=${ac_cv_lib_ICE_IceConnectionNumber='yes'}
+ ac_cv_lib_dnet_dnet_ntoa=${ac_cv_lib_dnet_dnet_ntoa='no'}
+ ac_cv_lib_dnet_stub_dnet_ntoa=${ac_cv_lib_dnet_stub_dnet_ntoa='no'}
+ ac_cv_prog_CC=${ac_cv_prog_CC='gcc'}
+ ac_cv_prog_CPP=${ac_cv_prog_CPP='gcc -E'}
+ ac_cv_prog_cc_cross=${ac_cv_prog_cc_cross='no'}
+ ac_cv_prog_cc_g=${ac_cv_prog_cc_g='yes'}
+ ac_cv_prog_cc_works=${ac_cv_prog_cc_works='yes'}
+ ac_cv_prog_gcc=${ac_cv_prog_gcc='yes'}
+ ac_cv_prog_gcc_traditional=${ac_cv_prog_gcc_traditional='no'}
+ ac_cv_prog_make_make_set=${ac_cv_prog_make_make_set='yes'}
+ ac_cv_sizeof___int64=${ac_cv_sizeof___int64='0'}
+ ac_cv_sizeof_char=${ac_cv_sizeof_char='1'}
+ ac_cv_sizeof_int=${ac_cv_sizeof_int='4'}
+ ac_cv_sizeof_long=${ac_cv_sizeof_long='4'}
+ ac_cv_sizeof_long_long=${ac_cv_sizeof_long_long='8'}
+ ac_cv_sizeof_short=${ac_cv_sizeof_short='2'}
+ ac_cv_struct_st_blocks=${ac_cv_struct_st_blocks='yes'}
+ ac_cv_struct_tm=${ac_cv_struct_tm='time.h'}
+ ac_cv_type_mode_t=${ac_cv_type_mode_t='yes'}
+ ac_cv_type_off_t=${ac_cv_type_off_t='yes'}
+ ac_cv_type_pid_t=${ac_cv_type_pid_t='yes'}
+ ac_cv_type_signal=${ac_cv_type_signal='void'}
diff -crB --new-file ./uae-0.8.21/src/tools/config.log ../uae_jit_cleaning/uae-0.8.21/src/tools/config.log
*** ./uae-0.8.21/src/tools/config.log	1970-01-01 02:00:00.000000000 +0200
--- ../uae_jit_cleaning/uae-0.8.21/src/tools/config.log	2021-01-10 13:54:05.570591684 +0200
***************
*** 0 ****
--- 1,89 ----
+ This file contains any messages produced by compilers while
+ running configure, to aid debugging if configure makes a mistake.
+ 
+ configure:532: checking for gcc
+ configure:645: checking whether the C compiler (gcc  ) works
+ configure:661: gcc -o conftest    conftest.c  1>&5
+ configure:687: checking whether the C compiler (gcc  ) is a cross-compiler
+ configure:692: checking whether we are using GNU C
+ configure:720: checking whether gcc accepts -g
+ configure:753: checking how to run the C preprocessor
+ configure:833: checking whether make sets ${MAKE}
+ configure:861: checking for AIX
+ configure:885: checking for POSIXized ISC
+ configure:912: checking for X
+ configure:1226: checking for dnet_ntoa in -ldnet
+ configure:1267: checking for dnet_ntoa in -ldnet_stub
+ configure:1315: checking for gethostbyname
+ configure:1413: checking for connect
+ configure:1505: checking for remove
+ configure:1597: checking for shmat
+ configure:1698: checking for IceConnectionNumber in -lICE
+ configure:1744: checking for ANSI C header files
+ configure:1852: checking for unistd.h
+ configure:1852: checking for fcntl.h
+ configure:1852: checking for sys/time.h
+ configure:1852: checking for sys/types.h
+ configure:1852: checking for utime.h
+ configure:1852: checking for string.h
+ configure:1852: checking for strings.h
+ configure:1852: checking for values.h
+ configure:1852: checking for ncurses.h
+ configure:1852: checking for curses.h
+ configure:1892: checking for sys/soundcard.h
+ configure:1892: checking for machine/soundcard.h
+ configure:1892: checking for sun/audioio.h
+ configure:1892: checking for sys/audioio.h
+ configure:1892: checking for getopt.h
+ configure:1892: checking for features.h
+ configure:1892: checking for sys/termios.h
+ configure:1932: checking for posix_opt.h
+ configure:1932: checking for sys/ioctl.h
+ configure:1932: checking for sys/ipc.h
+ configure:1932: checking for sys/shm.h
+ configure:1932: checking for sys/stat.h
+ configure:1932: checking for sys/utime.h
+ configure:1972: checking for windows.h
+ configure:1972: checking for ddraw.h
+ configure:2010: checking for be_math.h
+ configure:2046: checking for machine/joystick.h
+ configure:2086: checking for devices/ahi.h
+ configure:2126: checking for dmedia/audio.h
+ configure:2126: checking for SDL/SDL.h
+ configure:2166: checking for libraries/cybergraphics.h
+ configure:2166: checking for cybergraphx/cybergraphics.h
+ configure:2204: checking size of char
+ configure:2243: checking size of short
+ configure:2282: checking size of int
+ configure:2321: checking size of long
+ configure:2360: checking size of long long
+ configure:2399: checking size of __int64
+ configure:2439: checking for working const
+ configure:2514: checking for inline
+ configure:2557: checking for mode_t
+ configure:2590: checking for off_t
+ configure:2623: checking for pid_t
+ configure:2656: checking for st_blocks in struct stat
+ configure:2692: checking whether time.h and sys/time.h may both be included
+ configure:2727: checking whether struct tm is in sys/time.h or time.h
+ configure:2763: checking whether gcc needs -traditional
+ configure:2809: checking for 8-bit clean memcmp
+ configure:2845: checking return type of signal handlers
+ configure:2886: checking whether utime accepts a null argument
+ configure:2933: checking for getcwd
+ configure:2933: checking for getopt
+ configure:2933: checking for strdup
+ configure:2933: checking for gettimeofday
+ configure:2933: checking for sigaction
+ configure:2933: checking for mkdir
+ configure:2933: checking for rmdir
+ configure:2933: checking for select
+ configure:2933: checking for strerror
+ configure:2933: checking for strstr
+ configure:2988: checking for tcgetattr
+ configure:2988: checking for cfmakeraw
+ configure:2988: checking for readdir_r
+ configure:2988: checking for vprintf
+ configure:2988: checking for vsprintf
+ configure:2988: checking for vfprintf
+ configure:2988: checking for setitimer
diff -crB --new-file ./uae-0.8.21/src/tools/config.status ../uae_jit_cleaning/uae-0.8.21/src/tools/config.status
*** ./uae-0.8.21/src/tools/config.status	1970-01-01 02:00:00.000000000 +0200
--- ../uae_jit_cleaning/uae-0.8.21/src/tools/config.status	2021-01-10 13:54:06.118591684 +0200
***************
*** 0 ****
--- 1,429 ----
+ #! /bin/sh
+ # Generated automatically by configure.
+ # Run this file to recreate the current configuration.
+ # This directory was configured as follows,
+ # on host osboxes:
+ #
+ # /home/osboxes/uae_Archives/build_0_8_21_jit/uae_jit_cleaning/uae-0.8.21/src/tools/configure 
+ #
+ # Compiler output produced by configure, useful for debugging
+ # configure, is in ./config.log if it exists.
+ 
+ ac_cs_usage="Usage: ./config.status [--recheck] [--version] [--help]"
+ for ac_option
+ do
+   case "$ac_option" in
+   -recheck | --recheck | --rechec | --reche | --rech | --rec | --re | --r)
+     echo "running ${CONFIG_SHELL-/bin/sh} /home/osboxes/uae_Archives/build_0_8_21_jit/uae_jit_cleaning/uae-0.8.21/src/tools/configure  --no-create --no-recursion"
+     exec ${CONFIG_SHELL-/bin/sh} /home/osboxes/uae_Archives/build_0_8_21_jit/uae_jit_cleaning/uae-0.8.21/src/tools/configure  --no-create --no-recursion ;;
+   -version | --version | --versio | --versi | --vers | --ver | --ve | --v)
+     echo "./config.status generated by autoconf version 2.13"
+     exit 0 ;;
+   -help | --help | --hel | --he | --h)
+     echo "$ac_cs_usage"; exit 0 ;;
+   *) echo "$ac_cs_usage"; exit 1 ;;
+   esac
+ done
+ 
+ ac_given_srcdir=/home/osboxes/uae_Archives/build_0_8_21_jit/uae_jit_cleaning/uae-0.8.21/src/tools
+ 
+ trap 'rm -fr Makefile sysconfig.h conftest*; exit 1' 1 2 15
+ 
+ # Protect against being on the right side of a sed subst in config.status.
+ sed 's/%@/@@/; s/@%/@@/; s/%g$/@g/; /@g$/s/[\\&%]/\\&/g;
+  s/@@/%@/; s/@@/@%/; s/@g$/%g/' > conftest.subs <<\CEOF
+ 
+ 
+ s%@SHELL@%/bin/sh%g
+ s%@CFLAGS@%-g -O2%g
+ s%@CPPFLAGS@%%g
+ s%@CXXFLAGS@%%g
+ s%@FFLAGS@%%g
+ s%@DEFS@%-DHAVE_CONFIG_H%g
+ s%@LDFLAGS@%%g
+ s%@LIBS@%%g
+ s%@exec_prefix@%${prefix}%g
+ s%@prefix@%/usr/local%g
+ s%@program_transform_name@%s,x,x,%g
+ s%@bindir@%${exec_prefix}/bin%g
+ s%@sbindir@%${exec_prefix}/sbin%g
+ s%@libexecdir@%${exec_prefix}/libexec%g
+ s%@datadir@%${prefix}/share%g
+ s%@sysconfdir@%${prefix}/etc%g
+ s%@sharedstatedir@%${prefix}/com%g
+ s%@localstatedir@%${prefix}/var%g
+ s%@libdir@%${exec_prefix}/lib%g
+ s%@includedir@%${prefix}/include%g
+ s%@oldincludedir@%/usr/include%g
+ s%@infodir@%${prefix}/info%g
+ s%@mandir@%${prefix}/man%g
+ s%@CC@%gcc%g
+ s%@CPP@%gcc -E%g
+ s%@SET_MAKE@%%g
+ s%@X_CFLAGS@%%g
+ s%@X_PRE_LIBS@% -lSM -lICE%g
+ s%@X_LIBS@%%g
+ s%@X_EXTRA_LIBS@%%g
+ s%@LIBOBJS@%%g
+ s%@ac_cv_c_inline@%inline%g
+ s%@WRC@%%g
+ s%@top_srcdir@%%g
+ 
+ CEOF
+ 
+ # Split the substitutions into bite-sized pieces for seds with
+ # small command number limits, like on Digital OSF/1 and HP-UX.
+ ac_max_sed_cmds=90 # Maximum number of lines to put in a sed script.
+ ac_file=1 # Number of current file.
+ ac_beg=1 # First line for current file.
+ ac_end=$ac_max_sed_cmds # Line after last line for current file.
+ ac_more_lines=:
+ ac_sed_cmds=""
+ while $ac_more_lines; do
+   if test $ac_beg -gt 1; then
+     sed "1,${ac_beg}d; ${ac_end}q" conftest.subs > conftest.s$ac_file
+   else
+     sed "${ac_end}q" conftest.subs > conftest.s$ac_file
+   fi
+   if test ! -s conftest.s$ac_file; then
+     ac_more_lines=false
+     rm -f conftest.s$ac_file
+   else
+     if test -z "$ac_sed_cmds"; then
+       ac_sed_cmds="sed -f conftest.s$ac_file"
+     else
+       ac_sed_cmds="$ac_sed_cmds | sed -f conftest.s$ac_file"
+     fi
+     ac_file=`expr $ac_file + 1`
+     ac_beg=$ac_end
+     ac_end=`expr $ac_end + $ac_max_sed_cmds`
+   fi
+ done
+ if test -z "$ac_sed_cmds"; then
+   ac_sed_cmds=cat
+ fi
+ 
+ CONFIG_FILES=${CONFIG_FILES-"Makefile"}
+ for ac_file in .. $CONFIG_FILES; do if test "x$ac_file" != x..; then
+   # Support "outfile[:infile[:infile...]]", defaulting infile="outfile.in".
+   case "$ac_file" in
+   *:*) ac_file_in=`echo "$ac_file"|sed 's%[^:]*:%%'`
+        ac_file=`echo "$ac_file"|sed 's%:.*%%'` ;;
+   *) ac_file_in="${ac_file}.in" ;;
+   esac
+ 
+   # Adjust a relative srcdir, top_srcdir, and INSTALL for subdirectories.
+ 
+   # Remove last slash and all that follows it.  Not all systems have dirname.
+   ac_dir=`echo $ac_file|sed 's%/[^/][^/]*$%%'`
+   if test "$ac_dir" != "$ac_file" && test "$ac_dir" != .; then
+     # The file is in a subdirectory.
+     test ! -d "$ac_dir" && mkdir "$ac_dir"
+     ac_dir_suffix="/`echo $ac_dir|sed 's%^\./%%'`"
+     # A "../" for each directory in $ac_dir_suffix.
+     ac_dots=`echo $ac_dir_suffix|sed 's%/[^/]*%../%g'`
+   else
+     ac_dir_suffix= ac_dots=
+   fi
+ 
+   case "$ac_given_srcdir" in
+   .)  srcdir=.
+       if test -z "$ac_dots"; then top_srcdir=.
+       else top_srcdir=`echo $ac_dots|sed 's%/$%%'`; fi ;;
+   /*) srcdir="$ac_given_srcdir$ac_dir_suffix"; top_srcdir="$ac_given_srcdir" ;;
+   *) # Relative path.
+     srcdir="$ac_dots$ac_given_srcdir$ac_dir_suffix"
+     top_srcdir="$ac_dots$ac_given_srcdir" ;;
+   esac
+ 
+ 
+   echo creating "$ac_file"
+   rm -f "$ac_file"
+   configure_input="Generated automatically from `echo $ac_file_in|sed 's%.*/%%'` by configure."
+   case "$ac_file" in
+   *Makefile*) ac_comsub="1i\\
+ # $configure_input" ;;
+   *) ac_comsub= ;;
+   esac
+ 
+   ac_file_inputs=`echo $ac_file_in|sed -e "s%^%$ac_given_srcdir/%" -e "s%:% $ac_given_srcdir/%g"`
+   sed -e "$ac_comsub
+ s%@configure_input@%$configure_input%g
+ s%@srcdir@%$srcdir%g
+ s%@top_srcdir@%$top_srcdir%g
+ " $ac_file_inputs | (eval "$ac_sed_cmds") > $ac_file
+ fi; done
+ rm -f conftest.s*
+ 
+ # These sed commands are passed to sed as "A NAME B NAME C VALUE D", where
+ # NAME is the cpp macro being defined and VALUE is the value it is being given.
+ #
+ # ac_d sets the value in "#define NAME VALUE" lines.
+ ac_dA='s%^\([ 	]*\)#\([ 	]*define[ 	][ 	]*\)'
+ ac_dB='\([ 	][ 	]*\)[^ 	]*%\1#\2'
+ ac_dC='\3'
+ ac_dD='%g'
+ # ac_u turns "#undef NAME" with trailing blanks into "#define NAME VALUE".
+ ac_uA='s%^\([ 	]*\)#\([ 	]*\)undef\([ 	][ 	]*\)'
+ ac_uB='\([ 	]\)%\1#\2define\3'
+ ac_uC=' '
+ ac_uD='\4%g'
+ # ac_e turns "#undef NAME" without trailing blanks into "#define NAME VALUE".
+ ac_eA='s%^\([ 	]*\)#\([ 	]*\)undef\([ 	][ 	]*\)'
+ ac_eB='$%\1#\2define\3'
+ ac_eC=' '
+ ac_eD='%g'
+ 
+ if test "${CONFIG_HEADERS+set}" != set; then
+   CONFIG_HEADERS="sysconfig.h"
+ fi
+ for ac_file in .. $CONFIG_HEADERS; do if test "x$ac_file" != x..; then
+   # Support "outfile[:infile[:infile...]]", defaulting infile="outfile.in".
+   case "$ac_file" in
+   *:*) ac_file_in=`echo "$ac_file"|sed 's%[^:]*:%%'`
+        ac_file=`echo "$ac_file"|sed 's%:.*%%'` ;;
+   *) ac_file_in="${ac_file}.in" ;;
+   esac
+ 
+   echo creating $ac_file
+ 
+   rm -f conftest.frag conftest.in conftest.out
+   ac_file_inputs=`echo $ac_file_in|sed -e "s%^%$ac_given_srcdir/%" -e "s%:% $ac_given_srcdir/%g"`
+   cat $ac_file_inputs > conftest.in
+ 
+   cat > conftest.frag <<CEOF
+ ${ac_dA}STDC_HEADERS${ac_dB}STDC_HEADERS${ac_dC}1${ac_dD}
+ ${ac_uA}STDC_HEADERS${ac_uB}STDC_HEADERS${ac_uC}1${ac_uD}
+ ${ac_eA}STDC_HEADERS${ac_eB}STDC_HEADERS${ac_eC}1${ac_eD}
+ ${ac_dA}HAVE_UNISTD_H${ac_dB}HAVE_UNISTD_H${ac_dC}1${ac_dD}
+ ${ac_uA}HAVE_UNISTD_H${ac_uB}HAVE_UNISTD_H${ac_uC}1${ac_uD}
+ ${ac_eA}HAVE_UNISTD_H${ac_eB}HAVE_UNISTD_H${ac_eC}1${ac_eD}
+ ${ac_dA}HAVE_FCNTL_H${ac_dB}HAVE_FCNTL_H${ac_dC}1${ac_dD}
+ ${ac_uA}HAVE_FCNTL_H${ac_uB}HAVE_FCNTL_H${ac_uC}1${ac_uD}
+ ${ac_eA}HAVE_FCNTL_H${ac_eB}HAVE_FCNTL_H${ac_eC}1${ac_eD}
+ ${ac_dA}HAVE_SYS_TIME_H${ac_dB}HAVE_SYS_TIME_H${ac_dC}1${ac_dD}
+ ${ac_uA}HAVE_SYS_TIME_H${ac_uB}HAVE_SYS_TIME_H${ac_uC}1${ac_uD}
+ ${ac_eA}HAVE_SYS_TIME_H${ac_eB}HAVE_SYS_TIME_H${ac_eC}1${ac_eD}
+ CEOF
+   sed -f conftest.frag conftest.in > conftest.out
+   rm -f conftest.in
+   mv conftest.out conftest.in
+ 
+   cat > conftest.frag <<CEOF
+ ${ac_dA}HAVE_SYS_TYPES_H${ac_dB}HAVE_SYS_TYPES_H${ac_dC}1${ac_dD}
+ ${ac_uA}HAVE_SYS_TYPES_H${ac_uB}HAVE_SYS_TYPES_H${ac_uC}1${ac_uD}
+ ${ac_eA}HAVE_SYS_TYPES_H${ac_eB}HAVE_SYS_TYPES_H${ac_eC}1${ac_eD}
+ ${ac_dA}HAVE_UTIME_H${ac_dB}HAVE_UTIME_H${ac_dC}1${ac_dD}
+ ${ac_uA}HAVE_UTIME_H${ac_uB}HAVE_UTIME_H${ac_uC}1${ac_uD}
+ ${ac_eA}HAVE_UTIME_H${ac_eB}HAVE_UTIME_H${ac_eC}1${ac_eD}
+ ${ac_dA}HAVE_STRING_H${ac_dB}HAVE_STRING_H${ac_dC}1${ac_dD}
+ ${ac_uA}HAVE_STRING_H${ac_uB}HAVE_STRING_H${ac_uC}1${ac_uD}
+ ${ac_eA}HAVE_STRING_H${ac_eB}HAVE_STRING_H${ac_eC}1${ac_eD}
+ ${ac_dA}HAVE_STRINGS_H${ac_dB}HAVE_STRINGS_H${ac_dC}1${ac_dD}
+ ${ac_uA}HAVE_STRINGS_H${ac_uB}HAVE_STRINGS_H${ac_uC}1${ac_uD}
+ ${ac_eA}HAVE_STRINGS_H${ac_eB}HAVE_STRINGS_H${ac_eC}1${ac_eD}
+ CEOF
+   sed -f conftest.frag conftest.in > conftest.out
+   rm -f conftest.in
+   mv conftest.out conftest.in
+ 
+   cat > conftest.frag <<CEOF
+ ${ac_dA}HAVE_VALUES_H${ac_dB}HAVE_VALUES_H${ac_dC}1${ac_dD}
+ ${ac_uA}HAVE_VALUES_H${ac_uB}HAVE_VALUES_H${ac_uC}1${ac_uD}
+ ${ac_eA}HAVE_VALUES_H${ac_eB}HAVE_VALUES_H${ac_eC}1${ac_eD}
+ ${ac_dA}HAVE_NCURSES_H${ac_dB}HAVE_NCURSES_H${ac_dC}1${ac_dD}
+ ${ac_uA}HAVE_NCURSES_H${ac_uB}HAVE_NCURSES_H${ac_uC}1${ac_uD}
+ ${ac_eA}HAVE_NCURSES_H${ac_eB}HAVE_NCURSES_H${ac_eC}1${ac_eD}
+ ${ac_dA}HAVE_CURSES_H${ac_dB}HAVE_CURSES_H${ac_dC}1${ac_dD}
+ ${ac_uA}HAVE_CURSES_H${ac_uB}HAVE_CURSES_H${ac_uC}1${ac_uD}
+ ${ac_eA}HAVE_CURSES_H${ac_eB}HAVE_CURSES_H${ac_eC}1${ac_eD}
+ ${ac_dA}HAVE_SYS_SOUNDCARD_H${ac_dB}HAVE_SYS_SOUNDCARD_H${ac_dC}1${ac_dD}
+ ${ac_uA}HAVE_SYS_SOUNDCARD_H${ac_uB}HAVE_SYS_SOUNDCARD_H${ac_uC}1${ac_uD}
+ ${ac_eA}HAVE_SYS_SOUNDCARD_H${ac_eB}HAVE_SYS_SOUNDCARD_H${ac_eC}1${ac_eD}
+ CEOF
+   sed -f conftest.frag conftest.in > conftest.out
+   rm -f conftest.in
+   mv conftest.out conftest.in
+ 
+   cat > conftest.frag <<CEOF
+ ${ac_dA}HAVE_GETOPT_H${ac_dB}HAVE_GETOPT_H${ac_dC}1${ac_dD}
+ ${ac_uA}HAVE_GETOPT_H${ac_uB}HAVE_GETOPT_H${ac_uC}1${ac_uD}
+ ${ac_eA}HAVE_GETOPT_H${ac_eB}HAVE_GETOPT_H${ac_eC}1${ac_eD}
+ ${ac_dA}HAVE_FEATURES_H${ac_dB}HAVE_FEATURES_H${ac_dC}1${ac_dD}
+ ${ac_uA}HAVE_FEATURES_H${ac_uB}HAVE_FEATURES_H${ac_uC}1${ac_uD}
+ ${ac_eA}HAVE_FEATURES_H${ac_eB}HAVE_FEATURES_H${ac_eC}1${ac_eD}
+ ${ac_dA}HAVE_SYS_TERMIOS_H${ac_dB}HAVE_SYS_TERMIOS_H${ac_dC}1${ac_dD}
+ ${ac_uA}HAVE_SYS_TERMIOS_H${ac_uB}HAVE_SYS_TERMIOS_H${ac_uC}1${ac_uD}
+ ${ac_eA}HAVE_SYS_TERMIOS_H${ac_eB}HAVE_SYS_TERMIOS_H${ac_eC}1${ac_eD}
+ ${ac_dA}HAVE_SYS_IOCTL_H${ac_dB}HAVE_SYS_IOCTL_H${ac_dC}1${ac_dD}
+ ${ac_uA}HAVE_SYS_IOCTL_H${ac_uB}HAVE_SYS_IOCTL_H${ac_uC}1${ac_uD}
+ ${ac_eA}HAVE_SYS_IOCTL_H${ac_eB}HAVE_SYS_IOCTL_H${ac_eC}1${ac_eD}
+ CEOF
+   sed -f conftest.frag conftest.in > conftest.out
+   rm -f conftest.in
+   mv conftest.out conftest.in
+ 
+   cat > conftest.frag <<CEOF
+ ${ac_dA}HAVE_SYS_IPC_H${ac_dB}HAVE_SYS_IPC_H${ac_dC}1${ac_dD}
+ ${ac_uA}HAVE_SYS_IPC_H${ac_uB}HAVE_SYS_IPC_H${ac_uC}1${ac_uD}
+ ${ac_eA}HAVE_SYS_IPC_H${ac_eB}HAVE_SYS_IPC_H${ac_eC}1${ac_eD}
+ ${ac_dA}HAVE_SYS_SHM_H${ac_dB}HAVE_SYS_SHM_H${ac_dC}1${ac_dD}
+ ${ac_uA}HAVE_SYS_SHM_H${ac_uB}HAVE_SYS_SHM_H${ac_uC}1${ac_uD}
+ ${ac_eA}HAVE_SYS_SHM_H${ac_eB}HAVE_SYS_SHM_H${ac_eC}1${ac_eD}
+ ${ac_dA}HAVE_SYS_STAT_H${ac_dB}HAVE_SYS_STAT_H${ac_dC}1${ac_dD}
+ ${ac_uA}HAVE_SYS_STAT_H${ac_uB}HAVE_SYS_STAT_H${ac_uC}1${ac_uD}
+ ${ac_eA}HAVE_SYS_STAT_H${ac_eB}HAVE_SYS_STAT_H${ac_eC}1${ac_eD}
+ ${ac_dA}HAVE_SDL_SDL_H${ac_dB}HAVE_SDL_SDL_H${ac_dC}1${ac_dD}
+ ${ac_uA}HAVE_SDL_SDL_H${ac_uB}HAVE_SDL_SDL_H${ac_uC}1${ac_uD}
+ ${ac_eA}HAVE_SDL_SDL_H${ac_eB}HAVE_SDL_SDL_H${ac_eC}1${ac_eD}
+ CEOF
+   sed -f conftest.frag conftest.in > conftest.out
+   rm -f conftest.in
+   mv conftest.out conftest.in
+ 
+   cat > conftest.frag <<CEOF
+ ${ac_dA}SIZEOF_CHAR${ac_dB}SIZEOF_CHAR${ac_dC}1${ac_dD}
+ ${ac_uA}SIZEOF_CHAR${ac_uB}SIZEOF_CHAR${ac_uC}1${ac_uD}
+ ${ac_eA}SIZEOF_CHAR${ac_eB}SIZEOF_CHAR${ac_eC}1${ac_eD}
+ ${ac_dA}SIZEOF_SHORT${ac_dB}SIZEOF_SHORT${ac_dC}2${ac_dD}
+ ${ac_uA}SIZEOF_SHORT${ac_uB}SIZEOF_SHORT${ac_uC}2${ac_uD}
+ ${ac_eA}SIZEOF_SHORT${ac_eB}SIZEOF_SHORT${ac_eC}2${ac_eD}
+ ${ac_dA}SIZEOF_INT${ac_dB}SIZEOF_INT${ac_dC}4${ac_dD}
+ ${ac_uA}SIZEOF_INT${ac_uB}SIZEOF_INT${ac_uC}4${ac_uD}
+ ${ac_eA}SIZEOF_INT${ac_eB}SIZEOF_INT${ac_eC}4${ac_eD}
+ ${ac_dA}SIZEOF_LONG${ac_dB}SIZEOF_LONG${ac_dC}4${ac_dD}
+ ${ac_uA}SIZEOF_LONG${ac_uB}SIZEOF_LONG${ac_uC}4${ac_uD}
+ ${ac_eA}SIZEOF_LONG${ac_eB}SIZEOF_LONG${ac_eC}4${ac_eD}
+ CEOF
+   sed -f conftest.frag conftest.in > conftest.out
+   rm -f conftest.in
+   mv conftest.out conftest.in
+ 
+   cat > conftest.frag <<CEOF
+ ${ac_dA}SIZEOF_LONG_LONG${ac_dB}SIZEOF_LONG_LONG${ac_dC}8${ac_dD}
+ ${ac_uA}SIZEOF_LONG_LONG${ac_uB}SIZEOF_LONG_LONG${ac_uC}8${ac_uD}
+ ${ac_eA}SIZEOF_LONG_LONG${ac_eB}SIZEOF_LONG_LONG${ac_eC}8${ac_eD}
+ ${ac_dA}SIZEOF___INT64${ac_dB}SIZEOF___INT64${ac_dC}0${ac_dD}
+ ${ac_uA}SIZEOF___INT64${ac_uB}SIZEOF___INT64${ac_uC}0${ac_uD}
+ ${ac_eA}SIZEOF___INT64${ac_eB}SIZEOF___INT64${ac_eC}0${ac_eD}
+ ${ac_dA}HAVE_ST_BLOCKS${ac_dB}HAVE_ST_BLOCKS${ac_dC}1${ac_dD}
+ ${ac_uA}HAVE_ST_BLOCKS${ac_uB}HAVE_ST_BLOCKS${ac_uC}1${ac_uD}
+ ${ac_eA}HAVE_ST_BLOCKS${ac_eB}HAVE_ST_BLOCKS${ac_eC}1${ac_eD}
+ ${ac_dA}TIME_WITH_SYS_TIME${ac_dB}TIME_WITH_SYS_TIME${ac_dC}1${ac_dD}
+ ${ac_uA}TIME_WITH_SYS_TIME${ac_uB}TIME_WITH_SYS_TIME${ac_uC}1${ac_uD}
+ ${ac_eA}TIME_WITH_SYS_TIME${ac_eB}TIME_WITH_SYS_TIME${ac_eC}1${ac_eD}
+ CEOF
+   sed -f conftest.frag conftest.in > conftest.out
+   rm -f conftest.in
+   mv conftest.out conftest.in
+ 
+   cat > conftest.frag <<CEOF
+ ${ac_dA}RETSIGTYPE${ac_dB}RETSIGTYPE${ac_dC}void${ac_dD}
+ ${ac_uA}RETSIGTYPE${ac_uB}RETSIGTYPE${ac_uC}void${ac_uD}
+ ${ac_eA}RETSIGTYPE${ac_eB}RETSIGTYPE${ac_eC}void${ac_eD}
+ ${ac_dA}HAVE_UTIME_NULL${ac_dB}HAVE_UTIME_NULL${ac_dC}1${ac_dD}
+ ${ac_uA}HAVE_UTIME_NULL${ac_uB}HAVE_UTIME_NULL${ac_uC}1${ac_uD}
+ ${ac_eA}HAVE_UTIME_NULL${ac_eB}HAVE_UTIME_NULL${ac_eC}1${ac_eD}
+ ${ac_dA}HAVE_GETCWD${ac_dB}HAVE_GETCWD${ac_dC}1${ac_dD}
+ ${ac_uA}HAVE_GETCWD${ac_uB}HAVE_GETCWD${ac_uC}1${ac_uD}
+ ${ac_eA}HAVE_GETCWD${ac_eB}HAVE_GETCWD${ac_eC}1${ac_eD}
+ ${ac_dA}HAVE_GETOPT${ac_dB}HAVE_GETOPT${ac_dC}1${ac_dD}
+ ${ac_uA}HAVE_GETOPT${ac_uB}HAVE_GETOPT${ac_uC}1${ac_uD}
+ ${ac_eA}HAVE_GETOPT${ac_eB}HAVE_GETOPT${ac_eC}1${ac_eD}
+ CEOF
+   sed -f conftest.frag conftest.in > conftest.out
+   rm -f conftest.in
+   mv conftest.out conftest.in
+ 
+   cat > conftest.frag <<CEOF
+ ${ac_dA}HAVE_STRDUP${ac_dB}HAVE_STRDUP${ac_dC}1${ac_dD}
+ ${ac_uA}HAVE_STRDUP${ac_uB}HAVE_STRDUP${ac_uC}1${ac_uD}
+ ${ac_eA}HAVE_STRDUP${ac_eB}HAVE_STRDUP${ac_eC}1${ac_eD}
+ ${ac_dA}HAVE_GETTIMEOFDAY${ac_dB}HAVE_GETTIMEOFDAY${ac_dC}1${ac_dD}
+ ${ac_uA}HAVE_GETTIMEOFDAY${ac_uB}HAVE_GETTIMEOFDAY${ac_uC}1${ac_uD}
+ ${ac_eA}HAVE_GETTIMEOFDAY${ac_eB}HAVE_GETTIMEOFDAY${ac_eC}1${ac_eD}
+ ${ac_dA}HAVE_SIGACTION${ac_dB}HAVE_SIGACTION${ac_dC}1${ac_dD}
+ ${ac_uA}HAVE_SIGACTION${ac_uB}HAVE_SIGACTION${ac_uC}1${ac_uD}
+ ${ac_eA}HAVE_SIGACTION${ac_eB}HAVE_SIGACTION${ac_eC}1${ac_eD}
+ ${ac_dA}HAVE_MKDIR${ac_dB}HAVE_MKDIR${ac_dC}1${ac_dD}
+ ${ac_uA}HAVE_MKDIR${ac_uB}HAVE_MKDIR${ac_uC}1${ac_uD}
+ ${ac_eA}HAVE_MKDIR${ac_eB}HAVE_MKDIR${ac_eC}1${ac_eD}
+ CEOF
+   sed -f conftest.frag conftest.in > conftest.out
+   rm -f conftest.in
+   mv conftest.out conftest.in
+ 
+   cat > conftest.frag <<CEOF
+ ${ac_dA}HAVE_RMDIR${ac_dB}HAVE_RMDIR${ac_dC}1${ac_dD}
+ ${ac_uA}HAVE_RMDIR${ac_uB}HAVE_RMDIR${ac_uC}1${ac_uD}
+ ${ac_eA}HAVE_RMDIR${ac_eB}HAVE_RMDIR${ac_eC}1${ac_eD}
+ ${ac_dA}HAVE_SELECT${ac_dB}HAVE_SELECT${ac_dC}1${ac_dD}
+ ${ac_uA}HAVE_SELECT${ac_uB}HAVE_SELECT${ac_uC}1${ac_uD}
+ ${ac_eA}HAVE_SELECT${ac_eB}HAVE_SELECT${ac_eC}1${ac_eD}
+ ${ac_dA}HAVE_STRERROR${ac_dB}HAVE_STRERROR${ac_dC}1${ac_dD}
+ ${ac_uA}HAVE_STRERROR${ac_uB}HAVE_STRERROR${ac_uC}1${ac_uD}
+ ${ac_eA}HAVE_STRERROR${ac_eB}HAVE_STRERROR${ac_eC}1${ac_eD}
+ ${ac_dA}HAVE_STRSTR${ac_dB}HAVE_STRSTR${ac_dC}1${ac_dD}
+ ${ac_uA}HAVE_STRSTR${ac_uB}HAVE_STRSTR${ac_uC}1${ac_uD}
+ ${ac_eA}HAVE_STRSTR${ac_eB}HAVE_STRSTR${ac_eC}1${ac_eD}
+ CEOF
+   sed -f conftest.frag conftest.in > conftest.out
+   rm -f conftest.in
+   mv conftest.out conftest.in
+ 
+   cat > conftest.frag <<CEOF
+ ${ac_dA}HAVE_TCGETATTR${ac_dB}HAVE_TCGETATTR${ac_dC}1${ac_dD}
+ ${ac_uA}HAVE_TCGETATTR${ac_uB}HAVE_TCGETATTR${ac_uC}1${ac_uD}
+ ${ac_eA}HAVE_TCGETATTR${ac_eB}HAVE_TCGETATTR${ac_eC}1${ac_eD}
+ ${ac_dA}HAVE_CFMAKERAW${ac_dB}HAVE_CFMAKERAW${ac_dC}1${ac_dD}
+ ${ac_uA}HAVE_CFMAKERAW${ac_uB}HAVE_CFMAKERAW${ac_uC}1${ac_uD}
+ ${ac_eA}HAVE_CFMAKERAW${ac_eB}HAVE_CFMAKERAW${ac_eC}1${ac_eD}
+ ${ac_dA}HAVE_READDIR_R${ac_dB}HAVE_READDIR_R${ac_dC}1${ac_dD}
+ ${ac_uA}HAVE_READDIR_R${ac_uB}HAVE_READDIR_R${ac_uC}1${ac_uD}
+ ${ac_eA}HAVE_READDIR_R${ac_eB}HAVE_READDIR_R${ac_eC}1${ac_eD}
+ ${ac_dA}HAVE_VPRINTF${ac_dB}HAVE_VPRINTF${ac_dC}1${ac_dD}
+ ${ac_uA}HAVE_VPRINTF${ac_uB}HAVE_VPRINTF${ac_uC}1${ac_uD}
+ ${ac_eA}HAVE_VPRINTF${ac_eB}HAVE_VPRINTF${ac_eC}1${ac_eD}
+ CEOF
+   sed -f conftest.frag conftest.in > conftest.out
+   rm -f conftest.in
+   mv conftest.out conftest.in
+ 
+   cat > conftest.frag <<CEOF
+ ${ac_dA}HAVE_VSPRINTF${ac_dB}HAVE_VSPRINTF${ac_dC}1${ac_dD}
+ ${ac_uA}HAVE_VSPRINTF${ac_uB}HAVE_VSPRINTF${ac_uC}1${ac_uD}
+ ${ac_eA}HAVE_VSPRINTF${ac_eB}HAVE_VSPRINTF${ac_eC}1${ac_eD}
+ ${ac_dA}HAVE_VFPRINTF${ac_dB}HAVE_VFPRINTF${ac_dC}1${ac_dD}
+ ${ac_uA}HAVE_VFPRINTF${ac_uB}HAVE_VFPRINTF${ac_uC}1${ac_uD}
+ ${ac_eA}HAVE_VFPRINTF${ac_eB}HAVE_VFPRINTF${ac_eC}1${ac_eD}
+ ${ac_dA}HAVE_SETITIMER${ac_dB}HAVE_SETITIMER${ac_dC}1${ac_dD}
+ ${ac_uA}HAVE_SETITIMER${ac_uB}HAVE_SETITIMER${ac_uC}1${ac_uD}
+ ${ac_eA}HAVE_SETITIMER${ac_eB}HAVE_SETITIMER${ac_eC}1${ac_eD}
+ s%^[ 	]*#[ 	]*undef[ 	][ 	]*[a-zA-Z_][a-zA-Z_0-9]*%/* & */%
+ CEOF
+   sed -f conftest.frag conftest.in > conftest.out
+   rm -f conftest.in
+   mv conftest.out conftest.in
+ 
+   rm -f conftest.frag conftest.h
+   echo "/* $ac_file.  Generated automatically by configure.  */" > conftest.h
+   cat conftest.in >> conftest.h
+   rm -f conftest.in
+   if cmp -s $ac_file conftest.h 2>/dev/null; then
+     echo "$ac_file is unchanged"
+     rm -f conftest.h
+   else
+     # Remove last slash and all that follows it.  Not all systems have dirname.
+       ac_dir=`echo $ac_file|sed 's%/[^/][^/]*$%%'`
+       if test "$ac_dir" != "$ac_file" && test "$ac_dir" != .; then
+       # The file is in a subdirectory.
+       test ! -d "$ac_dir" && mkdir "$ac_dir"
+     fi
+     rm -f $ac_file
+     mv conftest.h $ac_file
+   fi
+ fi; done
+ 
+ 
+ 
+ exit 0
diff -crB --new-file ./uae-0.8.21/src/tools/cpudefs.c ../uae_jit_cleaning/uae-0.8.21/src/tools/cpudefs.c
*** ./uae-0.8.21/src/tools/cpudefs.c	1970-01-01 02:00:00.000000000 +0200
--- ../uae_jit_cleaning/uae-0.8.21/src/tools/cpudefs.c	2021-01-10 14:06:47.706591684 +0200
***************
*** 0 ****
--- 1,184 ----
+ #include "sysconfig.h"
+ #include "sysdeps.h"
+ #include "readcpu.h"
+ struct instr_def defs68k[] = {
+ { 60, 0, {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}, 65535, 0, 0, { { 0, 0 }, { 0, 0 }, { 0, 0 }, { 0, 0 }, { 0, 0 }  }, 16, "ORSR.B  #1"},
+ { 124, 0, {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}, 65535, 0, 2, { { 3, 5 }, { 3, 5 }, { 3, 5 }, { 3, 5 }, { 3, 5 }  }, 16, "ORSR.W  #1"},
+ { 192, 8, {17,17,11,11,11,12,12,12,0,0,0,0,0,0,0,0}, 63936, 2, 0, { { 3, 5 }, { 3, 5 }, { 3, 5 }, { 3, 5 }, { 3, 5 }  }, 17, "CHK2.z  #1,s[!Dreg,Areg,Aipi,Apdi,Immd]"},
+ { 0, 8, {17,17,13,13,13,14,14,14,0,0,0,0,0,0,0,0}, 65280, 0, 0, { { 1, 1 }, { 1, 0 }, { 1, 0 }, { 1, 2 }, { 1, 2 }  }, 19, "OR.z    #z,d[!Areg]"},
+ { 572, 0, {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}, 65535, 0, 0, { { 0, 0 }, { 0, 0 }, { 0, 0 }, { 0, 0 }, { 0, 0 }  }, 16, "ANDSR.B #1"},
+ { 636, 0, {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}, 65535, 0, 2, { { 3, 5 }, { 3, 5 }, { 3, 5 }, { 3, 5 }, { 3, 5 }  }, 16, "ANDSR.W #1"},
+ { 512, 8, {17,17,13,13,13,14,14,14,0,0,0,0,0,0,0,0}, 65280, 0, 0, { { 1, 1 }, { 1, 0 }, { 1, 0 }, { 1, 2 }, { 1, 2 }  }, 19, "AND.z   #z,d[!Areg]"},
+ { 1024, 8, {17,17,13,13,13,14,14,14,0,0,0,0,0,0,0,0}, 65280, 0, 0, { { 1, 0 }, { 1, 0 }, { 1, 0 }, { 1, 0 }, { 1, 0 }  }, 19, "SUB.z   #z,d[!Areg]"},
+ { 1536, 8, {17,17,13,13,13,14,14,14,0,0,0,0,0,0,0,0}, 65280, 0, 0, { { 1, 0 }, { 1, 0 }, { 1, 0 }, { 1, 0 }, { 1, 0 }  }, 19, "ADD.z   #z,d[!Areg]"},
+ { 1728, 6, {11,11,11,12,12,12,0,0,0,0,0,0,0,0,0,0}, 65472, 2, 0, { { 3, 5 }, { 3, 5 }, { 3, 5 }, { 3, 5 }, { 3, 5 }  }, 16, "CALLM   s[!Dreg,Areg,Aipi,Apdi,Immd]"},
+ { 1728, 6, {11,11,11,12,12,12,0,0,0,0,0,0,0,0,0,0}, 65472, 2, 0, { { 3, 5 }, { 3, 5 }, { 3, 5 }, { 3, 5 }, { 3, 5 }  }, 16, "RTM     s[Dreg,Areg]"},
+ { 2048, 6, {11,11,11,12,12,12,0,0,0,0,0,0,0,0,0,0}, 65472, 0, 0, { { 1, 1 }, { 1, 1 }, { 1, 0 }, { 1, 1 }, { 1, 1 }  }, 17, "BTST    #1,s[!Areg]"},
+ { 2112, 6, {11,11,11,12,12,12,0,0,0,0,0,0,0,0,0,0}, 65472, 0, 0, { { 1, 1 }, { 1, 1 }, { 1, 0 }, { 1, 1 }, { 1, 1 }  }, 19, "BCHG    #1,s[!Areg,Immd]"},
+ { 2176, 6, {11,11,11,12,12,12,0,0,0,0,0,0,0,0,0,0}, 65472, 0, 0, { { 1, 1 }, { 1, 1 }, { 1, 0 }, { 1, 1 }, { 1, 1 }  }, 19, "BCLR    #1,s[!Areg,Immd]"},
+ { 2240, 6, {11,11,11,12,12,12,0,0,0,0,0,0,0,0,0,0}, 65472, 0, 0, { { 1, 1 }, { 1, 1 }, { 1, 0 }, { 1, 1 }, { 1, 1 }  }, 19, "BSET    #1,s[!Areg,Immd]"},
+ { 2620, 0, {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}, 65535, 0, 0, { { 0, 0 }, { 0, 0 }, { 0, 0 }, { 0, 0 }, { 0, 0 }  }, 16, "EORSR.B #1"},
+ { 2684, 0, {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}, 65535, 0, 2, { { 3, 5 }, { 3, 5 }, { 3, 5 }, { 3, 5 }, { 3, 5 }  }, 16, "EORSR.W #1"},
+ { 2560, 8, {17,17,13,13,13,14,14,14,0,0,0,0,0,0,0,0}, 65280, 0, 0, { { 1, 1 }, { 1, 0 }, { 1, 0 }, { 1, 2 }, { 1, 2 }  }, 19, "EOR.z   #z,d[!Areg]"},
+ { 3072, 8, {17,17,11,11,11,12,12,12,0,0,0,0,0,0,0,0}, 65280, 0, 0, { { 1, 1 }, { 1, 0 }, { 1, 0 }, { 1, 0 }, { 1, 0 }  }, 17, "CMP.z   #z,s[!Areg,Immd]"},
+ { 2752, 6, {11,11,11,12,12,12,0,0,0,0,0,0,0,0,0,0}, 65472, 2, 0, { { 3, 5 }, { 3, 5 }, { 3, 5 }, { 3, 5 }, { 3, 5 }  }, 19, "CAS.B   #1,s[!Dreg,Areg,Immd,PC8r,PC16]"},
+ { 3264, 6, {11,11,11,12,12,12,0,0,0,0,0,0,0,0,0,0}, 65472, 2, 0, { { 3, 5 }, { 3, 5 }, { 3, 5 }, { 3, 5 }, { 3, 5 }  }, 19, "CAS.W   #1,s[!Dreg,Areg,Immd,PC8r,PC16]"},
+ { 3324, 0, {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}, 65535, 2, 0, { { 3, 5 }, { 3, 5 }, { 3, 5 }, { 3, 5 }, { 3, 5 }  }, 16, "CAS2.W  #2"},
+ { 3584, 8, {17,17,11,11,11,12,12,12,0,0,0,0,0,0,0,0}, 65280, 2, 2, { { 3, 5 }, { 3, 5 }, { 3, 5 }, { 3, 5 }, { 3, 5 }  }, 19, "MOVES.z #1,s[!Dreg,Areg,Immd,PC8r,PC16]"},
+ { 3776, 6, {11,11,11,12,12,12,0,0,0,0,0,0,0,0,0,0}, 65472, 2, 0, { { 3, 5 }, { 3, 5 }, { 3, 5 }, { 3, 5 }, { 3, 5 }  }, 19, "CAS.L   #1,s[!Dreg,Areg,Immd,PC8r,PC16]"},
+ { 3836, 0, {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}, 65535, 2, 0, { { 3, 5 }, { 3, 5 }, { 3, 5 }, { 3, 5 }, { 3, 5 }  }, 16, "CAS2.L  #2"},
+ { 256, 9, {15,15,15,13,13,13,14,14,14,0,0,0,0,0,0,0}, 61888, 0, 0, { { 1, 1 }, { 1, 1 }, { 1, 1 }, { 1, 1 }, { 1, 1 }  }, 18, "MVPMR.W d[Areg-Ad16],Dr"},
+ { 320, 9, {15,15,15,13,13,13,14,14,14,0,0,0,0,0,0,0}, 61888, 0, 0, { { 1, 1 }, { 1, 1 }, { 1, 1 }, { 1, 1 }, { 1, 1 }  }, 18, "MVPMR.L d[Areg-Ad16],Dr"},
+ { 384, 9, {15,15,15,13,13,13,14,14,14,0,0,0,0,0,0,0}, 61888, 0, 0, { { 1, 1 }, { 1, 1 }, { 1, 1 }, { 1, 1 }, { 1, 1 }  }, 18, "MVPRM.W Dr,d[Areg-Ad16]"},
+ { 448, 9, {15,15,15,13,13,13,14,14,14,0,0,0,0,0,0,0}, 61888, 0, 0, { { 1, 1 }, { 1, 1 }, { 1, 1 }, { 1, 1 }, { 1, 1 }  }, 18, "MVPRM.L Dr,d[Areg-Ad16]"},
+ { 256, 9, {15,15,15,11,11,11,12,12,12,0,0,0,0,0,0,0}, 61888, 0, 0, { { 1, 1 }, { 1, 1 }, { 1, 0 }, { 1, 1 }, { 1, 1 }  }, 17, "BTST    Dr,s[!Areg]"},
+ { 320, 9, {15,15,15,11,11,11,12,12,12,0,0,0,0,0,0,0}, 61888, 0, 0, { { 1, 1 }, { 1, 1 }, { 1, 0 }, { 1, 1 }, { 1, 1 }  }, 19, "BCHG    Dr,s[!Areg,Immd]"},
+ { 384, 9, {15,15,15,11,11,11,12,12,12,0,0,0,0,0,0,0}, 61888, 0, 0, { { 1, 1 }, { 1, 1 }, { 1, 0 }, { 1, 1 }, { 1, 1 }  }, 19, "BCLR    Dr,s[!Areg,Immd]"},
+ { 448, 9, {15,15,15,11,11,11,12,12,12,0,0,0,0,0,0,0}, 61888, 0, 0, { { 1, 1 }, { 1, 1 }, { 1, 0 }, { 1, 1 }, { 1, 1 }  }, 19, "BSET    Dr,s[!Areg,Immd]"},
+ { 4096, 12, {14,14,14,13,13,13,11,11,11,12,12,12,0,0,0,0}, 61440, 0, 0, { { 1, 1 }, { 1, 0 }, { 1, 0 }, { 1, 2 }, { 1, 2 }  }, 18, "MOVE.B  s,d[!Areg]"},
+ { 8192, 12, {14,14,14,13,13,13,11,11,11,12,12,12,0,0,0,0}, 61440, 0, 0, { { 1, 1 }, { 1, 1 }, { 1, 1 }, { 1, 1 }, { 1, 1 }  }, 18, "MOVEA.L s,d[Areg]"},
+ { 8192, 12, {14,14,14,13,13,13,11,11,11,12,12,12,0,0,0,0}, 61440, 0, 0, { { 1, 1 }, { 1, 0 }, { 1, 0 }, { 1, 2 }, { 1, 2 }  }, 18, "MOVE.L  s,d[!Areg]"},
+ { 12288, 12, {14,14,14,13,13,13,11,11,11,12,12,12,0,0,0,0}, 61440, 0, 0, { { 1, 1 }, { 1, 1 }, { 1, 1 }, { 1, 1 }, { 1, 1 }  }, 18, "MOVEA.W s,d[Areg]"},
+ { 12288, 12, {14,14,14,13,13,13,11,11,11,12,12,12,0,0,0,0}, 61440, 0, 0, { { 1, 1 }, { 1, 0 }, { 1, 0 }, { 1, 2 }, { 1, 2 }  }, 18, "MOVE.W  s,d[!Areg]"},
+ { 16384, 8, {17,17,13,13,13,14,14,14,0,0,0,0,0,0,0,0}, 65280, 0, 0, { { 0, 0 }, { 1, 4 }, { 0, 0 }, { 1, 4 }, { 1, 0 }  }, 48, "NEGX.z  d[!Areg]"},
+ { 16576, 6, {13,13,13,14,14,14,0,0,0,0,0,0,0,0,0,0}, 65472, 0, 1, { { 3, 5 }, { 3, 5 }, { 3, 5 }, { 3, 5 }, { 3, 5 }  }, 16, "MVSR2.W d[!Areg]"},
+ { 16896, 8, {17,17,13,13,13,14,14,14,0,0,0,0,0,0,0,0}, 65280, 0, 0, { { 1, 1 }, { 1, 2 }, { 1, 3 }, { 1, 2 }, { 1, 2 }  }, 32, "CLR.z   d[!Areg]"},
+ { 17088, 6, {13,13,13,14,14,14,0,0,0,0,0,0,0,0,0,0}, 65472, 1, 0, { { 3, 5 }, { 3, 5 }, { 3, 5 }, { 3, 5 }, { 3, 5 }  }, 16, "MVSR2.B d[!Areg]"},
+ { 17408, 8, {17,17,13,13,13,14,14,14,0,0,0,0,0,0,0,0}, 65280, 0, 0, { { 1, 0 }, { 1, 0 }, { 1, 0 }, { 1, 0 }, { 1, 0 }  }, 48, "NEG.z   d[!Areg]"},
+ { 17600, 6, {11,11,11,12,12,12,0,0,0,0,0,0,0,0,0,0}, 65472, 0, 0, { { 1, 0 }, { 1, 0 }, { 1, 0 }, { 1, 0 }, { 1, 0 }  }, 16, "MV2SR.B s[!Areg]"},
+ { 17920, 8, {17,17,13,13,13,14,14,14,0,0,0,0,0,0,0,0}, 65280, 0, 0, { { 1, 1 }, { 1, 0 }, { 1, 0 }, { 1, 2 }, { 1, 2 }  }, 48, "NOT.z   d[!Areg]"},
+ { 18112, 6, {11,11,11,12,12,12,0,0,0,0,0,0,0,0,0,0}, 65472, 0, 2, { { 3, 5 }, { 3, 5 }, { 3, 5 }, { 3, 5 }, { 3, 5 }  }, 16, "MV2SR.W s[!Areg]"},
+ { 18440, 3, {15,15,15,0,0,0,0,0,0,0,0,0,0,0,0,0}, 65528, 2, 0, { { 1, 1 }, { 1, 1 }, { 1, 1 }, { 1, 1 }, { 1, 1 }  }, 49, "LINK.L  Ar,#2"},
+ { 18432, 6, {13,13,13,14,14,14,0,0,0,0,0,0,0,0,0,0}, 65472, 0, 0, { { 0, 0 }, { 1, 5 }, { 0, 0 }, { 1, 5 }, { 1, 0 }  }, 48, "NBCD.B  d[!Areg]"},
+ { 18504, 3, {9,9,9,0,0,0,0,0,0,0,0,0,0,0,0,0}, 65528, 2, 0, { { 3, 5 }, { 3, 5 }, { 3, 5 }, { 3, 5 }, { 3, 5 }  }, 16, "BKPT    #k"},
+ { 18496, 6, {11,11,11,12,12,12,0,0,0,0,0,0,0,0,0,0}, 65472, 0, 0, { { 1, 1 }, { 1, 0 }, { 1, 0 }, { 1, 2 }, { 1, 2 }  }, 48, "SWAP.W  s[Dreg]"},
+ { 18496, 6, {11,11,11,12,12,12,0,0,0,0,0,0,0,0,0,0}, 65472, 0, 0, { { 1, 1 }, { 1, 1 }, { 1, 1 }, { 1, 1 }, { 1, 1 }  }, 0, "PEA.L   s[!Dreg,Areg,Aipi,Apdi,Immd]"},
+ { 18560, 6, {13,13,13,14,14,14,0,0,0,0,0,0,0,0,0,0}, 65472, 0, 0, { { 1, 1 }, { 1, 0 }, { 1, 0 }, { 1, 2 }, { 1, 2 }  }, 48, "EXT.W   d[Dreg]"},
+ { 18560, 6, {13,13,13,14,14,14,0,0,0,0,0,0,0,0,0,0}, 65472, 0, 0, { { 1, 1 }, { 1, 1 }, { 1, 1 }, { 1, 1 }, { 1, 1 }  }, 2, "MVMLE.W #1,d[!Dreg,Areg,Aipi]"},
+ { 18624, 6, {13,13,13,14,14,14,0,0,0,0,0,0,0,0,0,0}, 65472, 0, 0, { { 1, 1 }, { 1, 0 }, { 1, 0 }, { 1, 2 }, { 1, 2 }  }, 48, "EXT.L   d[Dreg]"},
+ { 18624, 6, {13,13,13,14,14,14,0,0,0,0,0,0,0,0,0,0}, 65472, 0, 0, { { 1, 1 }, { 1, 1 }, { 1, 1 }, { 1, 1 }, { 1, 1 }  }, 2, "MVMLE.L #1,d[!Dreg,Areg,Aipi]"},
+ { 18880, 6, {13,13,13,14,14,14,0,0,0,0,0,0,0,0,0,0}, 65472, 0, 0, { { 1, 1 }, { 1, 0 }, { 1, 0 }, { 1, 2 }, { 1, 2 }  }, 48, "EXT.B   d[Dreg]"},
+ { 18944, 8, {17,17,11,11,11,12,12,12,0,0,0,0,0,0,0,0}, 65280, 0, 0, { { 1, 1 }, { 1, 0 }, { 1, 0 }, { 1, 2 }, { 1, 2 }  }, 16, "TST.z   s"},
+ { 19136, 6, {13,13,13,14,14,14,0,0,0,0,0,0,0,0,0,0}, 65472, 0, 0, { { 3, 5 }, { 3, 5 }, { 3, 5 }, { 3, 5 }, { 3, 5 }  }, 48, "TAS.B   d[!Areg]"},
+ { 19196, 0, {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}, 65535, 0, 0, { { 3, 5 }, { 3, 5 }, { 3, 5 }, { 3, 5 }, { 3, 5 }  }, 0, "ILLEGAL"},
+ { 19456, 6, {11,11,11,12,12,12,0,0,0,0,0,0,0,0,0,0}, 65472, 2, 0, { { 1, 1 }, { 1, 0 }, { 1, 0 }, { 1, 0 }, { 1, 0 }  }, 19, "MULL.L  #1,s[!Areg]"},
+ { 19520, 6, {11,11,11,12,12,12,0,0,0,0,0,0,0,0,0,0}, 65472, 2, 0, { { 3, 5 }, { 3, 5 }, { 3, 5 }, { 3, 5 }, { 3, 5 }  }, 19, "DIVL.L  #1,s[!Areg]"},
+ { 19584, 6, {11,11,11,12,12,12,0,0,0,0,0,0,0,0,0,0}, 65472, 0, 0, { { 1, 1 }, { 1, 1 }, { 1, 1 }, { 1, 1 }, { 1, 1 }  }, 1, "MVMEL.W #1,s[!Dreg,Areg,Apdi,Immd]"},
+ { 19648, 6, {11,11,11,12,12,12,0,0,0,0,0,0,0,0,0,0}, 65472, 0, 0, { { 1, 1 }, { 1, 1 }, { 1, 1 }, { 1, 1 }, { 1, 1 }  }, 1, "MVMEL.L #1,s[!Dreg,Areg,Apdi,Immd]"},
+ { 20032, 4, {8,8,8,8,0,0,0,0,0,0,0,0,0,0,0,0}, 65520, 0, 0, { { 0, 1 }, { 0, 1 }, { 0, 1 }, { 0, 1 }, { 0, 1 }  }, 16, "TRAP    #J"},
+ { 20048, 3, {15,15,15,0,0,0,0,0,0,0,0,0,0,0,0,0}, 65528, 0, 0, { { 1, 1 }, { 1, 1 }, { 1, 1 }, { 1, 1 }, { 1, 1 }  }, 49, "LINK.W  Ar,#1"},
+ { 20056, 3, {15,15,15,0,0,0,0,0,0,0,0,0,0,0,0,0}, 65528, 0, 0, { { 1, 1 }, { 1, 1 }, { 1, 1 }, { 1, 1 }, { 1, 1 }  }, 48, "UNLK.L  Ar"},
+ { 20064, 3, {15,15,15,0,0,0,0,0,0,0,0,0,0,0,0,0}, 65528, 0, 2, { { 1, 1 }, { 1, 1 }, { 1, 1 }, { 1, 1 }, { 1, 1 }  }, 16, "MVR2USP.L Ar"},
+ { 20072, 3, {15,15,15,0,0,0,0,0,0,0,0,0,0,0,0,0}, 65528, 0, 2, { { 1, 1 }, { 1, 1 }, { 1, 1 }, { 1, 1 }, { 1, 1 }  }, 32, "MVUSP2R.L Ar"},
+ { 20080, 0, {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}, 65535, 0, 2, { { 1, 1 }, { 1, 1 }, { 1, 1 }, { 1, 1 }, { 1, 1 }  }, 0, "RESET"},
+ { 20081, 0, {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}, 65535, 0, 0, { { 1, 1 }, { 1, 1 }, { 1, 1 }, { 1, 1 }, { 1, 1 }  }, 0, "NOP"},
+ { 20082, 0, {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}, 65535, 0, 2, { { 1, 0 }, { 1, 0 }, { 1, 0 }, { 1, 0 }, { 1, 0 }  }, 16, "STOP    #1"},
+ { 20083, 0, {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}, 65535, 0, 2, { { 1, 0 }, { 1, 0 }, { 1, 0 }, { 1, 0 }, { 1, 0 }  }, 0, "RTE"},
+ { 20084, 0, {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}, 65535, 0, 0, { { 3, 5 }, { 3, 5 }, { 3, 5 }, { 3, 5 }, { 3, 5 }  }, 16, "RTD     #1"},
+ { 20085, 0, {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}, 65535, 0, 0, { { 1, 1 }, { 1, 1 }, { 1, 1 }, { 1, 1 }, { 1, 1 }  }, 0, "RTS"},
+ { 20086, 0, {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}, 65535, 0, 0, { { 0, 1 }, { 0, 1 }, { 0, 1 }, { 0, 1 }, { 0, 1 }  }, 0, "TRAPV"},
+ { 20087, 0, {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}, 65535, 0, 0, { { 1, 0 }, { 1, 0 }, { 1, 0 }, { 1, 0 }, { 1, 0 }  }, 0, "RTR"},
+ { 20090, 0, {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}, 65535, 1, 2, { { 3, 5 }, { 3, 5 }, { 3, 5 }, { 3, 5 }, { 3, 5 }  }, 16, "MOVEC2  #1"},
+ { 20091, 0, {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}, 65535, 1, 2, { { 3, 5 }, { 3, 5 }, { 3, 5 }, { 3, 5 }, { 3, 5 }  }, 16, "MOVE2C  #1"},
+ { 20096, 6, {11,11,11,12,12,12,0,0,0,0,0,0,0,0,0,0}, 65472, 0, 0, { { 4, 6 }, { 4, 6 }, { 4, 6 }, { 4, 6 }, { 4, 6 }  }, 128, "JSR.L   s[!Dreg,Areg,Aipi,Apdi,Immd]"},
+ { 16640, 9, {15,15,15,11,11,11,12,12,12,0,0,0,0,0,0,0}, 61888, 0, 0, { { 3, 5 }, { 3, 5 }, { 3, 5 }, { 3, 5 }, { 3, 5 }  }, 17, "CHK.L   s[!Areg],Dr"},
+ { 16768, 9, {15,15,15,11,11,11,12,12,12,0,0,0,0,0,0,0}, 61888, 0, 0, { { 3, 5 }, { 3, 5 }, { 3, 5 }, { 3, 5 }, { 3, 5 }  }, 17, "CHK.W   s[!Areg],Dr"},
+ { 20160, 6, {11,11,11,12,12,12,0,0,0,0,0,0,0,0,0,0}, 65472, 0, 0, { { 4, 6 }, { 4, 6 }, { 4, 6 }, { 4, 6 }, { 4, 6 }  }, 128, "JMP.L   s[!Dreg,Areg,Aipi,Apdi,Immd]"},
+ { 16832, 9, {15,15,15,11,11,11,12,12,12,0,0,0,0,0,0,0}, 61888, 0, 0, { { 1, 1 }, { 1, 1 }, { 1, 1 }, { 1, 1 }, { 1, 1 }  }, 2, "LEA.L   s[!Dreg,Areg,Aipi,Apdi,Immd],Ar"},
+ { 20544, 9, {7,7,7,13,13,13,14,14,14,0,0,0,0,0,0,0}, 61888, 0, 0, { { 1, 1 }, { 1, 1 }, { 1, 1 }, { 1, 1 }, { 1, 1 }  }, 19, "ADDA.W  #j,d[Areg]"},
+ { 20608, 9, {7,7,7,13,13,13,14,14,14,0,0,0,0,0,0,0}, 61888, 0, 0, { { 1, 1 }, { 1, 1 }, { 1, 1 }, { 1, 1 }, { 1, 1 }  }, 19, "ADDA.L  #j,d[Areg]"},
+ { 20480, 11, {7,7,7,17,17,13,13,13,14,14,14,0,0,0,0,0}, 61696, 0, 0, { { 1, 0 }, { 1, 0 }, { 1, 0 }, { 1, 0 }, { 1, 0 }  }, 19, "ADD.z   #j,d[!Areg]"},
+ { 20800, 9, {7,7,7,13,13,13,14,14,14,0,0,0,0,0,0,0}, 61888, 0, 0, { { 1, 1 }, { 1, 1 }, { 1, 1 }, { 1, 1 }, { 1, 1 }  }, 19, "SUBA.W  #j,d[Areg]"},
+ { 20864, 9, {7,7,7,13,13,13,14,14,14,0,0,0,0,0,0,0}, 61888, 0, 0, { { 1, 1 }, { 1, 1 }, { 1, 1 }, { 1, 1 }, { 1, 1 }  }, 19, "SUBA.L  #j,d[Areg]"},
+ { 20736, 11, {7,7,7,17,17,13,13,13,14,14,14,0,0,0,0,0}, 61696, 0, 0, { { 1, 0 }, { 1, 0 }, { 1, 0 }, { 1, 0 }, { 1, 0 }  }, 19, "SUB.z   #j,d[!Areg]"},
+ { 20680, 7, {2,2,2,2,15,15,15,0,0,0,0,0,0,0,0,0}, 61688, 0, 0, { { 1, 1 }, { 2, 1 }, { 2, 1 }, { 2, 1 }, { 2, 1 }  }, 49, "DBcc.W  Dr,#1"},
+ { 20672, 10, {2,2,2,2,13,13,13,14,14,14,0,0,0,0,0,0}, 61632, 0, 0, { { 1, 1 }, { 2, 1 }, { 2, 1 }, { 2, 1 }, { 2, 1 }  }, 32, "Scc.B   d[!Areg]"},
+ { 20730, 4, {2,2,2,2,0,0,0,0,0,0,0,0,0,0,0,0}, 61695, 2, 0, { { 3, 5 }, { 3, 5 }, { 3, 5 }, { 3, 5 }, { 3, 5 }  }, 16, "TRAPcc  #1"},
+ { 20731, 4, {2,2,2,2,0,0,0,0,0,0,0,0,0,0,0,0}, 61695, 2, 0, { { 3, 5 }, { 3, 5 }, { 3, 5 }, { 3, 5 }, { 3, 5 }  }, 16, "TRAPcc  #2"},
+ { 20732, 4, {2,2,2,2,0,0,0,0,0,0,0,0,0,0,0,0}, 61695, 2, 0, { { 3, 5 }, { 3, 5 }, { 3, 5 }, { 3, 5 }, { 3, 5 }  }, 0, "TRAPcc"},
+ { 24832, 0, {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}, 65535, 0, 0, { { 4, 6 }, { 4, 6 }, { 4, 6 }, { 4, 6 }, { 4, 6 }  }, 64, "BSR.W   #1"},
+ { 24832, 8, {6,6,6,6,6,6,6,6,0,0,0,0,0,0,0,0}, 65280, 0, 0, { { 4, 6 }, { 4, 6 }, { 4, 6 }, { 4, 6 }, { 4, 6 }  }, 64, "BSR.B   #i"},
+ { 25087, 0, {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}, 65535, 0, 0, { { 4, 6 }, { 4, 6 }, { 4, 6 }, { 4, 6 }, { 4, 6 }  }, 64, "BSR.L   #2"},
+ { 24576, 4, {3,3,3,3,0,0,0,0,0,0,0,0,0,0,0,0}, 61695, 0, 0, { { 1, 1 }, { 2, 1 }, { 2, 1 }, { 2, 1 }, { 2, 1 }  }, 64, "Bcc.W   #1"},
+ { 24576, 12, {3,3,3,3,6,6,6,6,6,6,6,6,0,0,0,0}, 61440, 0, 0, { { 1, 1 }, { 2, 1 }, { 2, 1 }, { 2, 1 }, { 2, 1 }  }, 64, "Bcc.B   #i"},
+ { 24831, 4, {3,3,3,3,0,0,0,0,0,0,0,0,0,0,0,0}, 61695, 0, 0, { { 1, 1 }, { 2, 1 }, { 2, 1 }, { 2, 1 }, { 2, 1 }  }, 64, "Bcc.L   #2"},
+ { 28672, 11, {15,15,15,5,5,5,5,5,5,5,5,0,0,0,0,0}, 61696, 0, 0, { { 1, 1 }, { 1, 0 }, { 1, 0 }, { 1, 2 }, { 1, 2 }  }, 18, "MOVE.L  #i,Dr"},
+ { 32768, 11, {15,15,15,17,17,11,11,11,12,12,12,0,0,0,0,0}, 61696, 0, 0, { { 1, 1 }, { 1, 0 }, { 1, 0 }, { 1, 2 }, { 1, 2 }  }, 19, "OR.z    s[!Areg],Dr"},
+ { 32960, 9, {15,15,15,11,11,11,12,12,12,0,0,0,0,0,0,0}, 61888, 0, 0, { { 3, 5 }, { 3, 5 }, { 3, 5 }, { 3, 5 }, { 3, 5 }  }, 19, "DIVU.W  s[!Areg],Dr"},
+ { 33024, 9, {15,15,15,13,13,13,14,14,14,0,0,0,0,0,0,0}, 61888, 0, 0, { { 0, 0 }, { 1, 4 }, { 0, 0 }, { 1, 4 }, { 1, 0 }  }, 19, "SBCD.B  d[Dreg],Dr"},
+ { 33024, 9, {15,15,15,13,13,13,14,14,14,0,0,0,0,0,0,0}, 61888, 0, 0, { { 0, 0 }, { 1, 4 }, { 0, 0 }, { 1, 4 }, { 1, 0 }  }, 19, "SBCD.B  d[Areg-Apdi],Arp"},
+ { 33024, 11, {15,15,15,17,17,13,13,13,14,14,14,0,0,0,0,0}, 61696, 0, 0, { { 1, 1 }, { 1, 0 }, { 1, 0 }, { 1, 2 }, { 1, 2 }  }, 19, "OR.z    Dr,d[!Areg,Dreg]"},
+ { 33088, 9, {15,15,15,13,13,13,14,14,14,0,0,0,0,0,0,0}, 61888, 2, 0, { { 3, 5 }, { 3, 5 }, { 3, 5 }, { 3, 5 }, { 3, 5 }  }, 18, "PACK    d[Dreg],Dr"},
+ { 33088, 9, {15,15,15,13,13,13,14,14,14,0,0,0,0,0,0,0}, 61888, 2, 0, { { 3, 5 }, { 3, 5 }, { 3, 5 }, { 3, 5 }, { 3, 5 }  }, 18, "PACK    d[Areg-Apdi],Arp"},
+ { 33152, 9, {15,15,15,13,13,13,14,14,14,0,0,0,0,0,0,0}, 61888, 2, 0, { { 3, 5 }, { 3, 5 }, { 3, 5 }, { 3, 5 }, { 3, 5 }  }, 18, "UNPK    d[Dreg],Dr"},
+ { 33152, 9, {15,15,15,13,13,13,14,14,14,0,0,0,0,0,0,0}, 61888, 2, 0, { { 3, 5 }, { 3, 5 }, { 3, 5 }, { 3, 5 }, { 3, 5 }  }, 18, "UNPK    d[Areg-Apdi],Arp"},
+ { 33216, 9, {15,15,15,11,11,11,12,12,12,0,0,0,0,0,0,0}, 61888, 0, 0, { { 3, 5 }, { 3, 5 }, { 3, 5 }, { 3, 5 }, { 3, 5 }  }, 19, "DIVS.W  s[!Areg],Dr"},
+ { 36864, 11, {15,15,15,17,17,11,11,11,12,12,12,0,0,0,0,0}, 61696, 0, 0, { { 1, 0 }, { 1, 0 }, { 1, 0 }, { 1, 0 }, { 1, 0 }  }, 19, "SUB.z   s,Dr"},
+ { 37056, 9, {15,15,15,11,11,11,12,12,12,0,0,0,0,0,0,0}, 61888, 0, 0, { { 1, 1 }, { 1, 1 }, { 1, 1 }, { 1, 1 }, { 1, 1 }  }, 19, "SUBA.W  s,Ar"},
+ { 37120, 11, {15,15,15,17,17,13,13,13,14,14,14,0,0,0,0,0}, 61696, 0, 0, { { 0, 0 }, { 1, 0 }, { 0, 0 }, { 1, 0 }, { 1, 0 }  }, 19, "SUBX.z  d[Dreg],Dr"},
+ { 37120, 11, {15,15,15,17,17,13,13,13,14,14,14,0,0,0,0,0}, 61696, 0, 0, { { 0, 0 }, { 1, 0 }, { 0, 0 }, { 1, 0 }, { 1, 0 }  }, 19, "SUBX.z  d[Areg-Apdi],Arp"},
+ { 37120, 11, {15,15,15,17,17,13,13,13,14,14,14,0,0,0,0,0}, 61696, 0, 0, { { 1, 0 }, { 1, 0 }, { 1, 0 }, { 1, 0 }, { 1, 0 }  }, 19, "SUB.z   Dr,d[!Areg,Dreg]"},
+ { 37312, 9, {15,15,15,11,11,11,12,12,12,0,0,0,0,0,0,0}, 61888, 0, 0, { { 1, 1 }, { 1, 1 }, { 1, 1 }, { 1, 1 }, { 1, 1 }  }, 19, "SUBA.L  s,Ar"},
+ { 45056, 11, {15,15,15,17,17,11,11,11,12,12,12,0,0,0,0,0}, 61696, 0, 0, { { 1, 1 }, { 1, 0 }, { 1, 0 }, { 1, 0 }, { 1, 0 }  }, 17, "CMP.z   s,Dr"},
+ { 45248, 9, {15,15,15,11,11,11,12,12,12,0,0,0,0,0,0,0}, 61888, 0, 0, { { 1, 1 }, { 1, 0 }, { 1, 0 }, { 1, 0 }, { 1, 0 }  }, 17, "CMPA.W  s,Ar"},
+ { 45504, 9, {15,15,15,11,11,11,12,12,12,0,0,0,0,0,0,0}, 61888, 0, 0, { { 1, 1 }, { 1, 0 }, { 1, 0 }, { 1, 0 }, { 1, 0 }  }, 17, "CMPA.L  s,Ar"},
+ { 45312, 11, {15,15,15,17,17,13,13,13,14,14,14,0,0,0,0,0}, 61696, 0, 0, { { 1, 1 }, { 1, 0 }, { 1, 0 }, { 1, 0 }, { 1, 0 }  }, 17, "CMPM.z  d[Areg-Aipi],ArP"},
+ { 45312, 11, {15,15,15,17,17,13,13,13,14,14,14,0,0,0,0,0}, 61696, 0, 0, { { 1, 1 }, { 1, 0 }, { 1, 0 }, { 1, 2 }, { 1, 2 }  }, 19, "EOR.z   Dr,d[!Areg]"},
+ { 49152, 11, {15,15,15,17,17,11,11,11,12,12,12,0,0,0,0,0}, 61696, 0, 0, { { 1, 1 }, { 1, 0 }, { 1, 0 }, { 1, 2 }, { 1, 2 }  }, 19, "AND.z   s[!Areg],Dr"},
+ { 49344, 9, {15,15,15,11,11,11,12,12,12,0,0,0,0,0,0,0}, 61888, 0, 0, { { 1, 1 }, { 1, 0 }, { 1, 0 }, { 1, 2 }, { 1, 2 }  }, 19, "MULU.W  s[!Areg],Dr"},
+ { 49408, 9, {15,15,15,13,13,13,14,14,14,0,0,0,0,0,0,0}, 61888, 0, 0, { { 0, 0 }, { 1, 4 }, { 0, 0 }, { 1, 4 }, { 1, 0 }  }, 19, "ABCD.B  d[Dreg],Dr"},
+ { 49408, 9, {15,15,15,13,13,13,14,14,14,0,0,0,0,0,0,0}, 61888, 0, 0, { { 0, 0 }, { 1, 4 }, { 0, 0 }, { 1, 4 }, { 1, 0 }  }, 19, "ABCD.B  d[Areg-Apdi],Arp"},
+ { 49408, 11, {15,15,15,17,17,13,13,13,14,14,14,0,0,0,0,0}, 61696, 0, 0, { { 1, 1 }, { 1, 0 }, { 1, 0 }, { 1, 2 }, { 1, 2 }  }, 19, "AND.z   Dr,d[!Areg,Dreg]"},
+ { 49472, 9, {15,15,15,13,13,13,14,14,14,0,0,0,0,0,0,0}, 61888, 0, 0, { { 1, 1 }, { 1, 1 }, { 1, 1 }, { 1, 1 }, { 1, 1 }  }, 51, "EXG.L   Dr,d[Dreg]"},
+ { 49472, 9, {15,15,15,13,13,13,14,14,14,0,0,0,0,0,0,0}, 61888, 0, 0, { { 1, 1 }, { 1, 1 }, { 1, 1 }, { 1, 1 }, { 1, 1 }  }, 51, "EXG.L   Ar,d[Areg]"},
+ { 49536, 9, {15,15,15,13,13,13,14,14,14,0,0,0,0,0,0,0}, 61888, 0, 0, { { 1, 1 }, { 1, 1 }, { 1, 1 }, { 1, 1 }, { 1, 1 }  }, 51, "EXG.L   Dr,d[Areg]"},
+ { 49600, 9, {15,15,15,11,11,11,12,12,12,0,0,0,0,0,0,0}, 61888, 0, 0, { { 1, 1 }, { 1, 0 }, { 1, 0 }, { 1, 2 }, { 1, 2 }  }, 19, "MULS.W  s[!Areg],Dr"},
+ { 53248, 11, {15,15,15,17,17,11,11,11,12,12,12,0,0,0,0,0}, 61696, 0, 0, { { 1, 0 }, { 1, 0 }, { 1, 0 }, { 1, 0 }, { 1, 0 }  }, 19, "ADD.z   s,Dr"},
+ { 53440, 9, {15,15,15,11,11,11,12,12,12,0,0,0,0,0,0,0}, 61888, 0, 0, { { 1, 1 }, { 1, 1 }, { 1, 1 }, { 1, 1 }, { 1, 1 }  }, 19, "ADDA.W  s,Ar"},
+ { 53504, 11, {15,15,15,17,17,13,13,13,14,14,14,0,0,0,0,0}, 61696, 0, 0, { { 0, 0 }, { 1, 0 }, { 0, 0 }, { 1, 0 }, { 1, 0 }  }, 19, "ADDX.z  d[Dreg],Dr"},
+ { 53504, 11, {15,15,15,17,17,13,13,13,14,14,14,0,0,0,0,0}, 61696, 0, 0, { { 0, 0 }, { 1, 0 }, { 0, 0 }, { 1, 0 }, { 1, 0 }  }, 19, "ADDX.z  d[Areg-Apdi],Arp"},
+ { 53504, 11, {15,15,15,17,17,13,13,13,14,14,14,0,0,0,0,0}, 61696, 0, 0, { { 1, 0 }, { 1, 0 }, { 1, 0 }, { 1, 0 }, { 1, 0 }  }, 19, "ADD.z   Dr,d[!Areg,Dreg]"},
+ { 53696, 9, {15,15,15,11,11,11,12,12,12,0,0,0,0,0,0,0}, 61888, 0, 0, { { 1, 1 }, { 1, 1 }, { 1, 1 }, { 1, 1 }, { 1, 1 }  }, 19, "ADDA.L  s,Ar"},
+ { 57344, 9, {7,7,7,4,17,17,16,16,16,0,0,0,0,0,0,0}, 61496, 0, 0, { { 1, 0 }, { 1, 0 }, { 1, 0 }, { 1, 0 }, { 1, 0 }  }, 19, "ASf.z   #j,DR"},
+ { 57352, 9, {7,7,7,4,17,17,16,16,16,0,0,0,0,0,0,0}, 61496, 0, 0, { { 1, 0 }, { 1, 0 }, { 1, 0 }, { 1, 2 }, { 1, 0 }  }, 19, "LSf.z   #j,DR"},
+ { 57360, 9, {7,7,7,4,17,17,16,16,16,0,0,0,0,0,0,0}, 61496, 0, 0, { { 0, 0 }, { 1, 0 }, { 1, 0 }, { 1, 2 }, { 1, 0 }  }, 19, "ROXf.z  #j,DR"},
+ { 57368, 9, {7,7,7,4,17,17,16,16,16,0,0,0,0,0,0,0}, 61496, 0, 0, { { 1, 1 }, { 1, 0 }, { 1, 0 }, { 1, 2 }, { 1, 0 }  }, 19, "ROf.z   #j,DR"},
+ { 57376, 9, {15,15,15,4,17,17,16,16,16,0,0,0,0,0,0,0}, 61496, 0, 0, { { 0, 0 }, { 1, 0 }, { 1, 0 }, { 1, 0 }, { 1, 0 }  }, 19, "ASf.z   Dr,DR"},
+ { 57384, 9, {15,15,15,4,17,17,16,16,16,0,0,0,0,0,0,0}, 61496, 0, 0, { { 0, 0 }, { 1, 0 }, { 1, 0 }, { 1, 2 }, { 1, 0 }  }, 19, "LSf.z   Dr,DR"},
+ { 57392, 9, {15,15,15,4,17,17,16,16,16,0,0,0,0,0,0,0}, 61496, 0, 0, { { 0, 0 }, { 1, 0 }, { 1, 0 }, { 1, 2 }, { 1, 0 }  }, 19, "ROXf.z  Dr,DR"},
+ { 57400, 9, {15,15,15,4,17,17,16,16,16,0,0,0,0,0,0,0}, 61496, 0, 0, { { 1, 1 }, { 1, 0 }, { 1, 0 }, { 1, 2 }, { 1, 0 }  }, 19, "ROf.z   Dr,DR"},
+ { 57536, 7, {4,13,13,13,14,14,14,0,0,0,0,0,0,0,0,0}, 65216, 0, 0, { { 1, 0 }, { 1, 0 }, { 1, 0 }, { 1, 0 }, { 1, 0 }  }, 19, "ASfW.W  d[!Dreg,Areg]"},
+ { 58048, 7, {4,13,13,13,14,14,14,0,0,0,0,0,0,0,0,0}, 65216, 0, 0, { { 1, 0 }, { 1, 0 }, { 1, 0 }, { 1, 2 }, { 1, 0 }  }, 19, "LSfW.W  d[!Dreg,Areg]"},
+ { 58560, 7, {4,13,13,13,14,14,14,0,0,0,0,0,0,0,0,0}, 65216, 0, 0, { { 0, 0 }, { 1, 0 }, { 1, 0 }, { 1, 2 }, { 1, 0 }  }, 19, "ROXfW.W d[!Dreg,Areg]"},
+ { 59072, 7, {4,13,13,13,14,14,14,0,0,0,0,0,0,0,0,0}, 65216, 0, 0, { { 1, 1 }, { 1, 0 }, { 1, 0 }, { 1, 2 }, { 1, 0 }  }, 19, "ROfW.W  d[!Dreg,Areg]"},
+ { 59584, 6, {11,11,11,12,12,12,0,0,0,0,0,0,0,0,0,0}, 65472, 2, 0, { { 3, 5 }, { 3, 5 }, { 3, 5 }, { 3, 5 }, { 3, 5 }  }, 17, "BFTST   #1,s[!Areg,Apdi,Aipi,Immd]"},
+ { 59840, 6, {11,11,11,12,12,12,0,0,0,0,0,0,0,0,0,0}, 65472, 2, 0, { { 3, 5 }, { 3, 5 }, { 3, 5 }, { 3, 5 }, { 3, 5 }  }, 17, "BFEXTU  #1,s[!Areg,Apdi,Aipi,Immd]"},
+ { 60096, 6, {11,11,11,12,12,12,0,0,0,0,0,0,0,0,0,0}, 65472, 2, 0, { { 3, 5 }, { 3, 5 }, { 3, 5 }, { 3, 5 }, { 3, 5 }  }, 19, "BFCHG   #1,s[!Areg,Apdi,Aipi,Immd,PC8r,PC16]"},
+ { 60352, 6, {11,11,11,12,12,12,0,0,0,0,0,0,0,0,0,0}, 65472, 2, 0, { { 3, 5 }, { 3, 5 }, { 3, 5 }, { 3, 5 }, { 3, 5 }  }, 17, "BFEXTS  #1,s[!Areg,Apdi,Aipi,Immd]"},
+ { 60608, 6, {11,11,11,12,12,12,0,0,0,0,0,0,0,0,0,0}, 65472, 2, 0, { { 3, 5 }, { 3, 5 }, { 3, 5 }, { 3, 5 }, { 3, 5 }  }, 19, "BFCLR   #1,s[!Areg,Apdi,Aipi,Immd,PC8r,PC16]"},
+ { 60864, 6, {11,11,11,12,12,12,0,0,0,0,0,0,0,0,0,0}, 65472, 2, 0, { { 3, 5 }, { 3, 5 }, { 3, 5 }, { 3, 5 }, { 3, 5 }  }, 17, "BFFFO   #1,s[!Areg,Apdi,Aipi,Immd]"},
+ { 61120, 6, {11,11,11,12,12,12,0,0,0,0,0,0,0,0,0,0}, 65472, 2, 0, { { 3, 5 }, { 3, 5 }, { 3, 5 }, { 3, 5 }, { 3, 5 }  }, 19, "BFSET   #1,s[!Areg,Apdi,Aipi,Immd,PC8r,PC16]"},
+ { 61376, 6, {11,11,11,12,12,12,0,0,0,0,0,0,0,0,0,0}, 65472, 2, 0, { { 3, 5 }, { 3, 5 }, { 3, 5 }, { 3, 5 }, { 3, 5 }  }, 19, "BFINS   #1,s[!Areg,Apdi,Aipi,Immd,PC8r,PC16]"},
+ { 61952, 6, {11,11,11,12,12,12,0,0,0,0,0,0,0,0,0,0}, 65472, 3, 0, { { 3, 5 }, { 3, 5 }, { 3, 5 }, { 3, 5 }, { 3, 5 }  }, 17, "FPP      #1,s"},
+ { 62016, 6, {11,11,11,12,12,12,0,0,0,0,0,0,0,0,0,0}, 65472, 3, 0, { { 3, 5 }, { 3, 5 }, { 3, 5 }, { 3, 5 }, { 3, 5 }  }, 17, "FDBcc    #1,s[Areg-Dreg]"},
+ { 62016, 6, {11,11,11,12,12,12,0,0,0,0,0,0,0,0,0,0}, 65472, 3, 0, { { 3, 5 }, { 3, 5 }, { 3, 5 }, { 3, 5 }, { 3, 5 }  }, 17, "FScc     #1,s[!Areg,Immd,PC8r,PC16]"},
+ { 62074, 0, {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}, 65535, 3, 0, { { 3, 5 }, { 3, 5 }, { 3, 5 }, { 3, 5 }, { 3, 5 }  }, 16, "FTRAPcc  #1"},
+ { 62075, 0, {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}, 65535, 3, 0, { { 3, 5 }, { 3, 5 }, { 3, 5 }, { 3, 5 }, { 3, 5 }  }, 16, "FTRAPcc  #2"},
+ { 62076, 0, {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}, 65535, 3, 0, { { 3, 5 }, { 3, 5 }, { 3, 5 }, { 3, 5 }, { 3, 5 }  }, 0, "FTRAPcc"},
+ { 62080, 6, {10,10,10,10,10,10,0,0,0,0,0,0,0,0,0,0}, 65472, 3, 0, { { 3, 5 }, { 3, 5 }, { 3, 5 }, { 3, 5 }, { 3, 5 }  }, 17, "FBcc     #K,#1"},
+ { 62144, 6, {10,10,10,10,10,10,0,0,0,0,0,0,0,0,0,0}, 65472, 3, 0, { { 3, 5 }, { 3, 5 }, { 3, 5 }, { 3, 5 }, { 3, 5 }  }, 17, "FBcc     #K,#2"},
+ { 62208, 6, {11,11,11,12,12,12,0,0,0,0,0,0,0,0,0,0}, 65472, 3, 2, { { 3, 5 }, { 3, 5 }, { 3, 5 }, { 3, 5 }, { 3, 5 }  }, 32, "FSAVE    s[!Dreg,Areg,Aipi,Immd,PC8r,PC16]"},
+ { 62272, 6, {11,11,11,12,12,12,0,0,0,0,0,0,0,0,0,0}, 65472, 3, 2, { { 3, 5 }, { 3, 5 }, { 3, 5 }, { 3, 5 }, { 3, 5 }  }, 16, "FRESTORE s[!Dreg,Areg,Apdi,Immd]"},
+ { 62720, 8, {5,5,5,5,5,12,12,12,0,0,0,0,0,0,0,0}, 65280, 4, 0, { { 3, 5 }, { 3, 5 }, { 3, 5 }, { 3, 5 }, { 3, 5 }  }, 17, "MMUOP    #i,s"},
+ { 62472, 5, {18,18,15,15,15,0,0,0,0,0,0,0,0,0,0,0}, 65336, 4, 2, { { 1, 1 }, { 1, 1 }, { 1, 1 }, { 1, 1 }, { 1, 1 }  }, 2, "CINVL    #p,Ar"},
+ { 62480, 5, {18,18,15,15,15,0,0,0,0,0,0,0,0,0,0,0}, 65336, 4, 2, { { 1, 1 }, { 1, 1 }, { 1, 1 }, { 1, 1 }, { 1, 1 }  }, 2, "CINVP    #p,Ar"},
+ { 62488, 5, {18,18,15,15,15,0,0,0,0,0,0,0,0,0,0,0}, 65336, 4, 2, { { 1, 1 }, { 1, 1 }, { 1, 1 }, { 1, 1 }, { 1, 1 }  }, 0, "CINVA    #p"},
+ { 62504, 5, {18,18,15,15,15,0,0,0,0,0,0,0,0,0,0,0}, 65336, 4, 2, { { 1, 1 }, { 1, 1 }, { 1, 1 }, { 1, 1 }, { 1, 1 }  }, 2, "CPUSHL   #p,Ar"},
+ { 62512, 5, {18,18,15,15,15,0,0,0,0,0,0,0,0,0,0,0}, 65336, 4, 2, { { 1, 1 }, { 1, 1 }, { 1, 1 }, { 1, 1 }, { 1, 1 }  }, 2, "CPUSHP   #p,Ar"},
+ { 62520, 5, {18,18,15,15,15,0,0,0,0,0,0,0,0,0,0,0}, 65336, 4, 2, { { 1, 1 }, { 1, 1 }, { 1, 1 }, { 1, 1 }, { 1, 1 }  }, 0, "CPUSHA   #p"},
+ { 63008, 3, {15,15,15,0,0,0,0,0,0,0,0,0,0,0,0,0}, 65528, 4, 0, { { 1, 1 }, { 1, 1 }, { 1, 1 }, { 1, 1 }, { 1, 1 }  }, 18, "MOVE16   ArP,AxP"},
+ { 62976, 6, {11,11,11,12,12,12,0,0,0,0,0,0,0,0,0,0}, 65472, 4, 0, { { 1, 1 }, { 1, 1 }, { 1, 1 }, { 1, 1 }, { 1, 1 }  }, 18, "MOVE16   s[Dreg-Aipi],L"},
+ { 62976, 6, {13,13,13,14,14,14,0,0,0,0,0,0,0,0,0,0}, 65472, 4, 0, { { 1, 1 }, { 1, 1 }, { 1, 1 }, { 1, 1 }, { 1, 1 }  }, 18, "MOVE16   L,d[Areg-Aipi]"},
+ { 62976, 6, {11,11,11,12,12,12,0,0,0,0,0,0,0,0,0,0}, 65472, 4, 0, { { 1, 1 }, { 1, 1 }, { 1, 1 }, { 1, 1 }, { 1, 1 }  }, 18, "MOVE16   s[Aind],L"},
+ { 62976, 6, {13,13,13,14,14,14,0,0,0,0,0,0,0,0,0,0}, 65472, 4, 0, { { 1, 1 }, { 1, 1 }, { 1, 1 }, { 1, 1 }, { 1, 1 }  }, 18, "MOVE16   L,d[Aipi-Aind]"}};
+ int n_defs68k = 179;
diff -crB --new-file ./uae-0.8.21/src/tools/Makefile ../uae_jit_cleaning/uae-0.8.21/src/tools/Makefile
*** ./uae-0.8.21/src/tools/Makefile	1970-01-01 02:00:00.000000000 +0200
--- ../uae_jit_cleaning/uae-0.8.21/src/tools/Makefile	2021-01-10 13:54:06.222591684 +0200
***************
*** 0 ****
--- 1,83 ----
+ # Generated automatically from Makefile.in by configure.
+ #
+ # Makefile.in for UAE tools
+ #
+ 
+ 
+ CC        = gcc
+ LDFLAGS   = 
+ CFLAGS    = -g -O2 -D__inline__=inline -DUAE_CONSOLE
+ LIBRARIES = 
+ 
+ INSTALL         = @INSTALL@
+ INSTALL_PROGRAM = @INSTALL_PROGRAM@
+ INSTALL_DATA    = @INSTALL_DATA@
+ prefix          = /usr/local
+ exec_prefix     = ${prefix}
+ bindir          = ${exec_prefix}/bin
+ libdir          = ${exec_prefix}/lib
+ sysconfdir      = ${prefix}/etc
+ 
+ VPATH = /home/osboxes/uae_Archives/build_0_8_21_jit/uae_jit_cleaning/uae-0.8.21/src/tools
+ 
+ .SUFFIXES: .o .c .h .m .i .S
+ 
+ INCLUDES=-I. -I/home/osboxes/uae_Archives/build_0_8_21_jit/uae_jit_cleaning/uae-0.8.21/src/tools/../include/ -I/home/osboxes/uae_Archives/build_0_8_21_jit/uae_jit_cleaning/uae-0.8.21/src/tools
+ 
+ all: gencpu gencomp build68k genblitter cpuopti
+ 
+ install:
+ 
+ 
+ clean:
+ 	-rm -f *.o
+ 	-rm -f gencpu gencomp genblitter cpuopti build68k
+ 
+ 
+ streifenfrei: clean
+ 
+ genblitter: genblitter.o blitops.o writelog.o
+ 	$(CC) $(LDFLAGS) -o genblitter genblitter.o blitops.o writelog.o
+ build68k: build68k.o writelog.o
+ 	$(CC) $(LDFLAGS) -o build68k build68k.o writelog.o
+ cpuopti: cpuopti.o writelog.o
+ 	$(CC) $(LDFLAGS) -o cpuopti cpuopti.o writelog.o
+ gencpu: gencpu.o readcpu.o cpudefs.o missing.o writelog.o
+ 	$(CC) $(LDFLAGS) -o gencpu gencpu.o readcpu.o cpudefs.o missing.o writelog.o
+ gencomp: gencomp.o readcpu.o cpudefs.o missing.o
+ 	$(CC) $(LDFLAGS) -o gencomp gencomp.o readcpu.o missing.o cpudefs.o
+ 
+ custom.o: blit.h
+ drawing.o: linetoscr.c
+ 
+ cpudefs.c: build68k /home/osboxes/uae_Archives/build_0_8_21_jit/uae_jit_cleaning/uae-0.8.21/src/tools/../table68k
+ 	./build68k </home/osboxes/uae_Archives/build_0_8_21_jit/uae_jit_cleaning/uae-0.8.21/src/tools/../table68k >cpudefs.c
+ 
+ # Normally I'd move the programs into this directory, but given that CVS
+ # sucks I have no choice but to leave them in their previous directory.
+ missing.o: /home/osboxes/uae_Archives/build_0_8_21_jit/uae_jit_cleaning/uae-0.8.21/src/tools/../missing.c
+ 	$(CC) $(INCLUDES) -c $(INCDIRS) $(CFLAGS) $(DEBUGFLAGS) /home/osboxes/uae_Archives/build_0_8_21_jit/uae_jit_cleaning/uae-0.8.21/src/tools/../missing.c -o $@
+ readcpu.o: /home/osboxes/uae_Archives/build_0_8_21_jit/uae_jit_cleaning/uae-0.8.21/src/tools/../readcpu.c
+ 	$(CC) $(INCLUDES) -c $(INCDIRS) $(CFLAGS) $(DEBUGFLAGS) /home/osboxes/uae_Archives/build_0_8_21_jit/uae_jit_cleaning/uae-0.8.21/src/tools/../readcpu.c -o $@
+ writelog.o: /home/osboxes/uae_Archives/build_0_8_21_jit/uae_jit_cleaning/uae-0.8.21/src/tools/../writelog.c
+ 	$(CC) $(INCLUDES) -c $(INCDIRS) $(CFLAGS) $(DEBUGFLAGS) /home/osboxes/uae_Archives/build_0_8_21_jit/uae_jit_cleaning/uae-0.8.21/src/tools/../writelog.c -o $@
+ genblitter.o: /home/osboxes/uae_Archives/build_0_8_21_jit/uae_jit_cleaning/uae-0.8.21/src/tools/../genblitter.c
+ 	$(CC) $(INCLUDES) -c $(INCDIRS) $(CFLAGS) $(DEBUGFLAGS) /home/osboxes/uae_Archives/build_0_8_21_jit/uae_jit_cleaning/uae-0.8.21/src/tools/../genblitter.c -o $@
+ gencpu.o: /home/osboxes/uae_Archives/build_0_8_21_jit/uae_jit_cleaning/uae-0.8.21/src/tools/../gencpu.c
+ 	$(CC) $(INCLUDES) -c $(INCDIRS) $(CFLAGS) $(DEBUGFLAGS) /home/osboxes/uae_Archives/build_0_8_21_jit/uae_jit_cleaning/uae-0.8.21/src/tools/../gencpu.c -o $@
+ gencomp.o: /home/osboxes/uae_Archives/build_0_8_21_jit/uae_jit_cleaning/uae-0.8.21/src/tools/../gencomp.c
+ 	$(CC) $(INCLUDES) -c $(INCDIRS) $(CFLAGS) $(DEBUGFLAGS) /home/osboxes/uae_Archives/build_0_8_21_jit/uae_jit_cleaning/uae-0.8.21/src/tools/../gencomp.c -o $@
+ build68k.o: /home/osboxes/uae_Archives/build_0_8_21_jit/uae_jit_cleaning/uae-0.8.21/src/tools/../build68k.c
+ 	$(CC) $(INCLUDES) -c $(INCDIRS) $(CFLAGS) $(DEBUGFLAGS) /home/osboxes/uae_Archives/build_0_8_21_jit/uae_jit_cleaning/uae-0.8.21/src/tools/../build68k.c -o $@
+ blitops.o: /home/osboxes/uae_Archives/build_0_8_21_jit/uae_jit_cleaning/uae-0.8.21/src/tools/../blitops.c
+ 	$(CC) $(INCLUDES) -c $(INCDIRS) $(CFLAGS) $(DEBUGFLAGS) /home/osboxes/uae_Archives/build_0_8_21_jit/uae_jit_cleaning/uae-0.8.21/src/tools/../blitops.c -o $@
+ cpuopti.o: /home/osboxes/uae_Archives/build_0_8_21_jit/uae_jit_cleaning/uae-0.8.21/src/tools/../cpuopti.c
+ 	$(CC) $(INCLUDES) -c $(INCDIRS) $(CFLAGS) $(DEBUGFLAGS) /home/osboxes/uae_Archives/build_0_8_21_jit/uae_jit_cleaning/uae-0.8.21/src/tools/../cpuopti.c -o $@
+ 
+ .c.o:
+ 	$(CC) $(INCLUDES) -c $(INCDIRS) $(CFLAGS) $(X_CFLAGS) $(DEBUGFLAGS) $(CFLAGS_$@) $< -o $@
+ .c.s:
+ 	$(CC) $(INCLUDES) -S $(INCDIRS) $(CFLAGS) $(X_CFLAGS) $(DEBUGFLAGS) $< -o $@
+ .c.i:
+ 	$(CC) $(INCLUDES) -E $(INCDIRS) $(CFLAGS) $(X_CFLAGS) $(DEBUGFLAGS) $< > $@
+ 
diff -crB --new-file ./uae-0.8.21/src/tools/Makefile.in ../uae_jit_cleaning/uae-0.8.21/src/tools/Makefile.in
*** ./uae-0.8.21/src/tools/Makefile.in	2001-11-22 02:03:30.000000000 +0200
--- ../uae_jit_cleaning/uae-0.8.21/src/tools/Makefile.in	2021-01-10 13:10:29.926591684 +0200
***************
*** 23,36 ****
  
  INCLUDES=-I. -I@top_srcdir@/../include/ -I@top_srcdir@
  
! all: gencpu build68k genblitter cpuopti
  
  install:
  
  
  clean:
  	-rm -f *.o
! 	-rm -f gencpu genblitter cpuopti build68k
  
  
  streifenfrei: clean
--- 23,36 ----
  
  INCLUDES=-I. -I@top_srcdir@/../include/ -I@top_srcdir@
  
! all: gencpu gencomp build68k genblitter cpuopti
  
  install:
  
  
  clean:
  	-rm -f *.o
! 	-rm -f gencpu gencomp genblitter cpuopti build68k
  
  
  streifenfrei: clean
***************
*** 43,48 ****
--- 43,50 ----
  	$(CC) $(LDFLAGS) -o cpuopti cpuopti.o writelog.o
  gencpu: gencpu.o readcpu.o cpudefs.o missing.o writelog.o
  	$(CC) $(LDFLAGS) -o gencpu gencpu.o readcpu.o cpudefs.o missing.o writelog.o
+ gencomp: gencomp.o readcpu.o cpudefs.o missing.o
+ 	$(CC) $(LDFLAGS) -o gencomp gencomp.o readcpu.o missing.o cpudefs.o
  
  custom.o: blit.h
  drawing.o: linetoscr.c
***************
*** 62,67 ****
--- 64,71 ----
  	$(CC) $(INCLUDES) -c $(INCDIRS) $(CFLAGS) $(DEBUGFLAGS) @top_srcdir@/../genblitter.c -o $@
  gencpu.o: @top_srcdir@/../gencpu.c
  	$(CC) $(INCLUDES) -c $(INCDIRS) $(CFLAGS) $(DEBUGFLAGS) @top_srcdir@/../gencpu.c -o $@
+ gencomp.o: @top_srcdir@/../gencomp.c
+ 	$(CC) $(INCLUDES) -c $(INCDIRS) $(CFLAGS) $(DEBUGFLAGS) @top_srcdir@/../gencomp.c -o $@
  build68k.o: @top_srcdir@/../build68k.c
  	$(CC) $(INCLUDES) -c $(INCDIRS) $(CFLAGS) $(DEBUGFLAGS) @top_srcdir@/../build68k.c -o $@
  blitops.o: @top_srcdir@/../blitops.c
diff -crB --new-file ./uae-0.8.21/src/tools/sysconfig.h ../uae_jit_cleaning/uae-0.8.21/src/tools/sysconfig.h
*** ./uae-0.8.21/src/tools/sysconfig.h	1970-01-01 02:00:00.000000000 +0200
--- ../uae_jit_cleaning/uae-0.8.21/src/tools/sysconfig.h	2021-01-10 13:14:46.990591684 +0200
***************
*** 0 ****
--- 1,210 ----
+ /* sysconfig.h.  Generated automatically by configure.  */
+ /* sysconfig.h.in.  Generated automatically from configure.in by autoheader.  */
+ 
+ /* Define if on AIX 3.
+    System headers sometimes define this.
+    We just want to avoid a redefinition error message.  */
+ #ifndef _ALL_SOURCE
+ /* #undef _ALL_SOURCE */
+ #endif
+ 
+ /* Define to empty if the keyword does not work.  */
+ /* #undef const */
+ 
+ /* Define if your struct stat has st_blocks.  */
+ #define HAVE_ST_BLOCKS 1
+ 
+ /* Define if utime(file, NULL) sets file's timestamp to the present.  */
+ #define HAVE_UTIME_NULL 1
+ 
+ /* Define as __inline if that's what the C compiler calls it.  */
+ /* #undef inline */
+ 
+ /* Define to `int' if <sys/types.h> doesn't define.  */
+ /* #undef mode_t */
+ 
+ /* Define to `long' if <sys/types.h> doesn't define.  */
+ /* #undef off_t */
+ 
+ /* Define to `int' if <sys/types.h> doesn't define.  */
+ /* #undef pid_t */
+ 
+ /* Define if you need to in order for stat and other things to work.  */
+ /* #undef _POSIX_SOURCE */
+ 
+ /* Define as the return type of signal handlers (int or void).  */
+ #define RETSIGTYPE void
+ 
+ /* Define if you have the ANSI C header files.  */
+ #define STDC_HEADERS 1
+ 
+ /* Define if you can safely include both <sys/time.h> and <time.h>.  */
+ #define TIME_WITH_SYS_TIME 1
+ 
+ /* Define if your <sys/time.h> declares struct tm.  */
+ /* #undef TM_IN_SYS_TIME */
+ 
+ /* Define if the X Window System is missing or not being used.  */
+ /* #undef X_DISPLAY_MISSING */
+ 
+ /* The number of bytes in a __int64.  */
+ #define SIZEOF___INT64 0
+ 
+ /* The number of bytes in a char.  */
+ #define SIZEOF_CHAR 1
+ 
+ /* The number of bytes in a int.  */
+ #define SIZEOF_INT 4
+ 
+ /* The number of bytes in a long.  */
+ #define SIZEOF_LONG 4
+ 
+ /* The number of bytes in a long long.  */
+ #define SIZEOF_LONG_LONG 8
+ 
+ /* The number of bytes in a short.  */
+ #define SIZEOF_SHORT 2
+ 
+ /* Define if you have the cfmakeraw function.  */
+ #define HAVE_CFMAKERAW 1
+ 
+ /* Define if you have the getcwd function.  */
+ #define HAVE_GETCWD 1
+ 
+ /* Define if you have the getopt function.  */
+ #define HAVE_GETOPT 1
+ 
+ /* Define if you have the gettimeofday function.  */
+ #define HAVE_GETTIMEOFDAY 1
+ 
+ /* Define if you have the mkdir function.  */
+ #define HAVE_MKDIR 1
+ 
+ /* Define if you have the readdir_r function.  */
+ #define HAVE_READDIR_R 1
+ 
+ /* Define if you have the rmdir function.  */
+ #define HAVE_RMDIR 1
+ 
+ /* Define if you have the select function.  */
+ #define HAVE_SELECT 1
+ 
+ /* Define if you have the setitimer function.  */
+ #define HAVE_SETITIMER 1
+ 
+ /* Define if you have the sigaction function.  */
+ #define HAVE_SIGACTION 1
+ 
+ /* Define if you have the strdup function.  */
+ #define HAVE_STRDUP 1
+ 
+ /* Define if you have the strerror function.  */
+ #define HAVE_STRERROR 1
+ 
+ /* Define if you have the strstr function.  */
+ #define HAVE_STRSTR 1
+ 
+ /* Define if you have the tcgetattr function.  */
+ #define HAVE_TCGETATTR 1
+ 
+ /* Define if you have the vfprintf function.  */
+ #define HAVE_VFPRINTF 1
+ 
+ /* Define if you have the vprintf function.  */
+ #define HAVE_VPRINTF 1
+ 
+ /* Define if you have the vsprintf function.  */
+ #define HAVE_VSPRINTF 1
+ 
+ /* Define if you have the <SDL/SDL.h> header file.  */
+ #define HAVE_SDL_SDL_H 1
+ 
+ /* Define if you have the <curses.h> header file.  */
+ #define HAVE_CURSES_H 1
+ 
+ /* Define if you have the <cybergraphx/cybergraphics.h> header file.  */
+ /* #undef HAVE_CYBERGRAPHX_CYBERGRAPHICS_H */
+ 
+ /* Define if you have the <ddraw.h> header file.  */
+ /* #undef HAVE_DDRAW_H */
+ 
+ /* Define if you have the <devices/ahi.h> header file.  */
+ /* #undef HAVE_DEVICES_AHI_H */
+ 
+ /* Define if you have the <dmedia/audio.h> header file.  */
+ /* #undef HAVE_DMEDIA_AUDIO_H */
+ 
+ /* Define if you have the <fcntl.h> header file.  */
+ #define HAVE_FCNTL_H 1
+ 
+ /* Define if you have the <features.h> header file.  */
+ #define HAVE_FEATURES_H 1
+ 
+ /* Define if you have the <getopt.h> header file.  */
+ #define HAVE_GETOPT_H 1
+ 
+ /* Define if you have the <libraries/cybergraphics.h> header file.  */
+ /* #undef HAVE_LIBRARIES_CYBERGRAPHICS_H */
+ 
+ /* Define if you have the <machine/joystick.h> header file.  */
+ /* #undef HAVE_MACHINE_JOYSTICK_H */
+ 
+ /* Define if you have the <machine/soundcard.h> header file.  */
+ /* #undef HAVE_MACHINE_SOUNDCARD_H */
+ 
+ /* Define if you have the <ncurses.h> header file.  */
+ #define HAVE_NCURSES_H 1
+ 
+ /* Define if you have the <posix_opt.h> header file.  */
+ /* #undef HAVE_POSIX_OPT_H */
+ 
+ /* Define if you have the <string.h> header file.  */
+ #define HAVE_STRING_H 1
+ 
+ /* Define if you have the <strings.h> header file.  */
+ #define HAVE_STRINGS_H 1
+ 
+ /* Define if you have the <sun/audioio.h> header file.  */
+ /* #undef HAVE_SUN_AUDIOIO_H */
+ 
+ /* Define if you have the <sys/audioio.h> header file.  */
+ /* #undef HAVE_SYS_AUDIOIO_H */
+ 
+ /* Define if you have the <sys/ioctl.h> header file.  */
+ #define HAVE_SYS_IOCTL_H 1
+ 
+ /* Define if you have the <sys/ipc.h> header file.  */
+ #define HAVE_SYS_IPC_H 1
+ 
+ /* Define if you have the <sys/shm.h> header file.  */
+ #define HAVE_SYS_SHM_H 1
+ 
+ /* Define if you have the <sys/soundcard.h> header file.  */
+ #define HAVE_SYS_SOUNDCARD_H 1
+ 
+ /* Define if you have the <sys/stat.h> header file.  */
+ #define HAVE_SYS_STAT_H 1
+ 
+ /* Define if you have the <sys/termios.h> header file.  */
+ #define HAVE_SYS_TERMIOS_H 1
+ 
+ /* Define if you have the <sys/time.h> header file.  */
+ #define HAVE_SYS_TIME_H 1
+ 
+ /* Define if you have the <sys/types.h> header file.  */
+ #define HAVE_SYS_TYPES_H 1
+ 
+ /* Define if you have the <sys/utime.h> header file.  */
+ /* #undef HAVE_SYS_UTIME_H */
+ 
+ /* Define if you have the <unistd.h> header file.  */
+ #define HAVE_UNISTD_H 1
+ 
+ /* Define if you have the <utime.h> header file.  */
+ #define HAVE_UTIME_H 1
+ 
+ /* Define if you have the <values.h> header file.  */
+ #define HAVE_VALUES_H 1
+ 
+ /* Define if you have the <windows.h> header file.  */
+ /* #undef HAVE_WINDOWS_H */
diff -crB --new-file ./uae-0.8.21/src/uaeexe.c ../uae_jit_cleaning/uae-0.8.21/src/uaeexe.c
*** ./uae-0.8.21/src/uaeexe.c	2000-08-26 00:29:42.000000000 +0300
--- ../uae_jit_cleaning/uae-0.8.21/src/uaeexe.c	2021-01-10 13:10:29.910591684 +0200
***************
*** 12,17 ****
--- 12,18 ----
  #include "uae.h"
  #include "memory.h"
  #include "custom.h"
+ #include "events.h"
  #include "newcpu.h"
  #include "autoconf.h"
  #include "uaeexe.h"
diff -crB --new-file ./uae-0.8.21/src/uaelib.c ../uae_jit_cleaning/uae-0.8.21/src/uaelib.c
*** ./uae-0.8.21/src/uaelib.c	2001-12-30 17:15:56.000000000 +0200
--- ../uae_jit_cleaning/uae-0.8.21/src/uaelib.c	2021-01-10 13:10:29.910591684 +0200
***************
*** 20,25 ****
--- 20,26 ----
  #include "uae.h"
  #include "include/memory.h"
  #include "custom.h"
+ #include "events.h"
  #include "newcpu.h"
  #include "xwin.h"
  #include "autoconf.h"
