Index: configure
===================================================================
RCS file: /usr/local/cvs/uae/configure,v
retrieving revision 1.87
retrieving revision 1.87.2.1
diff -c -p -d -u -p -r1.87 -r1.87.2.1
--- configure	2001/12/30 14:42:54	1.87
+++ configure	2002/02/06 15:09:18	1.87.2.1
@@ -32,6 +32,8 @@ ac_help="$ac_help
 ac_help="$ac_help
   --enable-ui             Use a user interface if possible (default on)"
 ac_help="$ac_help
+  --enable-jit            linux/X11 version: Use the JIT compiler"
+ac_help="$ac_help
   --with-hostcc=x         Use a x as compiler for the host system"
 ac_help="$ac_help
   --with-gtk-prefix=PFX   Prefix where GTK is installed (optional)"
@@ -560,7 +562,7 @@ fi
 # Extract the first word of "gcc", so it can be a program name with args.
 set dummy gcc; ac_word=$2
 echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
-echo "configure:564: checking for $ac_word" >&5
+echo "configure:566: checking for $ac_word" >&5
 if eval "test \"`echo '$''{'ac_cv_prog_CC'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -590,7 +592,7 @@ if test -z "$CC"; then
   # Extract the first word of "cc", so it can be a program name with args.
 set dummy cc; ac_word=$2
 echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
-echo "configure:594: checking for $ac_word" >&5
+echo "configure:596: checking for $ac_word" >&5
 if eval "test \"`echo '$''{'ac_cv_prog_CC'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -641,7 +643,7 @@ fi
       # Extract the first word of "cl", so it can be a program name with args.
 set dummy cl; ac_word=$2
 echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
-echo "configure:645: checking for $ac_word" >&5
+echo "configure:647: checking for $ac_word" >&5
 if eval "test \"`echo '$''{'ac_cv_prog_CC'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -673,7 +675,7 @@ fi
 fi
 
 echo $ac_n "checking whether the C compiler ($CC $CFLAGS $LDFLAGS) works""... $ac_c" 1>&6
-echo "configure:677: checking whether the C compiler ($CC $CFLAGS $LDFLAGS) works" >&5
+echo "configure:679: checking whether the C compiler ($CC $CFLAGS $LDFLAGS) works" >&5
 
 ac_ext=c
 # CFLAGS is not in ac_cpp because -g, -O, etc. are not valid cpp options.
@@ -684,12 +686,12 @@ cross_compiling=$ac_cv_prog_cc_cross
 
 cat > conftest.$ac_ext << EOF
 
-#line 688 "configure"
+#line 690 "configure"
 #include "confdefs.h"
 
 main(){return(0);}
 EOF
-if { (eval echo configure:693: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:695: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   ac_cv_prog_cc_works=yes
   # If we can't run a trivial program, we are probably using a cross compiler.
   if (./conftest; exit) 2>/dev/null; then
@@ -715,12 +717,12 @@ if test $ac_cv_prog_cc_works = no; then
   { echo "configure: error: installation or configuration problem: C compiler cannot create executables." 1>&2; exit 1; }
 fi
 echo $ac_n "checking whether the C compiler ($CC $CFLAGS $LDFLAGS) is a cross-compiler""... $ac_c" 1>&6
-echo "configure:719: checking whether the C compiler ($CC $CFLAGS $LDFLAGS) is a cross-compiler" >&5
+echo "configure:721: checking whether the C compiler ($CC $CFLAGS $LDFLAGS) is a cross-compiler" >&5
 echo "$ac_t""$ac_cv_prog_cc_cross" 1>&6
 cross_compiling=$ac_cv_prog_cc_cross
 
 echo $ac_n "checking whether we are using GNU C""... $ac_c" 1>&6
-echo "configure:724: checking whether we are using GNU C" >&5
+echo "configure:726: checking whether we are using GNU C" >&5
 if eval "test \"`echo '$''{'ac_cv_prog_gcc'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -729,7 +731,7 @@ else
   yes;
 #endif
 EOF
-if { ac_try='${CC-cc} -E conftest.c'; { (eval echo configure:733: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }; } | egrep yes >/dev/null 2>&1; then
+if { ac_try='${CC-cc} -E conftest.c'; { (eval echo configure:735: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }; } | egrep yes >/dev/null 2>&1; then
   ac_cv_prog_gcc=yes
 else
   ac_cv_prog_gcc=no
@@ -748,7 +750,7 @@ ac_test_CFLAGS="${CFLAGS+set}"
 ac_save_CFLAGS="$CFLAGS"
 CFLAGS=
 echo $ac_n "checking whether ${CC-cc} accepts -g""... $ac_c" 1>&6
-echo "configure:752: checking whether ${CC-cc} accepts -g" >&5
+echo "configure:754: checking whether ${CC-cc} accepts -g" >&5
 if eval "test \"`echo '$''{'ac_cv_prog_cc_g'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -781,7 +783,7 @@ fi
 
 
 echo $ac_n "checking how to run the C preprocessor""... $ac_c" 1>&6
-echo "configure:785: checking how to run the C preprocessor" >&5
+echo "configure:787: checking how to run the C preprocessor" >&5
 # On Suns, sometimes $CPP names a directory.
 if test -n "$CPP" && test -d "$CPP"; then
   CPP=
@@ -796,13 +798,13 @@ else
   # On the NeXT, cc -E runs the code through the compiler's parser,
   # not just through cpp.
   cat > conftest.$ac_ext <<EOF
-#line 800 "configure"
+#line 802 "configure"
 #include "confdefs.h"
 #include <assert.h>
 Syntax Error
 EOF
 ac_try="$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out"
-{ (eval echo configure:806: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
+{ (eval echo configure:808: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
 ac_err=`grep -v '^ *+' conftest.out | grep -v "^conftest.${ac_ext}\$"`
 if test -z "$ac_err"; then
   :
@@ -813,13 +815,13 @@ else
   rm -rf conftest*
   CPP="${CC-cc} -E -traditional-cpp"
   cat > conftest.$ac_ext <<EOF
-#line 817 "configure"
+#line 819 "configure"
 #include "confdefs.h"
 #include <assert.h>
 Syntax Error
 EOF
 ac_try="$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out"
-{ (eval echo configure:823: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
+{ (eval echo configure:825: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
 ac_err=`grep -v '^ *+' conftest.out | grep -v "^conftest.${ac_ext}\$"`
 if test -z "$ac_err"; then
   :
@@ -830,13 +832,13 @@ else
   rm -rf conftest*
   CPP="${CC-cc} -nologo -E"
   cat > conftest.$ac_ext <<EOF
-#line 834 "configure"
+#line 836 "configure"
 #include "confdefs.h"
 #include <assert.h>
 Syntax Error
 EOF
 ac_try="$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out"
-{ (eval echo configure:840: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
+{ (eval echo configure:842: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
 ac_err=`grep -v '^ *+' conftest.out | grep -v "^conftest.${ac_ext}\$"`
 if test -z "$ac_err"; then
   :
@@ -861,7 +863,7 @@ fi
 echo "$ac_t""$CPP" 1>&6
 
 echo $ac_n "checking whether ${MAKE-make} sets \${MAKE}""... $ac_c" 1>&6
-echo "configure:865: checking whether ${MAKE-make} sets \${MAKE}" >&5
+echo "configure:867: checking whether ${MAKE-make} sets \${MAKE}" >&5
 set dummy ${MAKE-make}; ac_make=`echo "$2" | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_prog_make_${ac_make}_set'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
@@ -890,7 +892,7 @@ fi
 # Extract the first word of "makedepend", so it can be a program name with args.
 set dummy makedepend; ac_word=$2
 echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
-echo "configure:894: checking for $ac_word" >&5
+echo "configure:896: checking for $ac_word" >&5
 if eval "test \"`echo '$''{'ac_cv_path_MAKEDEPPRG'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -926,7 +928,7 @@ fi
 # Extract the first word of "file", so it can be a program name with args.
 set dummy file; ac_word=$2
 echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
-echo "configure:930: checking for $ac_word" >&5
+echo "configure:932: checking for $ac_word" >&5
 if eval "test \"`echo '$''{'ac_cv_path_FILEPRG'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -962,7 +964,7 @@ fi
 # Extract the first word of "wrc", so it can be a program name with args.
 set dummy wrc; ac_word=$2
 echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
-echo "configure:966: checking for $ac_word" >&5
+echo "configure:968: checking for $ac_word" >&5
 if eval "test \"`echo '$''{'ac_cv_path_WRCPRG'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -998,7 +1000,7 @@ fi
 # Extract the first word of "rcl", so it can be a program name with args.
 set dummy rcl; ac_word=$2
 echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
-echo "configure:1002: checking for $ac_word" >&5
+echo "configure:1004: checking for $ac_word" >&5
 if eval "test \"`echo '$''{'ac_cv_path_RCLPRG'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -1034,7 +1036,7 @@ fi
 # Extract the first word of "sdl-config", so it can be a program name with args.
 set dummy sdl-config; ac_word=$2
 echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
-echo "configure:1038: checking for $ac_word" >&5
+echo "configure:1040: checking for $ac_word" >&5
 if eval "test \"`echo '$''{'ac_cv_path_SDL_CONFIG'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -1069,9 +1071,9 @@ fi
 
 
 echo $ac_n "checking for AIX""... $ac_c" 1>&6
-echo "configure:1073: checking for AIX" >&5
+echo "configure:1075: checking for AIX" >&5
 cat > conftest.$ac_ext <<EOF
-#line 1075 "configure"
+#line 1077 "configure"
 #include "confdefs.h"
 #ifdef _AIX
   yes
@@ -1093,7 +1095,7 @@ rm -f conftest*
 
 
 echo $ac_n "checking for POSIXized ISC""... $ac_c" 1>&6
-echo "configure:1097: checking for POSIXized ISC" >&5
+echo "configure:1099: checking for POSIXized ISC" >&5
 if test -d /etc/conf/kconfig.d &&
   grep _POSIX_VERSION /usr/include/sys/unistd.h >/dev/null 2>&1
 then
@@ -1115,9 +1117,9 @@ fi
 
 
 echo $ac_n "checking for Watcom C""... $ac_c" 1>&6
-echo "configure:1119: checking for Watcom C" >&5
+echo "configure:1121: checking for Watcom C" >&5
 cat > conftest.$ac_ext <<EOF
-#line 1121 "configure"
+#line 1123 "configure"
 #include "confdefs.h"
 #ifdef __WATCOMC__
   yes
@@ -1137,19 +1139,19 @@ rm -f conftest*
 echo "$ac_t""$uae_cv_prog_cc_watcom" 1>&6
 
 echo $ac_n "checking for Cygwin32 environment""... $ac_c" 1>&6
-echo "configure:1141: checking for Cygwin32 environment" >&5
+echo "configure:1143: checking for Cygwin32 environment" >&5
 if eval "test \"`echo '$''{'am_cv_cygwin32'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 1146 "configure"
+#line 1148 "configure"
 #include "confdefs.h"
 
 int main() {
 return __CYGWIN32__;
 ; return 0; }
 EOF
-if { (eval echo configure:1153: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
+if { (eval echo configure:1155: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
   rm -rf conftest*
   am_cv_cygwin32=yes
 else
@@ -1166,19 +1168,19 @@ echo "$ac_t""$am_cv_cygwin32" 1>&6
 CYGWIN32=
 test "$am_cv_cygwin32" = yes && CYGWIN32=yes
 echo $ac_n "checking for Mingw32 environment""... $ac_c" 1>&6
-echo "configure:1170: checking for Mingw32 environment" >&5
+echo "configure:1172: checking for Mingw32 environment" >&5
 if eval "test \"`echo '$''{'am_cv_mingw32'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 1175 "configure"
+#line 1177 "configure"
 #include "confdefs.h"
 
 int main() {
 return __MINGW32__;
 ; return 0; }
 EOF
-if { (eval echo configure:1182: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
+if { (eval echo configure:1184: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
   rm -rf conftest*
   am_cv_mingw32=yes
 else
@@ -1197,7 +1199,7 @@ test "$am_cv_mingw32" = yes && MINGW32=y
 
 
 echo $ac_n "checking for executable suffix""... $ac_c" 1>&6
-echo "configure:1201: checking for executable suffix" >&5
+echo "configure:1203: checking for executable suffix" >&5
 if eval "test \"`echo '$''{'am_cv_exeext'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -1241,7 +1243,7 @@ LDFLAGS="$LDFLAGS -L."
 HAVE_BEOS=no
 HAVE_POS=no
 echo $ac_n "checking for main in -lMedia_s""... $ac_c" 1>&6
-echo "configure:1245: checking for main in -lMedia_s" >&5
+echo "configure:1247: checking for main in -lMedia_s" >&5
 ac_lib_var=`echo Media_s'_'main | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
@@ -1249,14 +1251,14 @@ else
   ac_save_LIBS="$LIBS"
 LIBS="-lMedia_s  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 1253 "configure"
+#line 1255 "configure"
 #include "confdefs.h"
 
 int main() {
 main()
 ; return 0; }
 EOF
-if { (eval echo configure:1260: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:1262: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -1278,7 +1280,7 @@ HAVE_MEDIA_LIB=no
 fi
 
 echo $ac_n "checking for main in -lNeXT_s""... $ac_c" 1>&6
-echo "configure:1282: checking for main in -lNeXT_s" >&5
+echo "configure:1284: checking for main in -lNeXT_s" >&5
 ac_lib_var=`echo NeXT_s'_'main | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
@@ -1286,14 +1288,14 @@ else
   ac_save_LIBS="$LIBS"
 LIBS="-lNeXT_s  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 1290 "configure"
+#line 1292 "configure"
 #include "confdefs.h"
 
 int main() {
 main()
 ; return 0; }
 EOF
-if { (eval echo configure:1297: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:1299: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -1315,7 +1317,7 @@ HAVE_NEXT_LIB=no
 fi
 
 echo $ac_n "checking for cos in -lmoto""... $ac_c" 1>&6
-echo "configure:1319: checking for cos in -lmoto" >&5
+echo "configure:1321: checking for cos in -lmoto" >&5
 ac_lib_var=`echo moto'_'cos | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
@@ -1323,7 +1325,7 @@ else
   ac_save_LIBS="$LIBS"
 LIBS="-lmoto  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 1327 "configure"
+#line 1329 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -1334,7 +1336,7 @@ int main() {
 cos()
 ; return 0; }
 EOF
-if { (eval echo configure:1338: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:1340: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -1356,7 +1358,7 @@ HAVE_MOTO_LIB=no
 fi
 
 echo $ac_n "checking for OpenLibrary in -lamiga""... $ac_c" 1>&6
-echo "configure:1360: checking for OpenLibrary in -lamiga" >&5
+echo "configure:1362: checking for OpenLibrary in -lamiga" >&5
 ac_lib_var=`echo amiga'_'OpenLibrary | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
@@ -1364,7 +1366,7 @@ else
   ac_save_LIBS="$LIBS"
 LIBS="-lamiga  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 1368 "configure"
+#line 1370 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -1375,7 +1377,7 @@ int main() {
 OpenLibrary()
 ; return 0; }
 EOF
-if { (eval echo configure:1379: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:1381: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -1397,7 +1399,7 @@ HAVE_AMIGA_LIB=n
 fi
 
 echo $ac_n "checking for vga_setmode in -lvga""... $ac_c" 1>&6
-echo "configure:1401: checking for vga_setmode in -lvga" >&5
+echo "configure:1403: checking for vga_setmode in -lvga" >&5
 ac_lib_var=`echo vga'_'vga_setmode | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
@@ -1405,7 +1407,7 @@ else
   ac_save_LIBS="$LIBS"
 LIBS="-lvga  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 1409 "configure"
+#line 1411 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -1416,7 +1418,7 @@ int main() {
 vga_setmode()
 ; return 0; }
 EOF
-if { (eval echo configure:1420: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:1422: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -1438,7 +1440,7 @@ HAVE_SVGA_LIB=no
 fi
 
 echo $ac_n "checking for AFOpenAudioConn in -lAF""... $ac_c" 1>&6
-echo "configure:1442: checking for AFOpenAudioConn in -lAF" >&5
+echo "configure:1444: checking for AFOpenAudioConn in -lAF" >&5
 ac_lib_var=`echo AF'_'AFOpenAudioConn | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
@@ -1446,7 +1448,7 @@ else
   ac_save_LIBS="$LIBS"
 LIBS="-lAF  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 1450 "configure"
+#line 1452 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -1457,7 +1459,7 @@ int main() {
 AFOpenAudioConn()
 ; return 0; }
 EOF
-if { (eval echo configure:1461: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:1463: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -1479,7 +1481,7 @@ HAVE_AF_LIB=no
 fi
 
 echo $ac_n "checking for waveOutGetNumDevs in -lmme""... $ac_c" 1>&6
-echo "configure:1483: checking for waveOutGetNumDevs in -lmme" >&5
+echo "configure:1485: checking for waveOutGetNumDevs in -lmme" >&5
 ac_lib_var=`echo mme'_'waveOutGetNumDevs | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
@@ -1487,7 +1489,7 @@ else
   ac_save_LIBS="$LIBS"
 LIBS="-lmme  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 1491 "configure"
+#line 1493 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -1498,7 +1500,7 @@ int main() {
 waveOutGetNumDevs()
 ; return 0; }
 EOF
-if { (eval echo configure:1502: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:1504: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -1520,7 +1522,7 @@ HAVE_MME_LIB=no
 fi
 
 echo $ac_n "checking for waddch in -lncurses""... $ac_c" 1>&6
-echo "configure:1524: checking for waddch in -lncurses" >&5
+echo "configure:1526: checking for waddch in -lncurses" >&5
 ac_lib_var=`echo ncurses'_'waddch | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
@@ -1528,7 +1530,7 @@ else
   ac_save_LIBS="$LIBS"
 LIBS="-lncurses  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 1532 "configure"
+#line 1534 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -1539,7 +1541,7 @@ int main() {
 waddch()
 ; return 0; }
 EOF
-if { (eval echo configure:1543: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:1545: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -1561,7 +1563,7 @@ HAVE_NCURSES_LIB=no
 fi
 
 echo $ac_n "checking for sem_init in -lposix4""... $ac_c" 1>&6
-echo "configure:1565: checking for sem_init in -lposix4" >&5
+echo "configure:1567: checking for sem_init in -lposix4" >&5
 ac_lib_var=`echo posix4'_'sem_init | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
@@ -1569,7 +1571,7 @@ else
   ac_save_LIBS="$LIBS"
 LIBS="-lposix4  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 1573 "configure"
+#line 1575 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -1580,7 +1582,7 @@ int main() {
 sem_init()
 ; return 0; }
 EOF
-if { (eval echo configure:1584: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:1586: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -1602,7 +1604,7 @@ HAVE_POSIX4_LIB=no
 fi
 
 echo $ac_n "checking for sem_init in -lrt""... $ac_c" 1>&6
-echo "configure:1606: checking for sem_init in -lrt" >&5
+echo "configure:1608: checking for sem_init in -lrt" >&5
 ac_lib_var=`echo rt'_'sem_init | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
@@ -1610,7 +1612,7 @@ else
   ac_save_LIBS="$LIBS"
 LIBS="-lrt  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 1614 "configure"
+#line 1616 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -1621,7 +1623,7 @@ int main() {
 sem_init()
 ; return 0; }
 EOF
-if { (eval echo configure:1625: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:1627: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -1643,7 +1645,7 @@ HAVE_RT_LIB=no
 fi
 
 echo $ac_n "checking for alOpenPort in -laudio""... $ac_c" 1>&6
-echo "configure:1647: checking for alOpenPort in -laudio" >&5
+echo "configure:1649: checking for alOpenPort in -laudio" >&5
 ac_lib_var=`echo audio'_'alOpenPort | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
@@ -1651,7 +1653,7 @@ else
   ac_save_LIBS="$LIBS"
 LIBS="-laudio  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 1655 "configure"
+#line 1657 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -1662,7 +1664,7 @@ int main() {
 alOpenPort()
 ; return 0; }
 EOF
-if { (eval echo configure:1666: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:1668: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -1689,7 +1691,7 @@ fi
 # Uses ac_ vars as temps to allow command line to override cache and checks.
 # --without-x overrides everything else, but does not touch the cache.
 echo $ac_n "checking for X""... $ac_c" 1>&6
-echo "configure:1693: checking for X" >&5
+echo "configure:1695: checking for X" >&5
 
 # Check whether --with-x or --without-x was given.
 if test "${with_x+set}" = set; then
@@ -1751,12 +1753,12 @@ if test "$ac_x_includes" = NO; then
 
   # First, try using that file with no special directory specified.
 cat > conftest.$ac_ext <<EOF
-#line 1755 "configure"
+#line 1757 "configure"
 #include "confdefs.h"
 #include <$x_direct_test_include>
 EOF
 ac_try="$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out"
-{ (eval echo configure:1760: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
+{ (eval echo configure:1762: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
 ac_err=`grep -v '^ *+' conftest.out | grep -v "^conftest.${ac_ext}\$"`
 if test -z "$ac_err"; then
   rm -rf conftest*
@@ -1825,14 +1827,14 @@ if test "$ac_x_libraries" = NO; then
   ac_save_LIBS="$LIBS"
   LIBS="-l$x_direct_test_library $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 1829 "configure"
+#line 1831 "configure"
 #include "confdefs.h"
 
 int main() {
 ${x_direct_test_function}()
 ; return 0; }
 EOF
-if { (eval echo configure:1836: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:1838: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   LIBS="$ac_save_LIBS"
 # We can link X programs with no special library path.
@@ -1938,17 +1940,17 @@ else
     case "`(uname -sr) 2>/dev/null`" in
     "SunOS 5"*)
       echo $ac_n "checking whether -R must be followed by a space""... $ac_c" 1>&6
-echo "configure:1942: checking whether -R must be followed by a space" >&5
+echo "configure:1944: checking whether -R must be followed by a space" >&5
       ac_xsave_LIBS="$LIBS"; LIBS="$LIBS -R$x_libraries"
       cat > conftest.$ac_ext <<EOF
-#line 1945 "configure"
+#line 1947 "configure"
 #include "confdefs.h"
 
 int main() {
 
 ; return 0; }
 EOF
-if { (eval echo configure:1952: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:1954: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   ac_R_nospace=yes
 else
@@ -1964,14 +1966,14 @@ rm -f conftest*
       else
 	LIBS="$ac_xsave_LIBS -R $x_libraries"
 	cat > conftest.$ac_ext <<EOF
-#line 1968 "configure"
+#line 1970 "configure"
 #include "confdefs.h"
 
 int main() {
 
 ; return 0; }
 EOF
-if { (eval echo configure:1975: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:1977: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   ac_R_space=yes
 else
@@ -2003,7 +2005,7 @@ rm -f conftest*
     # libraries were built with DECnet support.  And karl@cs.umb.edu says
     # the Alpha needs dnet_stub (dnet does not exist).
     echo $ac_n "checking for dnet_ntoa in -ldnet""... $ac_c" 1>&6
-echo "configure:2007: checking for dnet_ntoa in -ldnet" >&5
+echo "configure:2009: checking for dnet_ntoa in -ldnet" >&5
 ac_lib_var=`echo dnet'_'dnet_ntoa | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
@@ -2011,7 +2013,7 @@ else
   ac_save_LIBS="$LIBS"
 LIBS="-ldnet  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 2015 "configure"
+#line 2017 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -2022,7 +2024,7 @@ int main() {
 dnet_ntoa()
 ; return 0; }
 EOF
-if { (eval echo configure:2026: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:2028: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -2044,7 +2046,7 @@ fi
 
     if test $ac_cv_lib_dnet_dnet_ntoa = no; then
       echo $ac_n "checking for dnet_ntoa in -ldnet_stub""... $ac_c" 1>&6
-echo "configure:2048: checking for dnet_ntoa in -ldnet_stub" >&5
+echo "configure:2050: checking for dnet_ntoa in -ldnet_stub" >&5
 ac_lib_var=`echo dnet_stub'_'dnet_ntoa | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
@@ -2052,7 +2054,7 @@ else
   ac_save_LIBS="$LIBS"
 LIBS="-ldnet_stub  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 2056 "configure"
+#line 2058 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -2063,7 +2065,7 @@ int main() {
 dnet_ntoa()
 ; return 0; }
 EOF
-if { (eval echo configure:2067: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:2069: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -2092,12 +2094,12 @@ fi
     # The nsl library prevents programs from opening the X display
     # on Irix 5.2, according to dickey@clark.net.
     echo $ac_n "checking for gethostbyname""... $ac_c" 1>&6
-echo "configure:2096: checking for gethostbyname" >&5
+echo "configure:2098: checking for gethostbyname" >&5
 if eval "test \"`echo '$''{'ac_cv_func_gethostbyname'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 2101 "configure"
+#line 2103 "configure"
 #include "confdefs.h"
 /* System header to define __stub macros and hopefully few prototypes,
     which can conflict with char gethostbyname(); below.  */
@@ -2120,7 +2122,7 @@ gethostbyname();
 
 ; return 0; }
 EOF
-if { (eval echo configure:2124: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:2126: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_func_gethostbyname=yes"
 else
@@ -2141,7 +2143,7 @@ fi
 
     if test $ac_cv_func_gethostbyname = no; then
       echo $ac_n "checking for gethostbyname in -lnsl""... $ac_c" 1>&6
-echo "configure:2145: checking for gethostbyname in -lnsl" >&5
+echo "configure:2147: checking for gethostbyname in -lnsl" >&5
 ac_lib_var=`echo nsl'_'gethostbyname | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
@@ -2149,7 +2151,7 @@ else
   ac_save_LIBS="$LIBS"
 LIBS="-lnsl  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 2153 "configure"
+#line 2155 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -2160,7 +2162,7 @@ int main() {
 gethostbyname()
 ; return 0; }
 EOF
-if { (eval echo configure:2164: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:2166: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -2190,12 +2192,12 @@ fi
     # -lsocket must be given before -lnsl if both are needed.
     # We assume that if connect needs -lnsl, so does gethostbyname.
     echo $ac_n "checking for connect""... $ac_c" 1>&6
-echo "configure:2194: checking for connect" >&5
+echo "configure:2196: checking for connect" >&5
 if eval "test \"`echo '$''{'ac_cv_func_connect'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 2199 "configure"
+#line 2201 "configure"
 #include "confdefs.h"
 /* System header to define __stub macros and hopefully few prototypes,
     which can conflict with char connect(); below.  */
@@ -2218,7 +2220,7 @@ connect();
 
 ; return 0; }
 EOF
-if { (eval echo configure:2222: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:2224: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_func_connect=yes"
 else
@@ -2239,7 +2241,7 @@ fi
 
     if test $ac_cv_func_connect = no; then
       echo $ac_n "checking for connect in -lsocket""... $ac_c" 1>&6
-echo "configure:2243: checking for connect in -lsocket" >&5
+echo "configure:2245: checking for connect in -lsocket" >&5
 ac_lib_var=`echo socket'_'connect | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
@@ -2247,7 +2249,7 @@ else
   ac_save_LIBS="$LIBS"
 LIBS="-lsocket $X_EXTRA_LIBS $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 2251 "configure"
+#line 2253 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -2258,7 +2260,7 @@ int main() {
 connect()
 ; return 0; }
 EOF
-if { (eval echo configure:2262: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:2264: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -2282,12 +2284,12 @@ fi
 
     # gomez@mi.uni-erlangen.de says -lposix is necessary on A/UX.
     echo $ac_n "checking for remove""... $ac_c" 1>&6
-echo "configure:2286: checking for remove" >&5
+echo "configure:2288: checking for remove" >&5
 if eval "test \"`echo '$''{'ac_cv_func_remove'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 2291 "configure"
+#line 2293 "configure"
 #include "confdefs.h"
 /* System header to define __stub macros and hopefully few prototypes,
     which can conflict with char remove(); below.  */
@@ -2310,7 +2312,7 @@ remove();
 
 ; return 0; }
 EOF
-if { (eval echo configure:2314: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:2316: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_func_remove=yes"
 else
@@ -2331,7 +2333,7 @@ fi
 
     if test $ac_cv_func_remove = no; then
       echo $ac_n "checking for remove in -lposix""... $ac_c" 1>&6
-echo "configure:2335: checking for remove in -lposix" >&5
+echo "configure:2337: checking for remove in -lposix" >&5
 ac_lib_var=`echo posix'_'remove | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
@@ -2339,7 +2341,7 @@ else
   ac_save_LIBS="$LIBS"
 LIBS="-lposix  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 2343 "configure"
+#line 2345 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -2350,7 +2352,7 @@ int main() {
 remove()
 ; return 0; }
 EOF
-if { (eval echo configure:2354: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:2356: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -2374,12 +2376,12 @@ fi
 
     # BSDI BSD/OS 2.1 needs -lipc for XOpenDisplay.
     echo $ac_n "checking for shmat""... $ac_c" 1>&6
-echo "configure:2378: checking for shmat" >&5
+echo "configure:2380: checking for shmat" >&5
 if eval "test \"`echo '$''{'ac_cv_func_shmat'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 2383 "configure"
+#line 2385 "configure"
 #include "confdefs.h"
 /* System header to define __stub macros and hopefully few prototypes,
     which can conflict with char shmat(); below.  */
@@ -2402,7 +2404,7 @@ shmat();
 
 ; return 0; }
 EOF
-if { (eval echo configure:2406: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:2408: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_func_shmat=yes"
 else
@@ -2423,7 +2425,7 @@ fi
 
     if test $ac_cv_func_shmat = no; then
       echo $ac_n "checking for shmat in -lipc""... $ac_c" 1>&6
-echo "configure:2427: checking for shmat in -lipc" >&5
+echo "configure:2429: checking for shmat in -lipc" >&5
 ac_lib_var=`echo ipc'_'shmat | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
@@ -2431,7 +2433,7 @@ else
   ac_save_LIBS="$LIBS"
 LIBS="-lipc  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 2435 "configure"
+#line 2437 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -2442,7 +2444,7 @@ int main() {
 shmat()
 ; return 0; }
 EOF
-if { (eval echo configure:2446: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:2448: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -2475,7 +2477,7 @@ fi
   # libraries we check for below, so use a different variable.
   #  --interran@uluru.Stanford.EDU, kb@cs.umb.edu.
   echo $ac_n "checking for IceConnectionNumber in -lICE""... $ac_c" 1>&6
-echo "configure:2479: checking for IceConnectionNumber in -lICE" >&5
+echo "configure:2481: checking for IceConnectionNumber in -lICE" >&5
 ac_lib_var=`echo ICE'_'IceConnectionNumber | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
@@ -2483,7 +2485,7 @@ else
   ac_save_LIBS="$LIBS"
 LIBS="-lICE $X_EXTRA_LIBS $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 2487 "configure"
+#line 2489 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -2494,7 +2496,7 @@ int main() {
 IceConnectionNumber()
 ; return 0; }
 EOF
-if { (eval echo configure:2498: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:2500: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -2525,12 +2527,12 @@ for ac_hdr in dirent.h sys/ndir.h sys/di
 do
 ac_safe=`echo "$ac_hdr" | sed 'y%./+-%__p_%'`
 echo $ac_n "checking for $ac_hdr that defines DIR""... $ac_c" 1>&6
-echo "configure:2529: checking for $ac_hdr that defines DIR" >&5
+echo "configure:2531: checking for $ac_hdr that defines DIR" >&5
 if eval "test \"`echo '$''{'ac_cv_header_dirent_$ac_safe'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 2534 "configure"
+#line 2536 "configure"
 #include "confdefs.h"
 #include <sys/types.h>
 #include <$ac_hdr>
@@ -2538,7 +2540,7 @@ int main() {
 DIR *dirp = 0;
 ; return 0; }
 EOF
-if { (eval echo configure:2542: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
+if { (eval echo configure:2544: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
   rm -rf conftest*
   eval "ac_cv_header_dirent_$ac_safe=yes"
 else
@@ -2563,7 +2565,7 @@ done
 # Two versions of opendir et al. are in -ldir and -lx on SCO Xenix.
 if test $ac_header_dirent = dirent.h; then
 echo $ac_n "checking for opendir in -ldir""... $ac_c" 1>&6
-echo "configure:2567: checking for opendir in -ldir" >&5
+echo "configure:2569: checking for opendir in -ldir" >&5
 ac_lib_var=`echo dir'_'opendir | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
@@ -2571,7 +2573,7 @@ else
   ac_save_LIBS="$LIBS"
 LIBS="-ldir  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 2575 "configure"
+#line 2577 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -2582,7 +2584,7 @@ int main() {
 opendir()
 ; return 0; }
 EOF
-if { (eval echo configure:2586: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:2588: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -2604,7 +2606,7 @@ fi
 
 else
 echo $ac_n "checking for opendir in -lx""... $ac_c" 1>&6
-echo "configure:2608: checking for opendir in -lx" >&5
+echo "configure:2610: checking for opendir in -lx" >&5
 ac_lib_var=`echo x'_'opendir | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
@@ -2612,7 +2614,7 @@ else
   ac_save_LIBS="$LIBS"
 LIBS="-lx  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 2616 "configure"
+#line 2618 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -2623,7 +2625,7 @@ int main() {
 opendir()
 ; return 0; }
 EOF
-if { (eval echo configure:2627: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:2629: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -2646,12 +2648,12 @@ fi
 fi
 
 echo $ac_n "checking for ANSI C header files""... $ac_c" 1>&6
-echo "configure:2650: checking for ANSI C header files" >&5
+echo "configure:2652: checking for ANSI C header files" >&5
 if eval "test \"`echo '$''{'ac_cv_header_stdc'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 2655 "configure"
+#line 2657 "configure"
 #include "confdefs.h"
 #include <stdlib.h>
 #include <stdarg.h>
@@ -2659,7 +2661,7 @@ else
 #include <float.h>
 EOF
 ac_try="$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out"
-{ (eval echo configure:2663: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
+{ (eval echo configure:2665: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
 ac_err=`grep -v '^ *+' conftest.out | grep -v "^conftest.${ac_ext}\$"`
 if test -z "$ac_err"; then
   rm -rf conftest*
@@ -2676,7 +2678,7 @@ rm -f conftest*
 if test $ac_cv_header_stdc = yes; then
   # SunOS 4.x string.h does not declare mem*, contrary to ANSI.
 cat > conftest.$ac_ext <<EOF
-#line 2680 "configure"
+#line 2682 "configure"
 #include "confdefs.h"
 #include <string.h>
 EOF
@@ -2694,7 +2696,7 @@ fi
 if test $ac_cv_header_stdc = yes; then
   # ISC 2.0.2 stdlib.h does not declare free, contrary to ANSI.
 cat > conftest.$ac_ext <<EOF
-#line 2698 "configure"
+#line 2700 "configure"
 #include "confdefs.h"
 #include <stdlib.h>
 EOF
@@ -2715,7 +2717,7 @@ if test "$cross_compiling" = yes; then
   :
 else
   cat > conftest.$ac_ext <<EOF
-#line 2719 "configure"
+#line 2721 "configure"
 #include "confdefs.h"
 #include <ctype.h>
 #define ISLOWER(c) ('a' <= (c) && (c) <= 'z')
@@ -2726,7 +2728,7 @@ if (XOR (islower (i), ISLOWER (i)) || to
 exit (0); }
 
 EOF
-if { (eval echo configure:2730: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
+if { (eval echo configure:2732: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
 then
   :
 else
@@ -2754,17 +2756,17 @@ for ac_hdr in unistd.h fcntl.h sys/time.
 do
 ac_safe=`echo "$ac_hdr" | sed 'y%./+-%__p_%'`
 echo $ac_n "checking for $ac_hdr""... $ac_c" 1>&6
-echo "configure:2758: checking for $ac_hdr" >&5
+echo "configure:2760: checking for $ac_hdr" >&5
 if eval "test \"`echo '$''{'ac_cv_header_$ac_safe'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 2763 "configure"
+#line 2765 "configure"
 #include "confdefs.h"
 #include <$ac_hdr>
 EOF
 ac_try="$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out"
-{ (eval echo configure:2768: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
+{ (eval echo configure:2770: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
 ac_err=`grep -v '^ *+' conftest.out | grep -v "^conftest.${ac_ext}\$"`
 if test -z "$ac_err"; then
   rm -rf conftest*
@@ -2794,17 +2796,17 @@ for ac_hdr in sys/soundcard.h machine/so
 do
 ac_safe=`echo "$ac_hdr" | sed 'y%./+-%__p_%'`
 echo $ac_n "checking for $ac_hdr""... $ac_c" 1>&6
-echo "configure:2798: checking for $ac_hdr" >&5
+echo "configure:2800: checking for $ac_hdr" >&5
 if eval "test \"`echo '$''{'ac_cv_header_$ac_safe'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 2803 "configure"
+#line 2805 "configure"
 #include "confdefs.h"
 #include <$ac_hdr>
 EOF
 ac_try="$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out"
-{ (eval echo configure:2808: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
+{ (eval echo configure:2810: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
 ac_err=`grep -v '^ *+' conftest.out | grep -v "^conftest.${ac_ext}\$"`
 if test -z "$ac_err"; then
   rm -rf conftest*
@@ -2834,17 +2836,17 @@ for ac_hdr in posix_opt.h sys/ioctl.h sy
 do
 ac_safe=`echo "$ac_hdr" | sed 'y%./+-%__p_%'`
 echo $ac_n "checking for $ac_hdr""... $ac_c" 1>&6
-echo "configure:2838: checking for $ac_hdr" >&5
+echo "configure:2840: checking for $ac_hdr" >&5
 if eval "test \"`echo '$''{'ac_cv_header_$ac_safe'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 2843 "configure"
+#line 2845 "configure"
 #include "confdefs.h"
 #include <$ac_hdr>
 EOF
 ac_try="$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out"
-{ (eval echo configure:2848: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
+{ (eval echo configure:2850: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
 ac_err=`grep -v '^ *+' conftest.out | grep -v "^conftest.${ac_ext}\$"`
 if test -z "$ac_err"; then
   rm -rf conftest*
@@ -2874,17 +2876,17 @@ for ac_hdr in windows.h ddraw.h
 do
 ac_safe=`echo "$ac_hdr" | sed 'y%./+-%__p_%'`
 echo $ac_n "checking for $ac_hdr""... $ac_c" 1>&6
-echo "configure:2878: checking for $ac_hdr" >&5
+echo "configure:2880: checking for $ac_hdr" >&5
 if eval "test \"`echo '$''{'ac_cv_header_$ac_safe'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 2883 "configure"
+#line 2885 "configure"
 #include "confdefs.h"
 #include <$ac_hdr>
 EOF
 ac_try="$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out"
-{ (eval echo configure:2888: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
+{ (eval echo configure:2890: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
 ac_err=`grep -v '^ *+' conftest.out | grep -v "^conftest.${ac_ext}\$"`
 if test -z "$ac_err"; then
   rm -rf conftest*
@@ -2912,17 +2914,17 @@ done
 
 ac_safe=`echo "be_math.h" | sed 'y%./+-%__p_%'`
 echo $ac_n "checking for be_math.h""... $ac_c" 1>&6
-echo "configure:2916: checking for be_math.h" >&5
+echo "configure:2918: checking for be_math.h" >&5
 if eval "test \"`echo '$''{'ac_cv_header_$ac_safe'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 2921 "configure"
+#line 2923 "configure"
 #include "confdefs.h"
 #include <be_math.h>
 EOF
 ac_try="$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out"
-{ (eval echo configure:2926: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
+{ (eval echo configure:2928: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
 ac_err=`grep -v '^ *+' conftest.out | grep -v "^conftest.${ac_ext}\$"`
 if test -z "$ac_err"; then
   rm -rf conftest*
@@ -2948,17 +2950,17 @@ for ac_hdr in machine/joystick.h
 do
 ac_safe=`echo "$ac_hdr" | sed 'y%./+-%__p_%'`
 echo $ac_n "checking for $ac_hdr""... $ac_c" 1>&6
-echo "configure:2952: checking for $ac_hdr" >&5
+echo "configure:2954: checking for $ac_hdr" >&5
 if eval "test \"`echo '$''{'ac_cv_header_$ac_safe'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 2957 "configure"
+#line 2959 "configure"
 #include "confdefs.h"
 #include <$ac_hdr>
 EOF
 ac_try="$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out"
-{ (eval echo configure:2962: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
+{ (eval echo configure:2964: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
 ac_err=`grep -v '^ *+' conftest.out | grep -v "^conftest.${ac_ext}\$"`
 if test -z "$ac_err"; then
   rm -rf conftest*
@@ -2988,17 +2990,17 @@ for ac_hdr in devices/ahi.h
 do
 ac_safe=`echo "$ac_hdr" | sed 'y%./+-%__p_%'`
 echo $ac_n "checking for $ac_hdr""... $ac_c" 1>&6
-echo "configure:2992: checking for $ac_hdr" >&5
+echo "configure:2994: checking for $ac_hdr" >&5
 if eval "test \"`echo '$''{'ac_cv_header_$ac_safe'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 2997 "configure"
+#line 2999 "configure"
 #include "confdefs.h"
 #include <$ac_hdr>
 EOF
 ac_try="$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out"
-{ (eval echo configure:3002: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
+{ (eval echo configure:3004: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
 ac_err=`grep -v '^ *+' conftest.out | grep -v "^conftest.${ac_ext}\$"`
 if test -z "$ac_err"; then
   rm -rf conftest*
@@ -3028,17 +3030,17 @@ for ac_hdr in dmedia/audio.h
 do
 ac_safe=`echo "$ac_hdr" | sed 'y%./+-%__p_%'`
 echo $ac_n "checking for $ac_hdr""... $ac_c" 1>&6
-echo "configure:3032: checking for $ac_hdr" >&5
+echo "configure:3034: checking for $ac_hdr" >&5
 if eval "test \"`echo '$''{'ac_cv_header_$ac_safe'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 3037 "configure"
+#line 3039 "configure"
 #include "confdefs.h"
 #include <$ac_hdr>
 EOF
 ac_try="$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out"
-{ (eval echo configure:3042: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
+{ (eval echo configure:3044: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
 ac_err=`grep -v '^ *+' conftest.out | grep -v "^conftest.${ac_ext}\$"`
 if test -z "$ac_err"; then
   rm -rf conftest*
@@ -3068,17 +3070,17 @@ for ac_hdr in libraries/cybergraphics.h 
 do
 ac_safe=`echo "$ac_hdr" | sed 'y%./+-%__p_%'`
 echo $ac_n "checking for $ac_hdr""... $ac_c" 1>&6
-echo "configure:3072: checking for $ac_hdr" >&5
+echo "configure:3074: checking for $ac_hdr" >&5
 if eval "test \"`echo '$''{'ac_cv_header_$ac_safe'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 3077 "configure"
+#line 3079 "configure"
 #include "confdefs.h"
 #include <$ac_hdr>
 EOF
 ac_try="$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out"
-{ (eval echo configure:3082: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
+{ (eval echo configure:3084: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
 ac_err=`grep -v '^ *+' conftest.out | grep -v "^conftest.${ac_ext}\$"`
 if test -z "$ac_err"; then
   rm -rf conftest*
@@ -3106,7 +3108,7 @@ done
 
 
 echo $ac_n "checking size of char""... $ac_c" 1>&6
-echo "configure:3110: checking size of char" >&5
+echo "configure:3112: checking size of char" >&5
 if eval "test \"`echo '$''{'ac_cv_sizeof_char'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -3114,7 +3116,7 @@ else
   ac_cv_sizeof_char=1
 else
   cat > conftest.$ac_ext <<EOF
-#line 3118 "configure"
+#line 3120 "configure"
 #include "confdefs.h"
 #include <stdio.h>
 main()
@@ -3125,7 +3127,7 @@ main()
   exit(0);
 }
 EOF
-if { (eval echo configure:3129: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
+if { (eval echo configure:3131: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
 then
   ac_cv_sizeof_char=`cat conftestval`
 else
@@ -3145,7 +3147,7 @@ EOF
 
 
 echo $ac_n "checking size of short""... $ac_c" 1>&6
-echo "configure:3149: checking size of short" >&5
+echo "configure:3151: checking size of short" >&5
 if eval "test \"`echo '$''{'ac_cv_sizeof_short'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -3153,7 +3155,7 @@ else
   ac_cv_sizeof_short=2
 else
   cat > conftest.$ac_ext <<EOF
-#line 3157 "configure"
+#line 3159 "configure"
 #include "confdefs.h"
 #include <stdio.h>
 main()
@@ -3164,7 +3166,7 @@ main()
   exit(0);
 }
 EOF
-if { (eval echo configure:3168: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
+if { (eval echo configure:3170: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
 then
   ac_cv_sizeof_short=`cat conftestval`
 else
@@ -3184,7 +3186,7 @@ EOF
 
 
 echo $ac_n "checking size of int""... $ac_c" 1>&6
-echo "configure:3188: checking size of int" >&5
+echo "configure:3190: checking size of int" >&5
 if eval "test \"`echo '$''{'ac_cv_sizeof_int'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -3192,7 +3194,7 @@ else
   ac_cv_sizeof_int=4
 else
   cat > conftest.$ac_ext <<EOF
-#line 3196 "configure"
+#line 3198 "configure"
 #include "confdefs.h"
 #include <stdio.h>
 main()
@@ -3203,7 +3205,7 @@ main()
   exit(0);
 }
 EOF
-if { (eval echo configure:3207: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
+if { (eval echo configure:3209: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
 then
   ac_cv_sizeof_int=`cat conftestval`
 else
@@ -3223,7 +3225,7 @@ EOF
 
 
 echo $ac_n "checking size of long""... $ac_c" 1>&6
-echo "configure:3227: checking size of long" >&5
+echo "configure:3229: checking size of long" >&5
 if eval "test \"`echo '$''{'ac_cv_sizeof_long'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -3231,7 +3233,7 @@ else
   ac_cv_sizeof_long=4
 else
   cat > conftest.$ac_ext <<EOF
-#line 3235 "configure"
+#line 3237 "configure"
 #include "confdefs.h"
 #include <stdio.h>
 main()
@@ -3242,7 +3244,7 @@ main()
   exit(0);
 }
 EOF
-if { (eval echo configure:3246: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
+if { (eval echo configure:3248: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
 then
   ac_cv_sizeof_long=`cat conftestval`
 else
@@ -3262,7 +3264,7 @@ EOF
 
 
 echo $ac_n "checking size of long long""... $ac_c" 1>&6
-echo "configure:3266: checking size of long long" >&5
+echo "configure:3268: checking size of long long" >&5
 if eval "test \"`echo '$''{'ac_cv_sizeof_long_long'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -3270,7 +3272,7 @@ else
   ac_cv_sizeof_long_long=8
 else
   cat > conftest.$ac_ext <<EOF
-#line 3274 "configure"
+#line 3276 "configure"
 #include "confdefs.h"
 #include <stdio.h>
 main()
@@ -3281,7 +3283,7 @@ main()
   exit(0);
 }
 EOF
-if { (eval echo configure:3285: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
+if { (eval echo configure:3287: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
 then
   ac_cv_sizeof_long_long=`cat conftestval`
 else
@@ -3301,7 +3303,7 @@ EOF
 
 
 echo $ac_n "checking size of __int64""... $ac_c" 1>&6
-echo "configure:3305: checking size of __int64" >&5
+echo "configure:3307: checking size of __int64" >&5
 if eval "test \"`echo '$''{'ac_cv_sizeof___int64'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -3309,7 +3311,7 @@ else
   ac_cv_sizeof___int64=8
 else
   cat > conftest.$ac_ext <<EOF
-#line 3313 "configure"
+#line 3315 "configure"
 #include "confdefs.h"
 #include <stdio.h>
 main()
@@ -3320,7 +3322,7 @@ main()
   exit(0);
 }
 EOF
-if { (eval echo configure:3324: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
+if { (eval echo configure:3326: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
 then
   ac_cv_sizeof___int64=`cat conftestval`
 else
@@ -3341,12 +3343,12 @@ EOF
 
 
 echo $ac_n "checking for working const""... $ac_c" 1>&6
-echo "configure:3345: checking for working const" >&5
+echo "configure:3347: checking for working const" >&5
 if eval "test \"`echo '$''{'ac_cv_c_const'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 3350 "configure"
+#line 3352 "configure"
 #include "confdefs.h"
 
 int main() {
@@ -3395,7 +3397,7 @@ ccp = (char const *const *) p;
 
 ; return 0; }
 EOF
-if { (eval echo configure:3399: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
+if { (eval echo configure:3401: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
   rm -rf conftest*
   ac_cv_c_const=yes
 else
@@ -3416,21 +3418,21 @@ EOF
 fi
 
 echo $ac_n "checking for inline""... $ac_c" 1>&6
-echo "configure:3420: checking for inline" >&5
+echo "configure:3422: checking for inline" >&5
 if eval "test \"`echo '$''{'ac_cv_c_inline'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   ac_cv_c_inline=no
 for ac_kw in inline __inline__ __inline; do
   cat > conftest.$ac_ext <<EOF
-#line 3427 "configure"
+#line 3429 "configure"
 #include "confdefs.h"
 
 int main() {
 } $ac_kw foo() {
 ; return 0; }
 EOF
-if { (eval echo configure:3434: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
+if { (eval echo configure:3436: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
   rm -rf conftest*
   ac_cv_c_inline=$ac_kw; break
 else
@@ -3459,12 +3461,12 @@ if [ "x$ac_cv_c_inline" = "xno" ]; then
   ac_cv_c_inline=
 fi
 echo $ac_n "checking for mode_t""... $ac_c" 1>&6
-echo "configure:3463: checking for mode_t" >&5
+echo "configure:3465: checking for mode_t" >&5
 if eval "test \"`echo '$''{'ac_cv_type_mode_t'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 3468 "configure"
+#line 3470 "configure"
 #include "confdefs.h"
 #include <sys/types.h>
 #if STDC_HEADERS
@@ -3492,12 +3494,12 @@ EOF
 fi
 
 echo $ac_n "checking for off_t""... $ac_c" 1>&6
-echo "configure:3496: checking for off_t" >&5
+echo "configure:3498: checking for off_t" >&5
 if eval "test \"`echo '$''{'ac_cv_type_off_t'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 3501 "configure"
+#line 3503 "configure"
 #include "confdefs.h"
 #include <sys/types.h>
 #if STDC_HEADERS
@@ -3525,12 +3527,12 @@ EOF
 fi
 
 echo $ac_n "checking for pid_t""... $ac_c" 1>&6
-echo "configure:3529: checking for pid_t" >&5
+echo "configure:3531: checking for pid_t" >&5
 if eval "test \"`echo '$''{'ac_cv_type_pid_t'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 3534 "configure"
+#line 3536 "configure"
 #include "confdefs.h"
 #include <sys/types.h>
 #if STDC_HEADERS
@@ -3558,12 +3560,12 @@ EOF
 fi
 
 echo $ac_n "checking for st_blocks in struct stat""... $ac_c" 1>&6
-echo "configure:3562: checking for st_blocks in struct stat" >&5
+echo "configure:3564: checking for st_blocks in struct stat" >&5
 if eval "test \"`echo '$''{'ac_cv_struct_st_blocks'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 3567 "configure"
+#line 3569 "configure"
 #include "confdefs.h"
 #include <sys/types.h>
 #include <sys/stat.h>
@@ -3571,7 +3573,7 @@ int main() {
 struct stat s; s.st_blocks;
 ; return 0; }
 EOF
-if { (eval echo configure:3575: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
+if { (eval echo configure:3577: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
   rm -rf conftest*
   ac_cv_struct_st_blocks=yes
 else
@@ -3594,12 +3596,12 @@ else
 fi
 
 echo $ac_n "checking whether time.h and sys/time.h may both be included""... $ac_c" 1>&6
-echo "configure:3598: checking whether time.h and sys/time.h may both be included" >&5
+echo "configure:3600: checking whether time.h and sys/time.h may both be included" >&5
 if eval "test \"`echo '$''{'ac_cv_header_time'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 3603 "configure"
+#line 3605 "configure"
 #include "confdefs.h"
 #include <sys/types.h>
 #include <sys/time.h>
@@ -3608,7 +3610,7 @@ int main() {
 struct tm *tp;
 ; return 0; }
 EOF
-if { (eval echo configure:3612: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
+if { (eval echo configure:3614: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
   rm -rf conftest*
   ac_cv_header_time=yes
 else
@@ -3629,12 +3631,12 @@ EOF
 fi
 
 echo $ac_n "checking whether struct tm is in sys/time.h or time.h""... $ac_c" 1>&6
-echo "configure:3633: checking whether struct tm is in sys/time.h or time.h" >&5
+echo "configure:3635: checking whether struct tm is in sys/time.h or time.h" >&5
 if eval "test \"`echo '$''{'ac_cv_struct_tm'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 3638 "configure"
+#line 3640 "configure"
 #include "confdefs.h"
 #include <sys/types.h>
 #include <time.h>
@@ -3642,7 +3644,7 @@ int main() {
 struct tm *tp; tp->tm_sec;
 ; return 0; }
 EOF
-if { (eval echo configure:3646: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
+if { (eval echo configure:3648: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
   rm -rf conftest*
   ac_cv_struct_tm=time.h
 else
@@ -3665,13 +3667,13 @@ fi
 
 if test $ac_cv_prog_gcc = yes; then
     echo $ac_n "checking whether ${CC-cc} needs -traditional""... $ac_c" 1>&6
-echo "configure:3669: checking whether ${CC-cc} needs -traditional" >&5
+echo "configure:3671: checking whether ${CC-cc} needs -traditional" >&5
 if eval "test \"`echo '$''{'ac_cv_prog_gcc_traditional'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
     ac_pattern="Autoconf.*'x'"
   cat > conftest.$ac_ext <<EOF
-#line 3675 "configure"
+#line 3677 "configure"
 #include "confdefs.h"
 #include <sgtty.h>
 Autoconf TIOCGETP
@@ -3689,7 +3691,7 @@ rm -f conftest*
 
   if test $ac_cv_prog_gcc_traditional = no; then
     cat > conftest.$ac_ext <<EOF
-#line 3693 "configure"
+#line 3695 "configure"
 #include "confdefs.h"
 #include <termio.h>
 Autoconf TCGETA
@@ -3711,7 +3713,7 @@ echo "$ac_t""$ac_cv_prog_gcc_traditional
 fi
 
 echo $ac_n "checking for 8-bit clean memcmp""... $ac_c" 1>&6
-echo "configure:3715: checking for 8-bit clean memcmp" >&5
+echo "configure:3717: checking for 8-bit clean memcmp" >&5
 if eval "test \"`echo '$''{'ac_cv_func_memcmp_clean'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -3719,7 +3721,7 @@ else
   ac_cv_func_memcmp_clean=no
 else
   cat > conftest.$ac_ext <<EOF
-#line 3723 "configure"
+#line 3725 "configure"
 #include "confdefs.h"
 
 main()
@@ -3729,7 +3731,7 @@ main()
 }
 
 EOF
-if { (eval echo configure:3733: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
+if { (eval echo configure:3735: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
 then
   ac_cv_func_memcmp_clean=yes
 else
@@ -3747,12 +3749,12 @@ echo "$ac_t""$ac_cv_func_memcmp_clean" 1
 test $ac_cv_func_memcmp_clean = no && LIBOBJS="$LIBOBJS memcmp.${ac_objext}"
 
 echo $ac_n "checking return type of signal handlers""... $ac_c" 1>&6
-echo "configure:3751: checking return type of signal handlers" >&5
+echo "configure:3753: checking return type of signal handlers" >&5
 if eval "test \"`echo '$''{'ac_cv_type_signal'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 3756 "configure"
+#line 3758 "configure"
 #include "confdefs.h"
 #include <sys/types.h>
 #include <signal.h>
@@ -3769,7 +3771,7 @@ int main() {
 int i;
 ; return 0; }
 EOF
-if { (eval echo configure:3773: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
+if { (eval echo configure:3775: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
   rm -rf conftest*
   ac_cv_type_signal=void
 else
@@ -3788,7 +3790,7 @@ EOF
 
 
 echo $ac_n "checking whether utime accepts a null argument""... $ac_c" 1>&6
-echo "configure:3792: checking whether utime accepts a null argument" >&5
+echo "configure:3794: checking whether utime accepts a null argument" >&5
 if eval "test \"`echo '$''{'ac_cv_func_utime_null'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -3798,7 +3800,7 @@ if test "$cross_compiling" = yes; then
   ac_cv_func_utime_null=no
 else
   cat > conftest.$ac_ext <<EOF
-#line 3802 "configure"
+#line 3804 "configure"
 #include "confdefs.h"
 #include <sys/types.h>
 #include <sys/stat.h>
@@ -3809,7 +3811,7 @@ exit(!(stat ("conftestdata", &s) == 0 &&
 && t.st_mtime - s.st_mtime < 120));
 }
 EOF
-if { (eval echo configure:3813: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
+if { (eval echo configure:3815: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
 then
   ac_cv_func_utime_null=yes
 else
@@ -3835,12 +3837,12 @@ fi
 for ac_func in getcwd getopt strdup gettimeofday sigaction mkdir rmdir
 do
 echo $ac_n "checking for $ac_func""... $ac_c" 1>&6
-echo "configure:3839: checking for $ac_func" >&5
+echo "configure:3841: checking for $ac_func" >&5
 if eval "test \"`echo '$''{'ac_cv_func_$ac_func'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 3844 "configure"
+#line 3846 "configure"
 #include "confdefs.h"
 /* System header to define __stub macros and hopefully few prototypes,
     which can conflict with char $ac_func(); below.  */
@@ -3863,7 +3865,7 @@ $ac_func();
 
 ; return 0; }
 EOF
-if { (eval echo configure:3867: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:3869: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_func_$ac_func=yes"
 else
@@ -3890,12 +3892,12 @@ done
 for ac_func in select strerror strstr isnan isinf setitimer
 do
 echo $ac_n "checking for $ac_func""... $ac_c" 1>&6
-echo "configure:3894: checking for $ac_func" >&5
+echo "configure:3896: checking for $ac_func" >&5
 if eval "test \"`echo '$''{'ac_cv_func_$ac_func'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 3899 "configure"
+#line 3901 "configure"
 #include "confdefs.h"
 /* System header to define __stub macros and hopefully few prototypes,
     which can conflict with char $ac_func(); below.  */
@@ -3918,7 +3920,7 @@ $ac_func();
 
 ; return 0; }
 EOF
-if { (eval echo configure:3922: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:3924: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_func_$ac_func=yes"
 else
@@ -3945,12 +3947,12 @@ done
 for ac_func in tcgetattr cfmakeraw readdir_r vprintf vsprintf vfprintf
 do
 echo $ac_n "checking for $ac_func""... $ac_c" 1>&6
-echo "configure:3949: checking for $ac_func" >&5
+echo "configure:3951: checking for $ac_func" >&5
 if eval "test \"`echo '$''{'ac_cv_func_$ac_func'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 3954 "configure"
+#line 3956 "configure"
 #include "confdefs.h"
 /* System header to define __stub macros and hopefully few prototypes,
     which can conflict with char $ac_func(); below.  */
@@ -3973,7 +3975,7 @@ $ac_func();
 
 ; return 0; }
 EOF
-if { (eval echo configure:3977: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:3979: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_func_$ac_func=yes"
 else
@@ -4010,17 +4012,17 @@ sys/filsys.h sys/fs_types.h sys/fs/s5par
 do
 ac_safe=`echo "$ac_hdr" | sed 'y%./+-%__p_%'`
 echo $ac_n "checking for $ac_hdr""... $ac_c" 1>&6
-echo "configure:4014: checking for $ac_hdr" >&5
+echo "configure:4016: checking for $ac_hdr" >&5
 if eval "test \"`echo '$''{'ac_cv_header_$ac_safe'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 4019 "configure"
+#line 4021 "configure"
 #include "confdefs.h"
 #include <$ac_hdr>
 EOF
 ac_try="$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out"
-{ (eval echo configure:4024: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
+{ (eval echo configure:4026: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
 ac_err=`grep -v '^ *+' conftest.out | grep -v "^conftest.${ac_ext}\$"`
 if test -z "$ac_err"; then
   rm -rf conftest*
@@ -4052,12 +4054,12 @@ getcwd getmntinfo gettimeofday isascii l
 listmntent memcpy mkfifo strchr strerror strrchr
 do
 echo $ac_n "checking for $ac_func""... $ac_c" 1>&6
-echo "configure:4056: checking for $ac_func" >&5
+echo "configure:4058: checking for $ac_func" >&5
 if eval "test \"`echo '$''{'ac_cv_func_$ac_func'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 4061 "configure"
+#line 4063 "configure"
 #include "confdefs.h"
 /* System header to define __stub macros and hopefully few prototypes,
     which can conflict with char $ac_func(); below.  */
@@ -4080,7 +4082,7 @@ $ac_func();
 
 ; return 0; }
 EOF
-if { (eval echo configure:4084: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:4086: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_func_$ac_func=yes"
 else
@@ -4112,7 +4114,7 @@ list_mounted_fs=
 # make sure LIBS contains -lsun (on Irix4) or -lseq (on PTX).
 # getmntent is in -lsun on Irix 4, -lseq on Dynix/PTX, -lgen on Unixware.
 echo $ac_n "checking for getmntent in -lsun""... $ac_c" 1>&6
-echo "configure:4116: checking for getmntent in -lsun" >&5
+echo "configure:4118: checking for getmntent in -lsun" >&5
 ac_lib_var=`echo sun'_'getmntent | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
@@ -4120,7 +4122,7 @@ else
   ac_save_LIBS="$LIBS"
 LIBS="-lsun  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 4124 "configure"
+#line 4126 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -4131,7 +4133,7 @@ int main() {
 getmntent()
 ; return 0; }
 EOF
-if { (eval echo configure:4135: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:4137: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -4150,7 +4152,7 @@ if eval "test \"`echo '$ac_cv_lib_'$ac_l
 else
   echo "$ac_t""no" 1>&6
 echo $ac_n "checking for getmntent in -lseq""... $ac_c" 1>&6
-echo "configure:4154: checking for getmntent in -lseq" >&5
+echo "configure:4156: checking for getmntent in -lseq" >&5
 ac_lib_var=`echo seq'_'getmntent | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
@@ -4158,7 +4160,7 @@ else
   ac_save_LIBS="$LIBS"
 LIBS="-lseq  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 4162 "configure"
+#line 4164 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -4169,7 +4171,7 @@ int main() {
 getmntent()
 ; return 0; }
 EOF
-if { (eval echo configure:4173: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:4175: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -4188,7 +4190,7 @@ if eval "test \"`echo '$ac_cv_lib_'$ac_l
 else
   echo "$ac_t""no" 1>&6
 echo $ac_n "checking for getmntent in -lgen""... $ac_c" 1>&6
-echo "configure:4192: checking for getmntent in -lgen" >&5
+echo "configure:4194: checking for getmntent in -lgen" >&5
 ac_lib_var=`echo gen'_'getmntent | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
@@ -4196,7 +4198,7 @@ else
   ac_save_LIBS="$LIBS"
 LIBS="-lgen  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 4200 "configure"
+#line 4202 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -4207,7 +4209,7 @@ int main() {
 getmntent()
 ; return 0; }
 EOF
-if { (eval echo configure:4211: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:4213: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -4232,12 +4234,12 @@ fi
 fi
 
 echo $ac_n "checking for getmntent""... $ac_c" 1>&6
-echo "configure:4236: checking for getmntent" >&5
+echo "configure:4238: checking for getmntent" >&5
 if eval "test \"`echo '$''{'ac_cv_func_getmntent'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 4241 "configure"
+#line 4243 "configure"
 #include "confdefs.h"
 /* System header to define __stub macros and hopefully few prototypes,
     which can conflict with char getmntent(); below.  */
@@ -4260,7 +4262,7 @@ getmntent();
 
 ; return 0; }
 EOF
-if { (eval echo configure:4264: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:4266: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_func_getmntent=yes"
 else
@@ -4295,13 +4297,13 @@ fi
 if test -z "$list_mounted_fs"; then
 # Cray UNICOS 9
 echo $ac_n "checking for listmntent of Cray/Unicos-9""... $ac_c" 1>&6
-echo "configure:4299: checking for listmntent of Cray/Unicos-9" >&5
+echo "configure:4301: checking for listmntent of Cray/Unicos-9" >&5
 if eval "test \"`echo '$''{'fu_cv_sys_mounted_cray_listmntent'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   fu_cv_sys_mounted_cray_listmntent=no
 cat > conftest.$ac_ext <<EOF
-#line 4305 "configure"
+#line 4307 "configure"
 #include "confdefs.h"
 #ifdef _CRAY
 yes
@@ -4339,7 +4341,7 @@ if test $ac_cv_func_getmntent = yes; the
 if test -z "$list_mounted_fs"; then
 # 4.3BSD, SunOS, HP-UX, Dynix, Irix
 echo $ac_n "checking for one-argument getmntent function""... $ac_c" 1>&6
-echo "configure:4343: checking for one-argument getmntent function" >&5
+echo "configure:4345: checking for one-argument getmntent function" >&5
 if eval "test \"`echo '$''{'fu_cv_sys_mounted_getmntent1'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -4361,12 +4363,12 @@ fi
 if test -z "$list_mounted_fs"; then
 # SVR4
 echo $ac_n "checking for two-argument getmntent function""... $ac_c" 1>&6
-echo "configure:4365: checking for two-argument getmntent function" >&5
+echo "configure:4367: checking for two-argument getmntent function" >&5
 if eval "test \"`echo '$''{'fu_cv_sys_mounted_getmntent2'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 4370 "configure"
+#line 4372 "configure"
 #include "confdefs.h"
 #include <sys/mnttab.h>
 EOF
@@ -4401,12 +4403,12 @@ fi
 if test -z "$list_mounted_fs"; then
 # DEC Alpha running OSF/1.
 echo $ac_n "checking for getfsstat function""... $ac_c" 1>&6
-echo "configure:4405: checking for getfsstat function" >&5
+echo "configure:4407: checking for getfsstat function" >&5
 if eval "test \"`echo '$''{'fu_cv_sys_mounted_getsstat'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 4410 "configure"
+#line 4412 "configure"
 #include "confdefs.h"
 
 #include <sys/types.h>
@@ -4417,7 +4419,7 @@ struct statfs *stats;
 int numsys = getfsstat ((struct statfs *)0, 0L, MNT_WAIT); 
 ; return 0; }
 EOF
-if { (eval echo configure:4421: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:4423: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   fu_cv_sys_mounted_getsstat=yes
 else
@@ -4442,17 +4444,17 @@ fi
 if test -z "$list_mounted_fs"; then
 # AIX.
 echo $ac_n "checking for mntctl function and struct vmount""... $ac_c" 1>&6
-echo "configure:4446: checking for mntctl function and struct vmount" >&5
+echo "configure:4448: checking for mntctl function and struct vmount" >&5
 if eval "test \"`echo '$''{'fu_cv_sys_mounted_vmount'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 4451 "configure"
+#line 4453 "configure"
 #include "confdefs.h"
 #include <fshelp.h>
 EOF
 ac_try="$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out"
-{ (eval echo configure:4456: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
+{ (eval echo configure:4458: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
 ac_err=`grep -v '^ *+' conftest.out | grep -v "^conftest.${ac_ext}\$"`
 if test -z "$ac_err"; then
   rm -rf conftest*
@@ -4480,12 +4482,12 @@ fi
 if test -z "$list_mounted_fs"; then
 # SVR3
 echo $ac_n "checking for FIXME existence of three headers""... $ac_c" 1>&6
-echo "configure:4484: checking for FIXME existence of three headers" >&5
+echo "configure:4486: checking for FIXME existence of three headers" >&5
 if eval "test \"`echo '$''{'fu_cv_sys_mounted_fread_fstyp'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 4489 "configure"
+#line 4491 "configure"
 #include "confdefs.h"
 
 #include <sys/statfs.h>
@@ -4493,7 +4495,7 @@ else
 #include <mnttab.h>
 EOF
 ac_try="$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out"
-{ (eval echo configure:4497: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
+{ (eval echo configure:4499: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
 ac_err=`grep -v '^ *+' conftest.out | grep -v "^conftest.${ac_ext}\$"`
 if test -z "$ac_err"; then
   rm -rf conftest*
@@ -4521,7 +4523,7 @@ fi
 if test -z "$list_mounted_fs"; then
 # 4.4BSD and DEC OSF/1.
 echo $ac_n "checking for getmntinfo function""... $ac_c" 1>&6
-echo "configure:4525: checking for getmntinfo function" >&5
+echo "configure:4527: checking for getmntinfo function" >&5
 if eval "test \"`echo '$''{'fu_cv_sys_mounted_getmntinfo'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -4529,7 +4531,7 @@ else
 ok=
 if test $ac_cv_func_getmntinfo = yes; then
 cat > conftest.$ac_ext <<EOF
-#line 4533 "configure"
+#line 4535 "configure"
 #include "confdefs.h"
 #include <sys/mount.h>
 EOF
@@ -4562,19 +4564,19 @@ fi
 if test -z "$list_mounted_fs"; then
 # Ultrix
 echo $ac_n "checking for getmnt function""... $ac_c" 1>&6
-echo "configure:4566: checking for getmnt function" >&5
+echo "configure:4568: checking for getmnt function" >&5
 if eval "test \"`echo '$''{'fu_cv_sys_mounted_getmnt'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 4571 "configure"
+#line 4573 "configure"
 #include "confdefs.h"
 
 #include <sys/fs_types.h>
 #include <sys/mount.h>
 EOF
 ac_try="$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out"
-{ (eval echo configure:4578: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
+{ (eval echo configure:4580: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
 ac_err=`grep -v '^ *+' conftest.out | grep -v "^conftest.${ac_ext}\$"`
 if test -z "$ac_err"; then
   rm -rf conftest*
@@ -4602,17 +4604,17 @@ fi
 if test -z "$list_mounted_fs"; then
 # SVR2
 echo $ac_n "checking whether it is possible to resort to fread on /etc/mnttab""... $ac_c" 1>&6
-echo "configure:4606: checking whether it is possible to resort to fread on /etc/mnttab" >&5
+echo "configure:4608: checking whether it is possible to resort to fread on /etc/mnttab" >&5
 if eval "test \"`echo '$''{'fu_cv_sys_mounted_fread'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 4611 "configure"
+#line 4613 "configure"
 #include "confdefs.h"
 #include <mnttab.h>
 EOF
 ac_try="$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out"
-{ (eval echo configure:4616: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
+{ (eval echo configure:4618: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
 ac_err=`grep -v '^ *+' conftest.out | grep -v "^conftest.${ac_ext}\$"`
 if test -z "$ac_err"; then
   rm -rf conftest*
@@ -4644,7 +4646,7 @@ if test -z "$list_mounted_fs"; then
 fi
 
 echo "checking how to get filesystem space usage" 1>&6
-echo "configure:4648: checking how to get filesystem space usage" >&5
+echo "configure:4650: checking how to get filesystem space usage" >&5
 space=no
 
 # Perform only the link test since it seems there are no variants of the
@@ -4656,12 +4658,12 @@ space=no
 if test $space = no; then
 # SVR4
 echo $ac_n "checking statvfs function (SVR4)""... $ac_c" 1>&6
-echo "configure:4660: checking statvfs function (SVR4)" >&5
+echo "configure:4662: checking statvfs function (SVR4)" >&5
 if eval "test \"`echo '$''{'fu_cv_sys_stat_statvfs'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 4665 "configure"
+#line 4667 "configure"
 #include "confdefs.h"
 #include <sys/types.h>
 #include <sys/statvfs.h>
@@ -4669,7 +4671,7 @@ int main() {
 struct statvfs fsd; statvfs (0, &fsd);
 ; return 0; }
 EOF
-if { (eval echo configure:4673: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:4675: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   fu_cv_sys_stat_statvfs=yes
 else
@@ -4694,7 +4696,7 @@ fi
 if test $space = no; then
 # DEC Alpha running OSF/1
 echo $ac_n "checking for 3-argument statfs function (DEC OSF/1)""... $ac_c" 1>&6
-echo "configure:4698: checking for 3-argument statfs function (DEC OSF/1)" >&5
+echo "configure:4700: checking for 3-argument statfs function (DEC OSF/1)" >&5
 if eval "test \"`echo '$''{'fu_cv_sys_stat_statfs3_osf1'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -4702,7 +4704,7 @@ else
   fu_cv_sys_stat_statfs3_osf1=no
 else
   cat > conftest.$ac_ext <<EOF
-#line 4706 "configure"
+#line 4708 "configure"
 #include "confdefs.h"
 
 #include <sys/param.h>
@@ -4715,7 +4717,7 @@ fsd.f_fsize = 0;
 exit (statfs (".", &fsd, sizeof (struct statfs)));
 }
 EOF
-if { (eval echo configure:4719: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
+if { (eval echo configure:4721: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
 then
   fu_cv_sys_stat_statfs3_osf1=yes
 else
@@ -4742,7 +4744,7 @@ fi
 if test $space = no; then
 # AIX
 echo $ac_n "checking for two-argument statfs with statfs.bsize member (AIX, 4.3BSD)""... $ac_c" 1>&6
-echo "configure:4746: checking for two-argument statfs with statfs.bsize member (AIX, 4.3BSD)" >&5
+echo "configure:4748: checking for two-argument statfs with statfs.bsize member (AIX, 4.3BSD)" >&5
 if eval "test \"`echo '$''{'fu_cv_sys_stat_statfs2_bsize'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -4750,7 +4752,7 @@ else
   fu_cv_sys_stat_statfs2_bsize=no
 else
   cat > conftest.$ac_ext <<EOF
-#line 4754 "configure"
+#line 4756 "configure"
 #include "confdefs.h"
 
 #ifdef HAVE_SYS_PARAM_H
@@ -4769,7 +4771,7 @@ fsd.f_bsize = 0;
 exit (statfs (".", &fsd));
 }
 EOF
-if { (eval echo configure:4773: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
+if { (eval echo configure:4775: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
 then
   fu_cv_sys_stat_statfs2_bsize=yes
 else
@@ -4796,7 +4798,7 @@ fi
 if test $space = no; then
 # SVR3
 echo $ac_n "checking for four-argument statfs (AIX-3.2.5, SVR3)""... $ac_c" 1>&6
-echo "configure:4800: checking for four-argument statfs (AIX-3.2.5, SVR3)" >&5
+echo "configure:4802: checking for four-argument statfs (AIX-3.2.5, SVR3)" >&5
 if eval "test \"`echo '$''{'fu_cv_sys_stat_statfs4'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -4804,7 +4806,7 @@ else
   fu_cv_sys_stat_statfs4=no
 else
   cat > conftest.$ac_ext <<EOF
-#line 4808 "configure"
+#line 4810 "configure"
 #include "confdefs.h"
 #include <sys/types.h>
 #include <sys/statfs.h>
@@ -4814,7 +4816,7 @@ struct statfs fsd;
 exit (statfs (".", &fsd, sizeof fsd, 0));
 }
 EOF
-if { (eval echo configure:4818: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
+if { (eval echo configure:4820: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
 then
   fu_cv_sys_stat_statfs4=yes
 else
@@ -4841,7 +4843,7 @@ fi
 if test $space = no; then
 # 4.4BSD and NetBSD
 echo $ac_n "checking for two-argument statfs with statfs.fsize member (4.4BSD and NetBSD)""... $ac_c" 1>&6
-echo "configure:4845: checking for two-argument statfs with statfs.fsize member (4.4BSD and NetBSD)" >&5
+echo "configure:4847: checking for two-argument statfs with statfs.fsize member (4.4BSD and NetBSD)" >&5
 if eval "test \"`echo '$''{'fu_cv_sys_stat_statfs2_fsize'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -4849,7 +4851,7 @@ else
   fu_cv_sys_stat_statfs2_fsize=no
 else
   cat > conftest.$ac_ext <<EOF
-#line 4853 "configure"
+#line 4855 "configure"
 #include "confdefs.h"
 #include <sys/types.h>
 #ifdef HAVE_SYS_PARAM_H
@@ -4865,7 +4867,7 @@ fsd.f_fsize = 0;
 exit (statfs (".", &fsd));
 }
 EOF
-if { (eval echo configure:4869: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
+if { (eval echo configure:4871: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
 then
   fu_cv_sys_stat_statfs2_fsize=yes
 else
@@ -4892,7 +4894,7 @@ fi
 if test $space = no; then
 # Ultrix
 echo $ac_n "checking for two-argument statfs with struct fs_data (Ultrix)""... $ac_c" 1>&6
-echo "configure:4896: checking for two-argument statfs with struct fs_data (Ultrix)" >&5
+echo "configure:4898: checking for two-argument statfs with struct fs_data (Ultrix)" >&5
 if eval "test \"`echo '$''{'fu_cv_sys_stat_fs_data'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -4900,7 +4902,7 @@ else
   fu_cv_sys_stat_fs_data=no
 else
   cat > conftest.$ac_ext <<EOF
-#line 4904 "configure"
+#line 4906 "configure"
 #include "confdefs.h"
 #include <sys/types.h>
 #ifdef HAVE_SYS_PARAM_H
@@ -4920,7 +4922,7 @@ struct fs_data fsd;
 exit (statfs (".", &fsd) != 1);
 }
 EOF
-if { (eval echo configure:4924: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
+if { (eval echo configure:4926: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
 then
   fu_cv_sys_stat_fs_data=yes
 else
@@ -4947,12 +4949,12 @@ fi
 if test $space = no; then
 # SVR2
 cat > conftest.$ac_ext <<EOF
-#line 4951 "configure"
+#line 4953 "configure"
 #include "confdefs.h"
 #include <sys/filsys.h>
 EOF
 ac_try="$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out"
-{ (eval echo configure:4956: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
+{ (eval echo configure:4958: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
 ac_err=`grep -v '^ *+' conftest.out | grep -v "^conftest.${ac_ext}\$"`
 if test -z "$ac_err"; then
   rm -rf conftest*
@@ -4977,12 +4979,12 @@ fi
 for ac_func in ftruncate
 do
 echo $ac_n "checking for $ac_func""... $ac_c" 1>&6
-echo "configure:4981: checking for $ac_func" >&5
+echo "configure:4983: checking for $ac_func" >&5
 if eval "test \"`echo '$''{'ac_cv_func_$ac_func'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 4986 "configure"
+#line 4988 "configure"
 #include "confdefs.h"
 /* System header to define __stub macros and hopefully few prototypes,
     which can conflict with char $ac_func(); below.  */
@@ -5005,7 +5007,7 @@ $ac_func();
 
 ; return 0; }
 EOF
-if { (eval echo configure:5009: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:5011: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_func_$ac_func=yes"
 else
@@ -5033,12 +5035,12 @@ done
 
 if test "$ftruncate_missing" = yes; then
 echo $ac_n "checking fcntl emulation of ftruncate""... $ac_c" 1>&6
-echo "configure:5037: checking fcntl emulation of ftruncate" >&5
+echo "configure:5039: checking fcntl emulation of ftruncate" >&5
 if eval "test \"`echo '$''{'fu_cv_sys_ftruncate_emulation'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 5042 "configure"
+#line 5044 "configure"
 #include "confdefs.h"
 
 #include <sys/types.h>
@@ -5051,7 +5053,7 @@ chsize();
 
 ; return 0; }
 EOF
-if { (eval echo configure:5055: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:5057: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   fu_cv_sys_ftruncate_emulation=yes
 else
@@ -5079,12 +5081,12 @@ esac
 # If <sys/vfs.h> exists and struct statfs has a member named f_spare,
 # enable the work-around code in fsusage.c.
 echo $ac_n "checking for statfs that truncates block counts""... $ac_c" 1>&6
-echo "configure:5083: checking for statfs that truncates block counts" >&5
+echo "configure:5085: checking for statfs that truncates block counts" >&5
 if eval "test \"`echo '$''{'fu_cv_sys_truncating_statfs'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 5088 "configure"
+#line 5090 "configure"
 #include "confdefs.h"
 
 #if !defined(sun) && !defined(__sun)
@@ -5096,7 +5098,7 @@ int main() {
 struct statfs t; long c = *(t.f_spare);
 ; return 0; }
 EOF
-if { (eval echo configure:5100: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
+if { (eval echo configure:5102: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
   rm -rf conftest*
   fu_cv_sys_truncating_statfs=yes
 else
@@ -5117,7 +5119,7 @@ fi
 echo "$ac_t""$fu_cv_sys_truncating_statfs" 1>&6
 
 echo "checking for AFS" 1>&6
-echo "configure:5121: checking for AFS" >&5
+echo "configure:5123: checking for AFS" >&5
 test -d /afs && cat >> confdefs.h <<\EOF
 #define AFS 1
 EOF
@@ -5129,9 +5131,9 @@ if [ $target = "p.os" ]; then
     HAVE_POS=yes
 else
   echo $ac_n "checking for pOS""... $ac_c" 1>&6
-echo "configure:5133: checking for pOS" >&5
+echo "configure:5135: checking for pOS" >&5
   cat > conftest.$ac_ext <<EOF
-#line 5135 "configure"
+#line 5137 "configure"
 #include "confdefs.h"
 #ifdef __POS__
     yes
@@ -5168,16 +5170,16 @@ if [ "x$HAVE_NCURSES_LIB" = "xyes" ]; th
   else
     if [ "x$ac_cv_header_ncurses_h" = "xno" ]; then
       echo $ac_n "checking for attr_t in curses.h""... $ac_c" 1>&6
-echo "configure:5172: checking for attr_t in curses.h" >&5
+echo "configure:5174: checking for attr_t in curses.h" >&5
       cat > conftest.$ac_ext <<EOF
-#line 5174 "configure"
+#line 5176 "configure"
 #include "confdefs.h"
 #include <curses.h>
 int main() {
 { attr_t a; a = A_NORMAL; }
 ; return 0; }
 EOF
-if { (eval echo configure:5181: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
+if { (eval echo configure:5183: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
   rm -rf conftest*
   echo "$ac_t""yes" 1>&6
 else
@@ -5194,16 +5196,16 @@ fi
 rm -f conftest*
     else
       echo $ac_n "checking for attr_t in ncurses.h""... $ac_c" 1>&6
-echo "configure:5198: checking for attr_t in ncurses.h" >&5
+echo "configure:5200: checking for attr_t in ncurses.h" >&5
       cat > conftest.$ac_ext <<EOF
-#line 5200 "configure"
+#line 5202 "configure"
 #include "confdefs.h"
 #include <ncurses.h>
 int main() {
 { attr_t a; a = A_NORMAL; }
 ; return 0; }
 EOF
-if { (eval echo configure:5207: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
+if { (eval echo configure:5209: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
   rm -rf conftest*
   echo "$ac_t""yes" 1>&6
 else
@@ -5223,12 +5225,12 @@ rm -f conftest*
 fi
 
 echo $ac_n "checking for pthread library""... $ac_c" 1>&6
-echo "configure:5227: checking for pthread library" >&5
+echo "configure:5229: checking for pthread library" >&5
 TMP_SAVE_CFLAGS=$CFLAGS
 TMP_SAVE_LIBS=$LIBS
 LIBS="$LIBS -lpthread"
 cat > conftest.$ac_ext <<EOF
-#line 5232 "configure"
+#line 5234 "configure"
 #include "confdefs.h"
 
 #include "confdefs.h"
@@ -5242,7 +5244,7 @@ pthread_exit (0);
 
 ; return 0; }
 EOF
-if { (eval echo configure:5246: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:5248: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   HAVE_PTHREAD_LIB=yes
 echo "$ac_t""yes" 1>&6
@@ -5258,13 +5260,13 @@ CFLAGS=$TMP_SAVE_CFLAGS
 LIBS=$TMP_SAVE_LIBS
 
 echo $ac_n "checking for DirectX""... $ac_c" 1>&6
-echo "configure:5262: checking for DirectX" >&5
+echo "configure:5264: checking for DirectX" >&5
 TMP_SAVE_CFLAGS=$CFLAGS
 TMP_SAVE_LIBS=$LIBS
 CFLAGS="$CFLAGS $X_CFLAGS"
 LIBS="$LIBS -lddraw"
 cat > conftest.$ac_ext <<EOF
-#line 5268 "configure"
+#line 5270 "configure"
 #include "confdefs.h"
 
 #include "confdefs.h"
@@ -5280,7 +5282,7 @@ IDirectDraw_CreateSurface(lpDD, 0, 0, 0)
 
 ; return 0; }
 EOF
-if { (eval echo configure:5284: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:5286: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   HAVE_DIRECTX=yes
 echo "$ac_t""yes" 1>&6
@@ -5301,6 +5303,7 @@ WANT_ASCIIART=dunno
 WANT_UI=dunno
 WANT_NCURSES_UI=no
 WANT_DGA=no
+WANT_JIT=no
 WANT_VIDMODE=no
 
 # Check whether --enable-profiling or --disable-profiling was given.
@@ -5357,6 +5360,12 @@ if test "${enable_ui+set}" = set; then
   WANT_UI=$enableval
 fi
 
+# Check whether --enable-jit or --disable-jit was given.
+if test "${enable_jit+set}" = set; then
+  enableval="$enable_jit"
+  WANT_JIT=$enableval
+fi
+
 # Check whether --with-hostcc or --without-hostcc was given.
 if test "${with_hostcc+set}" = set; then
   withval="$with_hostcc"
@@ -5443,7 +5452,7 @@ if [ "x$WANT_DGA" = "xyes" ]; then
   TMP_SAVE_LIBS=$LIBS
   LIBS="$X_LIBS $LIBS"
   echo $ac_n "checking for XF86DGAQueryExtension in -lXxf86dga""... $ac_c" 1>&6
-echo "configure:5447: checking for XF86DGAQueryExtension in -lXxf86dga" >&5
+echo "configure:5456: checking for XF86DGAQueryExtension in -lXxf86dga" >&5
 ac_lib_var=`echo Xxf86dga'_'XF86DGAQueryExtension | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
@@ -5451,7 +5460,7 @@ else
   ac_save_LIBS="$LIBS"
 LIBS="-lXxf86dga  $X_PRE_LIBS -lXext -lX11 $X_EXTRA_LIBS  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 5455 "configure"
+#line 5464 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -5462,7 +5471,7 @@ int main() {
 XF86DGAQueryExtension()
 ; return 0; }
 EOF
-if { (eval echo configure:5466: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:5475: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -5495,7 +5504,7 @@ if [ "x$WANT_VIDMODE" = "xyes" ]; then
   TMP_SAVE_LIBS=$LIBS
   LIBS="$X_LIBS $LIBS"
   echo $ac_n "checking for XF86VidModeQueryExtension in -lXxf86vm""... $ac_c" 1>&6
-echo "configure:5499: checking for XF86VidModeQueryExtension in -lXxf86vm" >&5
+echo "configure:5508: checking for XF86VidModeQueryExtension in -lXxf86vm" >&5
 ac_lib_var=`echo Xxf86vm'_'XF86VidModeQueryExtension | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
@@ -5503,7 +5512,7 @@ else
   ac_save_LIBS="$LIBS"
 LIBS="-lXxf86vm  $X_PRE_LIBS -lXext -lX11 $X_EXTRA_LIBS  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 5507 "configure"
+#line 5516 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -5514,7 +5523,7 @@ int main() {
 XF86VidModeQueryExtension()
 ; return 0; }
 EOF
-if { (eval echo configure:5518: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:5527: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -5584,7 +5593,7 @@ fi
   # Extract the first word of "gtk-config", so it can be a program name with args.
 set dummy gtk-config; ac_word=$2
 echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
-echo "configure:5588: checking for $ac_word" >&5
+echo "configure:5597: checking for $ac_word" >&5
 if eval "test \"`echo '$''{'ac_cv_path_GTK_CONFIG'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -5619,7 +5628,7 @@ fi
 
   min_gtk_version=0.99.7
   echo $ac_n "checking for GTK - version >= $min_gtk_version""... $ac_c" 1>&6
-echo "configure:5623: checking for GTK - version >= $min_gtk_version" >&5
+echo "configure:5632: checking for GTK - version >= $min_gtk_version" >&5
   no_gtk=""
   if test "$GTK_CONFIG" = "no" ; then
     no_gtk=yes
@@ -5642,7 +5651,7 @@ echo "configure:5623: checking for GTK -
   echo $ac_n "cross compiling; assumed OK... $ac_c"
 else
   cat > conftest.$ac_ext <<EOF
-#line 5646 "configure"
+#line 5655 "configure"
 #include "confdefs.h"
 
 #include <gtk/gtk.h>
@@ -5705,7 +5714,7 @@ main ()
 }
 
 EOF
-if { (eval echo configure:5709: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
+if { (eval echo configure:5718: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
 then
   :
 else
@@ -5739,7 +5748,7 @@ fi
           CFLAGS="$CFLAGS $GTK_CFLAGS"
           LIBS="$LIBS $GTK_LIBS"
           cat > conftest.$ac_ext <<EOF
-#line 5743 "configure"
+#line 5752 "configure"
 #include "confdefs.h"
 
 #include <gtk/gtk.h>
@@ -5749,7 +5758,7 @@ int main() {
  return ((gtk_major_version) || (gtk_minor_version) || (gtk_micro_version)); 
 ; return 0; }
 EOF
-if { (eval echo configure:5753: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:5762: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
    echo "*** The test program compiled, but did not run. This usually means"
           echo "*** that the run-time linker is not finding GTK or finding the wrong"
@@ -5792,13 +5801,13 @@ rm -f conftest*
 SHM_SUPPORT_LINKS=0
 if [ "x$no_x" != "xyes" -a "x$ac_cv_header_sys_ipc_h" = "xyes" -a "x$ac_cv_header_sys_shm_h" = "xyes" ]; then
   echo $ac_n "checking whether the X11 MIT-SHM extension can be compiled in""... $ac_c" 1>&6
-echo "configure:5796: checking whether the X11 MIT-SHM extension can be compiled in" >&5
+echo "configure:5805: checking whether the X11 MIT-SHM extension can be compiled in" >&5
   TMP_SAVE_CFLAGS=$CFLAGS
   TMP_SAVE_LIBS=$LIBS
   CFLAGS="$CFLAGS $X_CFLAGS"
   LIBS="$X_LIBS $LIBS $X_PRE_LIBS -lX11 -lXext $X_EXTRA_LIBS"
   cat > conftest.$ac_ext <<EOF
-#line 5802 "configure"
+#line 5811 "configure"
 #include "confdefs.h"
 
 #include "confdefs.h"
@@ -5822,7 +5831,7 @@ shmctl(shminfo.shmid, IPC_RMID, 0);
 
 ; return 0; }
 EOF
-if { (eval echo configure:5826: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:5835: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   SHM_SUPPORT_LINKS=1
 echo "$ac_t""yes" 1>&6
@@ -5842,7 +5851,7 @@ MATHLIB=-lm
 DEBUGOBJS="debug.o"
 
 echo $ac_n "checking which target to use""... $ac_c" 1>&6
-echo "configure:5846: checking which target to use" >&5
+echo "configure:5855: checking which target to use" >&5
 
 if [ "x$WANT_SDLGFX" = "xyes" ]; then
   echo "$ac_t""SDL" 1>&6
@@ -5973,14 +5982,14 @@ if [ "x$WANT_UI" != "xno" ]; then
     if [ "x$no_gtk" = "xyes" ]; then
       echo "Did not find gtk+, disabling user interface"
       GTK_CFLAGS=
-      TK_LIBS=
+      GUIOBJS=nogui.o
       if [ "x$WANT_UI" = "xyes" ]; then
         NR_ERRORS=`expr $NR_ERRORS + 1`
       fi
     else
       echo "Using gtk+ GUI."
       NEED_THREAD_SUPPORT=yes
-      DDITIONAL_CFLAGS="$ADDITIONAL_CFLAGS -DUSING_GTK_GUI"
+      ADDITIONAL_CFLAGS="$ADDITIONAL_CFLAGS -DUSING_GTK_GUI"
       GUIOBJS=gtkui.o
     fi
   else 
@@ -5998,6 +6007,12 @@ else
   GUIOBJS=nogui.o
 fi
 
+JITOBJS=""
+if [ "x$WANT_JIT" = "xyes" ]; then
+  JITOBJS="compstbl.o compemu.o compemu_support.o compemu_fpp.o cpustbl_nf.o cpufast_nf.o"
+  ADDITIONAL_CFLAGS="$ADDITIONAL_CFLAGS -DJIT -DNATMEM_OFFSET=0x50000000"
+fi
+
 GFXOBJS="$GFXOBJS $GUIOBJS"
  
 
@@ -6025,9 +6040,9 @@ ASMOBJS=
 CPUOBJS=cpuemu.o
 
 echo $ac_n "checking for GCC 2.7 or higher""... $ac_c" 1>&6
-echo "configure:6029: checking for GCC 2.7 or higher" >&5
+echo "configure:6044: checking for GCC 2.7 or higher" >&5
 cat > conftest.$ac_ext <<EOF
-#line 6031 "configure"
+#line 6046 "configure"
 #include "confdefs.h"
 #if __GNUC__ - 1 > 1 || __GNUC_MINOR__ - 1 > 5
   yes
@@ -6058,9 +6073,9 @@ fi
 
 if [ "x$ac_cv_header_features_h" = "xyes" ]; then
   echo $ac_n "checking for glibc-2.0 or higher""... $ac_c" 1>&6
-echo "configure:6062: checking for glibc-2.0 or higher" >&5
+echo "configure:6077: checking for glibc-2.0 or higher" >&5
   cat > conftest.$ac_ext <<EOF
-#line 6064 "configure"
+#line 6079 "configure"
 #include "confdefs.h"
 #include <features.h>
 #if __GLIBC__ - 1 >= 1
@@ -6107,9 +6122,9 @@ else
 fi
 
 echo $ac_n "checking for x86 target CPU""... $ac_c" 1>&6
-echo "configure:6111: checking for x86 target CPU" >&5
+echo "configure:6126: checking for x86 target CPU" >&5
 cat > conftest.$ac_ext <<EOF
-#line 6113 "configure"
+#line 6128 "configure"
 #include "confdefs.h"
 
 #ifdef __i386__
@@ -6129,9 +6144,9 @@ rm -f conftest*
 
 
 echo $ac_n "checking for m68k target CPU""... $ac_c" 1>&6
-echo "configure:6133: checking for m68k target CPU" >&5
+echo "configure:6148: checking for m68k target CPU" >&5
 cat > conftest.$ac_ext <<EOF
-#line 6135 "configure"
+#line 6150 "configure"
 #include "confdefs.h"
 
 #ifdef __m68k__
@@ -6151,9 +6166,9 @@ rm -f conftest*
 
 
 echo $ac_n "checking for ppc target CPU""... $ac_c" 1>&6
-echo "configure:6155: checking for ppc target CPU" >&5
+echo "configure:6170: checking for ppc target CPU" >&5
 cat > conftest.$ac_ext <<EOF
-#line 6157 "configure"
+#line 6172 "configure"
 #include "confdefs.h"
 
 #ifdef __powerpc__
@@ -6182,7 +6197,7 @@ fi
 
 
 echo $ac_n "checking whether assembler symbols need an underscore""... $ac_c" 1>&6
-echo "configure:6186: checking whether assembler symbols need an underscore" >&5
+echo "configure:6201: checking whether assembler symbols need an underscore" >&5
 cat >conftest1.S << EOF
 	.text
 	.globl _symbol
@@ -6219,14 +6234,14 @@ if [ "x$HAVEGCC27" = "xyes" -a "x$HAVEI3
   SAVECFLAGS=$CFLAGS
   CFLAGS="$CFLAGS -mno-schedule-prologue"
   cat > conftest.$ac_ext <<EOF
-#line 6223 "configure"
+#line 6238 "configure"
 #include "confdefs.h"
 
 int main() {
 int main(){return 0;}
 ; return 0; }
 EOF
-if { (eval echo configure:6230: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
+if { (eval echo configure:6245: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
   rm -rf conftest*
   NO_SCHED_CFLAGS="-mno-schedule-prologue"
 else
@@ -6241,14 +6256,14 @@ if [ "x$HAVEGCC27" = "xyes" -a "x$HAVEI3
   SAVECFLAGS=$CFLAGS
   CFLAGS="$CFLAGS -mpreferred-stack-boundary=2"
   cat > conftest.$ac_ext <<EOF
-#line 6245 "configure"
+#line 6260 "configure"
 #include "confdefs.h"
 
 int main() {
 int main(){return 0;}
 ; return 0; }
 EOF
-if { (eval echo configure:6252: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
+if { (eval echo configure:6267: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
   rm -rf conftest*
   SAVECFLAGS=$CFLAGS
 else
@@ -6265,14 +6280,14 @@ if [ "x$HAVEGCC27" = "xyes" -a "x$HAVEI3
   CFLAGS="$CFLAGS -fno-exceptions"
   NOEXCEPTIONS=no
   cat > conftest.$ac_ext <<EOF
-#line 6269 "configure"
+#line 6284 "configure"
 #include "confdefs.h"
 
 int main() {
 int main(){return 0;}
 ; return 0; }
 EOF
-if { (eval echo configure:6276: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
+if { (eval echo configure:6291: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
   rm -rf conftest*
   NOEXCEPTIONS=yes
 else
@@ -6383,9 +6398,9 @@ fi
 HAVE_USS_SOUND=no
 if [ "x$ac_cv_header_sys_soundcard_h" = "xyes" -o "x$ac_cv_header_machine_soundcard_h" = "xyes" ]; then
     echo $ac_n "checking whether sys/soundcard.h or machine/soundcard.h works""... $ac_c" 1>&6
-echo "configure:6387: checking whether sys/soundcard.h or machine/soundcard.h works" >&5
+echo "configure:6402: checking whether sys/soundcard.h or machine/soundcard.h works" >&5
   cat > conftest.$ac_ext <<EOF
-#line 6389 "configure"
+#line 6404 "configure"
 #include "confdefs.h"
 
 #include "confdefs.h"
@@ -6400,7 +6415,7 @@ int main() {
 int soundfd; ioctl (soundfd, SNDCTL_DSP_GETFMTS, 0);
 ; return 0; }
 EOF
-if { (eval echo configure:6404: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
+if { (eval echo configure:6419: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
   rm -rf conftest*
   echo "$ac_t""yes" 1>&6
 HAVE_USS_SOUND=yes
@@ -6418,7 +6433,7 @@ if [ "x$ac_cv_header_dmedia_audio.h" = "
 fi
 
 echo $ac_n "checking which sound system to use""... $ac_c" 1>&6
-echo "configure:6422: checking which sound system to use" >&5
+echo "configure:6437: checking which sound system to use" >&5
 # Check whether --enable-file-sound or --disable-file-sound was given.
 if test "${enable_file_sound+set}" = set; then
   enableval="$enable_file_sound"
@@ -6539,13 +6554,13 @@ fi
 
 if [ "x$USE_SCSI_DEVICE" = "xyes" ]; then
   echo $ac_n "checking "availability of libscg headers and lib"""... $ac_c" 1>&6
-echo "configure:6543: checking "availability of libscg headers and lib"" >&5
+echo "configure:6558: checking "availability of libscg headers and lib"" >&5
   OLDLIBS="$LIBS"
   OLDCFLAGS="$CFLAGS"
   CFLAGS="$CFLAGS -Isrc/include"
   LIBS="-Lsrc $LIBS -lscg -lschily"
   cat > conftest.$ac_ext <<EOF
-#line 6549 "configure"
+#line 6564 "configure"
 #include "confdefs.h"
 typedef int BOOL;
 #include "scg/scgcmd.h"
@@ -6555,7 +6570,7 @@ int main() {
 {SCSI *scgp = open_scsi ((void *)0, (void *)0, 0, 1, 1);}
 ; return 0; }
 EOF
-if { (eval echo configure:6559: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:6574: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   
     echo "$ac_t""available" 1>&6
@@ -6579,16 +6594,16 @@ fi
 
 if [ "x$WANT_SDL" = "xyes" ]; then
     OD_JOYSTICK=sdl-joystick.c
-else if [ "x$HAVE_MACHINE_JOYSTICK_H" = "xyes" ]; then
+else if [ "x$ac_cv_header_machine_joystick_h" = "xyes" ]; then
     cat > conftest.$ac_ext <<EOF
-#line 6585 "configure"
+#line 6600 "configure"
 #include "confdefs.h"
 #include <machine/joystick.h>
 int main() {
 { struct joystick a; }
 ; return 0; }
 EOF
-if { (eval echo configure:6592: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
+if { (eval echo configure:6607: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
   rm -rf conftest*
   OD_JOYSTICK=od-linux/joystick.c
 else
@@ -6616,13 +6631,13 @@ rm -f src/scsi-support.c
 
 if [ "x$TARGET" = "xamigaos" -o "x$TARGET" = "xp_os" ]; then
     echo $ac_n "checking which CPU to use""... $ac_c" 1>&6
-echo "configure:6620: checking which CPU to use" >&5
+echo "configure:6635: checking which CPU to use" >&5
   cpu=`cpu | cut -d' ' -f2`
   echo "$ac_t""$cpu" 1>&6
   CFLAGS="$CFLAGS -m$cpu"
 
     echo $ac_n "checking which FPU to use""... $ac_c" 1>&6
-echo "configure:6626: checking which FPU to use" >&5
+echo "configure:6641: checking which FPU to use" >&5
   fpu=`cpu | cut -d' ' -f3 | grep '^688812$'`
   if [ "x$fpu" != "x" ]; then
         echo "$ac_t""68881" 1>&6
@@ -6650,6 +6665,8 @@ fi
 
 
 
+
+
 trap '' 1 2 15
 cat > confcache <<\EOF
 # This file is a shell script that caches the results of configure
@@ -6804,6 +6821,8 @@ s%@NO_SCHED_CFLAGS@%$NO_SCHED_CFLAGS%g
 s%@LIBRARIES@%$LIBRARIES%g
 s%@TARGET@%$TARGET%g
 s%@GFXOBJS@%$GFXOBJS%g
+s%@JITOBJS@%$JITOBJS%g
+s%@JIT_CFLAGS@%$JIT_CFLAGS%g
 s%@RESOBJS@%$RESOBJS%g
 s%@ASMOBJS@%$ASMOBJS%g
 s%@SCSIOBJS@%$SCSIOBJS%g
Index: configure.in
===================================================================
RCS file: /usr/local/cvs/uae/configure.in,v
retrieving revision 1.93
retrieving revision 1.93.2.1
diff -c -p -d -u -p -r1.93 -r1.93.2.1
--- configure.in	2002/02/04 13:23:29	1.93
+++ configure.in	2002/02/06 15:09:18	1.93.2.1
@@ -224,6 +224,7 @@ WANT_ASCIIART=dunno
 WANT_UI=dunno
 WANT_NCURSES_UI=no
 WANT_DGA=no
+WANT_JIT=no
 WANT_VIDMODE=no
 
 AC_ARG_ENABLE(profiling,[  --enable-profiling      Build a profiling (SLOW!) version],[DO_PROFILING=$enableval],[])
@@ -235,6 +236,7 @@ AC_ARG_WITH(asciiart,[  --with-asciiart 
 AC_ARG_ENABLE(dga,[  --enable-dga            X11 version: Use the DGA extension],[WANT_DGA=$enableval],[])
 AC_ARG_ENABLE(vidmode,[  --enable-vidmode        X11 version: Use the XF86VidMode extension],[WANT_VIDMODE=$enableval],[])
 AC_ARG_ENABLE(ui,[  --enable-ui             Use a user interface if possible (default on)],[WANT_UI=$enableval],[])
+AC_ARG_ENABLE(jit,[  --enable-jit            linux/X11 version: Use the JIT compiler],[WANT_JIT=$enableval],[])
 AC_ARG_WITH(hostcc,[  --with-hostcc=x         Use a x as compiler for the host system],[HOSTCC=$withval],[HOSTCC=$CC])
 
 dnl Some simple plausibility tests...
@@ -519,7 +521,7 @@ if [[ "x$WANT_UI" != "xno" ]]; then
     else
       echo "Using gtk+ GUI."
       NEED_THREAD_SUPPORT=yes
-      DDITIONAL_CFLAGS="$ADDITIONAL_CFLAGS -DUSING_GTK_GUI"
+      ADDITIONAL_CFLAGS="$ADDITIONAL_CFLAGS -DUSING_GTK_GUI"
       GUIOBJS=gtkui.o
     fi
   else 
@@ -537,6 +539,12 @@ else
   GUIOBJS=nogui.o
 fi
 
+JITOBJS=""
+if [[ "x$WANT_JIT" = "xyes" ]]; then
+  JITOBJS="compstbl.o compemu.o compemu_support.o compemu_fpp.o cpustbl_nf.o cpufast_nf.o"
+  ADDITIONAL_CFLAGS="$ADDITIONAL_CFLAGS -DJIT -DNATMEM_OFFSET=0x50000000"
+fi
+
 GFXOBJS="$GFXOBJS $GUIOBJS"
  
 dnl Find out some things about the system 
@@ -1023,6 +1031,7 @@ AC_SUBST(NO_SCHED_CFLAGS)
 AC_SUBST(LIBRARIES)
 AC_SUBST(TARGET)
 AC_SUBST(GFXOBJS)
+AC_SUBST(JITOBJS)
 AC_SUBST(RESOBJS)
 AC_SUBST(ASMOBJS)
 AC_SUBST(SCSIOBJS)
diff -c -p -d -u -p -r1.214 -r1.204.2.1
Index: src/Makefile.in
===================================================================
RCS file: /usr/local/cvs/uae/src/Makefile.in,v
retrieving revision 1.56
retrieving revision 1.56.2.2
diff -c -p -d -u -p -r1.56 -r1.56.2.2
--- src/Makefile.in	2001/11/19 12:34:18	1.56
+++ src/Makefile.in	2002/02/09 17:12:08	1.56.2.2
@@ -39,8 +39,8 @@ OBJS = main.o newcpu.o memory.o @CPUOBJS
        disk.o audio.o compiler.o uaelib.o drawing.o picasso96.o cpustbl.o \
        uaeexe.o bsdsocket.o missing.o sd-sound.o od-joy.o md-support.o \
        fsusage.o cfgfile.o native2amiga.o @FSDBOBJS@ fsdb.o identify.o \
-       savestate.o writelog.o @ASMOBJS@ @GFXOBJS@ @DEBUGOBJS@ @SCSIOBJS@
-
+       savestate.o writelog.o @ASMOBJS@ @GFXOBJS@ @DEBUGOBJS@ @SCSIOBJS@ \
+       @JITOBJS@
 
 all: $(TARGET)
 
@@ -80,6 +80,7 @@ clean:
 	-rm -f blit.h cpudefs.c
 	-rm -f cpuemu.c build68k cputmp.s cpufast*.s cpustbl.c cputbl.h
 	-rm -f blitfunc.c blitfunc.h blittable.c
+	-rm -f compemu.c compstbl.c comptbl.h
 
 halfclean:
 	-rm -f $(OBJS)
@@ -106,6 +107,8 @@ tools/cpuopti:
 	$(MAKE) -C tools cpuopti
 tools/gencpu: 
 	$(MAKE) -C tools gencpu
+tools/gencomp:
+	$(MAKE) -C tools gencomp
 
 custom.o: blit.h
 drawing.o: linetoscr.c
@@ -116,15 +119,38 @@ cpudefs.c: tools/build68k @top_srcdir@/s
 cpuemu.c: tools/gencpu
 	./tools/gencpu
 
+compemu.c: tools/gencomp
+	./tools/gencomp
+
 # gencpu also creates cpustbl.c and cputbl.h
 cpustbl.c: cpuemu.c
 cputbl.h: cpuemu.c
+compstbl.c: compemu.c
+comptbl.h: compemu.c
+compemu_support.o: compemu_optimizer.c compemu_raw_x86.c
 
 cpufast.s: cpuemu.c tools/cpuopti
 	$(CC) $(INCLUDES) -S $(INCDIRS) $(CFLAGS) $(X_CFLAGS) $(DEBUGFLAGS) $(NO_SCHED_CFLAGS) $< -o cputmp.s
 	./tools/cpuopti <cputmp.s >$@
 	rm cputmp.s
 
+cpufast_nf.s: cpuemu.c tools/cpuopti
+	$(CC) $(INCLUDES) -S $(INCDIRS) $(CFLAGS) $(X_CFLAGS) $(DEBUGFLAGS) $(NO_SCHED_CFLAGS) -DNOFLAGS $< -o cputmp_nf.s
+	./tools/cpuopti <cputmp_nf.s >$@
+	rm cputmp_nf.s
+
+cpuemu_nf.o: cpuemu.c ./tools/cpuopti
+	$(CC) $(INCLUDES) -c $(INCDIRS) $(CFLAGS) $(X_CFLAGS) $(DEBUGFLAGS) $(NO_SCHED_CFLAGS) -DNOFLAGS $< -o $@
+
+cpustbl_nf.o: cpustbl.c
+	$(CC) $(INCLUDES) -c $(INCDIRS) $(CFLAGS) $(X_CFLAGS) $(DEBUGFLAGS) $(NO_SCHED_CFLAGS) -DNOFLAGS cpustbl.c -o $@
+
+comptest: compemu_support.o compemu.o comptest.o readcpu.o missing.o cpudefs.o compstbl.o 
+	$(CC) -o compemu_support.o comptest compemu.o comptest.o readcpu.o \
+		missing.o cpudefs.o compstbl.o \
+		$(GFXLDFLAGS) $(LDFLAGS) $(DEBUGFLAGS) $(LIBRARIES) $(MATHLIB)
+
+
 console_missing.o: missing.c
 	$(CC) $(INCLUDES) -c $(INCDIRS) $(CFLAGS) $(X_CFLAGS) $(DEBUGFLAGS) $(CFLAGS_$@) $< -o $@
 
@@ -206,6 +232,39 @@ cpufast8.s: cpuemu.c cpuopti
 	./tools/cpuopti <cputmp8.s >$@
 	rm cputmp8.s
 
+cpufast1_nf.s: cpuemu.c cpuopti
+	$(CC) -DPART_1 $(INCLUDES) -S $(INCDIRS) $(CFLAGS) $(X_CFLAGS) $(DEBUGFLAGS) $(NO_SCHED_CFLAGS) -DNOFLAGS -g0 $< -o cputmp_nf1.s
+	./tools/cpuopti <cputmp_nf1.s >$@
+	rm cputmp_nf1.s
+cpufast2_nf.s: cpuemu.c cpuopti
+	$(CC) -DPART_2 $(INCLUDES) -S $(INCDIRS) $(CFLAGS) $(X_CFLAGS) $(DEBUGFLAGS) $(NO_SCHED_CFLAGS) -DNOFLAGS -g0 $< -o cputmp_nf2.s
+	./tools/cpuopti <cputmp_nf2.s >$@
+	rm cputmp_nf2.s
+cpufast3_nf.s: cpuemu.c cpuopti
+	$(CC) -DPART_3 $(INCLUDES) -S $(INCDIRS) $(CFLAGS) $(X_CFLAGS) $(DEBUGFLAGS) $(NO_SCHED_CFLAGS) -DNOFLAGS -g0 $< -o cputmp_nf3.s
+	./tools/cpuopti <cputmp_nf3.s >$@
+	rm cputmp_nf3.s
+cpufast4_nf.s: cpuemu.c cpuopti
+	$(CC) -DPART_4 $(INCLUDES) -S $(INCDIRS) $(CFLAGS) $(X_CFLAGS) $(DEBUGFLAGS) $(NO_SCHED_CFLAGS) -DNOFLAGS -g0 $< -o cputmp_nf4.s
+	./tools/cpuopti <cputmp_nf4.s >$@
+	rm cputmp_nf4.s
+cpufast5_nf.s: cpuemu.c cpuopti
+	$(CC) -DPART_5 $(INCLUDES) -S $(INCDIRS) $(CFLAGS) $(X_CFLAGS) $(DEBUGFLAGS) $(NO_SCHED_CFLAGS) -DNOFLAGS -g0 $< -o cputmp_nf5.s
+	./tools/cpuopti <cputmp_nf5.s >$@
+	rm cputmp_nf5.s
+cpufast6_nf.s: cpuemu.c cpuopti
+	$(CC) -DPART_6 $(INCLUDES) -S $(INCDIRS) $(CFLAGS) $(X_CFLAGS) $(DEBUGFLAGS) $(NO_SCHED_CFLAGS) -DNOFLAGS -g0 $< -o cputmp_nf6.s
+	./tools/cpuopti <cputmp_nf6.s >$@
+	rm cputmp_nf6.s
+cpufast7_nf.s: cpuemu.c cpuopti
+	$(CC) -DPART_7 $(INCLUDES) -S $(INCDIRS) $(CFLAGS) $(X_CFLAGS) $(DEBUGFLAGS) $(NO_SCHED_CFLAGS) -DNOFLAGS -g0 $< -o cputmp_nf7.s
+	./tools/cpuopti <cputmp_nf7.s >$@
+	rm cputmp_nf7.s
+cpufast8_nf.s: cpuemu.c cpuopti
+	$(CC) -DPART_8 $(INCLUDES) -S $(INCDIRS) $(CFLAGS) $(X_CFLAGS) $(DEBUGFLAGS) $(NO_SCHED_CFLAGS) -DNOFLAGS -g0 $< -o cputmp_nf8.s
+	./tools/cpuopti <cputmp_nf8.s >$@
+	rm cputmp_nf8.s
+
 cpuemu1.o: cpuemu.c
 	$(CC) -DPART_1 $(INCLUDES) -c $(INCDIRS) $(CFLAGS) $(X_CFLAGS) $(DEBUGFLAGS) $< -o $@
 cpuemu2.o: cpuemu.c
@@ -222,3 +281,22 @@ cpuemu7.o: cpuemu.c
 	$(CC) -DPART_7 $(INCLUDES) -c $(INCDIRS) $(CFLAGS) $(X_CFLAGS) $(DEBUGFLAGS) $< -o $@
 cpuemu8.o: cpuemu.c
 	$(CC) -DPART_8 $(INCLUDES) -c $(INCDIRS) $(CFLAGS) $(X_CFLAGS) $(DEBUGFLAGS) $< -o $@
+
+
+cpuemu1_nf.o: cpuemu.c
+	$(CC) -DPART_1 $(INCLUDES) -c $(INCDIRS) $(CFLAGS) $(X_CFLAGS) $(DEBUGFLAGS) -DNOFLAGS $< -o $@
+cpuemu2_nf.o: cpuemu.c
+	$(CC) -DPART_2 $(INCLUDES) -c $(INCDIRS) $(CFLAGS) $(X_CFLAGS) $(DEBUGFLAGS) -DNOFLAGS $< -o $@
+cpuemu3_nf.o: cpuemu.c
+	$(CC) -DPART_3 $(INCLUDES) -c $(INCDIRS) $(CFLAGS) $(X_CFLAGS) $(DEBUGFLAGS) -DNOFLAGS $< -o $@
+cpuemu4_nf.o: cpuemu.c
+	$(CC) -DPART_4 $(INCLUDES) -c $(INCDIRS) $(CFLAGS) $(X_CFLAGS) $(DEBUGFLAGS) -DNOFLAGS $< -o $@
+cpuemu5_nf.o: cpuemu.c
+	$(CC) -DPART_5 $(INCLUDES) -c $(INCDIRS) $(CFLAGS) $(X_CFLAGS) $(DEBUGFLAGS) -DNOFLAGS $< -o $@
+cpuemu6_nf.o: cpuemu.c
+	$(CC) -DPART_6 $(INCLUDES) -c $(INCDIRS) $(CFLAGS) $(X_CFLAGS) $(DEBUGFLAGS) -DNOFLAGS $< -o $@
+cpuemu7_nf.o: cpuemu.c
+	$(CC) -DPART_7 $(INCLUDES) -c $(INCDIRS) $(CFLAGS) $(X_CFLAGS) $(DEBUGFLAGS) -DNOFLAGS $< -o $@
+cpuemu8_nf.o: cpuemu.c
+	$(CC) -DPART_8 $(INCLUDES) -c $(INCDIRS) $(CFLAGS) $(X_CFLAGS) $(DEBUGFLAGS) -DNOFLAGS $< -o $@
+
Index: src/audio.c
===================================================================
RCS file: /usr/local/cvs/uae/src/audio.c,v
retrieving revision 1.32
retrieving revision 1.32.2.1
diff -c -p -d -u -p -r1.32 -r1.32.2.1
--- src/audio.c	2001/12/30 15:15:56	1.32
+++ src/audio.c	2002/02/06 15:09:18	1.32.2.1
@@ -15,11 +15,11 @@
 #include "options.h"
 #include "memory.h"
 #include "custom.h"
+#include "events.h"
 #include "newcpu.h"
 #include "autoconf.h"
 #include "gensound.h"
 #include "sounddep/sound.h"
-#include "events.h"
 #include "audio.h"
 #include "savestate.h"
 
Index: src/autoconf.c
===================================================================
RCS file: /usr/local/cvs/uae/src/autoconf.c,v
retrieving revision 1.36
retrieving revision 1.36.2.1
diff -c -p -d -u -p -r1.36 -r1.36.2.1
--- src/autoconf.c	2001/12/30 15:15:56	1.36
+++ src/autoconf.c	2002/02/06 15:09:18	1.36.2.1
@@ -15,6 +15,7 @@
 #include "uae.h"
 #include "memory.h"
 #include "custom.h"
+#include "events.h"
 #include "newcpu.h"
 #include "compiler.h"
 #include "autoconf.h"
@@ -285,7 +286,7 @@ void REGPARAM2 call_calltrap(int func)
     int has_retval = (trapmode[func] & TRAPFLAG_NO_RETVAL) == 0;
     int implicit_rts = (trapmode[func] & TRAPFLAG_DORET) != 0;
 
-    if (*trapstr[func] != 0 && trace_traps)
+    if (trapstr[func] && *trapstr[func] != 0 && trace_traps)
 	write_log ("TRAP: %s\n", trapstr[func]);
 
     /* For monitoring only? */
Index: src/blitter.c
===================================================================
RCS file: /usr/local/cvs/uae/src/blitter.c,v
retrieving revision 1.29
retrieving revision 1.28.2.2
diff -c -p -d -u -p -r1.29 -r1.28.2.2
--- src/blitter.c	2002/02/16 14:18:13	1.29
+++ src/blitter.c	2002/02/16 20:06:59	1.28.2.2
@@ -11,10 +11,10 @@
 
 #include "config.h"
 #include "options.h"
-#include "events.h"
 #include "uae.h"
 #include "memory.h"
 #include "custom.h"
+#include "events.h"
 #include "newcpu.h"
 #include "blitter.h"
 #include "blit.h"
Index: src/bsdsocket.c
===================================================================
RCS file: /usr/local/cvs/uae/src/bsdsocket.c,v
retrieving revision 1.3
retrieving revision 1.3.2.1
diff -c -p -d -u -p -r1.3 -r1.3.2.1
--- src/bsdsocket.c	2000/08/25 21:29:41	1.3
+++ src/bsdsocket.c	2002/02/06 15:09:18	1.3.2.1
@@ -18,6 +18,7 @@
 #include "options.h"
 #include "memory.h"
 #include "custom.h"
+#include "events.h"
 #include "newcpu.h"
 #include "autoconf.h"
 #include "bsdsocket.h"
Index: src/cfgfile.c
===================================================================
RCS file: /usr/local/cvs/uae/src/cfgfile.c,v
retrieving revision 1.26
retrieving revision 1.25.2.2
diff -c -p -d -u -p -r1.26 -r1.25.2.2
--- src/cfgfile.c	2002/02/16 14:29:42	1.26
+++ src/cfgfile.c	2002/02/16 20:06:59	1.25.2.2
@@ -17,7 +17,6 @@
 #include "threaddep/thread.h"
 #include "uae.h"
 #include "autoconf.h"
-#include "events.h"
 #include "custom.h"
 
 /* @@@ need to get rid of this... just cut part of the manual and print that
@@ -67,10 +66,22 @@ static struct cfg_lines opttable[] =
     {"sound_channels", "" },
     {"sound_min_buff", "" },
     {"sound_max_buff", "" },
+    {"comp_trustbyte", "How to access bytes in compiler (direct/indirect/indirectKS/afterPic" },
+    {"comp_trustword", "How to access words in compiler (direct/indirect/indirectKS/afterPic" },
+    {"comp_trustlong", "How to access longs in compiler (direct/indirect/indirectKS/afterPic" },
+    {"comp_nf", "Whether to optimize away flag generation where possible" },
+    {"comp_fpu", "Whether to provide JIT FPU emulation" },
+    {"compforcesettings", "Whether to force the JIT compiler settings" },
+    {"cachesize", "How many MB to use to buffer translated instructions"},
+    {"override_dga_address","Address from which to map the frame buffer (upper 16 bits) (DANGEROUS!)"},
+    {"avoid_cmov", "Set to yes on machines that lack the CMOV instruction" },
+    {"avoid_dga", "Set to yes if the use of DGA extension creates problems" },
+    {"avoid_vid", "Set to yes if the use of the Vidmode extension creates problems" },
     {"parallel_on_demand", "" },
     {"serial_on_demand", "" },
     {"joyport0", "" },
     {"joyport1", "" },
+    {"pci_devices", "List of PCI devices to make visible to the emulated Amiga" },
     {"kickstart_rom_file", "Kickstart ROM image, (C) Copyright Amiga, Inc." },
     {"kickstart_ext_rom_file", "Extended Kickstart ROM image, (C) Copyright Amiga, Inc." },
     {"kickstart_key_file", "Key-file for encrypted ROM images (from Cloanto's Amiga Forever)" },
@@ -104,6 +115,8 @@ static const char *stereomode2[] = { "m"
 static const char *stereomode3[] = { "1", "2", "3", 0 };
 static const char *interpolmode[] = { "none", "rh", "crux", 0 };
 static const char *collmode[] = { "none", "sprites", "playfields", "full", 0 };
+static const char *compmode[] = { "direct", "indirect", "indirectKS", "afterPic", 0 };
+static const char *flushmode[]   = { "soft", "hard", 0 };
 
 #define UNEXPANDED "$(FILE_PATH)"
 
@@ -185,6 +198,26 @@ void save_options (FILE *f, struct uae_p
     fprintf (f, "sound_pri_time=%d\n", p->sound_pri_time);
     fprintf (f, "sound_pri_cutoff=%d\n", p->sound_pri_cutoff);
 
+    fprintf (f, "comp_trustbyte=%s\n", compmode[p->comptrustbyte]);
+    fprintf (f, "comp_trustword=%s\n", compmode[p->comptrustword]);
+    fprintf (f, "comp_trustlong=%s\n", compmode[p->comptrustlong]);
+    fprintf (f, "comp_trustnaddr=%s\n", compmode[p->comptrustnaddr]);
+    fprintf (f, "comp_nf=%s\n", p->compnf ? "true" : "false");
+    fprintf (f, "comp_constjump=%s\n", p->comp_constjump ? "true" : "false");
+    fprintf (f, "comp_oldsegv=%s\n", p->comp_oldsegv ? "true" : "false");
+    
+    fprintf (f, "comp_flushmode=%s\n", flushmode[p->comp_hardflush]);
+    fprintf (f, "compforcesettings=%s\n", p->compforcesettings ? "true" : "false");
+    fprintf (f, "compfpu=%s\n", p->compfpu ? "true" : "false");
+    fprintf (f, "comp_midopt=%s\n", p->comp_midopt ? "true" : "false");
+    fprintf (f, "comp_lowopt=%s\n", p->comp_lowopt ? "true" : "false");
+    fprintf (f, "avoid_cmov=%s\n", p->avoid_cmov ? "true" : "false" );
+    fprintf (f, "avoid_dga=%s\n", p->avoid_dga ? "true" : "false" );
+    fprintf (f, "avoid_vid=%s\n", p->avoid_vid ? "true" : "false" );
+    fprintf (f, "cachesize=%d\n", p->cachesize);
+    if (p->override_dga_address)
+	fprintf (f, "override_dga_address=0x%08x\n", p->override_dga_address);
+
     fprintf (f, "joyport0=%s\n", portmode[p->jport0]);
     fprintf (f, "joyport1=%s\n", portmode[p->jport1]);
 
@@ -377,6 +410,16 @@ int cfgfile_parse_option (struct uae_pre
 	|| cfgfile_yesno (option, value, "autoconfig", &dummy)
 	|| cfgfile_yesno (option, value, "parallel_on_demand", &p->parallel_demand)
 	|| cfgfile_yesno (option, value, "serial_on_demand", &p->serial_demand)
+	|| cfgfile_yesno (option, value, "comp_nf", &p->compnf)
+	|| cfgfile_yesno (option, value, "comp_constjump", &p->comp_constjump)
+	|| cfgfile_yesno (option, value, "comp_oldsegv", &p->comp_oldsegv)
+	|| cfgfile_yesno (option, value, "compforcesettings", &p->compforcesettings)
+	|| cfgfile_yesno (option, value, "compfpu", &p->compfpu)
+	|| cfgfile_yesno (option, value, "comp_midopt", &p->comp_midopt)
+	|| cfgfile_yesno (option, value, "comp_lowopt", &p->comp_lowopt)
+	|| cfgfile_yesno (option, value, "avoid_cmov", &p->avoid_cmov)
+	|| cfgfile_yesno (option, value, "avoid_dga", &p->avoid_dga)
+	|| cfgfile_yesno (option, value, "avoid_vid", &p->avoid_vid)
 	|| cfgfile_yesno (option, value, "log_illegal_mem", &p->illegal_mem))
 	return 1;
     if (cfgfile_intval (option, value, "accuracy", &p->emul_accuracy, 1)
@@ -386,6 +429,8 @@ int cfgfile_parse_option (struct uae_pre
 	|| cfgfile_intval (option, value, "sound_bits", &p->sound_bits, 1)
 	|| cfgfile_intval (option, value, "sound_pri_cutoff", &p->sound_pri_cutoff, 1)
 	|| cfgfile_intval (option, value, "sound_pri_time", &p->sound_pri_time, 1)
+	|| cfgfile_intval (option, value, "cachesize", &p->cachesize, 1)
+	|| cfgfile_intval (option, value, "override_dga_address", &p->override_dga_address, 1)
 	|| cfgfile_intval (option, value, "gfx_framerate", &p->gfx_framerate, 1)
 	|| cfgfile_intval (option, value, "gfx_width", &p->gfx_width, 1)
 	|| cfgfile_intval (option, value, "gfx_height", &p->gfx_height, 1)
@@ -399,6 +444,10 @@ int cfgfile_parse_option (struct uae_pre
 	return 1;
     if (cfgfile_strval (option, value, "sound_output", &p->produce_sound, soundmode, 0)
 	|| cfgfile_strval (option, value, "sound_interpol", &p->sound_interpol, interpolmode, 0)
+	||cfgfile_strval (option, value, "comp_trustbyte", &p->comptrustbyte, compmode, 0)
+	||cfgfile_strval (option, value, "comp_trustword", &p->comptrustword, compmode, 0)
+	||cfgfile_strval (option, value, "comp_trustlong", &p->comptrustlong, compmode, 0)
+	||cfgfile_strval (option, value, "comp_trustnaddr", &p->comptrustnaddr, compmode, 0)
 	|| cfgfile_strval (option, value, "joyport0", &p->jport0, portmode, 0)
 	|| cfgfile_strval (option, value, "joyport1", &p->jport1, portmode, 0)
 	|| cfgfile_strval (option, value, "use_gui", &p->start_gui, guimode1, 1)
@@ -414,7 +463,8 @@ int cfgfile_parse_option (struct uae_pre
 	|| cfgfile_strval (option, value, "gfx_colour_mode", &p->color_mode, colormode1, 1)
 	|| cfgfile_strval (option, value, "gfx_colour_mode", &p->color_mode, colormode2, 0)
 	|| cfgfile_strval (option, value, "gfx_color_mode", &p->color_mode, colormode1, 1)
-	|| cfgfile_strval (option, value, "gfx_color_mode", &p->color_mode, colormode2, 0))
+	|| cfgfile_strval (option, value, "gfx_color_mode", &p->color_mode, colormode2, 0)
+	|| cfgfile_strval (option, value, "comp_flushmode", &p->comp_hardflush, flushmode, 0))
 	return 1;
     if (cfgfile_string (option, value, "floppy0", p->df[0], 256)
 	|| cfgfile_string (option, value, "floppy1", p->df[1], 256)
@@ -423,6 +473,7 @@ int cfgfile_parse_option (struct uae_pre
 	|| cfgfile_string (option, value, "kickstart_rom_file", p->romfile, 256)
 	|| cfgfile_string (option, value, "kickstart_ext_rom_file", p->romextfile, 256)
 	|| cfgfile_string (option, value, "kickstart_key_file", p->keyfile, 256)
+	|| cfgfile_string (option, value, "pci_devices", p->pci_devices, 256)
 	|| cfgfile_string (option, value, "config_description", p->description, 256))
 	return 1;
 
Index: src/compemu_abandoned.c
===================================================================
RCS file: compemu_abandoned.c
diff -N compemu_abandoned.c
--- /dev/null	Tue Oct  2 20:51:52 2001
+++ src/compemu_abandoned.c	Sat Feb 16 20:08:35 2002
@@ -0,0 +1,244 @@
+
+#if 0   /* some code that was abandoned for one reason or another, but
+	   might not yet be ready for complete deletion */
+
+/* The jumps in the following would be a nightmare to get right with the
+   new flag handling */
+
+static void readmem_new(int address, int dest, int offset, int size, int tmp)
+{
+  int f=tmp;
+  uae_u8* branchadd;
+  uae_u8* branchadd2;
+  uae_u8* branchadd3;
+  bigstate keep, getto;   /* These are way too big for comfort! */
+  int i;
+
+  mov_l_rr(f,address);
+  shrl_l_ri(f,16);   /* The index into the baseaddr table */
+  mov_l_rm_indexed(f,(uae_u32)baseaddr,f,4);
+  /* f now holds either the offset, or whatever is in mem_banks */
+  test_l_ri(f,1);  /* Check for LSB */
+  keep=live;  /* Store the state for the second branch */
+  emit_byte(0x75); branchadd=target; emit_byte(0x00);  /* JNZ */
+  { /* Handling realmem situation */
+    if (isinreg(dest) && live.state[dest].size>size) {
+      tomem(dest); evict(dest);  /* So the state[dest].size will be
+				  * just what we loaded --- makes it
+				  * easier in the other branch */
+    }
+    switch(size) {
+    case 1: mov_b_rrm_indexed(dest,address,f,1); break;
+    case 2: mov_w_rrm_indexed(dest,address,f,1); bswap_16(dest); break;
+    case 4: mov_l_rrm_indexed(dest,address,f,1); bswap_32(dest); break;
+    }
+    if (live.state[dest].size>size) {
+      printf("Uh-oh, bad sd in,PC_P readmem, wanted %d\n",
+	     live.state[dest].size,size);
+      live.state[dest].size=size;
+    }
+    disassociate(f);
+    getto=live;  /* The state we need to get into */
+    emit_byte(0xeb); branchadd2=target; emit_byte(0x00); /* JMP */
+  }
+  if ((uae_u32)target&0x1f) 
+    target+=32-((uae_u32)target&0x1f);
+  *branchadd=(target-branchadd-1);  /* Fill in the jump length */
+  {
+    live=keep; /* Restore the pre-jump state */
+    mov_l_rR(f,f,-1+offset);  /* -1 makes up for the set LSB */
+    /* Now f holds the address of the b/w/lget function */
+    isclean(f); /* So it doesn't get pushed */
+    call_r_11(f,dest,address,4,4);
+    
+    /* OK, and now comes the part where we have to make the states the same */
+    /* First, the result might have to be moved */
+    if (live.state[dest].realreg!=getto.state[dest].realreg) {
+      raw_mov_l_rr(getto.state[dest].realreg,live.state[dest].realreg);
+      live.nat[getto.state[dest].realreg].holds=dest;
+      live.nat[live.state[dest].realreg].holds=-1;
+      live.state[dest].realreg=getto.state[dest].realreg;
+    }
+    /* That was the only live register. Now reload whatever else needs 
+       reloading */
+    for (i=0;i<N_REGS;i++) {
+      if (getto.nat[i].holds>=0 && live.nat[i].holds!=getto.nat[i].holds) {
+	raw_mov_l_rm(i,(uae_u32)live.state[getto.nat[i].holds].mem);
+      }
+    }
+    /* Now the state *should* be a superset of the getto state. */
+    live=getto;  /* Use the subset */
+    emit_byte(0xeb); branchadd3=target; emit_byte(0x00); /* JMP */
+  }
+  if ((uae_u32)target&0x1f) 
+    target+=32-((uae_u32)target&0x1f);
+  *branchadd2=(target-branchadd2-1);  /* Fill in the jump length */
+  *branchadd3=(target-branchadd3-1);  /* Fill in the jump length */
+}
+
+
+static void writemem_new(int address, int source, int offset, int size, int tmp)
+{
+  int f=tmp;
+  uae_u8* branchadd;
+  uae_u8* branchadd2;
+  uae_u8* branchadd3;
+  bigstate keep, getto;   /* These are way too big for comfort! */
+  int i;
+
+  mov_l_rr(f,address);
+  shrl_l_ri(f,16);   /* The index into the baseaddr table */
+  mov_l_rm_indexed(f,(uae_u32)(baseaddr+65536+512),f,4);
+  /* f now holds either the offset, or whatever is in mem_banks */
+  test_l_ri(f,1);  /* Check for LSB */
+  keep=live;  /* Store the state for the second branch */
+  emit_byte(0x75); branchadd=target; emit_byte(0x00);  /* JNZ */
+  { /* Handling realmem situation */
+    switch(size) {
+    case 1: mov_b_mrr_indexed(address,f,1,source); break;
+    case 2: bswap_16(source); mov_w_mrr_indexed(address,f,1,source); bswap_16(source); break;
+    case 4: bswap_32(source); mov_l_mrr_indexed(address,f,1,source); bswap_32(source); break;
+    }
+    disassociate(f);
+    getto=live;  /* The state we need to get into */
+    emit_byte(0xeb); branchadd2=target; emit_byte(0x00); /* JMP */
+  }
+  if ((uae_u32)target&0x1f) 
+    target+=32-((uae_u32)target&0x1f);
+  *branchadd=(target-branchadd-1);  /* Fill in the jump length */
+  {
+    live=keep; /* Restore the pre-jump state */
+    mov_l_rR(f,f,-1+offset);  /* -1 makes up for the set LSB */
+    /* Now f holds the address of the b/w/lget function */
+    isclean(f); /* So it doesn't get pushed */
+    call_r_02(f,address,source,4,size);
+    
+    /* OK, and now comes the part where we have to make the states the same */
+    for (i=0;i<N_REGS;i++) {
+      if (getto.nat[i].holds>=0 && live.nat[i].holds!=getto.nat[i].holds) {
+	raw_mov_l_rm(i,(uae_u32)live.state[getto.nat[i].holds].mem);
+      }
+    }
+    /* Now the state *should* be a superset of the getto state. */
+    live=getto;  /* Use the subset */
+    emit_byte(0xeb); branchadd3=target; emit_byte(0x00); /* JMP */
+  }
+  if ((uae_u32)target&0x1f) 
+    target+=32-((uae_u32)target&0x1f);
+  *branchadd2=(target-branchadd2-1);  /* Fill in the jump length */
+  *branchadd3=(target-branchadd3-1);  /* Fill in the jump length */
+}
+
+
+static __inline__ void empty_stack(void)
+{
+}
+
+static __inline__ void flags_to_stack(void) 
+{
+  if (live.flags_on_stack==VALID)
+    return;
+  if (!live.flags_are_important) 
+    return;
+
+  if (live.flags_in_flags==VALID) {
+    /* Move flags from x86 flags to FLAGTMP */
+    int tmp=writereg_specific(FLAGTMP,4,0);
+    //lahf(); /* Move low byte into AH. Gets all but V */
+    //setcc(tmp,0);  /* move V into bit 0 of AL */
+    pushfl();
+    raw_pop_l(tmp);
+
+    unlock(tmp);
+  }
+  else
+    abort();
+  live.flags_on_stack=VALID;
+}
+
+
+static __inline__ void clobber_flags(void)
+{
+  if (live.flags_in_flags==VALID && live.flags_on_stack!=VALID)
+    flags_to_stack();
+  if (live.flags_in_flags!=NADA)
+    live.flags_in_flags=TRASH;
+}
+
+static __inline__ void live_flags(void)
+{
+  if (live.flags_on_stack!=NADA)
+    live.flags_on_stack=TRASH;
+  live.flags_in_flags=VALID;
+  live.flags_are_important=1;
+}
+
+static __inline__ void dont_care_flags(void)
+{
+  live.flags_are_important=0;
+}
+
+static __inline__ void make_flags_live(void)
+{
+  if (live.flags_in_flags==VALID)
+    return;
+  if (live.flags_on_stack==TRASH) {
+    printf("Want flags, got something on stack, but it is TRASH\n");
+    abort();
+  }
+  if (live.flags_on_stack==NADA) {
+    /* First time --- need to get it from memory */
+    push_m((uae_u32)&regflags.cznv);
+    pop_l(FLAGTMP);
+    live.flags_on_stack=VALID;
+  }
+  if (live.flags_on_stack==VALID) {
+
+    int tmp=readreg_specific(FLAGTMP,4,0);
+    /* AL is 0 (no overflow) or 1 (overflow) */
+    //raw_cmp_b_ri(tmp,-127);  /* Set overflow accordingly. Clobber all others */
+    //sahf();   /* And set the rest from AH */
+    raw_push_l(tmp);
+    popfl();
+
+    unlock(tmp);
+    live.flags_in_flags=VALID;
+    return;
+  }
+  printf("Huh? live.flags_in_flags=%d, live.flags_on_stack=%d, but need to make live\n",
+	 live.flags_in_flags,live.flags_on_stack);
+  abort();
+}
+
+/* This will swap the nreg s into the nreg d, and
+   vice versa, and adjust the state information accordingly */
+static void swap_nregs(int s, int d)
+{
+  int vs=live.nat[s].holds;
+  int vd=live.nat[d].holds;
+
+  consistent(__LINE__);
+  printf("  Swap %d and %d (%d and %d)\n",s,d,vs,vd);
+
+  if (s==d)
+    return;
+  if (vs>=0 && vd>=0) 
+    raw_xchg_l_rr(s,d);
+  else if (vs>=0)
+    raw_mov_l_rr(d,s);
+  else
+    raw_mov_l_rr(s,d);
+
+  if (vs>=0) {
+    live.state[vs].realreg=d;
+  }
+  if (vd>=0) {
+    live.state[vd].realreg=s;
+  }
+  live.nat[s].holds=vd;
+  live.nat[d].holds=vs;
+  consistent(__LINE__);
+}
+
+
+#endif
Index: src/compemu_fpp.c
===================================================================
RCS file: compemu_fpp.c
diff -N compemu_fpp.c
--- /dev/null	Tue Oct  2 20:51:52 2001
+++ src/compemu_fpp.c	Sat Feb 16 20:08:35 2002
@@ -0,0 +1,1555 @@
+/*
+  * UAE - The Un*x Amiga Emulator
+  *
+  * MC68881 emulation
+  *
+  * Copyright 1996 Herman ten Brugge
+  * Adapted for JIT compilation (c) Bernd Meyer, 2000
+  */
+
+#include <math.h>
+
+#include "sysconfig.h"
+#include "sysdeps.h"
+
+#include "config.h"
+#include "options.h"
+#include "memory.h"
+#include "custom.h"
+#include "newcpu.h"
+#include "ersatz.h"
+#include "md-fpp.h"
+#include "compemu.h"
+
+#define MAKE_FPSR(r) do { fmov_rr(FP_RESULT,r); } while (0)
+
+#define delay   nop() ;nop()  
+#define delay2  nop() ;nop()   
+
+uae_s32 temp_fp[3];  /* To convert between FP/integer */
+
+/* return register number, or -1 for failure */
+STATIC_INLINE int get_fp_value (uae_u32 opcode, uae_u16 extra)
+{
+    uaecptr tmppc;
+    uae_u16 tmp;
+    int size;
+    int mode;
+    int reg;
+    double* src;
+    uae_u32 ad = 0;
+    static int sz1[8] = { 4, 4, 12, 12, 2, 8, 1, 0 };
+    static int sz2[8] = { 4, 4, 12, 12, 2, 8, 2, 0 };
+
+    if ((extra & 0x4000) == 0) {
+	return (extra >> 10) & 7;
+    }
+
+    mode = (opcode >> 3) & 7;
+    reg = opcode & 7;
+    size = (extra >> 10) & 7;
+    switch (mode) {
+     case 0:
+	switch (size) {
+	 case 6:
+	    sign_extend_8_rr(S1,reg);
+	    mov_l_mr((uae_u32)temp_fp,S1);
+	    delay2;
+	    fmovi_rm(FS1,(uae_u32)temp_fp);
+	    return FS1;
+	 case 4:
+	    sign_extend_16_rr(S1,reg);
+	    mov_l_mr((uae_u32)temp_fp,S1);
+	    delay2;
+	    fmovi_rm(FS1,(uae_u32)temp_fp);
+	    return FS1;
+	 case 0:
+	    mov_l_mr((uae_u32)temp_fp,reg);
+	    delay2;
+	    fmovi_rm(FS1,(uae_u32)temp_fp);
+	    return FS1;
+	 case 1:
+	    mov_l_mr((uae_u32)temp_fp,reg);
+	    delay2;
+	    fmovs_rm(FS1,(uae_u32)temp_fp);
+	    return FS1;
+	 default:
+	    return -1;
+	}
+	return -1; /* Should be unreachable */
+     case 1:
+	return -1; /* Genuine invalid instruction */
+     default:
+	break;
+    }
+    /* OK, we *will* have to load something from an address. Let's make
+       sure we know how to handle that, or quit early --- i.e. *before*
+       we do any postincrement/predecrement that we may regret */
+
+    switch (size) {
+     case 3:
+	return -1;
+     case 0:
+     case 1:
+     case 2:
+     case 4:
+     case 5:
+     case 6:
+	break; 
+     default:
+	return -1;
+    }
+
+    switch (mode) {
+     case 2:
+	ad=S1;  /* We will change it, anyway ;-) */
+	mov_l_rr(ad,reg+8);
+	break;
+     case 3:
+	ad=S1;
+	mov_l_rr(ad,reg+8);
+	lea_l_brr(reg+8,reg+8,(reg == 7?sz2[size]:sz1[size]));
+	break;
+     case 4:
+	ad=S1;
+	
+	lea_l_brr(reg+8,reg+8,-(reg == 7?sz2[size]:sz1[size]));
+	mov_l_rr(ad,reg+8);
+	break;
+     case 5:
+     {
+	 uae_u32 off=(uae_s32)(uae_s16)comp_get_iword((m68k_pc_offset+=2)-2);
+	 ad=S1;
+	 mov_l_rr(ad,reg+8);
+	 lea_l_brr(ad,ad,off);
+	 break;
+     }
+     case 6:
+     {
+	uae_u32 dp=comp_get_iword((m68k_pc_offset+=2)-2);
+	ad=S1;
+	calc_disp_ea_020(reg+8,dp,ad,S2);
+	break;
+     }
+     case 7:
+	switch (reg) {
+	 case 0:
+	 {
+	     uae_u32 off=(uae_s32)(uae_s16)comp_get_iword((m68k_pc_offset+=2)-2);
+	     ad=S1;
+	     mov_l_ri(ad,off);
+	     break;
+	 }
+	 case 1:
+	 {
+	     uae_u32 off=comp_get_ilong((m68k_pc_offset+=4)-4);
+	     ad=S1;
+	     mov_l_ri(ad,off);
+	     break;
+	 }
+	 case 2:
+	 {
+	     uae_u32 address=start_pc+((char *)comp_pc_p-(char *)start_pc_p)+
+		 m68k_pc_offset;
+	     uae_s32 PC16off =(uae_s32)(uae_s16)comp_get_iword((m68k_pc_offset+=2)-2);
+	     ad=S1;
+	     mov_l_ri(ad,address+PC16off);
+	     break;
+	 }
+	 case 3:
+	    return -1;
+	    tmppc = m68k_getpc ();
+	    tmp = next_iword ();
+	    ad = get_disp_ea_020 (tmppc, tmp);
+	    break;
+	 case 4: 
+	 {
+	     uae_u32 address=start_pc+((char *)comp_pc_p-(char *)start_pc_p)+
+		 m68k_pc_offset;
+	     ad=S1;
+	     mov_l_ri(ad,address);
+	     m68k_pc_offset+=sz2[size];
+	     break;
+	 }
+	 default:
+	    return -1;
+	}
+    }
+
+    switch (size) {
+     case 0:
+	readlong(ad,S2,S3);
+	mov_l_mr((uae_u32)temp_fp,S2);
+	delay2;
+	fmovi_rm(FS1,(uae_u32)temp_fp);
+	break;
+     case 1:
+	readlong(ad,S2,S3);
+	mov_l_mr((uae_u32)temp_fp,S2);
+	delay2;
+	fmovs_rm(FS1,(uae_u32)temp_fp);
+	break;
+     case 2:
+	readword(ad,S2,S3);
+	mov_w_mr(((uae_u32)temp_fp)+8,S2);
+	add_l_ri(ad,4);
+	readlong(ad,S2,S3);
+	mov_l_mr((uae_u32)(temp_fp)+4,S2);
+	add_l_ri(ad,4);
+	readlong(ad,S2,S3);
+	mov_l_mr((uae_u32)(temp_fp),S2);
+	delay2;
+	fmov_ext_rm(FS1,(uae_u32)(temp_fp));
+	break;
+     case 3:
+	return -1; /* Some silly "packed" stuff */
+     case 4:
+	readword(ad,S2,S3);
+	sign_extend_16_rr(S2,S2);
+	mov_l_mr((uae_u32)temp_fp,S2);
+	delay2;
+	fmovi_rm(FS1,(uae_u32)temp_fp);
+	break;
+     case 5:
+	readlong(ad,S2,S3);
+	mov_l_mr(((uae_u32)temp_fp)+4,S2);
+	add_l_ri(ad,4);
+	readlong(ad,S2,S3);
+	mov_l_mr((uae_u32)(temp_fp),S2);
+	delay2;
+	fmov_rm(FS1,(uae_u32)(temp_fp));
+	break;
+     case 6:
+	readbyte(ad,S2,S3);
+	sign_extend_8_rr(S2,S2);
+	mov_l_mr((uae_u32)temp_fp,S2);
+	delay2;
+	fmovi_rm(FS1,(uae_u32)temp_fp);
+	break;
+     default:
+	return -1;
+    }
+    return FS1;
+}
+
+/* return of -1 means failure, >=0 means OK */
+STATIC_INLINE int put_fp_value (int val, uae_u32 opcode, uae_u16 extra)
+{
+    uae_u16 tmp;
+    uaecptr tmppc;
+    int size;
+    int mode;
+    int reg;
+    uae_u32 ad;
+    static int sz1[8] = { 4, 4, 12, 12, 2, 8, 1, 0 };
+    static int sz2[8] = { 4, 4, 12, 12, 2, 8, 2, 0 };
+
+    if ((extra & 0x4000) == 0) {
+	fmov_rr((extra>>10)&7,val);
+	return 0;
+    }
+
+    mode = (opcode >> 3) & 7;
+    reg = opcode & 7;
+    size = (extra >> 10) & 7;
+    ad = -1;
+    switch (mode) {
+     case 0:
+	switch (size) {
+	 case 6:
+	    fmovi_mr((uae_u32)temp_fp,val);
+	    delay;
+	    mov_b_rm(reg,(uae_u32)temp_fp);
+	    return 0;
+	 case 4:
+	    fmovi_mr((uae_u32)temp_fp,val);
+	    delay;
+	    mov_w_rm(reg,(uae_u32)temp_fp);
+	    return 0;
+	 case 0:
+	    fmovi_mr((uae_u32)temp_fp,val);
+	    delay;
+	    mov_l_rm(reg,(uae_u32)temp_fp);
+	    return 0;
+	 case 1:
+	    fmovs_mr((uae_u32)temp_fp,val);
+	    delay;
+	    mov_l_rm(reg,(uae_u32)temp_fp);
+	    return 0;
+	 default:
+	    return -1;
+	}
+     case 1:
+	return -1; /* genuine invalid instruction */
+     default: break;
+    }
+
+    /* Let's make sure we get out *before* doing something silly if
+       we can't handle the size */
+    switch (size) {
+     case 0:
+     case 4:
+     case 5:
+     case 6:
+     case 2:
+     case 1:
+	break;
+     case 3:
+     default:
+	return -1;
+    }
+    
+    switch (mode) {
+     case 2:
+	ad=S1;
+	mov_l_rr(ad,reg+8);
+	break;
+     case 3:
+	ad=S1;
+	mov_l_rr(ad,reg+8);
+	lea_l_brr(reg+8,reg+8,(reg == 7?sz2[size]:sz1[size]));
+	break;
+     case 4:
+	ad=S1;
+	lea_l_brr(reg+8,reg+8,-(reg == 7?sz2[size]:sz1[size]));
+	mov_l_rr(ad,reg+8);
+	break;
+     case 5:
+     {
+	 uae_u32 off=(uae_s32)(uae_s16)comp_get_iword((m68k_pc_offset+=2)-2);
+	 ad=S1;
+	 mov_l_rr(ad,reg+8);
+	 add_l_ri(ad,off);
+	 break;
+     }
+     case 6:
+     {
+	uae_u32 dp=comp_get_iword((m68k_pc_offset+=2)-2);
+	ad=S1;
+	calc_disp_ea_020(reg+8,dp,ad,S2);
+	break;
+     }
+     case 7:
+	switch (reg) {
+	 case 0:
+	 {
+	     uae_u32 off=(uae_s32)(uae_s16)comp_get_iword((m68k_pc_offset+=2)-2);
+	     ad=S1;
+	     mov_l_ri(ad,off);
+	     break;
+	 }
+	 case 1:
+	 {
+	     uae_u32 off=comp_get_ilong((m68k_pc_offset+=4)-4);
+	     ad=S1;
+	     mov_l_ri(ad,off);
+	     break;
+	 }
+	 case 2:
+	 {
+	     uae_u32 address=start_pc+((char *)comp_pc_p-(char *)start_pc_p)+
+		 m68k_pc_offset;
+	     uae_s32 PC16off =(uae_s32)(uae_s16)comp_get_iword((m68k_pc_offset+=2)-2);
+	     ad=S1;
+	     mov_l_ri(ad,address+PC16off);
+	     break;
+	 }
+	 case 3:
+	    return -1;
+	    tmppc = m68k_getpc ();
+	    tmp = next_iword ();
+	    ad = get_disp_ea_020 (tmppc, tmp);
+	    break;
+	 case 4:
+	 {
+	     uae_u32 address=start_pc+((char *)comp_pc_p-(char *)start_pc_p)+
+		 m68k_pc_offset;
+	     ad=S1;
+	     mov_l_ri(ad,address);
+	     m68k_pc_offset+=sz2[size];
+	     break;
+	 }
+	 default:
+	    return -1;
+	}
+    }
+    switch (size) {
+     case 0:
+	fmovi_mr((uae_u32)temp_fp,val);
+	delay;
+	mov_l_rm(S2,(uae_u32)temp_fp);
+	writelong_clobber(ad,S2,S3);
+	break;
+     case 1:
+	fmovs_mr((uae_u32)temp_fp,val);
+	delay;
+	mov_l_rm(S2,(uae_u32)temp_fp);
+	writelong_clobber(ad,S2,S3);
+	break;
+     case 2:
+	fmov_ext_mr((uae_u32)temp_fp,val);
+	delay;
+	mov_w_rm(S2,(uae_u32)temp_fp+8);
+	writeword_clobber(ad,S2,S3);
+	add_l_ri(ad,4);
+	mov_l_rm(S2,(uae_u32)temp_fp+4);
+	writelong_clobber(ad,S2,S3);
+	add_l_ri(ad,4);
+	mov_l_rm(S2,(uae_u32)temp_fp);
+	writelong_clobber(ad,S2,S3);
+	break;
+     case 3: return -1; /* Packed */
+
+     case 4:
+	fmovi_mr((uae_u32)temp_fp,val);
+	delay;
+	mov_l_rm(S2,(uae_u32)temp_fp);
+	writeword_clobber(ad,S2,S3);
+	break;
+     case 5:
+	fmov_mr((uae_u32)temp_fp,val);
+	delay;
+	mov_l_rm(S2,(uae_u32)temp_fp+4);
+	writelong_clobber(ad,S2,S3);
+	add_l_ri(ad,4);
+	mov_l_rm(S2,(uae_u32)temp_fp);
+	writelong_clobber(ad,S2,S3);
+	break;
+     case 6:
+	fmovi_mr((uae_u32)temp_fp,val);
+	delay;
+	mov_l_rm(S2,(uae_u32)temp_fp);
+	writebyte(ad,S2,S3);
+	break;
+     default:
+	return -1;
+    }
+    return 0;
+}
+
+/* return -1 for failure, or register number for success */
+STATIC_INLINE int get_fp_ad (uae_u32 opcode, uae_u32 * ad)
+{
+    uae_u16 tmp;
+    uaecptr tmppc;
+    int mode;
+    int reg;
+    uae_s32 off;
+
+    mode = (opcode >> 3) & 7;
+    reg = opcode & 7;
+    switch (mode) {
+     case 0:
+     case 1:
+	return -1;
+     case 2:
+     case 3:
+     case 4:
+	mov_l_rr(S1,8+reg);
+	return S1;
+	*ad = m68k_areg (regs, reg);
+	break;
+     case 5:
+	off=(uae_s32)(uae_s16)comp_get_iword((m68k_pc_offset+=2)-2);
+
+	mov_l_rr(S1,8+reg);
+	add_l_ri(S1,off);
+	return S1;
+     case 6:
+	return -1;
+	break;
+     case 7:
+	switch (reg) {
+	 case 0:
+	    off=(uae_s32)(uae_s16)comp_get_iword((m68k_pc_offset+=2)-2);
+	    mov_l_ri(S1,off);
+	    return S1;
+	 case 1:
+	    off=comp_get_ilong((m68k_pc_offset+=4)-4);
+	    mov_l_ri(S1,off);
+	    return S1;
+	 case 2:
+	    return -1;
+	    *ad = m68k_getpc ();
+	    *ad += (uae_s32) (uae_s16) next_iword ();
+	    break;
+	 case 3:
+	    return -1;
+	    tmppc = m68k_getpc ();
+	    tmp = next_iword ();
+	    *ad = get_disp_ea_020 (tmppc, tmp);
+	    break;
+	 default:
+	    return -1;
+	}
+    }
+    abort();
+}
+
+void comp_fdbcc_opp (uae_u32 opcode, uae_u16 extra)
+{
+    FAIL(1);
+    return;
+
+    if (!currprefs.compfpu) {
+	FAIL(1);
+	return;
+    }
+}
+
+void comp_fscc_opp (uae_u32 opcode, uae_u16 extra)
+{
+    uae_u32 ad;
+    int cc;
+    int reg;
+
+    if (!currprefs.compfpu) {
+	FAIL(1);
+	return;
+    }
+
+#if DEBUG_FPP
+    printf ("fscc_opp at %08lx\n", m68k_getpc ());
+    fflush (stdout);
+#endif
+
+
+    if (extra&0x20) {  /* only cc from 00 to 1f are defined */
+	FAIL(1);
+	return;
+    }
+    if ((opcode & 0x38) != 0) { /* We can only do to integer register */
+	FAIL(1); 
+	return;
+    }
+
+    fflags_into_flags(S2);
+    reg=(opcode&7);
+    
+    mov_l_ri(S1,255);
+    mov_l_ri(S4,0);
+    switch(extra&0x0f) {  /* according to fpp.c, the 0x10 bit is ignored
+			    */
+     case 0: break;  /* set never */
+     case 1: mov_l_rr(S2,S4); 
+	cmov_l_rr(S4,S1,4); 
+	cmov_l_rr(S4,S2,10); break;
+     case 2: cmov_l_rr(S4,S1,7); break;
+     case 3: cmov_l_rr(S4,S1,3); break;
+     case 4: mov_l_rr(S2,S4); 
+	cmov_l_rr(S4,S1,2); 
+	cmov_l_rr(S4,S2,10); break;
+     case 5: mov_l_rr(S2,S4); 
+	cmov_l_rr(S4,S1,6); 
+	cmov_l_rr(S4,S2,10); break;
+     case 6: cmov_l_rr(S4,S1,5); break;
+     case 7: cmov_l_rr(S4,S1,11); break;
+     case 8: cmov_l_rr(S4,S1,10); break;
+     case 9: cmov_l_rr(S4,S1,4); break;
+     case 10: cmov_l_rr(S4,S1,10); cmov_l_rr(S4,S1,7); break;
+     case 11: cmov_l_rr(S4,S1,4); cmov_l_rr(S4,S1,3); break;
+     case 12: cmov_l_rr(S4,S1,2); break;
+     case 13: cmov_l_rr(S4,S1,6); break;
+     case 14: cmov_l_rr(S4,S1,5); cmov_l_rr(S4,S1,10); break;
+     case 15: mov_l_rr(S4,S1); break;
+    }
+
+    if ((opcode & 0x38) == 0) {
+	mov_b_rr(reg,S4);
+    } else {
+	abort();
+	if (get_fp_ad (opcode, &ad) == 0) {
+	    m68k_setpc (m68k_getpc () - 4);
+	    op_illg (opcode);
+	} else
+	    put_byte (ad, cc ? 0xff : 0x00);
+    }
+}
+
+void comp_ftrapcc_opp (uae_u32 opcode, uaecptr oldpc)
+{
+    int cc;
+
+    FAIL(1);
+    return;
+}
+
+extern unsigned long foink3, oink;
+
+void comp_fbcc_opp (uae_u32 opcode)
+{
+    uae_u32 start_68k_offset=m68k_pc_offset;
+    uae_u32 off;
+    uae_u32 v1;
+    uae_u32 v2;
+    uae_u32 nh;
+    int cc;
+
+    if (!currprefs.compfpu) {
+	FAIL(1);
+	return;
+    }
+
+    if (opcode&0x20) {  /* only cc from 00 to 1f are defined */
+	FAIL(1);
+	return;
+    }
+    if ((opcode&0x40)==0) {
+	off=(uae_s32)(uae_s16)comp_get_iword((m68k_pc_offset+=2)-2);
+    }
+    else {
+	off=comp_get_ilong((m68k_pc_offset+=4)-4);
+    }
+    mov_l_ri(S1,(uae_u32)
+	     (comp_pc_p+off-(m68k_pc_offset-start_68k_offset)));
+    mov_l_ri(PC_P,(uae_u32)comp_pc_p);
+
+    /* Now they are both constant. Might as well fold in m68k_pc_offset */
+    add_l_ri(S1,m68k_pc_offset);
+    add_l_ri(PC_P,m68k_pc_offset);
+    m68k_pc_offset=0;
+
+    /* according to fpp.c, the 0x10 bit is ignored
+       (it handles exception handling, which we don't
+       do, anyway ;-) */
+    cc=opcode&0x0f;
+    v1=get_const(PC_P);
+    v2=get_const(S1);
+    fflags_into_flags(S2);
+
+    // mov_l_mi((uae_u32)&foink3,cc);
+    switch(cc) {  
+     case 0: break;  /* jump never */
+     case 1: 
+	mov_l_rr(S2,PC_P); 
+	cmov_l_rr(PC_P,S1,4); 
+	cmov_l_rr(PC_P,S2,10); break;
+     case 2: register_branch(v1,v2,7); break;
+     case 3: register_branch(v1,v2,3); break;
+     case 4: 
+	mov_l_rr(S2,PC_P); 
+	cmov_l_rr(PC_P,S1,2); 
+	cmov_l_rr(PC_P,S2,10); break;
+     case 5:
+	mov_l_rr(S2,PC_P); 
+	cmov_l_rr(PC_P,S1,6); 
+	cmov_l_rr(PC_P,S2,10); break;
+     case 6: register_branch(v1,v2,5); break;
+     case 7: register_branch(v1,v2,11); break;
+     case 8: register_branch(v1,v2,10); break;
+     case 9: register_branch(v1,v2,4); break;
+     case 10: 
+	cmov_l_rr(PC_P,S1,10); 
+	cmov_l_rr(PC_P,S1,7); break;
+     case 11: 
+	cmov_l_rr(PC_P,S1,4); 
+	cmov_l_rr(PC_P,S1,3); break;
+     case 12: register_branch(v1,v2,2); break;
+     case 13: register_branch(v1,v2,6); break;
+     case 14: 
+	cmov_l_rr(PC_P,S1,5); 
+	cmov_l_rr(PC_P,S1,10); break;
+     case 15: mov_l_rr(PC_P,S1); break;
+    }
+}
+
+    /* Floating point conditions 
+       The "NotANumber" part could be problematic; Howver, when NaN is
+       encountered, the ftst instruction sets bot N and Z to 1 on the x87,
+       so quite often things just fall into place. This is probably not
+       accurate wrt the 68k FPU, but it is *as* accurate as this was before.
+       However, some more thought should go into fixing this stuff up so
+       it accurately emulates the 68k FPU.
+>=<U 
+0000    0x00: 0                        ---   Never jump
+0101    0x01: Z                        ---   jump if zero (x86: 4)
+1000    0x02: !(NotANumber || Z || N)  --- Neither Z nor N set (x86: 7)
+1101    0x03: Z || !(NotANumber || N); --- Z or !N (x86: 4 and 3)
+0010    0x04: N && !(NotANumber || Z); --- N and !Z (x86: hard!)
+0111    0x05: Z || (N && !NotANumber); --- Z or N (x86: 6)
+1010    0x06: !(NotANumber || Z);      --- not Z (x86: 5)
+1110    0x07: !NotANumber;             --- not NaN (x86: 11, not parity)
+0001    0x08: NotANumber;              --- NaN (x86: 10)
+0101    0x09: NotANumber || Z;         --- Z (x86: 4)
+1001    0x0a: NotANumber || !(N || Z); --- NaN or neither N nor Z (x86: 10 and 7)
+1101    0x0b: NotANumber || Z || !N;   --- Z or !N (x86: 4 and 3)
+0011    0x0c: NotANumber || (N && !Z); --- N (x86: 2)
+0111    0x0d: NotANumber || Z || N;    --- Z or N (x86: 6)
+1010    0x0e: !Z;                      --- not Z (x86: 5)
+1111    0x0f: 1;                       --- always
+
+This is not how the 68k handles things, though --- it sets Z to 0 and N
+to the NaN's sign.... ('o' and 'i' denote differences from the above
+table)
+
+>=<U 
+0000    0x00: 0                        ---   Never jump
+010o    0x01: Z                        ---   jump if zero (x86: 4, not 10)
+1000    0x02: !(NotANumber || Z || N)  --- Neither Z nor N set (x86: 7)
+110o    0x03: Z || !(NotANumber || N); --- Z or !N (x86: 3)
+0010    0x04: N && !(NotANumber || Z); --- N and !Z (x86: 2, not 10)
+011o    0x05: Z || (N && !NotANumber); --- Z or N (x86: 6, not 10)
+1010    0x06: !(NotANumber || Z);      --- not Z (x86: 5)
+1110    0x07: !NotANumber;             --- not NaN (x86: 11, not parity)
+0001    0x08: NotANumber;              --- NaN (x86: 10)
+0101    0x09: NotANumber || Z;         --- Z (x86: 4)
+1001    0x0a: NotANumber || !(N || Z); --- NaN or neither N nor Z (x86: 10 and 7)
+1101    0x0b: NotANumber || Z || !N;   --- Z or !N (x86: 4 and 3)
+0011    0x0c: NotANumber || (N && !Z); --- N (x86: 2)
+0111    0x0d: NotANumber || Z || N;    --- Z or N (x86: 6)
+101i    0x0e: !Z;                      --- not Z (x86: 5 and 10)
+1111    0x0f: 1;                       --- always
+
+Of course, this *still* doesn't mean that the x86 and 68k conditions are
+equivalent --- the handling of infinities is different, for one thing.
+On the 68k, +infinity minus +infinity is NotANumber (as it should be). On
+the x86, it is +infinity, and some exception is raised (which I suspect
+is promptly ignored) STUPID! 
+The more I learn about their CPUs, the more I detest Intel....
+
+You can see this in action if you have "Benoit" (see Aminet) and
+set the exponent to 16. Wait for a long time, and marvel at the extra black
+areas outside the center one. That's where Benoit expects NaN, and the x86
+gives +infinity. [Ooops --- that must have been some kind of bug in my code.
+it no longer happens, and the resulting graphic looks much better, too]
+
+x86 conditions
+0011    : 2
+1100    : 3
+0101    : 4
+1010    : 5
+0111    : 6
+1000    : 7
+0001    : 10
+1110    : 11
+    */
+void comp_fsave_opp (uae_u32 opcode)
+{
+    uae_u32 ad;
+    int incr = (opcode & 0x38) == 0x20 ? -1 : 1;
+    int i;
+
+    FAIL(1);
+    return;
+
+    if (!currprefs.compfpu) {
+	FAIL(1);
+	return;
+    }
+
+#if DEBUG_FPP
+    printf ("fsave_opp at %08lx\n", m68k_getpc ());
+    fflush (stdout);
+#endif
+    if (get_fp_ad (opcode, &ad) == 0) {
+	m68k_setpc (m68k_getpc () - 2);
+	op_illg (opcode);
+	return;
+    }
+
+    if (currprefs.cpu_level == 4) {
+	/* 4 byte 68040 IDLE frame.  */
+	if (incr < 0) {
+	    ad -= 4;
+	    put_long (ad, 0x41000000);
+	} else {
+	    put_long (ad, 0x41000000);
+	    ad += 4;
+	}
+    } else {
+	if (incr < 0) {
+	    ad -= 4;
+	    put_long (ad, 0x70000000);
+	    for (i = 0; i < 5; i++) {
+		ad -= 4;
+		put_long (ad, 0x00000000);
+	    }
+	    ad -= 4;
+	    put_long (ad, 0x1f180000);
+	} else {
+	    put_long (ad, 0x1f180000);
+	    ad += 4;
+	    for (i = 0; i < 5; i++) {
+		put_long (ad, 0x00000000);
+		ad += 4;
+	    }
+	    put_long (ad, 0x70000000);
+	    ad += 4;
+	}
+    }
+    if ((opcode & 0x38) == 0x18)
+	m68k_areg (regs, opcode & 7) = ad;
+    if ((opcode & 0x38) == 0x20)
+	m68k_areg (regs, opcode & 7) = ad;
+}
+
+void comp_frestore_opp (uae_u32 opcode)
+{
+    uae_u32 ad;
+    uae_u32 d;
+    int incr = (opcode & 0x38) == 0x20 ? -1 : 1;
+
+    FAIL(1);
+    return;
+
+    if (!currprefs.compfpu) {
+	FAIL(1);
+	return;
+    }
+
+#if DEBUG_FPP
+    printf ("frestore_opp at %08lx\n", m68k_getpc ());
+    fflush (stdout);
+#endif
+    if (get_fp_ad (opcode, &ad) == 0) {
+	m68k_setpc (m68k_getpc () - 2);
+	op_illg (opcode);
+	return;
+    }
+    if (currprefs.cpu_level == 4) {
+	/* 68040 */
+	if (incr < 0) {
+	    /* @@@ This may be wrong.  */
+	    ad -= 4;
+	    d = get_long (ad);
+	    if ((d & 0xff000000) != 0) { /* Not a NULL frame? */
+		if ((d & 0x00ff0000) == 0) { /* IDLE */
+		} else if ((d & 0x00ff0000) == 0x00300000) { /* UNIMP */
+		    ad -= 44;
+		} else if ((d & 0x00ff0000) == 0x00600000) { /* BUSY */
+		    ad -= 92;
+		}
+	    }
+	} else {
+	    d = get_long (ad);
+	    ad += 4;
+	    if ((d & 0xff000000) != 0) { /* Not a NULL frame? */
+		if ((d & 0x00ff0000) == 0) { /* IDLE */
+		} else if ((d & 0x00ff0000) == 0x00300000) { /* UNIMP */
+		    ad += 44;
+		} else if ((d & 0x00ff0000) == 0x00600000) { /* BUSY */
+		    ad += 92;
+		}
+	    }
+	}
+    } else {
+	if (incr < 0) {
+	    ad -= 4;
+	    d = get_long (ad);
+	    if ((d & 0xff000000) != 0) {
+		if ((d & 0x00ff0000) == 0x00180000)
+		    ad -= 6 * 4;
+		else if ((d & 0x00ff0000) == 0x00380000)
+		    ad -= 14 * 4;
+		else if ((d & 0x00ff0000) == 0x00b40000)
+		    ad -= 45 * 4;
+	    }
+	} else {
+	    d = get_long (ad);
+	    ad += 4;
+	    if ((d & 0xff000000) != 0) {
+		if ((d & 0x00ff0000) == 0x00180000)
+		    ad += 6 * 4;
+		else if ((d & 0x00ff0000) == 0x00380000)
+		    ad += 14 * 4;
+		else if ((d & 0x00ff0000) == 0x00b40000)
+		    ad += 45 * 4;
+	    }
+	}
+    }
+    if ((opcode & 0x38) == 0x18)
+	m68k_areg (regs, opcode & 7) = ad;
+    if ((opcode & 0x38) == 0x20)
+	m68k_areg (regs, opcode & 7) = ad;
+}
+
+static fptype const_e=2.718281828;  /* Got some more digits? */
+static fptype const_log10_e=0.4342944819;
+static fptype const_loge_10=2.302585093;
+static fptype power10[]={1e0,1e1,1e2,1e4,1e8,1e16,1e32,1e64,1e128,1e256
+#if USE_LONG_DOUBLE
+,       1e512, 1e1024, 1e2048, 1e4096
+#endif
+};
+
+/* 128 words, indexed through the low byte of the 68k fpu control word */
+static uae_u16 x86_fpucw[]={
+    0x137f, 0x137f, 0x137f, 0x137f, 0x137f, 0x137f, 0x137f, 0x137f, /* p0r0 */
+    0x1f7f, 0x1f7f, 0x1f7f, 0x1f7f, 0x1f7f, 0x1f7f, 0x1f7f, 0x1f7f, /* p0r1 */
+    0x177f, 0x177f, 0x177f, 0x177f, 0x177f, 0x177f, 0x177f, 0x177f, /* p0r2 */
+    0x1b7f, 0x1b7f, 0x1b7f, 0x1b7f, 0x1b7f, 0x1b7f, 0x1b7f, 0x1b7f, /* p0r3 */
+
+    0x107f, 0x107f, 0x107f, 0x107f, 0x107f, 0x107f, 0x107f, 0x107f, /* p1r0 */
+    0x1c7f, 0x1c7f, 0x1c7f, 0x1c7f, 0x1c7f, 0x1c7f, 0x1c7f, 0x1c7f, /* p1r1 */
+    0x147f, 0x147f, 0x147f, 0x147f, 0x147f, 0x147f, 0x147f, 0x147f, /* p1r2 */
+    0x187f, 0x187f, 0x187f, 0x187f, 0x187f, 0x187f, 0x187f, 0x187f, /* p1r3 */
+
+    0x127f, 0x127f, 0x127f, 0x127f, 0x127f, 0x127f, 0x127f, 0x127f, /* p2r0 */
+    0x1e7f, 0x1e7f, 0x1e7f, 0x1e7f, 0x1e7f, 0x1e7f, 0x1e7f, 0x1e7f, /* p2r1 */
+    0x167f, 0x167f, 0x167f, 0x167f, 0x167f, 0x167f, 0x167f, 0x167f, /* p2r2 */
+    0x1a7f, 0x1a7f, 0x1a7f, 0x1a7f, 0x1a7f, 0x1a7f, 0x1a7f, 0x1a7f, /* p2r3 */
+
+    0x137f, 0x137f, 0x137f, 0x137f, 0x137f, 0x137f, 0x137f, 0x137f, /* p3r0 */
+    0x1f7f, 0x1f7f, 0x1f7f, 0x1f7f, 0x1f7f, 0x1f7f, 0x1f7f, 0x1f7f, /* p3r1 */
+    0x177f, 0x177f, 0x177f, 0x177f, 0x177f, 0x177f, 0x177f, 0x177f, /* p3r2 */
+    0x1b7f, 0x1b7f, 0x1b7f, 0x1b7f, 0x1b7f, 0x1b7f, 0x1b7f, 0x1b7f  /* p3r3 */
+};
+
+void comp_fpp_opp (uae_u32 opcode, uae_u16 extra)
+{
+    int reg;
+    int src;
+    
+    if (!currprefs.compfpu) {
+	FAIL(1);
+	return;
+    }
+    switch ((extra >> 13) & 0x7) {
+     case 3: /* 2nd most common */
+	if (put_fp_value ((extra >> 7)&7 , opcode, extra) < 0) {
+	    FAIL(1);
+	    return;
+	}
+	return;
+     case 6:
+     case 7: 
+	{
+	    uae_u32 ad, list = 0;
+	    int incr = 0;
+	    if (extra & 0x2000) {
+		int ad;
+
+		/* FMOVEM FPP->memory */
+		switch ((extra >> 11) & 3) { /* Get out early if failure */
+		 case 0:
+		 case 2:
+		    break;
+		 case 1:
+		 case 3: 
+		 default:
+		    FAIL(1); return;
+		}
+		ad=get_fp_ad (opcode, &ad);
+		if (ad<0) {
+		    m68k_setpc (m68k_getpc () - 4);
+		    op_illg (opcode);
+		    return;
+		}
+		switch ((extra >> 11) & 3) {
+		case 0:	/* static pred */
+		    list = extra & 0xff;
+		    incr = -1;
+		    break;
+		case 2:	/* static postinc */
+		    list = extra & 0xff;
+		    incr = 1;
+		    break;
+		case 1:	/* dynamic pred */
+		case 3:	/* dynamic postinc */
+		   abort();
+		}
+		while (list) {
+		    uae_u32 wrd1, wrd2, wrd3;
+		    if (incr < 0) { /* Predecrement */
+			fmov_ext_mr((uae_u32)temp_fp,fpp_movem_index2[list]);
+			delay;
+			sub_l_ri(ad,4); 
+			mov_l_rm(S2,(uae_u32)temp_fp);
+			writelong_clobber(ad,S2,S3);
+			sub_l_ri(ad,4); 
+			mov_l_rm(S2,(uae_u32)temp_fp+4);
+			writelong_clobber(ad,S2,S3);
+			sub_l_ri(ad,4); 
+			mov_w_rm(S2,(uae_u32)temp_fp+8);
+			writeword_clobber(ad,S2,S3);
+		    } else { /* postinc */
+			fmov_ext_mr((uae_u32)temp_fp,fpp_movem_index2[list]);
+			delay;
+			mov_w_rm(S2,(uae_u32)temp_fp+8);
+			writeword_clobber(ad,S2,S3);
+			add_l_ri(ad,4);
+			mov_l_rm(S2,(uae_u32)temp_fp+4);
+			writelong_clobber(ad,S2,S3);
+			add_l_ri(ad,4);
+			mov_l_rm(S2,(uae_u32)temp_fp);
+			writelong_clobber(ad,S2,S3);
+			add_l_ri(ad,4);
+		    }
+		    list = fpp_movem_next[list];
+		}
+		if ((opcode & 0x38) == 0x18)
+		    mov_l_rr((opcode & 7)+8,ad);
+		if ((opcode & 0x38) == 0x20)
+		    mov_l_rr((opcode & 7)+8,ad);
+	    } else {
+		/* FMOVEM memory->FPP */
+
+		int ad;
+		switch ((extra >> 11) & 3) { /* Get out early if failure */
+		 case 0:
+		 case 2:
+		    break;
+		 case 1:
+		 case 3: 
+		 default:
+		    FAIL(1); return;
+		}
+		ad=get_fp_ad (opcode, &ad);
+		if (ad<0) {
+		    m68k_setpc (m68k_getpc () - 4);
+		    op_illg (opcode);
+		    return;
+		}
+		switch ((extra >> 11) & 3) {
+		case 0:	/* static pred */
+		    list = extra & 0xff;
+		    incr = -1;
+		    break;
+		case 2:	/* static postinc */
+		    list = extra & 0xff;
+		    incr = 1;
+		    break;
+		case 1:	/* dynamic pred */
+		case 3:	/* dynamic postinc */
+		   abort();
+		}
+
+		while (list) {
+		    uae_u32 wrd1, wrd2, wrd3;
+		    if (incr < 0) {
+			sub_l_ri(ad,4);
+			readlong(ad,S2,S3);
+			mov_l_mr((uae_u32)(temp_fp),S2);
+			sub_l_ri(ad,4);
+			readlong(ad,S2,S3);
+			mov_l_mr((uae_u32)(temp_fp)+4,S2);
+			sub_l_ri(ad,4);
+			readword(ad,S2,S3);
+			mov_w_mr(((uae_u32)temp_fp)+8,S2);
+			delay2;
+			fmov_ext_rm(fpp_movem_index2[list],(uae_u32)(temp_fp));
+		    } else {
+			readword(ad,S2,S3);
+			mov_w_mr(((uae_u32)temp_fp)+8,S2);
+			add_l_ri(ad,4);
+			readlong(ad,S2,S3);
+			mov_l_mr((uae_u32)(temp_fp)+4,S2);
+			add_l_ri(ad,4);
+			readlong(ad,S2,S3);
+			mov_l_mr((uae_u32)(temp_fp),S2);
+			add_l_ri(ad,4);
+			delay2;
+			fmov_ext_rm(fpp_movem_index1[list],(uae_u32)(temp_fp));
+		    }
+		    list = fpp_movem_next[list];
+		}
+		if ((opcode & 0x38) == 0x18)
+		    mov_l_rr((opcode & 7)+8,ad);
+		if ((opcode & 0x38) == 0x20)
+		    mov_l_rr((opcode & 7)+8,ad);
+	    }
+	}
+	return;
+
+     case 4:
+     case 5:  /* rare */
+	if ((opcode & 0x30) == 0) {
+	    if (extra & 0x2000) {
+		if (extra & 0x1000) {
+		    mov_l_rm(opcode & 15,(uae_u32)&regs.fpcr); return;
+		}
+		if (extra & 0x0800) {
+		    FAIL(1);
+		    return;
+		}
+		if (extra & 0x0400) {
+		    mov_l_rm(opcode & 15,(uae_u32)&regs.fpiar); return;
+		}
+	    } else {
+		if (extra & 0x1000) {
+		    mov_l_mr((uae_u32)&regs.fpcr,opcode & 15); 
+#if USE_X86_FPUCW
+		    mov_l_rr(S1,opcode & 15);
+		    and_l_ri(S1,0x000000f0);
+		    fldcw_m_indexed(S1,(uae_u32)x86_fpucw);
+#endif		    
+		    return;
+		}
+		if (extra & 0x0800) {
+		    FAIL(1);
+		    return;
+		    // set_fpsr(m68k_dreg (regs, opcode & 15));
+		}
+		if (extra & 0x0400) {
+		    mov_l_mr((uae_u32)&regs.fpiar,opcode & 15); return;
+		}
+	    }
+	} else if ((opcode & 0x3f) == 0x3c) {
+	    if ((extra & 0x2000) == 0) {
+		if (extra & 0x1000) {
+		    uae_u32 val=comp_get_ilong((m68k_pc_offset+=4)-4);
+		    mov_l_mi((uae_u32)&regs.fpcr,val);
+#if USE_X86_FPUCW
+		    mov_l_ri(S1,val&0x000000f0);
+		    fldcw_m_indexed(S1,(uae_u32)x86_fpucw);
+#endif		    
+		    return;
+		}
+		if (extra & 0x0800) {
+		    FAIL(1);
+		    return;
+		}
+		if (extra & 0x0400) {
+		    uae_u32 val=comp_get_ilong((m68k_pc_offset+=4)-4);
+		    mov_l_mi((uae_u32)&regs.fpiar,val);
+		    return;
+		}
+	    }
+	    FAIL(1);
+	    return;
+	} else if (extra & 0x2000) {
+	    FAIL(1);
+	    return;
+	} else {
+	    FAIL(1);
+	    return;
+	}
+	FAIL(1);
+	return;
+
+     case 0:
+     case 2: /* Extremely common */
+	reg = (extra >> 7) & 7;
+	if ((extra & 0xfc00) == 0x5c00) {
+	    switch (extra & 0x7f) {
+	     case 0x00:
+		fmov_pi(reg);
+		break;
+	     case 0x0b:
+		fmov_log10_2(reg);
+		break;
+	     case 0x0c:
+		fmov_rm(reg,(uae_u32)&const_e);
+		break;
+	     case 0x0d:
+		fmov_log2_e(reg);
+		break;
+	     case 0x0e:
+		fmov_rm(reg,(uae_u32)&const_log10_e);
+		break;
+	     case 0x0f:
+		fmov_0(reg);
+		break;
+	     case 0x30:
+		fmov_loge_2(reg);
+		break;
+	     case 0x31:
+		fmov_rm(reg,(uae_u32)&const_loge_10);
+		break;
+	     case 0x32:
+		fmov_1(reg);
+		break;
+	     case 0x33:
+	     case 0x34:
+	     case 0x35:
+	     case 0x36:
+	     case 0x37:
+	     case 0x38:
+	     case 0x39:
+	     case 0x3a:
+	     case 0x3b:
+		fmov_rm(reg,(uae_u32)(power10+(extra & 0x7f)-0x32));
+		break;
+	     default:
+		/* This is not valid, so we fail */
+		FAIL(1);
+		return;
+	    }
+	    return;
+	}
+	
+	switch (extra & 0x7f) {
+	 case 0x00:		/* FMOVE */
+	 case 0x40:  /* Explicit rounding. This is just a quick fix. Same
+		      * for all other cases that have three choices */
+	 case 0x44:   
+	    dont_care_fflags();
+	    src=get_fp_value (opcode, extra);
+	    if (src < 0) {
+		FAIL(1);  /* Illegal instruction */
+		return;
+	    }
+	    fmov_rr(reg,src);
+	    MAKE_FPSR (src);
+	    break;
+	 case 0x01:		/* FINT */
+	    FAIL(1);    
+	    return;
+	    dont_care_fflags();
+	 case 0x02:		/* FSINH */
+	    FAIL(1);  
+	    return;
+
+	    dont_care_fflags();
+	    regs.fp[reg] = sinh (src);
+	    MAKE_FPSR (regs.fp[reg]);
+	    break;
+	 case 0x03:		/* FINTRZ */
+#if USE_X86_FPUCW 
+	    /* If we have control over the CW, we can do this */
+	    dont_care_fflags();
+	    src=get_fp_value (opcode, extra);
+	    if (src < 0) {
+		FAIL(1);  /* Illegal instruction */
+		return;
+	    }
+	    mov_l_ri(S1,16);  /* Switch to "round to zero" mode */
+	    fldcw_m_indexed(S1,(uae_u32)x86_fpucw);
+	    
+	    frndint_rr(reg,src);
+
+	    /* restore control word */
+	    mov_l_rm(S1,(uae_u32)&regs.fpcr); 
+	    and_l_ri(S1,0x000000f0);
+	    fldcw_m_indexed(S1,(uae_u32)x86_fpucw);
+
+	    MAKE_FPSR (reg);
+	    break;
+#endif		    
+	    FAIL(1);  
+	    return;
+	    regs.fp[reg] = (int) src;
+	    MAKE_FPSR (regs.fp[reg]);
+	    break;
+	 case 0x04:		/* FSQRT */
+	 case 0x41:
+	 case 0x45:
+	    dont_care_fflags();
+	    src=get_fp_value (opcode, extra);
+	    if (src < 0) {
+		FAIL(1);  /* Illegal instruction */
+		return;
+	    }
+	    fsqrt_rr(reg,src);
+	    MAKE_FPSR (reg);
+	    break;
+	 case 0x06:		/* FLOGNP1 */
+	    FAIL(1);  
+	    return;
+	    dont_care_fflags();
+	    regs.fp[reg] = log (src + 1.0);
+	    MAKE_FPSR (regs.fp[reg]);
+	    break;
+	 case 0x08:		/* FETOXM1 */
+	    FAIL(1);  
+	    return;
+	    dont_care_fflags();
+	    regs.fp[reg] = exp (src) - 1.0;
+	    MAKE_FPSR (regs.fp[reg]);
+	    break;
+	 case 0x09:		/* FTANH */
+	    FAIL(1);  
+	    return;
+	    dont_care_fflags();
+	    regs.fp[reg] = tanh (src);
+	    MAKE_FPSR (regs.fp[reg]);
+	    break;
+	 case 0x0a:		/* FATAN */
+	    FAIL(1);  
+	    return;
+	    dont_care_fflags();
+	    regs.fp[reg] = atan (src);
+	    MAKE_FPSR (regs.fp[reg]);
+	    break;
+	 case 0x0c:		/* FASIN */
+	    FAIL(1);  
+	    return;
+	    dont_care_fflags();
+	    regs.fp[reg] = asin (src);
+	    MAKE_FPSR (regs.fp[reg]);
+	    break;
+	 case 0x0d:		/* FATANH */
+	    FAIL(1);  
+	    return;
+	    dont_care_fflags();
+#if 1				/* The BeBox doesn't have atanh, and it isn't in the HPUX libm either */
+	    regs.fp[reg] = log ((1 + src) / (1 - src)) / 2;
+#else
+	    regs.fp[reg] = atanh (src);
+#endif
+	    MAKE_FPSR (regs.fp[reg]);
+	    break;
+	 case 0x0e:		/* FSIN */
+	    dont_care_fflags();
+	    src=get_fp_value (opcode, extra);
+	    if (src < 0) {
+		FAIL(1);  /* Illegal instruction */
+		return;
+	    }
+	    fsin_rr(reg,src);
+	    MAKE_FPSR (reg);
+	    break;
+	 case 0x0f:		/* FTAN */
+	    FAIL(1);  
+	    return;
+	    dont_care_fflags();
+	    regs.fp[reg] = tan (src);
+	    MAKE_FPSR (regs.fp[reg]);
+	    break;
+	 case 0x10:		/* FETOX */
+	    dont_care_fflags();
+	    src=get_fp_value (opcode, extra);
+	    if (src < 0) {
+		FAIL(1);  /* Illegal instruction */
+		return;
+	    }
+	    fetox_rr(reg,src);
+	    MAKE_FPSR (reg);
+	    break;
+	 case 0x11:		/* FTWOTOX */
+	    dont_care_fflags();
+	    src=get_fp_value (opcode, extra);
+	    if (src < 0) {
+		FAIL(1);  /* Illegal instruction */
+		return;
+	    }
+	    ftwotox_rr(reg,src);
+	    MAKE_FPSR (reg);
+	    break;
+	 case 0x12:		/* FTENTOX */
+	    FAIL(1);  
+	    return;
+	    dont_care_fflags();
+	    regs.fp[reg] = pow (10.0, src);
+	    MAKE_FPSR (regs.fp[reg]);
+	    break;
+	 case 0x14:		/* FLOGN */
+	    FAIL(1);  
+	    return;
+	    dont_care_fflags();
+	    regs.fp[reg] = log (src);
+	    MAKE_FPSR (regs.fp[reg]);
+	    break;
+	 case 0x15:		/* FLOG10 */
+	    FAIL(1);  
+	    return;
+	    dont_care_fflags();
+	    regs.fp[reg] = log10 (src);
+	    MAKE_FPSR (regs.fp[reg]);
+	    break;
+	 case 0x16:		/* FLOG2 */
+	    dont_care_fflags();
+	    src=get_fp_value (opcode, extra);
+	    if (src < 0) {
+		FAIL(1);  /* Illegal instruction */
+		return;
+	    }
+	    flog2_rr(reg,src);
+	    MAKE_FPSR (reg);
+	    break;
+	 case 0x18:		/* FABS */
+	 case 0x58:
+	 case 0x5c:
+	    dont_care_fflags();
+	    src=get_fp_value (opcode, extra);
+	    if (src < 0) {
+		FAIL(1);  /* Illegal instruction */
+		return;
+	    }
+	    fabs_rr(reg,src);
+	    MAKE_FPSR (reg);
+	    break;
+	 case 0x19:		/* FCOSH */
+	    FAIL(1);  
+	    return;
+	    dont_care_fflags();
+	    regs.fp[reg] = cosh (src);
+	    MAKE_FPSR (regs.fp[reg]);
+	    break;
+	 case 0x1a:		/* FNEG */
+	 case 0x5a:
+	 case 0x5e:
+	    dont_care_fflags();
+	    src=get_fp_value (opcode, extra);
+	    if (src < 0) {
+		FAIL(1);  /* Illegal instruction */
+		return;
+	    }
+	    fneg_rr(reg,src);
+	    MAKE_FPSR (reg);
+	    break;
+	 case 0x1c:		/* FACOS */
+	    FAIL(1);  
+	    return;
+	    dont_care_fflags();
+	    regs.fp[reg] = acos (src);
+	    MAKE_FPSR (regs.fp[reg]);
+	    break;
+	 case 0x1d:		/* FCOS */
+	    dont_care_fflags();
+	    src=get_fp_value (opcode, extra);
+	    if (src < 0) {
+		FAIL(1);  /* Illegal instruction */
+		return;
+	    }
+	    fcos_rr(reg,src);
+	    MAKE_FPSR (reg);
+	    break;
+	 case 0x1e:		/* FGETEXP */
+	    FAIL(1);  
+	    return;
+	    dont_care_fflags();
+	    {
+		int expon;
+		frexp (src, &expon);
+		regs.fp[reg] = (double) (expon - 1);
+		MAKE_FPSR (regs.fp[reg]);
+	    }
+	    break;
+	 case 0x1f:		/* FGETMAN */
+	    FAIL(1);  
+	    return;
+	    dont_care_fflags();
+	    {
+		int expon;
+		regs.fp[reg] = frexp (src, &expon) * 2.0;
+		MAKE_FPSR (regs.fp[reg]);
+	    }
+	    break;
+	 case 0x20:		/* FDIV */
+	 case 0x60:
+	 case 0x64:
+	    dont_care_fflags();
+	    src=get_fp_value (opcode, extra);
+	    if (src < 0) {
+		FAIL(1);  /* Illegal instruction */
+		return;
+	    }
+	    fdiv_rr(reg,src);
+	    MAKE_FPSR (reg);
+	    break;
+	 case 0x21:		/* FMOD */
+	    dont_care_fflags();
+	    src=get_fp_value (opcode, extra);
+	    if (src < 0) {
+		FAIL(1);  /* Illegal instruction */
+		return;
+	    }
+	    frem_rr(reg,src);
+	    MAKE_FPSR (reg);
+	    break;
+	 case 0x22:		/* FADD */
+	 case 0x62:
+	 case 0x66:
+	    dont_care_fflags();
+	    src=get_fp_value (opcode, extra);
+	    if (src < 0) {
+		FAIL(1);  /* Illegal instruction */
+		return;
+	    }
+	    fadd_rr(reg,src);
+	    MAKE_FPSR (reg);
+	    break;
+	 case 0x23:		/* FMUL */
+	 case 0x63:
+	 case 0x67:
+	    dont_care_fflags();
+	    src=get_fp_value (opcode, extra);
+	    if (src < 0) {
+		FAIL(1);  /* Illegal instruction */
+		return;
+	    }
+	    fmul_rr(reg,src);
+	    MAKE_FPSR (reg);
+	    break;
+	 case 0x24:		/* FSGLDIV */
+	    dont_care_fflags();
+	    src=get_fp_value (opcode, extra);
+	    if (src < 0) {
+		FAIL(1);  /* Illegal instruction */
+		return;
+	    }
+	    fdiv_rr(reg,src);
+	    MAKE_FPSR (reg);
+	    break;
+	 case 0x25:		/* FREM */
+	    dont_care_fflags();
+	    src=get_fp_value (opcode, extra);
+	    if (src < 0) {
+		FAIL(1);  /* Illegal instruction */
+		return;
+	    }
+	    frem1_rr(reg,src);
+	    MAKE_FPSR (reg);
+	    break;
+	 case 0x26:		/* FSCALE */
+	    dont_care_fflags();
+	    FAIL(1);  
+	    return;
+	    regs.fp[reg] *= exp (log (2.0) * src);
+	    MAKE_FPSR (regs.fp[reg]);
+	    break;
+	 case 0x27:		/* FSGLMUL */
+	    dont_care_fflags();
+	    src=get_fp_value (opcode, extra);
+	    if (src < 0) {
+		FAIL(1);  /* Illegal instruction */
+		return;
+	    }
+	    fmul_rr(reg,src);
+	    MAKE_FPSR (reg);
+	    break;
+	 case 0x28:		/* FSUB */
+	 case 0x68:
+	 case 0x6c:
+	    dont_care_fflags();
+	    src=get_fp_value (opcode, extra);
+	    if (src < 0) {
+		FAIL(1);  /* Illegal instruction */
+		return;
+	    }
+	    fsub_rr(reg,src);
+	    MAKE_FPSR (reg);
+	    break;
+	 case 0x30:		/* FSINCOS */
+	 case 0x31:
+	 case 0x32:
+	 case 0x33:
+	 case 0x34:
+	 case 0x35:
+	 case 0x36:
+	 case 0x37:
+	    FAIL(1);  
+	    return;
+	    dont_care_fflags();
+	    regs.fp[reg] = sin (src);
+	    regs.fp[extra & 7] = cos (src);
+	    MAKE_FPSR (regs.fp[reg]);
+	    break;
+	 case 0x38:		/* FCMP */
+	    src=get_fp_value (opcode, extra);
+	    if (src < 0) {
+		FAIL(1);  /* Illegal instruction */
+		return;
+	    }
+	    fmov_rr(FP_RESULT,reg);
+	    fsub_rr(FP_RESULT,src); /* Right way? */
+	    break;
+	 case 0x3a:		/* FTST */
+	    src=get_fp_value (opcode, extra);
+	    if (src < 0) {
+		FAIL(1);  /* Illegal instruction */
+		return;
+	    }
+	    fmov_rr(FP_RESULT,src);
+	    break;
+	 default:
+	    FAIL(1);  
+	    return;
+	    break;
+	}
+	return;
+    }
+    m68k_setpc (m68k_getpc () - 4);
+    op_illg (opcode);
+}
Index: src/compemu_optimizer.c
===================================================================
RCS file: compemu_optimizer.c
diff -N compemu_optimizer.c
--- /dev/null	Tue Oct  2 20:51:52 2001
+++ src/compemu_optimizer.c	Sat Feb 16 20:08:35 2002
@@ -0,0 +1,174 @@
+#if USE_OPTIMIZER
+/* Welcome to the magical world of cpp ;-) */
+
+#define USE_REGALLOC optlev>=2
+
+#define opt_op0(dummy) opt_store_op0()
+#define opt_op1(a1) opt_store_op1(OPT_##a1)
+#define opt_op2(a1,a2) opt_store_op2(OPT_##a1,OPT_##a2)
+#define opt_op3(a1,a2,a3) opt_store_op3(OPT_##a1,OPT_##a2,OPT_##a3)
+#define opt_op4(a1,a2,a3,a4) opt_store_op4(OPT_##a1,OPT_##a2,OPT_##a3,OPT_##a4)
+#define opt_op5(a1,a2,a3,a4,a5) opt_store_op5(OPT_##a1,OPT_##a2,OPT_##a3,OPT_##a4,OPT_##a5)
+
+#define direct0(dummy) ()
+#define direct1(a1) (DIR_##a1)
+#define direct2(a1,a2) (DIR_##a1,DIR_##a2)
+#define direct3(a1,a2,a3) (DIR_##a1,DIR_##a2,DIR_##a3)
+#define direct4(a1,a2,a3,a4) (DIR_##a1,DIR_##a2,DIR_##a3,DIR_##a4)
+#define direct5(a1,a2,a3,a4,a5) (DIR_##a1,DIR_##a2,DIR_##a3,DIR_##a4,DIR_##a5)
+
+#define OIMM 0
+#define OMEMR 0
+#define OMEMW 0
+#define OMEMRW 0 /* These are all 32 bit immediates */
+#define OR1  1
+#define OR2  2
+#define OR4  3
+#define OW1  4
+#define OW2  5
+#define OW4  6
+#define ORW1 7
+#define ORW2 8
+#define ORW4 9
+
+#define OFW 10
+#define OFR 11
+#define OFRW 12
+
+#define INST_END 98
+#define FLUSH 99
+
+#define OPT_IMM OIMM,
+#define OPT_MEMR OMEMR,
+#define OPT_MEMW OMEMW,
+#define OPT_MEMRW OMEMRW,
+#define OPT_R1  OR1 ,
+#define OPT_R2  OR2 ,
+#define OPT_R4  OR4 ,
+#define OPT_W1  OW1 ,
+#define OPT_W2  OW2 ,
+#define OPT_W4  OW4 ,
+#define OPT_RW1 ORW1,
+#define OPT_RW2 ORW2,
+#define OPT_RW4 ORW4,
+
+#define OPT_FW  OFW ,
+#define OPT_FR  OFR ,
+#define OPT_FRW OFRW ,
+
+#define DIR_IMM 
+#define DIR_MEMR 
+#define DIR_MEMW 
+#define DIR_MEMRW 
+#define DIR_R1  
+#define DIR_R2  
+#define DIR_R4  
+#define DIR_W1  
+#define DIR_W2  
+#define DIR_W4  
+#define DIR_RW1 
+#define DIR_RW2 
+#define DIR_RW4 
+
+#define DIR_FR
+#define DIR_FW
+#define DIR_FRW
+
+#undef MIDFUNC
+#undef MENDFUNC
+
+#define MIDFUNC(nargs,func,args) \
+  __inline__ void do_##func args
+
+#define MENDFUNC(nargs,func,args) \
+  void func args \
+  { \
+    if (reg_alloc_run) { \
+      opt_op##nargs##args; \
+    } else { \
+      do_##func direct##nargs##args; \
+    } \
+  }
+
+#undef COMPCALL
+#define COMPCALL(func) do_##func
+
+int opt_index=0;
+
+static __inline__ void store_any(uae_u8 type, uae_u32 val)
+{
+    ra[opt_index].type=type;
+    ra[opt_index].reg=val;
+    opt_index++;
+    if (opt_index>=MAXREGOPT) {
+	printf("Oops! opt_index overflow....\n");
+	abort();
+    }
+}
+
+static __inline__ void store_arg(uae_u8 type, uae_u32 val)
+{
+    if (type<OR1 || type>ORW4) 
+	return;
+    store_any(type,val);
+}
+
+static __inline__ void opt_store_op0(void)
+{
+    /* zilch */
+}
+
+static __inline__ void opt_store_op1(uae_u8 t1, uae_u32 a1)
+{
+    store_arg(t1,a1);
+    opt_store_op0();
+}
+ 
+static __inline__ void opt_store_op2(uae_u8 t1, uae_u32 a1,
+				     uae_u8 t2, uae_u32 a2)
+{
+    store_arg(t2,a2);
+    opt_store_op1(t1,a1);
+}
+
+static __inline__ void opt_store_op3(uae_u8 t1, uae_u32 a1,
+				     uae_u8 t2, uae_u32 a2,
+				     uae_u8 t3, uae_u32 a3)
+{
+    store_arg(t3,a3);
+    opt_store_op2(t1,a1,t2,a2);
+}
+
+static __inline__ void opt_store_op4(uae_u8 t1, uae_u32 a1,
+				     uae_u8 t2, uae_u32 a2,
+				     uae_u8 t3, uae_u32 a3,
+				     uae_u8 t4, uae_u32 a4)
+{
+    store_arg(t4,a4);
+    opt_store_op3(t1,a1,t2,a2,t3,a3);
+}
+
+static __inline__ void opt_store_op5(uae_u8 t1, uae_u32 a1,
+				     uae_u8 t2, uae_u32 a2,
+				     uae_u8 t3, uae_u32 a3,
+				     uae_u8 t4, uae_u32 a4,
+				     uae_u8 t5, uae_u32 a5)
+{
+    store_arg(t5,a5);
+    opt_store_op4(t1,a1,t2,a2,t3,a3,t4,a4);
+}
+
+static void opt_assert_empty(int line)
+{
+}
+
+void empty_optimizer(void) 
+{
+}
+
+#else
+static __inline__ void opt_emit_all(void) {}
+static __inline__ void opt_assert_empty(int line) {}
+void empty_optimizer(void) {}
+#define USE_REGALLOC 0
+#endif
Index: src/compemu_optimizer_x86.c
===================================================================
RCS file: compemu_optimizer_x86.c
diff -N compemu_optimizer_x86.c
--- /dev/null	Tue Oct  2 20:51:52 2001
+++ src/compemu_optimizer_x86.c	Sat Feb 16 20:08:35 2002
@@ -0,0 +1,421 @@
+#if USE_LOW_OPTIMIZER
+/* Welcome to the magical world of cpp ;-) */
+
+/* This was broken by the advent of FPU emulation. It also didn't
+   provide any useful speedup while it worked. *Sigh* Someone fix my
+   software, please ;-) */
+
+#define MAXLOPTINST 100
+
+#define LDECISION currprefs.comp_lowopt
+
+#define lopt_op0(dummy) lopt_store_op0(
+#define lopt_op1(a1) lopt_store_op1(LOPT_##a1,
+#define lopt_op2(a1,a2) lopt_store_op2(LOPT_##a1,LOPT_##a2,
+#define lopt_op3(a1,a2,a3) lopt_store_op3(LOPT_##a1,LOPT_##a2,LOPT_##a3,
+#define lopt_op4(a1,a2,a3,a4) lopt_store_op4(LOPT_##a1,LOPT_##a2,LOPT_##a3,LOPT_##a4,
+#define lopt_op5(a1,a2,a3,a4,a5) lopt_store_op5(LOPT_##a1,LOPT_##a2,LOPT_##a3,LOPT_##a4,LOPT_##a5,
+
+#define ldirect0(dummy) ()
+#define ldirect1(a1) (LDIR_##a1)
+#define ldirect2(a1,a2) (LDIR_##a1,LDIR_##a2)
+#define ldirect3(a1,a2,a3) (LDIR_##a1,LDIR_##a2,LDIR_##a3)
+#define ldirect4(a1,a2,a3,a4) (LDIR_##a1,LDIR_##a2,LDIR_##a3,LDIR_##a4)
+#define ldirect5(a1,a2,a3,a4,a5) (LDIR_##a1,LDIR_##a2,LDIR_##a3,LDIR_##a4,LDIR_##a5)
+
+#define NONE 0
+#define READ 1
+#define WRITE 2
+#define RMW (READ|WRITE)
+
+#define SIZE1 4
+#define SIZE2 8
+#define SIZE4 12
+#define FLOAT 16
+#define SIZEMASK 12
+
+#define LIMM NONE
+#define LR1  (READ | SIZE1)
+#define LR2  (READ | SIZE2)
+#define LR4  (READ | SIZE4)
+#define LW1  (WRITE | SIZE1)
+#define LW2  (WRITE | SIZE2)
+#define LW4  (WRITE | SIZE4)
+#define LRW1 (RMW | SIZE1)
+#define LRW2 (RMW | SIZE2)
+#define LRW4 (RMW | SIZE4)
+#define LFW  (READ | FLOAT)
+#define LFR  (WRITE | FLOAT)
+#define LFRW (RMW | FLOAT)
+#define LMEMR NONE
+#define LMEMW NONE
+#define LMEMRW NONE
+
+#define LOPT_IMM LIMM,
+#define LOPT_R1  LR1 ,
+#define LOPT_R2  LR2 ,
+#define LOPT_R4  LR4 ,
+#define LOPT_W1  LW1 ,
+#define LOPT_W2  LW2 ,
+#define LOPT_W4  LW4 ,
+#define LOPT_RW1 LRW1,
+#define LOPT_RW2 LRW2,
+#define LOPT_RW4 LRW4,
+#define LOPT_FR  LFR,
+#define LOPT_FW  LFW,
+#define LOPT_FRW LFRW,
+#define LOPT_MEMR LMEMR,
+#define LOPT_MEMW LMEMW,
+#define LOPT_MEMRW LMEMRW,
+
+#define LDIR_IMM 
+#define LDIR_R1  
+#define LDIR_R2  
+#define LDIR_R4  
+#define LDIR_W1  
+#define LDIR_W2  
+#define LDIR_W4  
+#define LDIR_RW1 
+#define LDIR_RW2 
+#define LDIR_RW4 
+#define LDIR_FW
+#define LDIR_FR
+#define LDIR_FRW
+#define LDIR_MEMR 
+#define LDIR_MEMW 
+#define LDIR_MEMRW 
+
+
+#undef LOWFUNC
+#undef LENDFUNC
+
+#define LOWFUNC(flags,mem,nargs,func,args) \
+  static __inline__ void do_##func args
+
+#define LENDFUNC(flags,mem,nargs,func,args) \
+  static __inline__ void func args \
+  { \
+  if (LDECISION) { \
+    lopt_op##nargs##args do_##func, mem, flags); \
+  } else { \
+    do_##func ldirect##nargs##args; \
+  } \
+  } 
+
+typedef struct lopt_inst_rec {
+    void* func;
+    uae_u32 args[5];
+    uae_u8 argtype[5];
+    uae_s8 nargs;
+    uae_u8 mem;
+    uae_u8 flags;
+} lopt_inst;
+
+
+
+static lopt_inst linst[MAXLOPTINST];
+static int lopt_index=0;
+
+static __inline__ int argsize(int type)
+{
+    return type&SIZEMASK;
+}
+
+static __inline__ int reads_mem(int i) {
+    return linst[i].mem & READ;
+}
+    
+    
+static __inline__ int access_reg(int i, int r, int mode)
+{
+    int k;
+    for (k=0;k<linst[i].nargs;k++)
+	if (linst[i].args[k]==r && 
+	    (linst[i].argtype[k]&mode) &&
+	    !(linst[i].argtype[k]&FLOAT))
+	    return 1;
+    return 0;
+}
+
+static __inline__ int writes_reg(int i, int r)
+{
+    return access_reg(i,r,WRITE);
+}
+
+static __inline__ int reads_reg(int i, int r)
+{
+    return access_reg(i,r,READ);
+}
+
+static __inline__ int uses_reg(int i, int r)
+{
+    return access_reg(i,r,RMW);
+}
+
+
+static __inline__ int writes_mem(int i) {
+    return linst[i].mem & WRITE;
+}
+
+static __inline__ int uses_mem(int i)
+{
+    return linst[i].mem & RMW;
+}
+
+static __inline__ int reads_flags(int i) {
+    return linst[i].flags & READ;
+}
+
+static __inline__ int writes_flags(int i) {
+    return linst[i].flags & WRITE;
+}
+
+static __inline__ int uses_flags(int i)
+{
+    return linst[i].flags & RMW;
+}
+
+static void do_raw_mov_l_rm(W4,MEMR);
+static void do_raw_fflags_save(void);
+
+
+/* Whether i depends on j */
+static __inline__ int depends_on(int i, int j)
+{
+    int n;
+
+    /* First, check memory */
+    if (writes_mem(i) && uses_mem(j))
+	return 1;
+    if (reads_mem(i) && writes_mem(j))
+	return 1;
+
+    /* Next, check flags */
+    if (writes_flags(i) && uses_flags(j))
+	return 1;
+    if (reads_flags(i) && writes_flags(j))
+	return 1;
+    
+    for (n=0;n<linst[i].nargs;n++) {
+	if (linst[i].argtype[n] & FLOAT)
+	    return 1;
+    }
+    for (n=0;n<linst[j].nargs;n++) {
+	if (linst[j].argtype[n] & FLOAT)
+	    return 1;
+    }
+
+    for (n=0;n<linst[i].nargs;n++) {
+	if ((linst[i].argtype[n] & WRITE) &&
+	    !(linst[i].argtype[n] & FLOAT)) {
+	    if (uses_reg(j,linst[i].args[n]))
+		return 1;
+	}
+	else if ((linst[i].argtype[n] & READ) &&
+		 !(linst[i].argtype[n] & FLOAT))  {
+	    if (writes_reg(j,linst[i].args[n]))
+		return 1;
+	}
+    }
+
+    /* The need for this indicates a problem somewhere in the
+       LOWFUNC definitions --- I think. FIXME! */
+
+    if (uses_flags(j) && uses_flags(i))
+	return 1;
+    if (linst[i].func==do_raw_fflags_save)
+	return 1;
+    if (linst[j].func==do_raw_fflags_save)
+	return 1;
+
+    return 0;
+}
+
+static void do_raw_mov_l_rm(W4 d, MEMR s);
+	    
+static __inline__ void low_peephole(void)
+{
+    int i;
+    
+    for (i=0;i<lopt_index;i++) {
+	if (uses_mem(i)) {
+	    int j=i-1;
+	    
+	    while (j>=i-4 && j>=0 && !depends_on(i,j)) {
+		j--;
+	    }
+	    if (j!=i-1) {
+		lopt_inst x=linst[i];
+		int k=i;
+
+		j++;
+		while (k>j) {
+		    linst[k]=linst[k-1];
+		    k--;
+		}
+		linst[j]=x;
+	    }
+	}
+    }
+}
+
+
+typedef void lopt_handler0(void);
+typedef void lopt_handler1(uae_u32);
+typedef void lopt_handler2(uae_u32,uae_u32);
+typedef void lopt_handler3(uae_u32,uae_u32,uae_u32);
+typedef void lopt_handler4(uae_u32,uae_u32,uae_u32,uae_u32);
+typedef void lopt_handler5(uae_u32,uae_u32,uae_u32,uae_u32,uae_u32);
+
+static void lopt_emit_all(void)
+{
+    int i;
+    lopt_inst* x;
+    static int inemit=0;
+    
+    if (inemit) {
+	printf("WARNING: lopt_emit is not reentrant!\n");
+    }
+    inemit=1;
+
+    low_peephole();
+
+    for (i=0;i<lopt_index;i++) {
+	x=linst+i;
+	switch(x->nargs) {
+	 case 0: ((lopt_handler0*)x->func)(); break;
+	 case 1: ((lopt_handler1*)x->func)(x->args[0]); break;
+	 case 2: ((lopt_handler2*)x->func)(x->args[0],x->args[1]); break;
+	 case 3: ((lopt_handler3*)x->func)(x->args[0],x->args[1],x->args[2]); break;
+	 case 4: ((lopt_handler4*)x->func)(x->args[0],x->args[1],x->args[2],
+					   x->args[3]); break;
+	 case 5: ((lopt_handler5*)x->func)(x->args[0],x->args[1],x->args[2],
+					   x->args[3],x->args[4]); break;
+	 default: abort();
+	}
+    }
+    lopt_index=0;
+    inemit=0;
+}
+
+static __inline__ void low_advance(void)
+{
+  lopt_index++;
+  if (lopt_index==MAXLOPTINST)
+    lopt_emit_all();
+}
+
+static __inline__ void lopt_store_op0(void* lfuncptr, uae_u32 lmem, 
+				      uae_u32 lflags)
+{
+  linst[lopt_index].func=lfuncptr;
+  linst[lopt_index].mem=lmem;
+  linst[lopt_index].flags=lflags;
+  linst[lopt_index].nargs=0;
+  low_advance();
+}
+
+static __inline__ void lopt_store_op1(uae_u8 t1, uae_u32 a1,
+				      void* lfuncptr, uae_u32 lmem, 
+				      uae_u32 lflags)
+{
+  linst[lopt_index].func=lfuncptr;
+  linst[lopt_index].mem=lmem;
+  linst[lopt_index].flags=lflags;
+  linst[lopt_index].nargs=1;
+  linst[lopt_index].argtype[0]=t1;
+  linst[lopt_index].args[0]=a1;
+  low_advance();
+}
+
+static __inline__ void lopt_store_op2(uae_u8 t1, uae_u32 a1,
+				      uae_u8 t2, uae_u32 a2,
+				      void* lfuncptr, uae_u32 lmem, 
+				      uae_u32 lflags)
+{
+  linst[lopt_index].func=lfuncptr;
+  linst[lopt_index].mem=lmem;
+  linst[lopt_index].flags=lflags;
+  linst[lopt_index].nargs=2;
+  linst[lopt_index].argtype[0]=t1;
+  linst[lopt_index].args[0]=a1;
+  linst[lopt_index].argtype[1]=t2;
+  linst[lopt_index].args[1]=a2;
+  low_advance();
+}
+
+static __inline__ void lopt_store_op3(uae_u8 t1, uae_u32 a1,
+				      uae_u8 t2, uae_u32 a2,
+				      uae_u8 t3, uae_u32 a3,
+				      void* lfuncptr, uae_u32 lmem, 
+				      uae_u32 lflags)
+{
+  linst[lopt_index].func=lfuncptr;
+  linst[lopt_index].mem=lmem;
+  linst[lopt_index].flags=lflags;
+  linst[lopt_index].nargs=3;
+  linst[lopt_index].argtype[0]=t1;
+  linst[lopt_index].args[0]=a1;
+  linst[lopt_index].argtype[1]=t2;
+  linst[lopt_index].args[1]=a2;
+  linst[lopt_index].argtype[2]=t3;
+  linst[lopt_index].args[2]=a3;
+  low_advance();
+}
+
+static __inline__ void lopt_store_op4(uae_u8 t1, uae_u32 a1,
+				      uae_u8 t2, uae_u32 a2,
+				      uae_u8 t3, uae_u32 a3,
+				      uae_u8 t4, uae_u32 a4,
+				      void* lfuncptr, uae_u32 lmem, 
+				      uae_u32 lflags)
+{
+  linst[lopt_index].func=lfuncptr;
+  linst[lopt_index].mem=lmem;
+  linst[lopt_index].flags=lflags;
+  linst[lopt_index].nargs=4;
+  linst[lopt_index].argtype[0]=t1;
+  linst[lopt_index].args[0]=a1;
+  linst[lopt_index].argtype[1]=t2;
+  linst[lopt_index].args[1]=a2;
+  linst[lopt_index].argtype[2]=t3;
+  linst[lopt_index].args[2]=a3;
+  linst[lopt_index].argtype[3]=t4;
+  linst[lopt_index].args[3]=a4;
+  low_advance();
+}
+
+static __inline__ void lopt_store_op5(uae_u8 t1, uae_u32 a1,
+				      uae_u8 t2, uae_u32 a2,
+				      uae_u8 t3, uae_u32 a3,
+				      uae_u8 t4, uae_u32 a4,
+				      uae_u8 t5, uae_u32 a5,
+				      void* lfuncptr, uae_u32 lmem, 
+				      uae_u32 lflags)
+{
+  linst[lopt_index].func=lfuncptr;
+  linst[lopt_index].mem=lmem;
+  linst[lopt_index].flags=lflags;
+  linst[lopt_index].nargs=5;
+  linst[lopt_index].argtype[0]=t1;
+  linst[lopt_index].args[0]=a1;
+  linst[lopt_index].argtype[1]=t2;
+  linst[lopt_index].args[1]=a2;
+  linst[lopt_index].argtype[2]=t3;
+  linst[lopt_index].args[2]=a3;
+  linst[lopt_index].argtype[3]=t4;
+  linst[lopt_index].args[3]=a4;
+  linst[lopt_index].argtype[4]=t5;
+  linst[lopt_index].args[4]=a5;
+  low_advance();
+}
+
+static __inline__ void empty_low_optimizer(void) 
+{
+  lopt_emit_all();
+}
+
+#else
+static __inline__ void lopt_emit_all(void) {}
+static __inline__ void empty_low_optimizer(void) {}
+#endif
Index: src/compemu_raw_x86.c
===================================================================
RCS file: compemu_raw_x86.c
diff -N compemu_raw_x86.c
--- /dev/null	Tue Oct  2 20:51:52 2001
+++ src/compemu_raw_x86.c	Sat Feb 16 20:08:35 2002
@@ -0,0 +1,3246 @@
+/* This should eventually end up in machdep/, but for now, x86 is the
+   only target, and it's easier this way... */
+
+/*************************************************************************
+ * Some basic information about the the target CPU                       *
+ *************************************************************************/
+
+#define EAX 0
+#define ECX 1
+#define EDX 2
+#define EBX 3
+
+/* The register in which subroutines return an integer return value */
+#define REG_RESULT 0
+
+/* The registers subroutines take their first and second argument in */
+#define REG_PAR1 0
+#define REG_PAR2 2
+
+/* Three registers that are not used for any of the above */
+#define REG_NOPAR1 6
+#define REG_NOPAR2 5
+#define REG_NOPAR3 3
+
+#define REG_PC_PRE 0 /* The register we use for preloading regs.pc_p */
+#define REG_PC_TMP 1 /* Another register that is not the above */
+
+#define SHIFTCOUNT_NREG 1  /* Register that can be used for shiftcount.
+			      -1 if any reg will do */
+#define MUL_NREG1 0 /* %eax will hold the low 32 bits after a 32x32 mul */
+#define MUL_NREG2 2 /* %edx will hold the high 32 bits */
+
+uae_s8 always_used[]={4,-1};
+uae_s8 can_byte[]={0,1,2,3,-1};
+uae_s8 can_word[]={0,1,2,3,5,6,7,-1};
+
+uae_u8 call_saved[]={0,0,0,0,1,0,0,0};
+
+/* This *should* be the same as call_saved. But:
+   - We might not really know which registers are saved, and which aren't,
+     so we need to preserve some, but don't want to rely on everyone else
+     also saving those registers
+   - Special registers (such like the stack pointer) should not be "preserved"
+     by pushing, even though they are "saved" across function calls
+*/
+uae_u8 need_to_preserve[]={1,1,1,1,0,1,1,1};
+
+/* Whether classes of instructions do or don't clobber the native flags */
+#define CLOBBER_MOV
+#define CLOBBER_LEA
+#define CLOBBER_CMOV
+#define CLOBBER_POP
+#define CLOBBER_PUSH
+#define CLOBBER_SUB  clobber_flags()
+#define CLOBBER_SBB  clobber_flags()
+#define CLOBBER_CMP  clobber_flags()
+#define CLOBBER_ADD  clobber_flags()
+#define CLOBBER_ADC  clobber_flags()
+#define CLOBBER_AND  clobber_flags()
+#define CLOBBER_OR   clobber_flags()
+#define CLOBBER_XOR  clobber_flags()
+
+#define CLOBBER_ROL  clobber_flags()
+#define CLOBBER_ROR  clobber_flags()
+#define CLOBBER_SHLL clobber_flags()
+#define CLOBBER_SHRL clobber_flags()
+#define CLOBBER_SHRA clobber_flags()
+#define CLOBBER_TEST clobber_flags()
+#define CLOBBER_CL16 
+#define CLOBBER_CL8  
+#define CLOBBER_SE16
+#define CLOBBER_SE8
+#define CLOBBER_ZE16
+#define CLOBBER_ZE8
+#define CLOBBER_SW16 clobber_flags()
+#define CLOBBER_SW32
+#define CLOBBER_SETCC
+#define CLOBBER_MUL  clobber_flags()
+#define CLOBBER_BT   clobber_flags()
+#define CLOBBER_BSF  clobber_flags()
+
+/*************************************************************************
+ * Actual encoding of the instructions on the target CPU                 *
+ *************************************************************************/
+
+static int have_cmov=0;  /* We need to generate different code if 
+			    we don't have cmov */
+
+#include "compemu_optimizer_x86.c"
+
+static uae_u16 swap16(uae_u16 x)
+{
+    return ((x&0xff00)>>8)|((x&0x00ff)<<8);
+}
+
+static uae_u32 swap32(uae_u32 x)
+{
+    return ((x&0xff00)<<8)|((x&0x00ff)<<24)|((x&0xff0000)>>8)|((x&0xff000000)>>24);
+}
+
+static __inline__ int isbyte(uae_s32 x)
+{
+  return (x>=-128 && x<=127);
+}
+
+LOWFUNC(NONE,WRITE,1,raw_push_l_r,(R4 r))
+{
+	emit_byte(0x50+r);
+}
+LENDFUNC(NONE,WRITE,1,raw_push_l_r,(R4 r))
+
+LOWFUNC(NONE,READ,1,raw_pop_l_r,(R4 r))
+{
+	emit_byte(0x58+r);
+}
+LENDFUNC(NONE,READ,1,raw_pop_l_r,(R4 r))
+
+LOWFUNC(WRITE,NONE,2,raw_bt_l_ri,(R4 r, IMM i))
+{
+	emit_byte(0x0f);
+	emit_byte(0xba);
+	emit_byte(0xe0+r);
+	emit_byte(i);
+}
+LENDFUNC(WRITE,NONE,2,raw_bt_l_ri,(R4 r, IMM i))
+
+LOWFUNC(WRITE,NONE,2,raw_bt_l_rr,(R4 r, R4 b))
+{
+	emit_byte(0x0f);
+	emit_byte(0xa3);
+	emit_byte(0xc0+8*b+r);
+}
+LENDFUNC(WRITE,NONE,2,raw_bt_l_rr,(R4 r, R4 b))
+
+LOWFUNC(WRITE,NONE,2,raw_btc_l_ri,(RW4 r, IMM i))
+{
+	emit_byte(0x0f);
+	emit_byte(0xba);
+	emit_byte(0xf8+r);
+	emit_byte(i);
+}
+LENDFUNC(WRITE,NONE,2,raw_btc_l_ri,(RW4 r, IMM i))
+
+LOWFUNC(WRITE,NONE,2,raw_btc_l_rr,(RW4 r, R4 b))
+{
+	emit_byte(0x0f);
+	emit_byte(0xbb);
+	emit_byte(0xc0+8*b+r);
+}
+LENDFUNC(WRITE,NONE,2,raw_btc_l_rr,(RW4 r, R4 b))
+
+
+LOWFUNC(WRITE,NONE,2,raw_btr_l_ri,(RW4 r, IMM i))
+{
+	emit_byte(0x0f);
+	emit_byte(0xba);
+	emit_byte(0xf0+r);
+	emit_byte(i);
+}
+LENDFUNC(WRITE,NONE,2,raw_btr_l_ri,(RW4 r, IMM i))
+
+LOWFUNC(WRITE,NONE,2,raw_btr_l_rr,(RW4 r, R4 b))
+{
+	emit_byte(0x0f);
+	emit_byte(0xb3);
+	emit_byte(0xc0+8*b+r);
+}
+LENDFUNC(WRITE,NONE,2,raw_btr_l_rr,(RW4 r, R4 b))
+
+LOWFUNC(WRITE,NONE,2,raw_bts_l_ri,(RW4 r, IMM i))
+{
+	emit_byte(0x0f);
+	emit_byte(0xba);
+	emit_byte(0xe8+r);
+	emit_byte(i);
+}
+LENDFUNC(WRITE,NONE,2,raw_bts_l_ri,(RW4 r, IMM i))
+
+LOWFUNC(WRITE,NONE,2,raw_bts_l_rr,(RW4 r, R4 b))
+{
+	emit_byte(0x0f);
+	emit_byte(0xab);
+	emit_byte(0xc0+8*b+r);
+}
+LENDFUNC(WRITE,NONE,2,raw_bts_l_rr,(RW4 r, R4 b))
+
+LOWFUNC(WRITE,NONE,2,raw_sub_w_ri,(RW2 d, IMM i))
+{
+    emit_byte(0x66);
+    if (isbyte(i)) {
+	emit_byte(0x83);
+	emit_byte(0xe8+d);
+	emit_byte(i);
+    }
+    else {
+	emit_byte(0x81);
+	emit_byte(0xe8+d);
+	emit_word(i);
+    }
+}
+LENDFUNC(WRITE,NONE,2,raw_sub_w_ri,(RW2 d, IMM i))
+
+
+LOWFUNC(NONE,WRITE,2,raw_mov_l_mi,(MEMW d, IMM s))
+{
+    emit_byte(0xc7);
+    emit_byte(0x05);
+    emit_long(d);
+    emit_long(s);
+}
+LENDFUNC(NONE,WRITE,2,raw_mov_l_mi,(MEMW d, IMM s))
+
+LOWFUNC(NONE,WRITE,2,raw_mov_w_mi,(MEMW d, IMM s))
+{
+    emit_byte(0x66);
+    emit_byte(0xc7);
+    emit_byte(0x05);
+    emit_long(d);
+    emit_word(s);
+}
+LENDFUNC(NONE,WRITE,2,raw_mov_w_mi,(MEMW d, IMM s))
+
+LOWFUNC(NONE,WRITE,2,raw_mov_b_mi,(MEMW d, IMM s))
+{
+    emit_byte(0xc6);
+    emit_byte(0x05);
+    emit_long(d);
+    emit_byte(s);
+}
+LENDFUNC(NONE,WRITE,2,raw_mov_b_mi,(MEMW d, IMM s))
+
+LOWFUNC(WRITE,RMW,2,raw_rol_b_mi,(MEMRW d, IMM i))
+{
+    emit_byte(0xc0);
+    emit_byte(0x05);
+    emit_long(d);
+    emit_byte(i);
+}
+LENDFUNC(WRITE,RMW,2,raw_rol_b_mi,(MEMRW d, IMM i))
+
+LOWFUNC(WRITE,NONE,2,raw_rol_b_ri,(RW1 r, IMM i))
+{
+    emit_byte(0xc0);
+    emit_byte(0xc0+r);
+    emit_byte(i);
+}
+LENDFUNC(WRITE,NONE,2,raw_rol_b_ri,(RW1 r, IMM i))
+
+LOWFUNC(WRITE,NONE,2,raw_rol_w_ri,(RW2 r, IMM i))
+{
+    emit_byte(0x66);
+    emit_byte(0xc1);
+    emit_byte(0xc0+r);
+    emit_byte(i);
+}
+LENDFUNC(WRITE,NONE,2,raw_rol_w_ri,(RW2 r, IMM i))
+
+LOWFUNC(WRITE,NONE,2,raw_rol_l_ri,(RW4 r, IMM i))
+{
+    emit_byte(0xc1);
+    emit_byte(0xc0+r);
+    emit_byte(i);
+}
+LENDFUNC(WRITE,NONE,2,raw_rol_l_ri,(RW4 r, IMM i))
+
+LOWFUNC(WRITE,NONE,2,raw_rol_l_rr,(RW4 d, R1 r))
+{
+    emit_byte(0xd3);
+    emit_byte(0xc0+d);
+}
+LENDFUNC(WRITE,NONE,2,raw_rol_l_rr,(RW4 d, R1 r))
+
+LOWFUNC(WRITE,NONE,2,raw_rol_w_rr,(RW2 d, R1 r))
+{
+    emit_byte(0x66);
+    emit_byte(0xd3);
+    emit_byte(0xc0+d);
+}
+LENDFUNC(WRITE,NONE,2,raw_rol_w_rr,(RW2 d, R1 r))
+
+LOWFUNC(WRITE,NONE,2,raw_rol_b_rr,(RW1 d, R1 r))
+{
+    emit_byte(0xd2);
+    emit_byte(0xc0+d);
+}
+LENDFUNC(WRITE,NONE,2,raw_rol_b_rr,(RW1 d, R1 r))
+
+LOWFUNC(WRITE,NONE,2,raw_shll_l_rr,(RW4 d, R1 r))
+{
+    emit_byte(0xd3);
+    emit_byte(0xe0+d);
+}
+LENDFUNC(WRITE,NONE,2,raw_shll_l_rr,(RW4 d, R1 r))
+
+LOWFUNC(WRITE,NONE,2,raw_shll_w_rr,(RW2 d, R1 r))
+{
+    emit_byte(0x66);
+    emit_byte(0xd3);
+    emit_byte(0xe0+d);
+}
+LENDFUNC(WRITE,NONE,2,raw_shll_w_rr,(RW2 d, R1 r))
+
+LOWFUNC(WRITE,NONE,2,raw_shll_b_rr,(RW1 d, R1 r))
+{
+    emit_byte(0xd2);
+    emit_byte(0xe0+d);
+}
+LENDFUNC(WRITE,NONE,2,raw_shll_b_rr,(RW1 d, R1 r))
+
+LOWFUNC(WRITE,NONE,2,raw_ror_b_ri,(RW1 r, IMM i))
+{
+    emit_byte(0xc0);
+    emit_byte(0xc8+r);
+    emit_byte(i);
+}
+LENDFUNC(WRITE,NONE,2,raw_ror_b_ri,(RW1 r, IMM i))
+
+LOWFUNC(WRITE,NONE,2,raw_ror_w_ri,(RW2 r, IMM i))
+{
+    emit_byte(0x66);
+    emit_byte(0xc1);
+    emit_byte(0xc8+r);
+    emit_byte(i);
+}
+LENDFUNC(WRITE,NONE,2,raw_ror_w_ri,(RW2 r, IMM i))
+
+LOWFUNC(WRITE,NONE,2,raw_ror_l_ri,(RW4 r, IMM i))
+{
+    emit_byte(0xc1);
+    emit_byte(0xc8+r);
+    emit_byte(i);
+}
+LENDFUNC(WRITE,NONE,2,raw_ror_l_ri,(RW4 r, IMM i))
+
+LOWFUNC(WRITE,NONE,2,raw_ror_l_rr,(RW4 d, R1 r))
+{
+    emit_byte(0xd3);
+    emit_byte(0xc8+d);
+}
+LENDFUNC(WRITE,NONE,2,raw_ror_l_rr,(RW4 d, R1 r))
+
+LOWFUNC(WRITE,NONE,2,raw_ror_w_rr,(RW2 d, R1 r))
+{
+    emit_byte(0x66);
+    emit_byte(0xd3);
+    emit_byte(0xc8+d);
+}
+LENDFUNC(WRITE,NONE,2,raw_ror_w_rr,(RW2 d, R1 r))
+
+LOWFUNC(WRITE,NONE,2,raw_ror_b_rr,(RW1 d, R1 r))
+{
+    emit_byte(0xd2);
+    emit_byte(0xc8+d);
+}
+LENDFUNC(WRITE,NONE,2,raw_ror_b_rr,(RW1 d, R1 r))
+
+LOWFUNC(WRITE,NONE,2,raw_shrl_l_rr,(RW4 d, R1 r))
+{
+    emit_byte(0xd3);
+    emit_byte(0xe8+d);
+}
+LENDFUNC(WRITE,NONE,2,raw_shrl_l_rr,(RW4 d, R1 r))
+
+LOWFUNC(WRITE,NONE,2,raw_shrl_w_rr,(RW2 d, R1 r))
+{
+    emit_byte(0x66);
+    emit_byte(0xd3);
+    emit_byte(0xe8+d);
+}
+LENDFUNC(WRITE,NONE,2,raw_shrl_w_rr,(RW2 d, R1 r))
+
+LOWFUNC(WRITE,NONE,2,raw_shrl_b_rr,(RW1 d, R1 r))
+{
+    emit_byte(0xd2);
+    emit_byte(0xe8+d);
+}
+LENDFUNC(WRITE,NONE,2,raw_shrl_b_rr,(RW1 d, R1 r))
+
+LOWFUNC(WRITE,NONE,2,raw_shra_l_rr,(RW4 d, R1 r))
+{
+    emit_byte(0xd3);
+    emit_byte(0xf8+d);
+}
+LENDFUNC(WRITE,NONE,2,raw_shra_l_rr,(RW4 d, R1 r))
+
+LOWFUNC(WRITE,NONE,2,raw_shra_w_rr,(RW2 d, R1 r))
+{
+    emit_byte(0x66);
+    emit_byte(0xd3);
+    emit_byte(0xf8+d);
+}
+LENDFUNC(WRITE,NONE,2,raw_shra_w_rr,(RW2 d, R1 r))
+
+LOWFUNC(WRITE,NONE,2,raw_shra_b_rr,(RW1 d, R1 r))
+{
+    emit_byte(0xd2);
+    emit_byte(0xf8+d);
+}
+LENDFUNC(WRITE,NONE,2,raw_shra_b_rr,(RW1 d, R1 r))
+
+LOWFUNC(WRITE,NONE,2,raw_shll_l_ri,(RW4 r, IMM i))
+{
+    emit_byte(0xc1);
+    emit_byte(0xe0+r);
+    emit_byte(i);
+}
+LENDFUNC(WRITE,NONE,2,raw_shll_l_ri,(RW4 r, IMM i))
+
+LOWFUNC(WRITE,NONE,2,raw_shll_w_ri,(RW2 r, IMM i))
+{
+    emit_byte(0x66);
+    emit_byte(0xc1);
+    emit_byte(0xe0+r);
+    emit_byte(i);
+}
+LENDFUNC(WRITE,NONE,2,raw_shll_w_ri,(RW2 r, IMM i))
+
+LOWFUNC(WRITE,NONE,2,raw_shll_b_ri,(RW1 r, IMM i))
+{
+    emit_byte(0xc0);
+    emit_byte(0xe0+r);
+    emit_byte(i);
+}
+LENDFUNC(WRITE,NONE,2,raw_shll_b_ri,(RW1 r, IMM i))
+
+LOWFUNC(WRITE,NONE,2,raw_shrl_l_ri,(RW4 r, IMM i))
+{
+    emit_byte(0xc1);
+    emit_byte(0xe8+r);
+    emit_byte(i);
+}
+LENDFUNC(WRITE,NONE,2,raw_shrl_l_ri,(RW4 r, IMM i))
+
+LOWFUNC(WRITE,NONE,2,raw_shrl_w_ri,(RW2 r, IMM i))
+{
+    emit_byte(0x66);
+    emit_byte(0xc1);
+    emit_byte(0xe8+r);
+    emit_byte(i);
+}
+LENDFUNC(WRITE,NONE,2,raw_shrl_w_ri,(RW2 r, IMM i))
+
+LOWFUNC(WRITE,NONE,2,raw_shrl_b_ri,(RW1 r, IMM i))
+{
+    emit_byte(0xc0);
+    emit_byte(0xe8+r);
+    emit_byte(i);
+}
+LENDFUNC(WRITE,NONE,2,raw_shrl_b_ri,(RW1 r, IMM i))
+
+LOWFUNC(WRITE,NONE,2,raw_shra_l_ri,(RW4 r, IMM i))
+{
+    emit_byte(0xc1);
+    emit_byte(0xf8+r);
+    emit_byte(i);
+}
+LENDFUNC(WRITE,NONE,2,raw_shra_l_ri,(RW4 r, IMM i))
+
+LOWFUNC(WRITE,NONE,2,raw_shra_w_ri,(RW2 r, IMM i))
+{
+    emit_byte(0x66);
+    emit_byte(0xc1);
+    emit_byte(0xf8+r);
+    emit_byte(i);
+}
+LENDFUNC(WRITE,NONE,2,raw_shra_w_ri,(RW2 r, IMM i))
+
+LOWFUNC(WRITE,NONE,2,raw_shra_b_ri,(RW1 r, IMM i))
+{
+    emit_byte(0xc0);
+    emit_byte(0xf8+r);
+    emit_byte(i);
+}
+LENDFUNC(WRITE,NONE,2,raw_shra_b_ri,(RW1 r, IMM i))
+
+LOWFUNC(WRITE,NONE,1,raw_sahf,(R2 dummy_ah))
+{
+    emit_byte(0x9e);
+}
+LENDFUNC(WRITE,NONE,1,raw_sahf,(R2 dummy_ah))
+
+LOWFUNC(NONE,NONE,1,raw_cpuid,(R4 dummy_eax))
+{
+    emit_byte(0x0f);
+    emit_byte(0xa2);
+}
+LENDFUNC(NONE,NONE,1,raw_cpuid,(R4 dummy_eax))
+
+LOWFUNC(READ,NONE,1,raw_lahf,(W2 dummy_ah))
+{
+    emit_byte(0x9f);
+}
+LENDFUNC(READ,NONE,1,raw_lahf,(W2 dummy_ah))
+
+LOWFUNC(READ,NONE,2,raw_setcc,(W1 d, IMM cc))
+{
+    emit_byte(0x0f);
+    emit_byte(0x90+cc);
+    emit_byte(0xc0+d);
+}
+LENDFUNC(READ,NONE,2,raw_setcc,(W1 d, IMM cc))
+
+LOWFUNC(READ,WRITE,2,raw_setcc_m,(MEMW d, IMM cc))
+{
+    emit_byte(0x0f);
+    emit_byte(0x90+cc);
+    emit_byte(0x05);
+    emit_long(d);
+}
+LENDFUNC(READ,WRITE,2,raw_setcc_m,(MEMW d, IMM cc))
+
+LOWFUNC(READ,NONE,3,raw_cmov_l_rr,(RW4 d, R4 s, IMM cc))
+{
+    if (have_cmov) {
+	emit_byte(0x0f);
+	emit_byte(0x40+cc);
+	emit_byte(0xc0+8*d+s);
+    }
+    else { /* replacement using branch and mov */
+	int uncc=(cc^1);
+	emit_byte(0x70+uncc); 
+	emit_byte(2);  /* skip next 2 bytes if not cc=true */
+	emit_byte(0x89);
+	emit_byte(0xc0+8*s+d);
+    }
+}
+LENDFUNC(READ,NONE,3,raw_cmov_l_rr,(RW4 d, R4 s, IMM cc))
+
+LOWFUNC(WRITE,NONE,2,raw_bsf_l_rr,(W4 d, R4 s))
+{
+    emit_byte(0x0f);
+    emit_byte(0xbc);
+    emit_byte(0xc0+8*d+s);
+}
+LENDFUNC(WRITE,NONE,2,raw_bsf_l_rr,(W4 d, R4 s))
+
+LOWFUNC(NONE,NONE,2,raw_sign_extend_16_rr,(W4 d, R2 s))
+{
+    emit_byte(0x0f);
+    emit_byte(0xbf);
+    emit_byte(0xc0+8*d+s);
+}
+LENDFUNC(NONE,NONE,2,raw_sign_extend_16_rr,(W4 d, R2 s))
+
+LOWFUNC(NONE,NONE,2,raw_sign_extend_8_rr,(W4 d, R1 s))
+{
+    emit_byte(0x0f);
+    emit_byte(0xbe);
+    emit_byte(0xc0+8*d+s);
+}
+LENDFUNC(NONE,NONE,2,raw_sign_extend_8_rr,(W4 d, R1 s))
+
+LOWFUNC(NONE,NONE,2,raw_zero_extend_16_rr,(W4 d, R2 s))
+{
+    emit_byte(0x0f);
+    emit_byte(0xb7);
+    emit_byte(0xc0+8*d+s);
+}
+LENDFUNC(NONE,NONE,2,raw_zero_extend_16_rr,(W4 d, R2 s))
+
+LOWFUNC(NONE,NONE,2,raw_zero_extend_8_rr,(W4 d, R1 s))
+{
+    emit_byte(0x0f);
+    emit_byte(0xb6);
+    emit_byte(0xc0+8*d+s);
+}
+LENDFUNC(NONE,NONE,2,raw_zero_extend_8_rr,(W4 d, R1 s))
+
+LOWFUNC(NONE,NONE,2,raw_imul_32_32,(RW4 d, R4 s))
+{
+    emit_byte(0x0f);
+    emit_byte(0xaf);
+    emit_byte(0xc0+8*d+s);
+}
+LENDFUNC(NONE,NONE,2,raw_imul_32_32,(RW4 d, R4 s))
+
+LOWFUNC(NONE,NONE,2,raw_imul_64_32,(RW4 d, RW4 s))
+{
+    if (d!=MUL_NREG1 || s!=MUL_NREG2)
+	abort();
+    emit_byte(0xf7);
+    emit_byte(0xea);
+}
+LENDFUNC(NONE,NONE,2,raw_imul_64_32,(RW4 d, RW4 s))
+
+LOWFUNC(NONE,NONE,2,raw_mul_64_32,(RW4 d, RW4 s))
+{
+    if (d!=MUL_NREG1 || s!=MUL_NREG2) {
+	printf("Bad register in MUL: d=%d, s=%d\n",d,s);
+	abort();
+    }
+    emit_byte(0xf7);
+    emit_byte(0xe2);
+}
+LENDFUNC(NONE,NONE,2,raw_mul_64_32,(RW4 d, RW4 s))
+
+LOWFUNC(NONE,NONE,2,raw_mul_32_32,(RW4 d, R4 s))
+{
+    abort(); /* %^$&%^$%#^ x86! */
+    emit_byte(0x0f);
+    emit_byte(0xaf);
+    emit_byte(0xc0+8*d+s);
+}
+LENDFUNC(NONE,NONE,2,raw_mul_32_32,(RW4 d, R4 s))
+
+LOWFUNC(NONE,NONE,2,raw_mov_b_rr,(W1 d, R1 s))
+{
+    emit_byte(0x88);
+    emit_byte(0xc0+8*s+d);
+}
+LENDFUNC(NONE,NONE,2,raw_mov_b_rr,(W1 d, R1 s))
+
+LOWFUNC(NONE,NONE,2,raw_mov_w_rr,(W2 d, R2 s))
+{
+    emit_byte(0x66);
+    emit_byte(0x89);
+    emit_byte(0xc0+8*s+d);
+}
+LENDFUNC(NONE,NONE,2,raw_mov_w_rr,(W2 d, R2 s))
+
+LOWFUNC(NONE,READ,4,raw_mov_l_rrm_indexed,(W4 d,R4 baser, R4 index, IMM factor))
+{
+    int isebp=(baser==5)?0x40:0;
+    int fi;
+    
+    switch(factor) {
+     case 1: fi=0; break;
+     case 2: fi=1; break;
+     case 4: fi=2; break;
+     case 8: fi=3; break;
+     default: abort();
+    }
+
+
+    emit_byte(0x8b);
+    emit_byte(0x04+8*d+isebp);
+    emit_byte(baser+8*index+0x40*fi);
+    if (isebp)
+	emit_byte(0x00);
+}
+LENDFUNC(NONE,READ,4,raw_mov_l_rrm_indexed,(W4 d,R4 baser, R4 index, IMM factor))
+
+LOWFUNC(NONE,READ,4,raw_mov_w_rrm_indexed,(W2 d, R4 baser, R4 index, IMM factor))
+{
+    int fi;
+    int isebp;
+    
+    switch(factor) {
+     case 1: fi=0; break;
+     case 2: fi=1; break;
+     case 4: fi=2; break;
+     case 8: fi=3; break;
+     default: abort();
+    }
+    isebp=(baser==5)?0x40:0;
+    
+    emit_byte(0x66);
+    emit_byte(0x8b);
+    emit_byte(0x04+8*d+isebp);
+    emit_byte(baser+8*index+0x40*fi);
+    if (isebp)
+	emit_byte(0x00);
+}
+LENDFUNC(NONE,READ,4,raw_mov_w_rrm_indexed,(W2 d, R4 baser, R4 index, IMM factor))
+
+LOWFUNC(NONE,READ,4,raw_mov_b_rrm_indexed,(W1 d, R4 baser, R4 index, IMM factor))
+{
+   int fi;
+  int isebp;
+
+  switch(factor) {
+  case 1: fi=0; break;
+  case 2: fi=1; break;
+  case 4: fi=2; break;
+  case 8: fi=3; break;
+  default: abort();
+  }
+  isebp=(baser==5)?0x40:0;
+
+   emit_byte(0x8a);
+    emit_byte(0x04+8*d+isebp);
+    emit_byte(baser+8*index+0x40*fi);
+    if (isebp)
+	emit_byte(0x00);
+}
+LENDFUNC(NONE,READ,4,raw_mov_b_rrm_indexed,(W1 d, R4 baser, R4 index, IMM factor))
+
+LOWFUNC(NONE,WRITE,4,raw_mov_l_mrr_indexed,(R4 baser, R4 index, IMM factor, R4 s))
+{
+  int fi;
+  int isebp;
+
+  switch(factor) {
+  case 1: fi=0; break;
+  case 2: fi=1; break;
+  case 4: fi=2; break;
+  case 8: fi=3; break;
+  default: abort();
+  }
+
+  
+  isebp=(baser==5)?0x40:0;
+
+    emit_byte(0x89);
+    emit_byte(0x04+8*s+isebp);
+    emit_byte(baser+8*index+0x40*fi);
+    if (isebp)
+	emit_byte(0x00);
+}
+LENDFUNC(NONE,WRITE,4,raw_mov_l_mrr_indexed,(R4 baser, R4 index, IMM factor, R4 s))
+
+LOWFUNC(NONE,WRITE,4,raw_mov_w_mrr_indexed,(R4 baser, R4 index, IMM factor, R2 s))
+{
+  int fi;
+  int isebp;
+
+  switch(factor) {
+  case 1: fi=0; break;
+  case 2: fi=1; break;
+  case 4: fi=2; break;
+  case 8: fi=3; break;
+  default: abort();
+  }
+  isebp=(baser==5)?0x40:0;
+
+    emit_byte(0x66);
+    emit_byte(0x89);
+    emit_byte(0x04+8*s+isebp);
+    emit_byte(baser+8*index+0x40*fi);
+    if (isebp)
+	emit_byte(0x00);
+}
+LENDFUNC(NONE,WRITE,4,raw_mov_w_mrr_indexed,(R4 baser, R4 index, IMM factor, R2 s))
+
+LOWFUNC(NONE,WRITE,4,raw_mov_b_mrr_indexed,(R4 baser, R4 index, IMM factor, R1 s))
+{
+  int fi;
+  int isebp;
+
+  switch(factor) {
+  case 1: fi=0; break;
+  case 2: fi=1; break;
+  case 4: fi=2; break;
+  case 8: fi=3; break;
+  default: abort();
+  }
+  isebp=(baser==5)?0x40:0;
+
+    emit_byte(0x88);
+    emit_byte(0x04+8*s+isebp);
+    emit_byte(baser+8*index+0x40*fi);
+    if (isebp)
+	emit_byte(0x00);
+}
+LENDFUNC(NONE,WRITE,4,raw_mov_b_mrr_indexed,(R4 baser, R4 index, IMM factor, R1 s))
+
+LOWFUNC(NONE,WRITE,5,raw_mov_l_bmrr_indexed,(IMM base, R4 baser, R4 index, IMM factor, R4 s))
+{
+  int fi;
+
+  switch(factor) {
+  case 1: fi=0; break;
+  case 2: fi=1; break;
+  case 4: fi=2; break;
+  case 8: fi=3; break;
+  default: abort();
+  }
+
+    emit_byte(0x89);
+    emit_byte(0x84+8*s);
+    emit_byte(baser+8*index+0x40*fi);
+    emit_long(base);
+}
+LENDFUNC(NONE,WRITE,5,raw_mov_l_bmrr_indexed,(IMM base, R4 baser, R4 index, IMM factor, R4 s))
+
+LOWFUNC(NONE,WRITE,5,raw_mov_w_bmrr_indexed,(IMM base, R4 baser, R4 index, IMM factor, R2 s))
+{
+  int fi;
+
+  switch(factor) {
+  case 1: fi=0; break;
+  case 2: fi=1; break;
+  case 4: fi=2; break;
+  case 8: fi=3; break;
+  default: abort();
+  }
+
+    emit_byte(0x66);
+    emit_byte(0x89);
+    emit_byte(0x84+8*s);
+    emit_byte(baser+8*index+0x40*fi);
+    emit_long(base);
+}
+LENDFUNC(NONE,WRITE,5,raw_mov_w_bmrr_indexed,(IMM base, R4 baser, R4 index, IMM factor, R2 s))
+
+LOWFUNC(NONE,WRITE,5,raw_mov_b_bmrr_indexed,(IMM base, R4 baser, R4 index, IMM factor, R1 s))
+{
+  int fi;
+
+  switch(factor) {
+  case 1: fi=0; break;
+  case 2: fi=1; break;
+  case 4: fi=2; break;
+  case 8: fi=3; break;
+  default: abort();
+  }
+
+    emit_byte(0x88);
+    emit_byte(0x84+8*s);
+    emit_byte(baser+8*index+0x40*fi);
+    emit_long(base);
+}
+LENDFUNC(NONE,WRITE,5,raw_mov_b_bmrr_indexed,(IMM base, R4 baser, R4 index, IMM factor, R1 s))
+
+LOWFUNC(NONE,READ,5,raw_mov_l_brrm_indexed,(W4 d, IMM base, R4 baser, R4 index, IMM factor))
+{
+  int fi;
+
+  switch(factor) {
+  case 1: fi=0; break;
+  case 2: fi=1; break;
+  case 4: fi=2; break;
+  case 8: fi=3; break;
+  default: abort();
+  }
+
+    emit_byte(0x8b);
+    emit_byte(0x84+8*d);
+    emit_byte(baser+8*index+0x40*fi);
+    emit_long(base);
+}
+LENDFUNC(NONE,READ,5,raw_mov_l_brrm_indexed,(W4 d, IMM base, R4 baser, R4 index, IMM factor))
+
+LOWFUNC(NONE,READ,5,raw_mov_w_brrm_indexed,(W2 d, IMM base, R4 baser, R4 index, IMM factor))
+{
+  int fi;
+
+  switch(factor) {
+  case 1: fi=0; break;
+  case 2: fi=1; break;
+  case 4: fi=2; break;
+  case 8: fi=3; break;
+  default: abort();
+  }
+
+    emit_byte(0x66);
+    emit_byte(0x8b);
+    emit_byte(0x84+8*d);
+    emit_byte(baser+8*index+0x40*fi);
+    emit_long(base);
+}
+LENDFUNC(NONE,READ,5,raw_mov_w_brrm_indexed,(W2 d, IMM base, R4 baser, R4 index, IMM factor))
+
+LOWFUNC(NONE,READ,5,raw_mov_b_brrm_indexed,(W1 d, IMM base, R4 baser, R4 index, IMM factor))
+{
+  int fi;
+
+  switch(factor) {
+  case 1: fi=0; break;
+  case 2: fi=1; break;
+  case 4: fi=2; break;
+  case 8: fi=3; break;
+  default: abort();
+  }
+
+    emit_byte(0x8a);
+    emit_byte(0x84+8*d);
+    emit_byte(baser+8*index+0x40*fi);
+    emit_long(base);
+}
+LENDFUNC(NONE,READ,5,raw_mov_b_brrm_indexed,(W1 d, IMM base, R4 baser, R4 index, IMM factor))
+
+LOWFUNC(NONE,READ,4,raw_mov_l_rm_indexed,(W4 d, IMM base, R4 index, IMM factor))
+{
+  int fi;
+  switch(factor) {
+  case 1: fi=0; break;
+  case 2: fi=1; break;
+  case 4: fi=2; break;
+  case 8: fi=3; break;
+  default: 
+    fprintf(stderr,"Bad factor %d in mov_l_rm_indexed!\n",factor);
+    abort();
+  }
+    emit_byte(0x8b);
+    emit_byte(0x04+8*d);
+    emit_byte(0x05+8*index+64*fi);
+    emit_long(base);
+}
+LENDFUNC(NONE,READ,4,raw_mov_l_rm_indexed,(W4 d, IMM base, R4 index, IMM factor))
+
+LOWFUNC(NONE,READ,5,raw_cmov_l_rm_indexed,(W4 d, IMM base, R4 index, IMM factor, IMM cond))
+{
+    int fi;
+    switch(factor) {
+     case 1: fi=0; break;
+     case 2: fi=1; break;
+     case 4: fi=2; break;
+     case 8: fi=3; break;
+     default: 
+	fprintf(stderr,"Bad factor %d in mov_l_rm_indexed!\n",factor);
+	abort();
+    }
+    if (have_cmov) {
+	emit_byte(0x0f);
+	emit_byte(0x40+cond);
+	emit_byte(0x04+8*d);
+	emit_byte(0x05+8*index+64*fi);
+	emit_long(base);
+    }
+    else { /* replacement using branch and mov */
+	int uncc=(cond^1);
+	emit_byte(0x70+uncc); 
+	emit_byte(7);  /* skip next 7 bytes if not cc=true */
+	emit_byte(0x8b);
+	emit_byte(0x04+8*d);
+	emit_byte(0x05+8*index+64*fi);
+	emit_long(base);
+    }
+}
+LENDFUNC(NONE,READ,5,raw_cmov_l_rm_indexed,(W4 d, IMM base, R4 index, IMM factor, IMM cond))
+
+LOWFUNC(NONE,READ,3,raw_cmov_l_rm,(W4 d, IMM mem, IMM cond))
+{
+    if (have_cmov) {
+	emit_byte(0x0f);
+	emit_byte(0x40+cond);
+	emit_byte(0x05+8*d);
+	emit_long(mem);
+    }
+    else { /* replacement using branch and mov */
+	int uncc=(cond^1);
+	emit_byte(0x70+uncc); 
+	emit_byte(6);  /* skip next 6 bytes if not cc=true */
+	emit_byte(0x8b);
+	emit_byte(0x05+8*d);
+	emit_long(mem);
+    }
+}
+LENDFUNC(NONE,READ,3,raw_cmov_l_rm,(W4 d, IMM mem, IMM cond))
+
+LOWFUNC(NONE,READ,3,raw_mov_l_rR,(W4 d, R4 s, IMM offset))
+{
+    emit_byte(0x8b);
+    emit_byte(0x40+8*d+s);
+    emit_byte(offset);
+}
+LENDFUNC(NONE,READ,3,raw_mov_l_rR,(W4 d, R4 s, IMM offset))
+
+LOWFUNC(NONE,READ,3,raw_mov_w_rR,(W2 d, R4 s, IMM offset))
+{
+    emit_byte(0x66);
+    emit_byte(0x8b);
+    emit_byte(0x40+8*d+s);
+    emit_byte(offset);
+}
+LENDFUNC(NONE,READ,3,raw_mov_w_rR,(W2 d, R4 s, IMM offset))
+
+LOWFUNC(NONE,READ,3,raw_mov_b_rR,(W1 d, R4 s, IMM offset))
+{
+    emit_byte(0x8a);
+    emit_byte(0x40+8*d+s);
+    emit_byte(offset);
+}
+LENDFUNC(NONE,READ,3,raw_mov_b_rR,(W1 d, R4 s, IMM offset))
+
+LOWFUNC(NONE,READ,3,raw_mov_l_rR_gs,(W4 d, R4 s, IMM offset))
+{
+    emit_byte(0x65);
+    emit_byte(0x8b);
+    emit_byte(0x40+8*d+s);
+    emit_byte(offset);
+}
+LENDFUNC(NONE,READ,3,raw_mov_l_rR_gs,(W4 d, R4 s, IMM offset))
+
+LOWFUNC(NONE,READ,3,raw_mov_w_rR_gs,(W2 d, R4 s, IMM offset))
+{
+    emit_byte(0x65);
+    emit_byte(0x66);
+    emit_byte(0x8b);
+    emit_byte(0x40+8*d+s);
+    emit_byte(offset);
+}
+LENDFUNC(NONE,READ,3,raw_mov_w_rR_gs,(W2 d, R4 s, IMM offset))
+
+LOWFUNC(NONE,READ,3,raw_mov_b_rR_gs,(W1 d, R4 s, IMM offset))
+{
+    emit_byte(0x65);
+    emit_byte(0x8a);
+    emit_byte(0x40+8*d+s);
+    emit_byte(offset);
+}
+LENDFUNC(NONE,READ,3,raw_mov_b_rR_gs,(W1 d, R4 s, IMM offset))
+
+LOWFUNC(NONE,READ,3,raw_mov_l_brR,(W4 d, R4 s, IMM offset))
+{
+    emit_byte(0x8b);
+    emit_byte(0x80+8*d+s);
+    emit_long(offset);
+}
+LENDFUNC(NONE,READ,3,raw_mov_l_brR,(W4 d, R4 s, IMM offset))
+
+LOWFUNC(NONE,READ,3,raw_mov_w_brR,(W2 d, R4 s, IMM offset))
+{
+    emit_byte(0x66);
+    emit_byte(0x8b);
+    emit_byte(0x80+8*d+s);
+    emit_long(offset);
+}
+LENDFUNC(NONE,READ,3,raw_mov_w_brR,(W2 d, R4 s, IMM offset))
+
+LOWFUNC(NONE,READ,3,raw_mov_b_brR,(W1 d, R4 s, IMM offset))
+{
+    emit_byte(0x8a);
+    emit_byte(0x80+8*d+s);
+    emit_long(offset);
+}
+LENDFUNC(NONE,READ,3,raw_mov_b_brR,(W1 d, R4 s, IMM offset))
+
+LOWFUNC(NONE,READ,3,raw_mov_l_brR_gs,(W4 d, R4 s, IMM offset))
+{
+    emit_byte(0x65);
+    emit_byte(0x8b);
+    emit_byte(0x80+8*d+s);
+    emit_long(offset);
+}
+LENDFUNC(NONE,READ,3,raw_mov_l_brR_gs,(W4 d, R4 s, IMM offset))
+
+LOWFUNC(NONE,READ,3,raw_mov_w_brR_gs,(W2 d, R4 s, IMM offset))
+{
+    emit_byte(0x65);
+    emit_byte(0x66);
+    emit_byte(0x8b);
+    emit_byte(0x80+8*d+s);
+    emit_long(offset);
+}
+LENDFUNC(NONE,READ,3,raw_mov_w_brR_gs,(W2 d, R4 s, IMM offset))
+
+LOWFUNC(NONE,READ,3,raw_mov_b_brR_gs,(W1 d, R4 s, IMM offset))
+{
+    emit_byte(0x65);
+    emit_byte(0x8a);
+    emit_byte(0x80+8*d+s);
+    emit_long(offset);
+}
+LENDFUNC(NONE,READ,3,raw_mov_b_brR_gs,(W1 d, R4 s, IMM offset))
+
+LOWFUNC(NONE,WRITE,3,raw_mov_l_Ri,(R4 d, IMM i, IMM offset))
+{
+    emit_byte(0xc7);
+    emit_byte(0x40+d);
+    emit_byte(offset);
+    emit_long(i);
+}
+LENDFUNC(NONE,WRITE,3,raw_mov_l_Ri,(R4 d, IMM i, IMM offset))
+
+LOWFUNC(NONE,WRITE,3,raw_mov_w_Ri,(R4 d, IMM i, IMM offset))
+{
+    emit_byte(0x66);
+    emit_byte(0xc7);
+    emit_byte(0x40+d);
+    emit_byte(offset);
+    emit_word(i);
+}
+LENDFUNC(NONE,WRITE,3,raw_mov_w_Ri,(R4 d, IMM i, IMM offset))
+
+LOWFUNC(NONE,WRITE,3,raw_mov_b_Ri,(R4 d, IMM i, IMM offset))
+{
+    emit_byte(0xc6);
+    emit_byte(0x40+d);
+    emit_byte(offset);
+    emit_byte(i);
+}
+LENDFUNC(NONE,WRITE,3,raw_mov_b_Ri,(R4 d, IMM i, IMM offset))
+
+LOWFUNC(NONE,WRITE,3,raw_mov_l_Rr,(R4 d, R4 s, IMM offset))
+{
+    emit_byte(0x89);
+    emit_byte(0x40+8*s+d);
+    emit_byte(offset);
+}
+LENDFUNC(NONE,WRITE,3,raw_mov_l_Rr,(R4 d, R4 s, IMM offset))
+
+LOWFUNC(NONE,WRITE,3,raw_mov_w_Rr,(R4 d, R2 s, IMM offset))
+{
+    emit_byte(0x66);
+    emit_byte(0x89);
+    emit_byte(0x40+8*s+d);
+    emit_byte(offset);
+}
+LENDFUNC(NONE,WRITE,3,raw_mov_w_Rr,(R4 d, R2 s, IMM offset))
+
+LOWFUNC(NONE,WRITE,3,raw_mov_b_Rr,(R4 d, R1 s, IMM offset))
+{
+    emit_byte(0x88);
+    emit_byte(0x40+8*s+d);
+    emit_byte(offset);
+}
+LENDFUNC(NONE,WRITE,3,raw_mov_b_Rr,(R4 d, R1 s, IMM offset))
+
+LOWFUNC(NONE,WRITE,3,raw_mov_l_Rr_gs,(R4 d, R4 s, IMM offset))
+{
+    emit_byte(0x65);
+    emit_byte(0x89);
+    emit_byte(0x40+8*s+d);
+    emit_byte(offset);
+}
+LENDFUNC(NONE,WRITE,3,raw_mov_l_Rr_gs,(R4 d, R4 s, IMM offset))
+
+LOWFUNC(NONE,WRITE,3,raw_mov_w_Rr_gs,(R4 d, R2 s, IMM offset))
+{
+    emit_byte(0x65);
+    emit_byte(0x66);
+    emit_byte(0x89);
+    emit_byte(0x40+8*s+d);
+    emit_byte(offset);
+}
+LENDFUNC(NONE,WRITE,3,raw_mov_w_Rr_gs,(R4 d, R2 s, IMM offset))
+
+LOWFUNC(NONE,WRITE,3,raw_mov_b_Rr_gs,(R4 d, R1 s, IMM offset))
+{
+    emit_byte(0x65);
+    emit_byte(0x88);
+    emit_byte(0x40+8*s+d);
+    emit_byte(offset);
+}
+LENDFUNC(NONE,WRITE,3,raw_mov_b_Rr_gs,(R4 d, R1 s, IMM offset))
+
+LOWFUNC(NONE,NONE,3,raw_lea_l_brr,(W4 d, R4 s, IMM offset))
+{
+    emit_byte(0x8d);
+    emit_byte(0x80+8*d+s);
+    emit_long(offset);
+}
+LENDFUNC(NONE,NONE,3,raw_lea_l_brr,(W4 d, R4 s, IMM offset))
+
+LOWFUNC(NONE,NONE,5,raw_lea_l_brr_indexed,(W4 d, R4 s, R4 index, IMM factor, IMM offset))
+{
+  int fi;
+  
+  switch(factor) {
+  case 1: fi=0; break;
+  case 2: fi=1; break;
+  case 4: fi=2; break;
+  case 8: fi=3; break;
+  default: abort();
+  }
+
+    emit_byte(0x8d);
+    emit_byte(0x84+8*d);
+    emit_byte(0x40*fi+8*index+s);
+    emit_long(offset);
+}
+LENDFUNC(NONE,NONE,5,raw_lea_l_brr_indexed,(W4 d, R4 s, R4 index, IMM factor, IMM offset))
+
+LOWFUNC(NONE,NONE,4,raw_lea_l_rr_indexed,(W4 d, R4 s, R4 index, IMM factor))
+{
+  int isebp=(s==5)?0x40:0;
+  int fi;
+  
+  switch(factor) {
+  case 1: fi=0; break;
+  case 2: fi=1; break;
+  case 4: fi=2; break;
+  case 8: fi=3; break;
+  default: abort();
+  }
+
+    emit_byte(0x8d);
+    emit_byte(0x04+8*d+isebp);
+    emit_byte(0x40*fi+8*index+s);
+    if (isebp)
+      emit_byte(0);
+}
+LENDFUNC(NONE,NONE,4,raw_lea_l_rr_indexed,(W4 d, R4 s, R4 index, IMM factor))
+
+LOWFUNC(NONE,WRITE,3,raw_mov_l_bRr,(R4 d, R4 s, IMM offset))
+{
+    emit_byte(0x89);
+    emit_byte(0x80+8*s+d);
+    emit_long(offset);
+}
+LENDFUNC(NONE,WRITE,3,raw_mov_l_bRr,(R4 d, R4 s, IMM offset))
+
+LOWFUNC(NONE,WRITE,3,raw_mov_w_bRr,(R4 d, R2 s, IMM offset))
+{
+    emit_byte(0x66);
+    emit_byte(0x89);
+    emit_byte(0x80+8*s+d);
+    emit_long(offset);
+}
+LENDFUNC(NONE,WRITE,3,raw_mov_w_bRr,(R4 d, R2 s, IMM offset))
+
+LOWFUNC(NONE,WRITE,3,raw_mov_b_bRr,(R4 d, R1 s, IMM offset))
+{
+    emit_byte(0x88);
+    emit_byte(0x80+8*s+d);
+    emit_long(offset);
+}
+LENDFUNC(NONE,WRITE,3,raw_mov_b_bRr,(R4 d, R1 s, IMM offset))
+
+LOWFUNC(NONE,WRITE,3,raw_mov_l_bRr_gs,(R4 d, R4 s, IMM offset))
+{
+    emit_byte(0x65);
+    emit_byte(0x89);
+    emit_byte(0x80+8*s+d);
+    emit_long(offset);
+}
+LENDFUNC(NONE,WRITE,3,raw_mov_l_bRr_gs,(R4 d, R4 s, IMM offset))
+
+LOWFUNC(NONE,WRITE,3,raw_mov_w_bRr_gs,(R4 d, R2 s, IMM offset))
+{
+    emit_byte(0x65);
+    emit_byte(0x66);
+    emit_byte(0x89);
+    emit_byte(0x80+8*s+d);
+    emit_long(offset);
+}
+LENDFUNC(NONE,WRITE,3,raw_mov_w_bRr_gs,(R4 d, R2 s, IMM offset))
+
+LOWFUNC(NONE,WRITE,3,raw_mov_b_bRr_gs,(R4 d, R1 s, IMM offset))
+{
+    emit_byte(0x65);
+    emit_byte(0x88);
+    emit_byte(0x80+8*s+d);
+    emit_long(offset);
+}
+LENDFUNC(NONE,WRITE,3,raw_mov_b_bRr_gs,(R4 d, R1 s, IMM offset))
+
+LOWFUNC(NONE,NONE,1,raw_bswap_32,(RW4 r))
+{
+    emit_byte(0x0f);
+    emit_byte(0xc8+r);
+}
+LENDFUNC(NONE,NONE,1,raw_bswap_32,(RW4 r))
+
+LOWFUNC(WRITE,NONE,1,raw_bswap_16,(RW2 r))
+{
+    emit_byte(0x66);
+    emit_byte(0xc1);
+    emit_byte(0xc0+r);
+    emit_byte(0x08);
+}
+LENDFUNC(WRITE,NONE,1,raw_bswap_16,(RW2 r))
+
+LOWFUNC(NONE,NONE,2,raw_mov_l_rr,(W4 d, R4 s))
+{
+    emit_byte(0x89);
+    emit_byte(0xc0+8*s+d);
+}
+LENDFUNC(NONE,NONE,2,raw_mov_l_rr,(W4 d, R4 s))
+
+LOWFUNC(NONE,WRITE,2,raw_mov_l_mr,(IMM d, R4 s))
+{
+    emit_byte(0x89);
+    emit_byte(0x05+8*s);
+    emit_long(d);
+}
+LENDFUNC(NONE,WRITE,2,raw_mov_l_mr,(IMM d, R4 s))
+
+LOWFUNC(NONE,READ,2,raw_mov_l_rm,(W4 d, MEMR s))
+{
+    emit_byte(0x8b);
+    emit_byte(0x05+8*d);
+    emit_long(s);
+}
+LENDFUNC(NONE,READ,2,raw_mov_l_rm,(W4 d, MEMR s))
+
+LOWFUNC(NONE,WRITE,2,raw_mov_w_mr,(IMM d, R2 s))
+{
+    emit_byte(0x66);
+    emit_byte(0x89);
+    emit_byte(0x05+8*s);
+    emit_long(d);
+}
+LENDFUNC(NONE,WRITE,2,raw_mov_w_mr,(IMM d, R2 s))
+
+LOWFUNC(NONE,READ,2,raw_mov_w_rm,(W2 d, IMM s))
+{
+    emit_byte(0x66);
+    emit_byte(0x8b);
+    emit_byte(0x05+8*d);
+    emit_long(s);
+}
+LENDFUNC(NONE,READ,2,raw_mov_w_rm,(W2 d, IMM s))
+
+LOWFUNC(NONE,WRITE,2,raw_mov_b_mr,(IMM d, R1 s))
+{
+    emit_byte(0x88);
+    emit_byte(0x05+8*s);
+    emit_long(d);
+}
+LENDFUNC(NONE,WRITE,2,raw_mov_b_mr,(IMM d, R1 s))
+
+LOWFUNC(NONE,READ,2,raw_mov_b_rm,(W1 d, IMM s))
+{
+    emit_byte(0x8a);
+    emit_byte(0x05+8*d);
+    emit_long(s);
+}
+LENDFUNC(NONE,READ,2,raw_mov_b_rm,(W1 d, IMM s))
+
+LOWFUNC(NONE,NONE,2,raw_mov_l_ri,(W4 d, IMM s))
+{
+    emit_byte(0xb8+d);
+    emit_long(s);
+}
+LENDFUNC(NONE,NONE,2,raw_mov_l_ri,(W4 d, IMM s))
+
+LOWFUNC(NONE,NONE,2,raw_mov_w_ri,(W2 d, IMM s))
+{
+    emit_byte(0x66);
+    emit_byte(0xb8+d);
+    emit_word(s);
+}
+LENDFUNC(NONE,NONE,2,raw_mov_w_ri,(W2 d, IMM s))
+
+LOWFUNC(NONE,NONE,2,raw_mov_b_ri,(W1 d, IMM s))
+{
+    emit_byte(0xb0+d);
+    emit_byte(s);
+}
+LENDFUNC(NONE,NONE,2,raw_mov_b_ri,(W1 d, IMM s))
+
+LOWFUNC(RMW,RMW,2,raw_adc_l_mi,(MEMRW d, IMM s))
+{
+    emit_byte(0x81);
+    emit_byte(0x15);
+    emit_long(d);
+    emit_long(s);
+}
+LENDFUNC(RMW,RMW,2,raw_adc_l_mi,(MEMRW d, IMM s))
+
+LOWFUNC(WRITE,RMW,2,raw_add_l_mi,(IMM d, IMM s)) 
+{
+    emit_byte(0x81);
+    emit_byte(0x05);
+    emit_long(d);
+    emit_long(s);
+}
+LENDFUNC(WRITE,RMW,2,raw_add_l_mi,(IMM d, IMM s)) 
+
+LOWFUNC(WRITE,RMW,2,raw_add_w_mi,(IMM d, IMM s)) 
+{
+    emit_byte(0x66);
+    emit_byte(0x81);
+    emit_byte(0x05);
+    emit_long(d);
+    emit_word(s);
+}
+LENDFUNC(WRITE,RMW,2,raw_add_w_mi,(IMM d, IMM s)) 
+
+LOWFUNC(WRITE,RMW,2,raw_add_b_mi,(IMM d, IMM s)) 
+{
+    emit_byte(0x80);
+    emit_byte(0x05);
+    emit_long(d);
+    emit_byte(s);
+}
+LENDFUNC(WRITE,RMW,2,raw_add_b_mi,(IMM d, IMM s)) 
+
+LOWFUNC(WRITE,NONE,2,raw_test_l_ri,(R4 d, IMM i))
+{
+    emit_byte(0xf7);
+    emit_byte(0xc0+d);
+    emit_long(i);
+}
+LENDFUNC(WRITE,NONE,2,raw_test_l_ri,(R4 d, IMM i))
+
+LOWFUNC(WRITE,NONE,2,raw_test_l_rr,(R4 d, R4 s))
+{
+    emit_byte(0x85);
+    emit_byte(0xc0+8*s+d);
+}
+LENDFUNC(WRITE,NONE,2,raw_test_l_rr,(R4 d, R4 s))
+
+LOWFUNC(WRITE,NONE,2,raw_test_w_rr,(R2 d, R2 s))
+{
+    emit_byte(0x66);
+    emit_byte(0x85);
+    emit_byte(0xc0+8*s+d);
+}
+LENDFUNC(WRITE,NONE,2,raw_test_w_rr,(R2 d, R2 s))
+
+LOWFUNC(WRITE,NONE,2,raw_test_b_rr,(R1 d, R1 s))
+{
+    emit_byte(0x84);
+    emit_byte(0xc0+8*s+d);
+}
+LENDFUNC(WRITE,NONE,2,raw_test_b_rr,(R1 d, R1 s))
+
+LOWFUNC(WRITE,NONE,2,raw_and_l_ri,(RW4 d, IMM i))
+{
+    emit_byte(0x81);
+    emit_byte(0xe0+d);
+    emit_long(i);
+}
+LENDFUNC(WRITE,NONE,2,raw_and_l_ri,(RW4 d, IMM i))
+
+LOWFUNC(WRITE,NONE,2,raw_and_w_ri,(RW2 d, IMM i))
+{
+    emit_byte(0x66);
+    emit_byte(0x81);
+    emit_byte(0xe0+d);
+    emit_word(i);
+}
+LENDFUNC(WRITE,NONE,2,raw_and_w_ri,(RW2 d, IMM i))
+
+LOWFUNC(WRITE,NONE,2,raw_and_l,(RW4 d, R4 s))
+{
+    emit_byte(0x21);
+    emit_byte(0xc0+8*s+d);
+}
+LENDFUNC(WRITE,NONE,2,raw_and_l,(RW4 d, R4 s))
+
+LOWFUNC(WRITE,NONE,2,raw_and_w,(RW2 d, R2 s))
+{
+    emit_byte(0x66);
+    emit_byte(0x21);
+    emit_byte(0xc0+8*s+d);
+}
+LENDFUNC(WRITE,NONE,2,raw_and_w,(RW2 d, R2 s))
+
+LOWFUNC(WRITE,NONE,2,raw_and_b,(RW1 d, R1 s))
+{
+    emit_byte(0x20);
+    emit_byte(0xc0+8*s+d);
+}
+LENDFUNC(WRITE,NONE,2,raw_and_b,(RW1 d, R1 s))
+
+LOWFUNC(WRITE,NONE,2,raw_or_l_ri,(RW4 d, IMM i))
+{
+    emit_byte(0x81);
+    emit_byte(0xc8+d);
+    emit_long(i);
+}
+LENDFUNC(WRITE,NONE,2,raw_or_l_ri,(RW4 d, IMM i))
+
+LOWFUNC(WRITE,NONE,2,raw_or_l,(RW4 d, R4 s))
+{
+    emit_byte(0x09);
+    emit_byte(0xc0+8*s+d);
+}
+LENDFUNC(WRITE,NONE,2,raw_or_l,(RW4 d, R4 s))
+
+LOWFUNC(WRITE,NONE,2,raw_or_w,(RW2 d, R2 s))
+{
+    emit_byte(0x66);
+    emit_byte(0x09);
+    emit_byte(0xc0+8*s+d);
+}
+LENDFUNC(WRITE,NONE,2,raw_or_w,(RW2 d, R2 s))
+
+LOWFUNC(WRITE,NONE,2,raw_or_b,(RW1 d, R1 s))
+{
+    emit_byte(0x08);
+    emit_byte(0xc0+8*s+d);
+}
+LENDFUNC(WRITE,NONE,2,raw_or_b,(RW1 d, R1 s))
+
+LOWFUNC(RMW,NONE,2,raw_adc_l,(RW4 d, R4 s))
+{
+    emit_byte(0x11);
+    emit_byte(0xc0+8*s+d);
+}
+LENDFUNC(RMW,NONE,2,raw_adc_l,(RW4 d, R4 s))
+
+LOWFUNC(RMW,NONE,2,raw_adc_w,(RW2 d, R2 s))
+{
+    emit_byte(0x66);
+    emit_byte(0x11);
+    emit_byte(0xc0+8*s+d);
+}
+LENDFUNC(RMW,NONE,2,raw_adc_w,(RW2 d, R2 s))
+
+LOWFUNC(RMW,NONE,2,raw_adc_b,(RW1 d, R1 s))
+{
+    emit_byte(0x10);
+    emit_byte(0xc0+8*s+d);
+}
+LENDFUNC(RMW,NONE,2,raw_adc_b,(RW1 d, R1 s))
+
+LOWFUNC(WRITE,NONE,2,raw_add_l,(RW4 d, R4 s))
+{
+    emit_byte(0x01);
+    emit_byte(0xc0+8*s+d);
+}
+LENDFUNC(WRITE,NONE,2,raw_add_l,(RW4 d, R4 s))
+
+LOWFUNC(WRITE,NONE,2,raw_add_w,(RW2 d, R2 s))
+{
+    emit_byte(0x66);
+    emit_byte(0x01);
+    emit_byte(0xc0+8*s+d);
+}
+LENDFUNC(WRITE,NONE,2,raw_add_w,(RW2 d, R2 s))
+
+LOWFUNC(WRITE,NONE,2,raw_add_b,(RW1 d, R1 s))
+{
+    emit_byte(0x00);
+    emit_byte(0xc0+8*s+d);
+}
+LENDFUNC(WRITE,NONE,2,raw_add_b,(RW1 d, R1 s))
+
+LOWFUNC(WRITE,NONE,2,raw_sub_l_ri,(RW4 d, IMM i))
+{
+  if (isbyte(i)) {
+    emit_byte(0x83);
+    emit_byte(0xe8+d);
+    emit_byte(i);
+  }
+  else {
+    emit_byte(0x81);
+    emit_byte(0xe8+d);
+    emit_long(i);
+  }
+}
+LENDFUNC(WRITE,NONE,2,raw_sub_l_ri,(RW4 d, IMM i))
+
+LOWFUNC(WRITE,NONE,2,raw_sub_b_ri,(RW1 d, IMM i))
+{
+    emit_byte(0x80);
+    emit_byte(0xe8+d);
+    emit_byte(i);
+}
+LENDFUNC(WRITE,NONE,2,raw_sub_b_ri,(RW1 d, IMM i))
+
+LOWFUNC(WRITE,NONE,2,raw_add_l_ri,(RW4 d, IMM i))
+{
+    if (isbyte(i)) {
+	emit_byte(0x83);
+	emit_byte(0xc0+d);
+	emit_byte(i);
+    }
+    else {
+	emit_byte(0x81);
+	emit_byte(0xc0+d);
+	emit_long(i);
+    }
+}
+LENDFUNC(WRITE,NONE,2,raw_add_l_ri,(RW4 d, IMM i))
+
+LOWFUNC(WRITE,NONE,2,raw_add_w_ri,(RW2 d, IMM i))
+{
+    if (isbyte(i)) {
+	emit_byte(0x66);
+	emit_byte(0x83);
+	emit_byte(0xc0+d);
+	emit_byte(i);
+    }
+    else {
+	emit_byte(0x66);
+	emit_byte(0x81);
+	emit_byte(0xc0+d);
+	emit_word(i);
+    }
+}
+LENDFUNC(WRITE,NONE,2,raw_add_w_ri,(RW2 d, IMM i))
+
+LOWFUNC(WRITE,NONE,2,raw_add_b_ri,(RW1 d, IMM i))
+{
+    emit_byte(0x80);
+    emit_byte(0xc0+d);
+    emit_byte(i);
+}
+LENDFUNC(WRITE,NONE,2,raw_add_b_ri,(RW1 d, IMM i))
+
+LOWFUNC(RMW,NONE,2,raw_sbb_l,(RW4 d, R4 s))
+{
+    emit_byte(0x19);
+    emit_byte(0xc0+8*s+d);
+}
+LENDFUNC(RMW,NONE,2,raw_sbb_l,(RW4 d, R4 s))
+
+LOWFUNC(RMW,NONE,2,raw_sbb_w,(RW2 d, R2 s))
+{
+    emit_byte(0x66);
+    emit_byte(0x19);
+    emit_byte(0xc0+8*s+d);
+}
+LENDFUNC(RMW,NONE,2,raw_sbb_w,(RW2 d, R2 s))
+
+LOWFUNC(RMW,NONE,2,raw_sbb_b,(RW1 d, R1 s))
+{
+    emit_byte(0x18);
+    emit_byte(0xc0+8*s+d);
+}
+LENDFUNC(RMW,NONE,2,raw_sbb_b,(RW1 d, R1 s))
+
+LOWFUNC(WRITE,NONE,2,raw_sub_l,(RW4 d, R4 s))
+{
+    emit_byte(0x29);
+    emit_byte(0xc0+8*s+d);
+}
+LENDFUNC(WRITE,NONE,2,raw_sub_l,(RW4 d, R4 s))
+
+LOWFUNC(WRITE,NONE,2,raw_sub_w,(RW2 d, R2 s))
+{
+    emit_byte(0x66);
+    emit_byte(0x29);
+    emit_byte(0xc0+8*s+d);
+}
+LENDFUNC(WRITE,NONE,2,raw_sub_w,(RW2 d, R2 s))
+
+LOWFUNC(WRITE,NONE,2,raw_sub_b,(RW1 d, R1 s))
+{
+    emit_byte(0x28);
+    emit_byte(0xc0+8*s+d);
+}
+LENDFUNC(WRITE,NONE,2,raw_sub_b,(RW1 d, R1 s))
+
+LOWFUNC(WRITE,NONE,2,raw_cmp_l,(R4 d, R4 s))
+{
+    emit_byte(0x39);
+    emit_byte(0xc0+8*s+d);
+}
+LENDFUNC(WRITE,NONE,2,raw_cmp_l,(R4 d, R4 s))
+
+LOWFUNC(WRITE,NONE,2,raw_cmp_l_ri,(R4 r, IMM i))
+{
+    emit_byte(0x81);
+    emit_byte(0xf8+r);
+    emit_long(i);
+}
+LENDFUNC(WRITE,NONE,2,raw_cmp_l_ri,(R4 r, IMM i))
+
+LOWFUNC(WRITE,NONE,2,raw_cmp_w,(R2 d, R2 s))
+{
+    emit_byte(0x66);
+    emit_byte(0x39);
+    emit_byte(0xc0+8*s+d);
+}
+LENDFUNC(WRITE,NONE,2,raw_cmp_w,(R2 d, R2 s))
+
+LOWFUNC(WRITE,NONE,2,raw_cmp_b_ri,(R1 d, IMM i))
+{
+  emit_byte(0x80);
+  emit_byte(0xf8+d);
+  emit_byte(i);
+}
+LENDFUNC(WRITE,NONE,2,raw_cmp_b_ri,(R1 d, IMM i))
+
+LOWFUNC(WRITE,NONE,2,raw_cmp_b,(R1 d, R1 s))
+{
+    emit_byte(0x38);
+    emit_byte(0xc0+8*s+d);
+}
+LENDFUNC(WRITE,NONE,2,raw_cmp_b,(R1 d, R1 s))
+
+LOWFUNC(WRITE,READ,4,raw_cmp_l_rm_indexed,(R4 d, IMM offset, R4 index, IMM factor))
+{
+    int fi;
+    
+    switch(factor) {
+     case 1: fi=0; break;
+     case 2: fi=1; break;
+     case 4: fi=2; break;
+     case 8: fi=3; break;
+     default: abort();
+    }
+    emit_byte(0x39);
+    emit_byte(0x04+8*d);
+    emit_byte(5+8*index+0x40*fi);
+    emit_long(offset);
+}
+LENDFUNC(WRITE,READ,4,raw_cmp_l_rm_indexed,(R4 d, IMM offset, R4 index, IMM factor))
+
+LOWFUNC(WRITE,NONE,2,raw_xor_l,(RW4 d, R4 s))
+{
+    emit_byte(0x31);
+    emit_byte(0xc0+8*s+d);
+}
+LENDFUNC(WRITE,NONE,2,raw_xor_l,(RW4 d, R4 s))
+
+LOWFUNC(WRITE,NONE,2,raw_xor_w,(RW2 d, R2 s))
+{
+    emit_byte(0x66);
+    emit_byte(0x31);
+    emit_byte(0xc0+8*s+d);
+}
+LENDFUNC(WRITE,NONE,2,raw_xor_w,(RW2 d, R2 s))
+
+LOWFUNC(WRITE,NONE,2,raw_xor_b,(RW1 d, R1 s))
+{
+    emit_byte(0x30);
+    emit_byte(0xc0+8*s+d);
+}
+LENDFUNC(WRITE,NONE,2,raw_xor_b,(RW1 d, R1 s))
+
+LOWFUNC(WRITE,RMW,2,raw_sub_l_mi,(MEMRW d, IMM s))
+{
+    emit_byte(0x81);
+    emit_byte(0x2d);
+    emit_long(d);
+    emit_long(s);
+}
+LENDFUNC(WRITE,RMW,2,raw_sub_l_mi,(MEMRW d, IMM s))
+
+LOWFUNC(WRITE,READ,2,raw_cmp_l_mi,(MEMR d, IMM s))
+{
+    emit_byte(0x81);
+    emit_byte(0x3d);
+    emit_long(d);
+    emit_long(s);
+}
+LENDFUNC(WRITE,READ,2,raw_cmp_l_mi,(MEMR d, IMM s))
+
+LOWFUNC(NONE,NONE,2,raw_xchg_l_rr,(RW4 r1, RW4 r2))
+{
+  emit_byte(0x87);
+  emit_byte(0xc0+8*r1+r2);
+}
+LENDFUNC(NONE,NONE,2,raw_xchg_l_rr,(RW4 r1, RW4 r2))
+
+
+/*************************************************************************
+ * Unoptimizable stuff --- jump                                          *
+ *************************************************************************/
+
+static __inline__ void raw_call_r(R4 r)
+{
+    lopt_emit_all();
+    emit_byte(0xff);
+    emit_byte(0xd0+r);
+}
+
+static __inline__ void raw_jmp_r(R4 r)
+{
+    lopt_emit_all();
+    emit_byte(0xff);
+    emit_byte(0xe0+r);
+}
+
+static __inline__ void raw_jmp_m_indexed(uae_u32 base, uae_u32 r, uae_u32 m)
+{
+    int mu;
+    switch(m) {
+     case 1: mu=0; break;
+     case 2: mu=1; break;
+     case 4: mu=2; break;
+     case 8: mu=3; break;
+     default: abort();
+    }
+    lopt_emit_all();
+    emit_byte(0xff);
+    emit_byte(0x24);
+    emit_byte(0x05+8*r+0x40*mu);
+    emit_long(base);
+}
+
+static __inline__ void raw_jmp_m(uae_u32 base)
+{
+    lopt_emit_all();
+    emit_byte(0xff);
+    emit_byte(0x25);
+    emit_long(base);
+}
+
+
+static __inline__ void raw_call(uae_u32 t)
+{
+    lopt_emit_all();
+    emit_byte(0xe8);
+    emit_long(t-(uae_u32)target-4);
+}
+
+static __inline__ void raw_jmp(uae_u32 t)
+{
+    lopt_emit_all();
+    emit_byte(0xe9);
+    emit_long(t-(uae_u32)target-4);
+}
+
+static __inline__ void raw_jl(uae_u32 t)
+{
+    lopt_emit_all();
+    emit_byte(0x0f);
+    emit_byte(0x8c);
+    emit_long(t-(uae_u32)target-4);
+}
+
+static __inline__ void raw_jz(uae_u32 t)
+{
+    lopt_emit_all();
+    emit_byte(0x0f);
+    emit_byte(0x84);
+    emit_long(t-(uae_u32)target-4);
+}
+
+static __inline__ void raw_jnz(uae_u32 t)
+{
+    lopt_emit_all();
+    emit_byte(0x0f);
+    emit_byte(0x85);
+    emit_long(t-(uae_u32)target-4);
+}
+
+static __inline__ void raw_jnz_l_oponly(void)
+{
+    lopt_emit_all();
+    emit_byte(0x0f); 
+    emit_byte(0x85); 
+}
+
+static __inline__ void raw_jcc_l_oponly(int cc)
+{
+    lopt_emit_all();
+    emit_byte(0x0f); 
+    emit_byte(0x80+cc); 
+}
+
+static __inline__ void raw_jnz_b_oponly(void)
+{
+    lopt_emit_all();
+    emit_byte(0x75); 
+}
+
+static __inline__ void raw_jz_b_oponly(void)
+{
+    lopt_emit_all();
+    emit_byte(0x74); 
+}
+
+static __inline__ void raw_jmp_l_oponly(void)
+{
+    lopt_emit_all();
+    emit_byte(0xe9); 
+}
+
+static __inline__ void raw_jmp_b_oponly(void)
+{
+    lopt_emit_all();
+    emit_byte(0xeb); 
+}
+
+static __inline__ void raw_ret(void)
+{
+    lopt_emit_all();
+    emit_byte(0xc3);  
+}
+
+static __inline__ void raw_nop(void)
+{
+    lopt_emit_all();
+    emit_byte(0x90);
+}
+
+
+/*************************************************************************
+ * Flag handling, to and fro UAE flag register                           *
+ *************************************************************************/
+
+
+#define FLAG_NREG1 0  /* Set to -1 if any register will do */
+
+static __inline__ void raw_flags_to_reg(int r)
+{
+  raw_lahf(0);  /* Most flags in AH */
+  //raw_setcc(r,0); /* V flag in AL */
+  raw_setcc_m((uae_u32)live.state[FLAGTMP].mem,0); 
+  
+#if 1   /* Let's avoid those nasty partial register stalls */
+  //raw_mov_b_mr((uae_u32)live.state[FLAGTMP].mem,r);
+  raw_mov_b_mr(((uae_u32)live.state[FLAGTMP].mem)+1,r+4);
+  //live.state[FLAGTMP].status=CLEAN;
+  live.state[FLAGTMP].status=INMEM;
+  live.state[FLAGTMP].realreg=-1;
+  /* We just "evicted" FLAGTMP. */
+  if (live.nat[r].nholds!=1) {
+      /* Huh? */
+      abort();
+  }
+  live.nat[r].nholds=0;
+#endif
+}
+
+#define FLAG_NREG2 0  /* Set to -1 if any register will do */
+static __inline__ void raw_reg_to_flags(int r)
+{
+  raw_cmp_b_ri(r,-127); /* set V */
+  raw_sahf(0);
+}
+
+/* Apparently, there are enough instructions between flag store and
+   flag reload to avoid the partial memory stall */
+static __inline__ void raw_load_flagreg(uae_u32 target, uae_u32 r)
+{
+#if 1
+    raw_mov_l_rm(target,(uae_u32)live.state[r].mem);
+#else
+    raw_mov_b_rm(target,(uae_u32)live.state[r].mem);
+    raw_mov_b_rm(target+4,((uae_u32)live.state[r].mem)+1);
+#endif
+}
+
+/* FLAGX is byte sized, and we *do* write it at that size */
+static __inline__ void raw_load_flagx(uae_u32 target, uae_u32 r)
+{
+    if (live.nat[target].canbyte)
+	raw_mov_b_rm(target,(uae_u32)live.state[r].mem);
+    else if (live.nat[target].canword)
+	raw_mov_w_rm(target,(uae_u32)live.state[r].mem);
+    else
+	raw_mov_l_rm(target,(uae_u32)live.state[r].mem);
+}
+
+
+static __inline__ void raw_inc_sp(int off)
+{
+    raw_add_l_ri(4,off);
+}
+
+/*************************************************************************
+ * Handling mistaken direct memory access                                *
+ *************************************************************************/
+
+
+#ifdef NATMEM_OFFSET
+#ifdef _WIN32 // %%% BRIAN KING WAS HERE %%%
+#include <winbase.h>
+#else
+#include <asm/sigcontext.h>
+#endif
+#include <signal.h>
+
+#define SIG_READ 1
+#define SIG_WRITE 2
+
+static int in_handler=0;
+static uae_u8 veccode[256];
+
+#ifdef _WIN32
+int EvalException ( LPEXCEPTION_POINTERS blah, int n_except )
+{
+    PEXCEPTION_RECORD pExceptRecord = NULL;
+    PCONTEXT          pContext = NULL;
+
+    uae_u8* i = NULL;
+    uae_u32 addr = 0;
+    int r=-1;
+    int size=4;
+    int dir=-1;
+    int len=0;
+    int j;
+
+    write_log( "EvalException!\n" );
+
+    if( n_except != STATUS_ACCESS_VIOLATION )
+        return EXCEPTION_CONTINUE_SEARCH;
+
+    pExceptRecord = blah->ExceptionRecord;
+    pContext = blah->ContextRecord;
+
+    if( pContext )
+    {
+	i = (uae_u8 *)(pContext->Eip);
+    }
+    if( pExceptRecord )
+    {
+	addr = (uae_u32)(pExceptRecord->ExceptionInformation[1]);
+    }
+
+    write_log("fault address is 0x%x at 0x%x\n",addr,i);
+    if (!canbang || !currprefs.cachesize) 
+    {
+	write_log("Not happy! Canbang or cachesize is 0 in SIGSEGV handler!\n");
+	return EXCEPTION_CONTINUE_SEARCH;
+    }
+
+    if (in_handler) 
+	write_log("Argh --- Am already in a handler. Shouldn't happen!\n");
+    
+    if (canbang && i>=compiled_code && i<=current_compile_p) {
+	if (*i==0x66) {
+	    i++;
+	    size=2;
+	    len++;
+	}
+	
+	switch(i[0]) {
+	case 0x8a:
+	    if ((i[1]&0xc0)==0x80) {
+		r=(i[1]>>3)&7;
+		dir=SIG_READ;
+		size=1;
+		len+=6;
+		break;
+	    }
+	    break;
+	case 0x88:
+	    if ((i[1]&0xc0)==0x80) {
+		r=(i[1]>>3)&7;
+		dir=SIG_WRITE;
+		size=1;
+		len+=6;
+		break;
+	    }
+	    break;
+	case 0x8b:
+	    switch(i[1]&0xc0) {
+	    case 0x80:
+		r=(i[1]>>3)&7;
+		dir=SIG_READ;
+		len+=6;
+		break;
+	    case 0x40:
+		r=(i[1]>>3)&7;
+		dir=SIG_READ;
+		len+=3;
+		break;
+	    case 0x00:
+		r=(i[1]>>3)&7;
+		dir=SIG_READ;
+		len+=2;
+		break;
+	    default: 
+		break;
+	    }
+	    break;
+	    case 0x89:
+		switch(i[1]&0xc0) {
+		case 0x80:
+		    r=(i[1]>>3)&7;
+		    dir=SIG_WRITE;
+		    len+=6;
+		    break;
+		case 0x40:
+		    r=(i[1]>>3)&7;
+		    dir=SIG_WRITE;
+		    len+=3;
+		    break;
+		case 0x00:
+		    r=(i[1]>>3)&7;
+		    dir=SIG_WRITE;
+		    len+=2;
+		    break;
+		}
+		break;
+	}	
+    }
+    
+    if (r!=-1) { 
+	void* pr=NULL;
+	write_log("register was %d, direction was %d, size was %d\n",r,dir,size);
+	
+	switch(r) {
+	case 0: pr=&(pContext->Eax); break;
+	case 1: pr=&(pContext->Ecx); break;
+	case 2: pr=&(pContext->Edx); break;
+	case 3: pr=&(pContext->Ebx); break;
+	case 4: pr=(size>1)?NULL:(((uae_u8*)&(pContext->Eax))+1); break;
+	case 5: pr=(size>1)?
+		    (void*)(&(pContext->Ebp)):
+	    (void*)(((uae_u8*)&(pContext->Ecx))+1); break;
+	case 6: pr=(size>1)?
+		    (void*)(&(pContext->Esi)):
+	    (void*)(((uae_u8*)&(pContext->Edx))+1); break;
+	case 7: pr=(size>1)?
+		    (void*)(&(pContext->Edi)):
+	    (void*)(((uae_u8*)&(pContext->Ebx))+1); break;
+	default: abort();
+	}
+	if (pr) {
+	    blockinfo* bi;
+	    
+	    if (currprefs.comp_oldsegv) {
+		addr-=GS_NATMEM_OFFSET;
+		
+		if ((addr>=0x10000000 && addr<0x40000000) ||
+		    (addr>=0x50000000)) {
+		    write_log("Suspicious address 0x%x in SEGV handler.\n",addr);
+		}
+		if (dir==SIG_READ) {
+		    switch(size) {
+		    case 1: *((uae_u8*)pr)=get_byte(addr); break;
+		    case 2: *((uae_u16*)pr)=swap16(get_word(addr)); break;
+		    case 4: *((uae_u32*)pr)=swap32(get_long(addr)); break;
+		    default: abort();
+		    }
+		}
+		else { /* write */
+		    switch(size) {
+		    case 1: put_byte(addr,*((uae_u8*)pr)); break;
+		    case 2: put_word(addr,swap16(*((uae_u16*)pr))); break;
+		    case 4: put_long(addr,swap32(*((uae_u32*)pr))); break;
+		    default: abort();
+		    }
+		}
+		write_log("Handled one access!\n");
+		fflush(stdout);
+		segvcount++;
+		pContext->Eip+=len;
+	    }
+	    else {
+		void* tmp=target;
+		int i;
+		uae_u8 vecbuf[5];
+		
+		addr-=GS_NATMEM_OFFSET;
+		
+		if ((addr>=0x10000000 && addr<0x40000000) ||
+		    (addr>=0x50000000)) {
+		    write_log("Suspicious address 0x%x in SEGV handler.\n",addr);
+		}
+		
+		target=(uae_u8*)pContext->Eip;
+		for (i=0;i<5;i++)
+		    vecbuf[i]=target[i];
+		emit_byte(0xe9);
+		emit_long((uae_u32)veccode-(uae_u32)target-4);
+		write_log("Create jump to %p\n",veccode);
+		
+		write_log("Handled one access!\n");
+		segvcount++;
+		
+		target=veccode;
+		
+		if (dir==SIG_READ) {
+		    switch(size) {
+		    case 1: raw_mov_b_ri(r,get_byte(addr)); break;
+		    case 2: raw_mov_w_ri(r,swap16(get_word(addr))); break;
+		    case 4: raw_mov_l_ri(r,swap32(get_long(addr))); break;
+		    default: abort();
+		    }
+		}
+		else { /* write */
+		    switch(size) {
+		    case 1: put_byte(addr,*((uae_u8*)pr)); break;
+		    case 2: put_word(addr,swap16(*((uae_u16*)pr))); break;
+		    case 4: put_long(addr,swap32(*((uae_u32*)pr))); break;
+		    default: abort();
+		    }
+		}
+		for (i=0;i<5;i++)
+		    raw_mov_b_mi(pContext->Eip+i,vecbuf[i]);
+		raw_mov_l_mi((uae_u32)&in_handler,0);
+		emit_byte(0xe9);
+		emit_long(pContext->Eip+len-(uae_u32)target-4);
+		in_handler=1;
+		target=tmp;
+	    }
+	    bi=active;
+	    while (bi) {
+		if (bi->handler && 
+		    (uae_u8*)bi->direct_handler<=i &&
+		    (uae_u8*)bi->nexthandler>i) {
+		    write_log("deleted trigger (%p<%p<%p) %p\n",
+			bi->handler,
+			i,
+			bi->nexthandler,
+			bi->pc_p);
+		    invalidate_block(bi);
+		    raise_in_cl_list(bi);
+		    set_special(0);
+		    return EXCEPTION_CONTINUE_EXECUTION;
+		}
+		bi=bi->next;
+	    }
+	    /* Not found in the active list. Might be a rom routine that
+	    is in the dormant list */
+	    bi=dormant;
+	    while (bi) {
+		if (bi->handler && 
+		    (uae_u8*)bi->direct_handler<=i &&
+		    (uae_u8*)bi->nexthandler>i) {
+		    write_log("deleted trigger (%p<%p<%p) %p\n",
+			bi->handler,
+			i,
+			bi->nexthandler,
+			bi->pc_p);
+		    invalidate_block(bi);
+		    raise_in_cl_list(bi);
+		    set_special(0);
+		    return EXCEPTION_CONTINUE_EXECUTION;
+		}
+		bi=bi->next;
+	    }
+	    write_log("Huh? Could not find trigger!\n");
+	    return EXCEPTION_CONTINUE_EXECUTION;
+	}
+    }
+    write_log("Can't handle access!\n");
+    if (i) {
+	for (j=0;j<10;j++) {
+	    write_log("instruction byte %2d is 0x%02x\n",j,i[j]);
+	}
+    }
+#if 0
+    write_log("Please send the above info (starting at \"fault address\") to\n"
+	   "bmeyer@csse.monash.edu.au\n"
+	   "This shouldn't happen ;-)\n");
+#endif
+    return EXCEPTION_CONTINUE_SEARCH;
+}
+#else
+static void segfault_vec (int x, struct sigcontext sc)
+{
+    uae_u8 *i = (uae_u8*)sc.eip;
+    uae_u32 addr=sc.cr2;
+    int r = -1;
+    int size = 4;
+    int dir = -1;
+    int len = 1;
+    int j;
+    
+    write_log("fault address is %08x at %08x\n",sc.cr2,sc.eip);
+    if (!canbang) 
+	write_log("Not happy! Canbang is 0 in SIGSEGV handler!\n");
+    if (in_handler) 
+	write_log("Argh --- Am already in a handler. Shouldn't happen!\n");
+
+    if (canbang && i>=compiled_code && i<=current_compile_p) {
+	if (*i++ != 0x65)
+	    goto oh_dear;
+
+	if (*i == 0x66) {
+	    i++;
+	    size=2;
+	    len++;
+	}
+	
+	switch(i[0]) {
+	case 0x8a:
+	    if ((i[1]&0xc0)==0x80) {
+		r=(i[1]>>3)&7;
+		dir=SIG_READ;
+		size=1;
+		len+=6;
+		break;
+	    }
+	    break;
+	case 0x88:
+	    if ((i[1]&0xc0)==0x80) {
+		r=(i[1]>>3)&7;
+		dir=SIG_WRITE;
+		size=1;
+		len+=6;
+		break;
+	    }
+	    break;
+
+	case 0x8b:
+	    switch(i[1]&0xc0) {
+	    case 0x80:
+		r=(i[1]>>3)&7;
+		dir=SIG_READ;
+		len+=6;
+		break;
+	    case 0x40:
+		r=(i[1]>>3)&7;
+		dir=SIG_READ;
+		len+=3;
+		break;
+	    case 0x00:
+		r=(i[1]>>3)&7;
+		dir=SIG_READ;
+		len+=2;
+		break;
+	    default: 
+		break;
+	    }
+	    break;
+	    
+	case 0x89:
+	    switch(i[1]&0xc0) {
+	    case 0x80:
+		r=(i[1]>>3)&7;
+		dir=SIG_WRITE;
+		len+=6;
+		break;
+	    case 0x40:
+		r=(i[1]>>3)&7;
+		dir=SIG_WRITE;
+		len+=3;
+		break;
+	    case 0x00:
+		r=(i[1]>>3)&7;
+		dir=SIG_WRITE;
+		len+=2;
+		break;
+	    }
+	    break;
+	}	
+    }
+
+    if (r!=-1) { 
+	void* pr=NULL;
+	write_log("register was %d, direction was %d, size was %d\n",r,dir,size);
+	
+	switch(r) {
+	case 0: pr=&(sc.eax); break;
+	case 1: pr=&(sc.ecx); break;
+	case 2: pr=&(sc.edx); break;
+	case 3: pr=&(sc.ebx); break;
+	case 4: pr=(size>1)?NULL:(((uae_u8*)&(sc.eax))+1); break;
+	case 5: pr=(size>1)?
+		    (void*)(&(sc.ebp)):
+			(void*)(((uae_u8*)&(sc.ecx))+1); break;
+	case 6: pr=(size>1)?
+		    (void*)(&(sc.esi)):
+			(void*)(((uae_u8*)&(sc.edx))+1); break;
+	case 7: pr=(size>1)?
+		    (void*)(&(sc.edi)):
+			(void*)(((uae_u8*)&(sc.ebx))+1); break;
+	default: abort();
+	}
+	if (pr) {
+	    blockinfo* bi;
+
+	    if (currprefs.comp_oldsegv) {
+		addr-=GS_NATMEM_OFFSET;
+		
+		if ((addr>=0x10000000 && addr<0x40000000) ||
+		    (addr>=0x50000000)) {
+		    write_log("Suspicious address in %x SEGV handler.\n",addr);
+		}
+		if (dir==SIG_READ) {
+		    switch(size) {
+		    case 1: *((uae_u8*)pr)=get_byte(addr); break;
+		    case 2: *((uae_u16*)pr)=get_word(addr); break;
+		    case 4: *((uae_u32*)pr)=get_long(addr); break;
+		    default: abort();
+		    }
+		}
+		else { /* write */
+		    switch(size) {
+		    case 1: put_byte(addr,*((uae_u8*)pr)); break;
+		    case 2: put_word(addr,*((uae_u16*)pr)); break;
+		    case 4: put_long(addr,*((uae_u32*)pr)); break;
+		    default: abort();
+		    }
+		}
+		write_log("Handled one access!\n");
+		fflush(stdout);
+		segvcount++;
+		sc.eip+=len;
+	    }
+	    else {
+		void* tmp=target;
+		int i;
+		uae_u8 vecbuf[5];
+		
+		addr-=GS_NATMEM_OFFSET;
+		
+		if ((addr>=0x10000000 && addr<0x40000000) ||
+		    (addr>=0x50000000)) {
+		    write_log("Suspicious address 0x%x in SEGV handler.\n",addr);
+		}
+		
+		target=(uae_u8*)sc.eip;
+		for (i=0;i<5;i++)
+		    vecbuf[i]=target[i];
+		emit_byte(0xe9);
+		emit_long((uae_u32)veccode-(uae_u32)target-4);
+		write_log("Create jump to %p\n",veccode);
+
+		write_log("Handled one access!\n");
+		fflush(stdout);
+		segvcount++;
+		
+		target=veccode;
+
+		if (dir==SIG_READ) {
+		    switch(size) {
+		    case 1: raw_mov_b_ri(r,get_byte(addr)); break;
+		    case 2: raw_mov_w_ri(r,get_word(addr)); break;
+		    case 4: raw_mov_l_ri(r,get_long(addr)); break;
+		    default: abort();
+		    }
+		}
+		else { /* write */
+		    switch(size) {
+		    case 1: put_byte(addr,*((uae_u8*)pr)); break;
+		    case 2: put_word(addr,*((uae_u16*)pr)); break;
+		    case 4: put_long(addr,*((uae_u32*)pr)); break;
+		    default: abort();
+		    }
+		}
+		for (i=0;i<5;i++)
+		    raw_mov_b_mi(sc.eip+i,vecbuf[i]);
+		raw_mov_l_mi((uae_u32)&in_handler,0);
+		emit_byte(0xe9);
+		emit_long(sc.eip+len-(uae_u32)target-4);
+		in_handler=1;
+		target=tmp;
+	    }
+	    bi=active;
+	    while (bi) {
+		if (bi->handler && 
+		    (uae_u8*)bi->direct_handler<=i &&
+		    (uae_u8*)bi->nexthandler>i) {
+		    write_log("deleted trigger (%p<%p<%p) %p\n",
+			      bi->handler,
+			      i,
+			      bi->nexthandler,
+			      bi->pc_p);
+		    invalidate_block(bi);
+		    raise_in_cl_list(bi);
+		    set_special(0);
+		    return;
+		}
+		bi=bi->next;
+	    }
+	    /* Not found in the active list. Might be a rom routine that
+	       is in the dormant list */
+	    bi=dormant;
+	    while (bi) {
+		if (bi->handler && 
+		    (uae_u8*)bi->direct_handler<=i &&
+		    (uae_u8*)bi->nexthandler>i) {
+		    write_log("deleted trigger (%p<%p<%p) %p\n",
+			      bi->handler,
+			      i,
+			      bi->nexthandler,
+			      bi->pc_p);
+		    invalidate_block(bi);
+		    raise_in_cl_list(bi);
+		    set_special(0);
+		    return;
+		}
+		bi=bi->next;
+	    }
+	    write_log("Huh? Could not find trigger!\n");
+	    return;
+	}
+    }
+  oh_dear:
+    write_log ("Can't handle access!\n");
+    if (sc.eip >= compiled_code && sc.eip + 12 <= current_compile_p)
+	for (j = 0; j < 12; j++) {
+	    write_log ("instruction byte %2d is %02x\n", j, ((uae_u8 *)sc.eip)[j]);
+	}
+#if 0
+    write_log("Please send the above info (starting at \"fault address\") to\n"
+	      "bmeyer@csse.monash.edu.au\n"
+	      "This shouldn't happen ;-)\n");
+    fflush(stdout);
+#endif
+    signal (SIGSEGV, SIG_DFL);  /* returning here will cause a "real" SEGV */
+}
+#endif
+#endif
+
+/*************************************************************************
+ * Checking for CPU features                                             *
+ *************************************************************************/
+
+typedef struct {
+    uae_u32 eax;
+    uae_u32 ecx;
+    uae_u32 edx;
+    uae_u32 ebx;
+} x86_regs;
+
+
+/* This could be so much easier if it could make assumptions about the
+   compiler... */
+
+static uae_u8 cpuid_space[256];   
+static uae_u32 cpuid_ptr;
+static uae_u32 cpuid_level;
+
+static x86_regs cpuid(uae_u32 level)
+{
+    x86_regs answer;
+    void* tmp=get_target();
+
+    cpuid_ptr=(uae_u32)&answer;
+    cpuid_level=level;
+
+    set_target(cpuid_space);
+    raw_push_l_r(0); /* eax */
+    raw_push_l_r(1); /* ecx */
+    raw_push_l_r(2); /* edx */
+    raw_push_l_r(3); /* ebx */
+    raw_push_l_r(7); /* edi */
+    raw_mov_l_rm(0,(uae_u32)&cpuid_level);
+    raw_cpuid(0);
+    raw_mov_l_rm(7,(uae_u32)&cpuid_ptr);
+    raw_mov_l_Rr(7,0,0);
+    raw_mov_l_Rr(7,1,4);
+    raw_mov_l_Rr(7,2,8);
+    raw_mov_l_Rr(7,3,12);
+    raw_pop_l_r(7);
+    raw_pop_l_r(3);
+    raw_pop_l_r(2);
+    raw_pop_l_r(1);
+    raw_pop_l_r(0);
+    raw_ret();
+    set_target(tmp);
+
+    ((cpuop_func*)cpuid_space)(0);
+    return answer;
+}
+
+static void raw_init_cpu(void)
+{
+    x86_regs x;
+    uae_u32 maxlev;
+    
+    x=cpuid(0);
+    maxlev=x.eax;
+    write_log("Max CPUID level=%d Processor is %c%c%c%c%c%c%c%c%c%c%c%c\n",
+	      maxlev,
+	      x.ebx,
+	      x.ebx>>8,
+	      x.ebx>>16,
+	      x.ebx>>24,
+	      x.edx,
+	      x.edx>>8,
+	      x.edx>>16,
+	      x.edx>>24,
+	      x.ecx,
+	      x.ecx>>8,
+	      x.ecx>>16,
+	      x.ecx>>24
+	      );
+    have_rat_stall=(x.ecx==0x6c65746e);
+
+    if (maxlev>=1) {
+	x=cpuid(1);
+	if (x.edx&(1<<15)) 
+	    have_cmov=1;
+    }
+    if (!have_cmov)
+	have_rat_stall=0;
+#if 0
+    write_log ("have_cmov=%d, avoid_cmov=%d, have_rat_stall=%d\n",
+	       have_cmov,currprefs.avoid_cmov,have_rat_stall);
+    if (currprefs.avoid_cmov) {
+	write_log("Disabling cmov use despite processor claiming to support it!\n");
+	have_cmov=0;
+    }
+#else
+    /* Dear Bernie, I don't want to keep around options which are useless, and not
+       represented in the GUI anymore... Is this okay? */
+    write_log ("have_cmov=%d, have_rat_stall=%d\n", have_cmov, have_rat_stall);
+#endif
+#if 0   /* For testing of non-cmov code! */
+    have_cmov=0;
+#endif
+#if 1 /* It appears that partial register writes are a bad idea even on
+	 AMD K7 cores, even though they are not supposed to have the
+	 dreaded rat stall. Why? Anyway, that's why we lie about it ;-) */
+    if (have_cmov)
+      have_rat_stall=1;
+#endif
+}
+
+/*************************************************************************
+ * FPU stuff                                                             *
+ *************************************************************************/
+
+
+static __inline__ void raw_fp_init(void)
+{
+    int i;
+    
+    for (i=0;i<N_FREGS;i++)
+	live.spos[i]=-2;
+    live.tos=-1;  /* Stack is empty */
+}
+
+static __inline__ void raw_fp_cleanup_drop(void)
+{
+#if 0
+    /* using FINIT instead of popping all the entries.
+       Seems to have side effects --- there is display corruption in
+       Quake when this is used */
+    if (live.tos>1) {
+	emit_byte(0x9b);
+	emit_byte(0xdb);
+	emit_byte(0xe3);
+	live.tos=-1;
+    }
+#endif
+    while (live.tos>=1) {
+	emit_byte(0xde);
+	emit_byte(0xd9);
+	live.tos-=2;
+    }
+    while (live.tos>=0) {
+	emit_byte(0xdd);
+	emit_byte(0xd8);
+	live.tos--;
+    }
+    raw_fp_init();
+}
+
+static __inline__ void make_tos(int r)
+{
+    int p,q;
+
+    if (live.spos[r]<0) { /* Register not yet on stack */
+	emit_byte(0xd9);
+	emit_byte(0xe8);  /* Push '1' on the stack, just to grow it */
+	live.tos++;
+	live.spos[r]=live.tos;
+	live.onstack[live.tos]=r;
+	return;
+    }
+    /* Register is on stack */
+    if (live.tos==live.spos[r])
+	return;
+    p=live.spos[r];
+    q=live.onstack[live.tos];
+
+    emit_byte(0xd9);
+    emit_byte(0xc8+live.tos-live.spos[r]);  /* exchange it with top of stack */
+    live.onstack[live.tos]=r;
+    live.spos[r]=live.tos;
+    live.onstack[p]=q;
+    live.spos[q]=p;
+}
+
+static __inline__ void make_tos2(int r, int r2)
+{
+    int q;
+
+    make_tos(r2); /* Put the reg that's supposed to end up in position2
+		     on top */
+
+    if (live.spos[r]<0) { /* Register not yet on stack */
+	make_tos(r); /* This will extend the stack */
+	return;
+    }
+    /* Register is on stack */
+    emit_byte(0xd9);
+    emit_byte(0xc9); /* Move r2 into position 2 */
+
+    q=live.onstack[live.tos-1];
+    live.onstack[live.tos]=q;
+    live.spos[q]=live.tos;
+    live.onstack[live.tos-1]=r2;
+    live.spos[r2]=live.tos-1;
+
+    make_tos(r); /* And r into 1 */
+}
+
+static __inline__ int stackpos(int r)
+{
+    if (live.spos[r]<0)
+	abort();
+    if (live.tos<live.spos[r]) {
+	printf("Looking for spos for fnreg %d\n",r);
+	abort();
+    }
+    return live.tos-live.spos[r];
+}
+
+static __inline__ void usereg(int r)
+{
+    if (live.spos[r]<0)
+	make_tos(r);
+}
+
+/* This is called with one FP value in a reg *above* tos, which it will
+   pop off the stack if necessary */
+static __inline__ void tos_make(int r)
+{
+    if (live.spos[r]<0) {
+	live.tos++;
+	live.spos[r]=live.tos;
+	live.onstack[live.tos]=r;
+	return;
+    }
+    emit_byte(0xdd);
+    emit_byte(0xd8+(live.tos+1)-live.spos[r]);  /* store top of stack in reg, 
+					 and pop it*/
+}
+    
+	
+LOWFUNC(NONE,WRITE,2,raw_fmov_mr,(MEMW m, FR r))
+{
+    make_tos(r);
+    emit_byte(0xdd);
+    emit_byte(0x15);
+    emit_long(m);
+}
+LENDFUNC(NONE,WRITE,2,raw_fmov_mr,(MEMW m, FR r))
+
+LOWFUNC(NONE,WRITE,2,raw_fmov_mr_drop,(MEMW m, FR r))
+{
+    make_tos(r);
+    emit_byte(0xdd);
+    emit_byte(0x1d);
+    emit_long(m);
+    live.onstack[live.tos]=-1;
+    live.tos--;
+    live.spos[r]=-2;
+}
+LENDFUNC(NONE,WRITE,2,raw_fmov_mr,(MEMW m, FR r))
+
+LOWFUNC(NONE,READ,2,raw_fmov_rm,(FW r, MEMR m))
+{
+    emit_byte(0xdd);
+    emit_byte(0x05);
+    emit_long(m);
+    tos_make(r);
+}
+LENDFUNC(NONE,READ,2,raw_fmov_rm,(FW r, MEMR m))
+
+LOWFUNC(NONE,READ,2,raw_fmovi_rm,(FW r, MEMR m))
+{
+    emit_byte(0xdb);
+    emit_byte(0x05);
+    emit_long(m);
+    tos_make(r);
+}
+LENDFUNC(NONE,READ,2,raw_fmovi_rm,(FW r, MEMR m))
+
+LOWFUNC(NONE,WRITE,2,raw_fmovi_mr,(MEMW m, FR r))
+{
+    make_tos(r);
+    emit_byte(0xdb);
+    emit_byte(0x15);
+    emit_long(m);
+}
+LENDFUNC(NONE,WRITE,2,raw_fmovi_mr,(MEMW m, FR r))
+
+LOWFUNC(NONE,READ,2,raw_fmovs_rm,(FW r, MEMR m))
+{
+    emit_byte(0xd9);
+    emit_byte(0x05);
+    emit_long(m);
+    tos_make(r);
+}
+LENDFUNC(NONE,READ,2,raw_fmovs_rm,(FW r, MEMR m))
+
+LOWFUNC(NONE,WRITE,2,raw_fmovs_mr,(MEMW m, FR r))
+{
+    make_tos(r);
+    emit_byte(0xd9);
+    emit_byte(0x15);
+    emit_long(m);
+}
+LENDFUNC(NONE,WRITE,2,raw_fmovs_mr,(MEMW m, FR r))
+
+LOWFUNC(NONE,WRITE,2,raw_fmov_ext_mr,(MEMW m, FR r))
+{
+    int rs;
+
+    /* Stupid x87 can't write a long double to mem without popping the 
+       stack! */
+    usereg(r);
+    rs=stackpos(r);
+    emit_byte(0xd9);     /* Get a copy to the top of stack */
+    emit_byte(0xc0+rs);
+
+    emit_byte(0xdb);  /* store and pop it */
+    emit_byte(0x3d);
+    emit_long(m);
+}
+LENDFUNC(NONE,WRITE,2,raw_fmov_ext_mr,(MEMW m, FR r))
+
+LOWFUNC(NONE,WRITE,2,raw_fmov_ext_mr_drop,(MEMW m, FR r))
+{
+    int rs;
+
+    make_tos(r);
+    emit_byte(0xdb);  /* store and pop it */
+    emit_byte(0x3d);
+    emit_long(m);
+    live.onstack[live.tos]=-1;
+    live.tos--;
+    live.spos[r]=-2;
+}
+LENDFUNC(NONE,WRITE,2,raw_fmov_ext_mr,(MEMW m, FR r))
+
+LOWFUNC(NONE,READ,2,raw_fmov_ext_rm,(FW r, MEMR m))
+{
+    emit_byte(0xdb);
+    emit_byte(0x2d);
+    emit_long(m);
+    tos_make(r);
+}
+LENDFUNC(NONE,READ,2,raw_fmov_ext_rm,(FW r, MEMR m))
+
+LOWFUNC(NONE,NONE,1,raw_fmov_pi,(FW r))
+{
+    emit_byte(0xd9);
+    emit_byte(0xeb);
+    tos_make(r);
+}
+LENDFUNC(NONE,NONE,1,raw_fmov_pi,(FW r))
+
+LOWFUNC(NONE,NONE,1,raw_fmov_log10_2,(FW r))
+{
+    emit_byte(0xd9);
+    emit_byte(0xec);
+    tos_make(r);
+}
+LENDFUNC(NONE,NONE,1,raw_fmov_log10_2,(FW r))
+
+LOWFUNC(NONE,NONE,1,raw_fmov_log2_e,(FW r))
+{
+    emit_byte(0xd9);
+    emit_byte(0xea);
+    tos_make(r);
+}
+LENDFUNC(NONE,NONE,1,raw_fmov_log2_e,(FW r))
+
+LOWFUNC(NONE,NONE,1,raw_fmov_loge_2,(FW r))
+{
+    emit_byte(0xd9);
+    emit_byte(0xed);
+    tos_make(r);
+}
+LENDFUNC(NONE,NONE,1,raw_fmov_loge_2,(FW r))
+
+LOWFUNC(NONE,NONE,1,raw_fmov_1,(FW r))
+{
+    emit_byte(0xd9);
+    emit_byte(0xe8);
+    tos_make(r);
+}
+LENDFUNC(NONE,NONE,1,raw_fmov_1,(FW r))
+
+LOWFUNC(NONE,NONE,1,raw_fmov_0,(FW r))
+{
+    emit_byte(0xd9);
+    emit_byte(0xee);
+    tos_make(r);
+}
+LENDFUNC(NONE,NONE,1,raw_fmov_0,(FW r))
+
+LOWFUNC(NONE,NONE,2,raw_fmov_rr,(FW d, FR s))
+{
+    int ds;
+
+    usereg(s);
+    ds=stackpos(s);
+    if (ds==0 && live.spos[d]>=0) {
+	/* source is on top of stack, and we already have the dest */
+	int dd=stackpos(d);
+	emit_byte(0xdd);
+	emit_byte(0xd0+dd);
+    }
+    else {
+	emit_byte(0xd9);
+	emit_byte(0xc0+ds); /* duplicate source on tos */
+	tos_make(d); /* store to destination, pop if necessary */
+    }
+}
+LENDFUNC(NONE,NONE,2,raw_fmov_rr,(FW d, FR s))
+
+LOWFUNC(NONE,READ,4,raw_fldcw_m_indexed,(R4 index, IMM base))
+{
+    emit_byte(0xd9);
+    emit_byte(0xa8+index);
+    emit_long(base);
+}
+LENDFUNC(NONE,READ,4,raw_fldcw_m_indexed,(R4 index, IMM base))
+
+
+LOWFUNC(NONE,NONE,2,raw_fsqrt_rr,(FW d, FR s))
+{
+    int ds;
+
+    if (d!=s) {
+	usereg(s);
+	ds=stackpos(s);
+	emit_byte(0xd9);
+	emit_byte(0xc0+ds); /* duplicate source */
+	emit_byte(0xd9);
+	emit_byte(0xfa); /* take square root */
+	tos_make(d); /* store to destination */
+    }
+    else {
+	make_tos(d);
+	emit_byte(0xd9);
+	emit_byte(0xfa); /* take square root */
+    }	
+}
+LENDFUNC(NONE,NONE,2,raw_fsqrt_rr,(FW d, FR s))
+
+LOWFUNC(NONE,NONE,2,raw_fabs_rr,(FW d, FR s))
+{
+    int ds;
+
+    if (d!=s) {
+	usereg(s);
+	ds=stackpos(s);
+	emit_byte(0xd9);
+	emit_byte(0xc0+ds); /* duplicate source */
+	emit_byte(0xd9);
+	emit_byte(0xe1); /* take fabs */
+	tos_make(d); /* store to destination */
+    }
+    else {
+	make_tos(d);
+	emit_byte(0xd9);
+	emit_byte(0xe1); /* take fabs */
+    }	
+}
+LENDFUNC(NONE,NONE,2,raw_fabs_rr,(FW d, FR s))
+
+LOWFUNC(NONE,NONE,2,raw_frndint_rr,(FW d, FR s))
+{
+    int ds;
+
+    if (d!=s) {
+	usereg(s);
+	ds=stackpos(s);
+	emit_byte(0xd9);
+	emit_byte(0xc0+ds); /* duplicate source */
+	emit_byte(0xd9);
+	emit_byte(0xfc); /* take frndint */
+	tos_make(d); /* store to destination */
+    }
+    else {
+	make_tos(d);
+	emit_byte(0xd9);
+	emit_byte(0xfc); /* take frndint */
+    }	
+}
+LENDFUNC(NONE,NONE,2,raw_frndint_rr,(FW d, FR s))
+
+LOWFUNC(NONE,NONE,2,raw_fcos_rr,(FW d, FR s))
+{
+    int ds;
+
+    if (d!=s) {
+	usereg(s);
+	ds=stackpos(s);
+	emit_byte(0xd9);
+	emit_byte(0xc0+ds); /* duplicate source */
+	emit_byte(0xd9);
+	emit_byte(0xff); /* take cos */
+	tos_make(d); /* store to destination */
+    }
+    else {
+	make_tos(d);
+	emit_byte(0xd9);
+	emit_byte(0xff); /* take cos */
+    }	
+}
+LENDFUNC(NONE,NONE,2,raw_fcos_rr,(FW d, FR s))
+
+LOWFUNC(NONE,NONE,2,raw_fsin_rr,(FW d, FR s))
+{
+    int ds;
+
+    if (d!=s) {
+	usereg(s);
+	ds=stackpos(s);
+	emit_byte(0xd9);
+	emit_byte(0xc0+ds); /* duplicate source */
+	emit_byte(0xd9);
+	emit_byte(0xfe); /* take sin */
+	tos_make(d); /* store to destination */
+    }
+    else {
+	make_tos(d);
+	emit_byte(0xd9);
+	emit_byte(0xfe); /* take sin */
+    }	
+}
+LENDFUNC(NONE,NONE,2,raw_fsin_rr,(FW d, FR s))
+
+double one=1;
+LOWFUNC(NONE,NONE,2,raw_ftwotox_rr,(FW d, FR s))
+{
+    int ds;
+
+    usereg(s);
+    ds=stackpos(s);
+    emit_byte(0xd9);
+    emit_byte(0xc0+ds); /* duplicate source */
+
+    emit_byte(0xd9);
+    emit_byte(0xc0);  /* duplicate top of stack. Now up to 8 high */
+    emit_byte(0xd9);
+    emit_byte(0xfc);  /* rndint */
+    emit_byte(0xd9);
+    emit_byte(0xc9);  /* swap top two elements */
+    emit_byte(0xd8);
+    emit_byte(0xe1);  /* subtract rounded from original */
+    emit_byte(0xd9);
+    emit_byte(0xf0);  /* f2xm1 */
+    emit_byte(0xdc);
+    emit_byte(0x05);
+    emit_long((uae_u32)&one);  /* Add '1' without using extra stack space */
+    emit_byte(0xd9);
+    emit_byte(0xfd);  /* and scale it */
+    emit_byte(0xdd);
+    emit_byte(0xd9);  /* take he rounded value off */
+    tos_make(d); /* store to destination */
+}
+LENDFUNC(NONE,NONE,2,raw_ftwotox_rr,(FW d, FR s))
+
+LOWFUNC(NONE,NONE,2,raw_fetox_rr,(FW d, FR s))
+{
+    int ds;
+
+    usereg(s);
+    ds=stackpos(s);
+    emit_byte(0xd9);
+    emit_byte(0xc0+ds); /* duplicate source */
+    emit_byte(0xd9);
+    emit_byte(0xea);   /* fldl2e */
+    emit_byte(0xde);
+    emit_byte(0xc9);  /* fmulp --- multiply source by log2(e) */
+
+    emit_byte(0xd9);
+    emit_byte(0xc0);  /* duplicate top of stack. Now up to 8 high */
+    emit_byte(0xd9);
+    emit_byte(0xfc);  /* rndint */
+    emit_byte(0xd9);
+    emit_byte(0xc9);  /* swap top two elements */
+    emit_byte(0xd8);
+    emit_byte(0xe1);  /* subtract rounded from original */
+    emit_byte(0xd9);
+    emit_byte(0xf0);  /* f2xm1 */
+    emit_byte(0xdc);
+    emit_byte(0x05);
+    emit_long((uae_u32)&one);  /* Add '1' without using extra stack space */
+    emit_byte(0xd9);
+    emit_byte(0xfd);  /* and scale it */
+    emit_byte(0xdd);
+    emit_byte(0xd9);  /* take he rounded value off */
+    tos_make(d); /* store to destination */
+}
+LENDFUNC(NONE,NONE,2,raw_fetox_rr,(FW d, FR s))
+ 
+LOWFUNC(NONE,NONE,2,raw_flog2_rr,(FW d, FR s))
+{
+    int ds;
+
+    usereg(s);
+    ds=stackpos(s);
+    emit_byte(0xd9);
+    emit_byte(0xc0+ds); /* duplicate source */
+    emit_byte(0xd9);
+    emit_byte(0xe8); /* push '1' */
+    emit_byte(0xd9);
+    emit_byte(0xc9); /* swap top two */
+    emit_byte(0xd9);
+    emit_byte(0xf1); /* take 1*log2(x) */
+    tos_make(d); /* store to destination */
+}
+LENDFUNC(NONE,NONE,2,raw_flog2_rr,(FW d, FR s))
+
+
+LOWFUNC(NONE,NONE,2,raw_fneg_rr,(FW d, FR s))
+{
+    int ds;
+
+    if (d!=s) {
+	usereg(s);
+	ds=stackpos(s);
+	emit_byte(0xd9);
+	emit_byte(0xc0+ds); /* duplicate source */
+	emit_byte(0xd9);
+	emit_byte(0xe0); /* take fchs */
+	tos_make(d); /* store to destination */
+    }
+    else {
+	make_tos(d);
+	emit_byte(0xd9);
+	emit_byte(0xe0); /* take fchs */
+    }	
+}
+LENDFUNC(NONE,NONE,2,raw_fneg_rr,(FW d, FR s))
+
+LOWFUNC(NONE,NONE,2,raw_fadd_rr,(FRW d, FR s))
+{
+    int ds;
+
+    usereg(s);
+    usereg(d);
+    
+    if (live.spos[s]==live.tos) {
+	/* Source is on top of stack */
+	ds=stackpos(d);
+	emit_byte(0xdc);
+	emit_byte(0xc0+ds); /* add source to dest*/
+    }
+    else {
+	make_tos(d);
+	ds=stackpos(s);
+	
+	emit_byte(0xd8);
+	emit_byte(0xc0+ds); /* add source to dest*/
+    }
+}
+LENDFUNC(NONE,NONE,2,raw_fadd_rr,(FRW d, FR s))
+
+LOWFUNC(NONE,NONE,2,raw_fsub_rr,(FRW d, FR s))
+{
+    int ds;
+
+    usereg(s);
+    usereg(d);
+    
+    if (live.spos[s]==live.tos) {
+	/* Source is on top of stack */
+	ds=stackpos(d);
+	emit_byte(0xdc);
+	emit_byte(0xe8+ds); /* sub source from dest*/
+    }
+    else {
+	make_tos(d);
+	ds=stackpos(s);
+	
+	emit_byte(0xd8);
+	emit_byte(0xe0+ds); /* sub src from dest */
+    }
+}
+LENDFUNC(NONE,NONE,2,raw_fsub_rr,(FRW d, FR s))
+
+LOWFUNC(NONE,NONE,2,raw_fcmp_rr,(FR d, FR s))
+{
+    int ds;
+
+    usereg(s);
+    usereg(d);
+    
+    make_tos(d);
+    ds=stackpos(s);
+
+    emit_byte(0xdd);
+    emit_byte(0xe0+ds); /* cmp dest with source*/
+}
+LENDFUNC(NONE,NONE,2,raw_fcmp_rr,(FR d, FR s))
+
+LOWFUNC(NONE,NONE,2,raw_fmul_rr,(FRW d, FR s))
+{
+    int ds;
+
+    usereg(s);
+    usereg(d);
+    
+    if (live.spos[s]==live.tos) {
+	/* Source is on top of stack */
+	ds=stackpos(d);
+	emit_byte(0xdc);
+	emit_byte(0xc8+ds); /* mul dest by source*/
+    }
+    else {
+	make_tos(d);
+	ds=stackpos(s);
+	
+	emit_byte(0xd8);
+	emit_byte(0xc8+ds); /* mul dest by source*/
+    }
+}
+LENDFUNC(NONE,NONE,2,raw_fmul_rr,(FRW d, FR s))
+
+LOWFUNC(NONE,NONE,2,raw_fdiv_rr,(FRW d, FR s))
+{
+    int ds;
+
+    usereg(s);
+    usereg(d);
+    
+    if (live.spos[s]==live.tos) {
+	/* Source is on top of stack */
+	ds=stackpos(d);
+	emit_byte(0xdc);
+	emit_byte(0xf8+ds); /* div dest by source */
+    }
+    else {
+	make_tos(d);
+	ds=stackpos(s);
+	
+	emit_byte(0xd8);
+	emit_byte(0xf0+ds); /* div dest by source*/
+    }
+}
+LENDFUNC(NONE,NONE,2,raw_fdiv_rr,(FRW d, FR s))
+
+LOWFUNC(NONE,NONE,2,raw_frem_rr,(FRW d, FR s))
+{
+    int ds;
+
+    usereg(s);
+    usereg(d);
+    
+    make_tos2(d,s);
+    ds=stackpos(s);
+
+    if (ds!=1) {
+	printf("Failed horribly in raw_frem_rr! ds is %d\n",ds);
+	abort();
+    }
+    emit_byte(0xd9);
+    emit_byte(0xf8); /* take rem from dest by source */
+}
+LENDFUNC(NONE,NONE,2,raw_frem_rr,(FRW d, FR s))
+
+LOWFUNC(NONE,NONE,2,raw_frem1_rr,(FRW d, FR s))
+{
+    int ds;
+
+    usereg(s);
+    usereg(d);
+    
+    make_tos2(d,s);
+    ds=stackpos(s);
+
+    if (ds!=1) {
+	printf("Failed horribly in raw_frem1_rr! ds is %d\n",ds);
+	abort();
+    }
+    emit_byte(0xd9);
+    emit_byte(0xf5); /* take rem1 from dest by source */
+}
+LENDFUNC(NONE,NONE,2,raw_frem1_rr,(FRW d, FR s))
+
+
+LOWFUNC(NONE,NONE,1,raw_ftst_r,(FR r))
+{
+    make_tos(r);
+    emit_byte(0xd9);  /* ftst */
+    emit_byte(0xe4);
+}
+LENDFUNC(NONE,NONE,1,raw_ftst_r,(FR r))
+
+static __inline__ void raw_fflags_into_flags(int r)
+{
+    int p;
+
+    usereg(r);
+    p=stackpos(r);
+
+    emit_byte(0xd9);
+    emit_byte(0xee); /* Push 0 */
+    emit_byte(0xd9);
+    emit_byte(0xc9+p); /* swap top two around */
+    if (have_cmov) {
+            // gb-- fucomi is for P6 cores only, not K6-2 then...
+    emit_byte(0xdb);
+    emit_byte(0xe9+p); /* fucomi them */
+    }
+    else {
+            emit_byte(0xdd);
+            emit_byte(0xe1+p); /* fucom them */
+            emit_byte(0x9b);
+            emit_byte(0xdf);
+            emit_byte(0xe0); /* fstsw ax */
+            raw_sahf(0); /* sahf */
+    }
+    emit_byte(0xdd);
+    emit_byte(0xd9+p);  /* store value back, and get rid of 0 */
+}
Index: src/compemu_support.c
===================================================================
RCS file: compemu_support.c
diff -N compemu_support.c
--- /dev/null	Tue Oct  2 20:51:52 2001
+++ src/compemu_support.c	Sat Feb 16 20:08:35 2002
@@ -0,0 +1,6244 @@
+#define writemem_special writemem
+#define readmem_special  readmem
+
+#define GS_NATMEM_OFFSET 0
+
+#define USE_MATCHSTATE 0
+
+#include "sysconfig.h"
+#include "sysdeps.h"
+#include "config.h"
+#include "options.h"
+#include "events.h"
+#include "include/memory.h"
+#include "custom.h"
+#include "newcpu.h"
+#include "compiler.h"
+#include "comptbl.h"
+#include "compemu.h"
+
+// %%% BRIAN KING WAS HERE %%%
+extern int canbang;
+static int use_gs_seg = 0;
+
+#ifndef _WIN32
+#include <sys/mman.h>
+#else
+#include <signal.h>
+#include "osdep/mman.h"
+#endif
+#include <limits.h>		/* for PAGESIZE */
+
+cpuop_func *compfunctbl[65536];
+cpuop_func *nfcompfunctbl[65536];
+#ifdef NOFLAGS_SUPPORT
+cpuop_func *nfcpufunctbl[65536];
+#endif
+uae_u8 *comp_pc_p;
+
+uae_u8 *start_pc_p;
+uae_u32 start_pc;
+uae_u32 current_block_pc_p;
+uae_u32 current_block_start_target;
+uae_u32 needed_flags;
+static uae_u32 next_pc_p;
+static uae_u32 taken_pc_p;
+static int branch_cc;
+int segvcount = 0;
+int soft_flush_count = 0;
+int hard_flush_count = 0;
+int compile_count = 0;
+int checksum_count = 0;
+static uae_u8 *current_compile_p = NULL;
+static uae_u8 *max_compile_start;
+static uae_u8 *compiled_code = NULL;
+static uae_s32 reg_alloc_run;
+static int have_rat_stall = 0;
+
+void *pushall_call_handler = NULL;
+static void *popall_do_nothing = NULL;
+static void *popall_exec_nostats = NULL;
+static void *popall_execute_normal = NULL;
+static void *popall_cache_miss = NULL;
+static void *popall_recompile_block = NULL;
+static void *popall_check_checksum = NULL;
+
+extern uae_u32 oink;
+extern unsigned long foink3;
+extern unsigned long foink;
+
+/* The 68k only ever executes from even addresses. So right now, we
+   waste half the entries in this array
+   UPDATE: We now use those entries to store the start of the linked
+   lists that we maintain for each hash result. */
+cacheline cache_tags[TAGSIZE];
+int letit = 0;
+blockinfo *hold_bi[MAX_HOLD_BI];
+blockinfo *active;
+blockinfo *dormant;
+
+op_properties prop[65536];
+
+#ifdef NOFLAGS_SUPPORT
+/* 68040 */
+extern struct cputbl op_smalltbl_0_nf[];
+#endif
+extern struct cputbl op_smalltbl_0_comp_nf[];
+extern struct cputbl op_smalltbl_0_comp_ff[];
+#ifdef NOFLAGS_SUPPORT
+/* 68020 + 68881 */
+extern struct cputbl op_smalltbl_1_nf[];
+/* 68020 */
+extern struct cputbl op_smalltbl_2_nf[];
+/* 68010 */
+extern struct cputbl op_smalltbl_3_nf[];
+/* 68000 */
+extern struct cputbl op_smalltbl_4_nf[];
+/* 68000 slow but compatible.  */
+extern struct cputbl op_smalltbl_5_nf[];
+#endif
+
+static void flush_icache_hard (int n);
+
+
+
+bigstate live;
+smallstate empty_ss;
+smallstate default_ss;
+static int optlev;
+
+static int writereg (int r, int size);
+static void unlock (int r);
+static void setlock (int r);
+static int readreg_specific (int r, int size, int spec);
+static int writereg_specific (int r, int size, int spec);
+static void prepare_for_call_1 (void);
+static void prepare_for_call_2 (void);
+static void align_target (uae_u32 a);
+
+static uae_s32 nextused[VREGS];
+
+uae_u32 m68k_pc_offset;
+
+/* Some arithmetic ooperations can be optimized away if the operands
+   are known to be constant. But that's only a good idea when the
+   side effects they would have on the flags are not important. This
+   variable indicates whether we need the side effects or not 
+*/
+uae_u32 needflags = 0;
+
+/* Flag handling is complicated.
+
+   x86 instructions create flags, which quite often are exactly what we
+   want. So at times, the "68k" flags are actually in the x86 flags.
+
+   Then again, sometimes we do x86 instructions that clobber the x86
+   flags, but don't represent a corresponding m68k instruction. In that
+   case, we have to save them. 
+
+   We used to save them to the stack, but now store them back directly
+   into the regflags.cznv of the traditional emulation. Thus some odd
+   names.
+
+   So flags can be in either of two places (used to be three; boy were
+   things complicated back then!); And either place can contain either
+   valid flags or invalid trash (and on the stack, there was also the
+   option of "nothing at all", now gone). A couple of variables keep
+   track of the respective states.
+
+   To make things worse, we might or might not be interested in the flags.
+   by default, we are, but a call to dont_care_flags can change that 
+   until the next call to live_flags. If we are not, pretty much whatever
+   is in the register and/or the native flags is seen as valid.
+*/
+
+
+static __inline__ blockinfo *get_blockinfo (uae_u32 cl)
+{
+    return cache_tags[cl + 1].bi;
+}
+
+static __inline__ blockinfo *get_blockinfo_addr (void *addr)
+{
+    blockinfo *bi = get_blockinfo (cacheline (addr));
+
+    while (bi) {
+	if (bi->pc_p == addr)
+	    return bi;
+	bi = bi->next_same_cl;
+    }
+    return NULL;
+}
+
+
+/*******************************************************************
+ * All sorts of list related functions for all of the lists        *
+ *******************************************************************/
+
+static __inline__ void remove_from_cl_list (blockinfo * bi)
+{
+    uae_u32 cl = cacheline (bi->pc_p);
+
+    if (bi->prev_same_cl_p)
+	*(bi->prev_same_cl_p) = bi->next_same_cl;
+    if (bi->next_same_cl)
+	bi->next_same_cl->prev_same_cl_p = bi->prev_same_cl_p;
+    if (cache_tags[cl + 1].bi)
+	cache_tags[cl].handler = cache_tags[cl + 1].bi->handler_to_use;
+    else
+	cache_tags[cl].handler = popall_execute_normal;
+}
+
+static __inline__ void remove_from_list (blockinfo * bi)
+{
+    if (bi->prev_p)
+	*(bi->prev_p) = bi->next;
+    if (bi->next)
+	bi->next->prev_p = bi->prev_p;
+}
+
+static __inline__ void remove_from_lists (blockinfo * bi)
+{
+    remove_from_list (bi);
+    remove_from_cl_list (bi);
+}
+
+static __inline__ void add_to_cl_list (blockinfo * bi)
+{
+    uae_u32 cl = cacheline (bi->pc_p);
+
+    if (cache_tags[cl + 1].bi)
+	cache_tags[cl + 1].bi->prev_same_cl_p = &(bi->next_same_cl);
+    bi->next_same_cl = cache_tags[cl + 1].bi;
+
+    cache_tags[cl + 1].bi = bi;
+    bi->prev_same_cl_p = &(cache_tags[cl + 1].bi);
+
+    cache_tags[cl].handler = bi->handler_to_use;
+}
+
+static __inline__ void raise_in_cl_list (blockinfo * bi)
+{
+    remove_from_cl_list (bi);
+    add_to_cl_list (bi);
+}
+
+static __inline__ void add_to_active (blockinfo * bi)
+{
+    if (active)
+	active->prev_p = &(bi->next);
+    bi->next = active;
+
+    active = bi;
+    bi->prev_p = &active;
+}
+
+static __inline__ void add_to_dormant (blockinfo * bi)
+{
+    if (dormant)
+	dormant->prev_p = &(bi->next);
+    bi->next = dormant;
+
+    dormant = bi;
+    bi->prev_p = &dormant;
+}
+
+static __inline__ void remove_dep (dependency * d)
+{
+    if (d->prev_p)
+	*(d->prev_p) = d->next;
+    if (d->next)
+	d->next->prev_p = d->prev_p;
+    d->prev_p = NULL;
+    d->next = NULL;
+}
+
+/* This block's code is about to be thrown away, so it no longer
+   depends on anything else */
+static __inline__ void remove_deps (blockinfo * bi)
+{
+    remove_dep (&(bi->dep[0]));
+    remove_dep (&(bi->dep[1]));
+}
+
+static __inline__ void adjust_jmpdep (dependency * d, void *a)
+{
+    *(d->jmp_off) = (uae_u32) a - ((uae_u32) d->jmp_off + 4);
+}
+
+/********************************************************************
+ * Soft flush handling support functions                            *
+ ********************************************************************/
+
+static __inline__ void set_dhtu (blockinfo * bi, void *dh)
+{
+    //printf("bi is %p\n",bi);
+    if (dh != bi->direct_handler_to_use) {
+	dependency *x = bi->deplist;
+	//printf("bi->deplist=%p\n",bi->deplist);
+	while (x) {
+	    //printf("x is %p\n",x);
+	    //printf("x->next is %p\n",x->next);
+	    //printf("x->prev_p is %p\n",x->prev_p);
+
+	    if (x->jmp_off) {
+		adjust_jmpdep (x, dh);
+	    }
+	    x = x->next;
+	}
+	bi->direct_handler_to_use = dh;
+    }
+}
+
+static __inline__ void invalidate_block (blockinfo * bi)
+{
+    int i;
+
+    bi->optlevel = 0;
+    bi->count = currprefs.optcount[0] - 1;
+    bi->handler = NULL;
+    bi->handler_to_use = popall_execute_normal;
+    bi->direct_handler = NULL;
+    set_dhtu (bi, bi->direct_pen);
+    bi->needed_flags = 0xff;
+
+    for (i = 0; i < 2; i++) {
+	bi->dep[i].jmp_off = NULL;
+	bi->dep[i].target = NULL;
+    }
+    remove_deps (bi);
+}
+
+static __inline__ void create_jmpdep (blockinfo * bi, int i, uae_u32 * jmpaddr, uae_u32 target)
+{
+    blockinfo *tbi = get_blockinfo_addr ((void *) target);
+
+    Dif (!tbi) {
+	printf ("Could not create jmpdep!\n");
+	abort ();
+    }
+    bi->dep[i].jmp_off = jmpaddr;
+    bi->dep[i].target = tbi;
+    bi->dep[i].next = tbi->deplist;
+    if (bi->dep[i].next)
+	bi->dep[i].next->prev_p = &(bi->dep[i].next);
+    bi->dep[i].prev_p = &(tbi->deplist);
+    tbi->deplist = &(bi->dep[i]);
+}
+
+static __inline__ void big_to_small_state (bigstate * b, smallstate * s)
+{
+    int i;
+    int count = 0;
+
+    for (i = 0; i < N_REGS; i++) {
+	s->nat[i].validsize = 0;
+	s->nat[i].dirtysize = 0;
+	if (b->nat[i].nholds) {
+	    int index = b->nat[i].nholds - 1;
+	    int r = b->nat[i].holds[index];
+	    s->nat[i].holds = r;
+	    s->nat[i].validsize = b->state[r].validsize;
+	    s->nat[i].dirtysize = b->state[r].dirtysize;
+	    count++;
+	}
+    }
+    printf ("count=%d\n", count);
+    for (i = 0; i < N_REGS; i++) {	// FIXME --- don't do dirty yet 
+	s->nat[i].dirtysize = 0;
+    }
+}
+
+static __inline__ void attached_state (blockinfo * bi)
+{
+    bi->havestate = 1;
+    if (bi->direct_handler_to_use == bi->direct_handler)
+	set_dhtu (bi, bi->direct_pen);
+    bi->direct_handler = bi->direct_pen;
+    bi->status = BI_TARGETTED;
+}
+
+static __inline__ blockinfo *get_blockinfo_addr_new (void *addr, int setstate)
+{
+    blockinfo *bi = get_blockinfo_addr (addr);
+    int i;
+
+#if USE_OPTIMIZER
+    if (reg_alloc_run)
+	return NULL;
+#endif
+    if (!bi) {
+	for (i = 0; i < MAX_HOLD_BI && !bi; i++) {
+	    if (hold_bi[i]) {
+		uae_u32 cl = cacheline (addr);
+
+		bi = hold_bi[i];
+		hold_bi[i] = NULL;
+		bi->pc_p = addr;
+		invalidate_block (bi);
+		add_to_active (bi);
+		add_to_cl_list (bi);
+
+	    }
+	}
+    }
+    if (!bi) {
+	fprintf (stderr, "Looking for blockinfo, can't find free one\n");
+	abort ();
+    }
+#if USE_MATCHSTATE
+    if (setstate && !bi->havestate) {
+	big_to_small_state (&live, &(bi->env));
+	attached_state (bi);
+    }
+#endif
+    return bi;
+}
+
+static void prepare_block (blockinfo * bi);
+
+static __inline__ void alloc_blockinfos (void)
+{
+    int i;
+    blockinfo *bi;
+
+    for (i = 0; i < MAX_HOLD_BI; i++) {
+	if (hold_bi[i])
+	    return;
+	bi = hold_bi[i] = (blockinfo *) current_compile_p;
+	current_compile_p += sizeof (blockinfo);
+
+	prepare_block (bi);
+    }
+}
+
+/********************************************************************
+ * Preferences handling. This is just a convenient place to put it  *
+ ********************************************************************/
+extern int have_done_picasso;
+
+void check_prefs_changed_comp (void)
+{
+    currprefs.comptrustbyte = changed_prefs.comptrustbyte;
+    currprefs.comptrustword = changed_prefs.comptrustword;
+    currprefs.comptrustlong = changed_prefs.comptrustlong;
+    currprefs.comptrustnaddr = changed_prefs.comptrustnaddr;
+    currprefs.compnf = changed_prefs.compnf;
+    currprefs.comp_hardflush = changed_prefs.comp_hardflush;
+    currprefs.comp_constjump = changed_prefs.comp_constjump;
+    currprefs.comp_oldsegv = changed_prefs.comp_oldsegv;
+    currprefs.compfpu = changed_prefs.compfpu;
+
+    // Turn off JIT for 24-bit address-space CPU settings...
+    if (currprefs.address_space_24 || (currprefs.cpu_level < 2)) {
+	changed_prefs.cachesize = 0;
+    }
+
+    if (currprefs.cachesize != changed_prefs.cachesize) {
+	currprefs.cachesize = changed_prefs.cachesize;
+	alloc_cache ();
+    }
+    // Turn off illegal-mem logging when using JIT...
+    if (currprefs.cachesize)
+	currprefs.illegal_mem = changed_prefs.illegal_mem;	// = 0;
+
+    currprefs.comp_midopt = changed_prefs.comp_midopt;
+    currprefs.comp_lowopt = changed_prefs.comp_lowopt;
+
+    if ((!canbang || !currprefs.cachesize) && currprefs.comptrustbyte != 1) {
+	// Set all of these to indirect when canbang == 0
+	// Basically, set the  compforcesettings option...
+	currprefs.comptrustbyte = 1;
+	currprefs.comptrustword = 1;
+	currprefs.comptrustlong = 1;
+	currprefs.comptrustnaddr = 1;
+	currprefs.compforcesettings = 1;
+
+	changed_prefs.comptrustbyte = 1;
+	changed_prefs.comptrustword = 1;
+	changed_prefs.comptrustlong = 1;
+	changed_prefs.comptrustnaddr = 1;
+	changed_prefs.compforcesettings = 1;
+
+	if (currprefs.cachesize) {
+	    write_log ("JIT: Reverting to \"indirect\" access, because canbang is zero!\n");
+	}
+    }
+
+    if (!currprefs.compforcesettings && !have_done_picasso) {
+	int stop = 0;
+	if (currprefs.comptrustbyte != 0 && currprefs.comptrustbyte != 3)
+	    stop = 1, write_log ("<JIT compiler> : comptrustbyte is not 'direct' or 'afterpic'\n");
+	if (currprefs.comptrustword != 0 && currprefs.comptrustword != 3)
+	    stop = 1, write_log ("<JIT compiler> : comptrustword is not 'direct' or 'afterpic'\n");
+	if (currprefs.comptrustlong != 0 && currprefs.comptrustlong != 3)
+	    stop = 1, write_log ("<JIT compiler> : comptrustlong is not 'direct' or 'afterpic'\n");
+	if (currprefs.comptrustnaddr != 0 && currprefs.comptrustnaddr != 3)
+	    stop = 1, write_log ("<JIT compiler> : comptrustnaddr is not 'direct' or 'afterpic'\n");
+	if (currprefs.compnf != 1)
+	    stop = 1, write_log ("<JIT compiler> : compnf is not 'yes'\n");
+	if (currprefs.cachesize < 1024)
+	    stop = 1, write_log ("<JIT compiler> : cachesize is less than 1024\n");
+	if (currprefs.comp_hardflush)
+	    stop = 1, write_log ("<JIT compiler> : comp_flushmode is 'hard'\n");
+	if (!canbang)
+	    stop = 1, write_log ("<JIT compiler> : Cannot use most direct memory access,\n"
+				 "                 and unable to recover from failed guess!\n");
+#if 0
+	if (stop) {
+	    gui_message ("JIT: Configuration problems were detected!\n"
+			 "JIT: These will adversely affect performance, and should\n"
+			 "JIT: not be used. For more info, please see README.JIT-tuning\n"
+			 "JIT: in the UAE documentation directory. You can force\n"
+			 "JIT: your settings to be used by setting\n"
+			 "JIT:      'compforcesettings=yes'\n" "JIT: in your config file\n");
+	    exit (1);
+	}
+#endif
+    }
+}
+
+/********************************************************************
+ * Get the optimizer stuff                                          *
+ ********************************************************************/
+
+#include "compemu_optimizer.c"
+
+/********************************************************************
+ * Functions to emit data into memory, and other general support    *
+ ********************************************************************/
+
+static uae_u8 *target;
+
+static void emit_init (void)
+{
+}
+
+static __inline__ void emit_byte (uae_u8 x)
+{
+    *target++ = x;
+}
+
+static __inline__ void emit_word (uae_u16 x)
+{
+    *((uae_u16 *) target) = x;
+    target += 2;
+}
+
+static __inline__ void emit_long (uae_u32 x)
+{
+    *((uae_u32 *) target) = x;
+    target += 4;
+}
+
+static __inline__ uae_u32 reverse32 (uae_u32 oldv)
+{
+    return ((oldv >> 24) & 0xff) | ((oldv >> 8) & 0xff00) | ((oldv << 8) & 0xff0000) | ((oldv << 24) & 0xff000000);
+}
+
+
+void set_target (uae_u8 * t)
+{
+    lopt_emit_all ();
+    target = t;
+}
+
+static __inline__ uae_u8 *get_target_noopt (void)
+{
+    return target;
+}
+
+__inline__ uae_u8 *get_target (void)
+{
+    lopt_emit_all ();
+    return get_target_noopt ();
+}
+
+
+/********************************************************************
+ * Getting the information about the target CPU                     *
+ ********************************************************************/
+
+#include "compemu_raw_x86.c"
+
+
+/********************************************************************
+ * Flags status handling. EMIT TIME!                                *
+ ********************************************************************/
+
+static void bt_l_ri_noclobber (R4 r, IMM i);
+
+static void make_flags_live_internal (void)
+{
+    if (live.flags_in_flags == VALID)
+	return;
+    Dif (live.flags_on_stack == TRASH) {
+	printf ("Want flags, got something on stack, but it is TRASH\n");
+	abort ();
+    }
+    if (live.flags_on_stack == VALID) {
+	int tmp;
+	tmp = readreg_specific (FLAGTMP, 4, FLAG_NREG2);
+	raw_reg_to_flags (tmp);
+	unlock (tmp);
+
+	live.flags_in_flags = VALID;
+	return;
+    }
+    printf ("Huh? live.flags_in_flags=%d, live.flags_on_stack=%d, but need to make live\n",
+	    live.flags_in_flags, live.flags_on_stack);
+    abort ();
+}
+
+static void flags_to_stack (void)
+{
+    if (live.flags_on_stack == VALID)
+	return;
+    if (!live.flags_are_important) {
+	live.flags_on_stack = VALID;
+	return;
+    }
+    Dif (live.flags_in_flags != VALID)
+	abort ();
+    else {
+	int tmp;
+	tmp = writereg_specific (FLAGTMP, 4, FLAG_NREG1);
+	raw_flags_to_reg (tmp);
+	unlock (tmp);
+    }
+    live.flags_on_stack = VALID;
+}
+
+static __inline__ void clobber_flags (void)
+{
+    if (live.flags_in_flags == VALID && live.flags_on_stack != VALID)
+	flags_to_stack ();
+    live.flags_in_flags = TRASH;
+}
+
+/* Prepare for leaving the compiled stuff */
+static __inline__ void flush_flags (void)
+{
+    flags_to_stack ();
+    return;
+}
+
+int touchcnt;
+
+/********************************************************************
+ * register allocation per block logging                            *
+ ********************************************************************/
+
+static uae_s8 vstate[VREGS];
+static uae_s8 nstate[N_REGS];
+
+#define L_UNKNOWN -127
+#define L_UNAVAIL -1
+#define L_NEEDED -2
+#define L_UNNEEDED -3
+
+static __inline__ void log_startblock (void)
+{
+    int i;
+    for (i = 0; i < VREGS; i++)
+	vstate[i] = L_UNKNOWN;
+    for (i = 0; i < N_REGS; i++)
+	nstate[i] = L_UNKNOWN;
+}
+
+static __inline__ void log_isused (int n)
+{
+    if (nstate[n] == L_UNKNOWN)
+	nstate[n] = L_UNAVAIL;
+}
+
+static __inline__ void log_isreg (int n, int r)
+{
+    if (nstate[n] == L_UNKNOWN)
+	nstate[n] = r;
+    if (vstate[r] == L_UNKNOWN)
+	vstate[r] = L_NEEDED;
+}
+
+static __inline__ void log_clobberreg (int r)
+{
+    if (vstate[r] == L_UNKNOWN)
+	vstate[r] = L_UNNEEDED;
+}
+
+/* This ends all possibility of clever register allocation */
+
+static __inline__ void log_flush (void)
+{
+    int i;
+    for (i = 0; i < VREGS; i++)
+	if (vstate[i] == L_UNKNOWN)
+	    vstate[i] = L_NEEDED;
+    for (i = 0; i < N_REGS; i++)
+	if (nstate[i] == L_UNKNOWN)
+	    nstate[i] = L_UNAVAIL;
+}
+
+static __inline__ void log_dump (void)
+{
+    int i;
+
+    return;
+
+    write_log ("----------------------\n");
+    for (i = 0; i < N_REGS; i++) {
+	switch (nstate[i]) {
+	case L_UNKNOWN:
+	    write_log ("Nat %d : UNKNOWN\n", i);
+	    break;
+	case L_UNAVAIL:
+	    write_log ("Nat %d : UNAVAIL\n", i);
+	    break;
+	default:
+	    write_log ("Nat %d : %d\n", i, nstate[i]);
+	    break;
+	}
+    }
+    for (i = 0; i < VREGS; i++) {
+	if (vstate[i] == L_UNNEEDED)
+	    write_log ("Virt %d: UNNEEDED\n", i);
+    }
+}
+
+/********************************************************************
+ * register status handling. EMIT TIME!                             *
+ ********************************************************************/
+
+static __inline__ void set_status (int r, int status)
+{
+    if (status == ISCONST)
+	log_clobberreg (r);
+    live.state[r].status = status;
+}
+
+
+static __inline__ int isinreg (int r)
+{
+    return live.state[r].status == CLEAN || live.state[r].status == DIRTY;
+}
+
+static __inline__ void adjust_nreg (int r, uae_u32 val)
+{
+    if (!val)
+	return;
+    raw_lea_l_brr (r, r, val);
+}
+
+static void tomem (int r)
+{
+    int rr = live.state[r].realreg;
+
+    if (isinreg (r)) {
+	if (live.state[r].val && live.nat[rr].nholds == 1 && !live.nat[rr].locked) {
+	    // printf("RemovingA offset %x from reg %d (%d) at %p\n",
+	    //   live.state[r].val,r,rr,target); 
+	    adjust_nreg (rr, live.state[r].val);
+	    live.state[r].val = 0;
+	    live.state[r].dirtysize = 4;
+	    set_status (r, DIRTY);
+	}
+    }
+
+    if (live.state[r].status == DIRTY) {
+	switch (live.state[r].dirtysize) {
+	case 1:
+	    raw_mov_b_mr ((uae_u32) live.state[r].mem, rr);
+	    break;
+	case 2:
+	    raw_mov_w_mr ((uae_u32) live.state[r].mem, rr);
+	    break;
+	case 4:
+	    raw_mov_l_mr ((uae_u32) live.state[r].mem, rr);
+	    break;
+	default:
+	    abort ();
+	}
+	set_status (r, CLEAN);
+	live.state[r].dirtysize = 0;
+    }
+}
+
+static __inline__ int isconst (int r)
+{
+    return live.state[r].status == ISCONST;
+}
+
+int is_const (int r)
+{
+    return isconst (r);
+}
+
+static __inline__ void writeback_const (int r)
+{
+    if (!isconst (r))
+	return;
+    Dif (live.state[r].needflush == NF_HANDLER) {
+	fprintf (stderr, "Trying to write back constant NF_HANDLER!\n");
+	abort ();
+    }
+
+    raw_mov_l_mi ((uae_u32) live.state[r].mem, live.state[r].val);
+    live.state[r].val = 0;
+    set_status (r, INMEM);
+}
+
+static __inline__ void tomem_c (int r)
+{
+    if (isconst (r)) {
+	writeback_const (r);
+    } else
+	tomem (r);
+}
+
+static void evict (int r)
+{
+    int rr;
+
+    if (!isinreg (r))
+	return;
+    tomem (r);
+    rr = live.state[r].realreg;
+
+    Dif (live.nat[rr].locked && live.nat[rr].nholds == 1) {
+	fprintf (stderr, "register %d in nreg %d is locked!\n", r, live.state[r].realreg);
+	abort ();
+    }
+
+    live.nat[rr].nholds--;
+    if (live.nat[rr].nholds != live.state[r].realind) {	/* Was not last */
+	int topreg = live.nat[rr].holds[live.nat[rr].nholds];
+	int thisind = live.state[r].realind;
+	live.nat[rr].holds[thisind] = topreg;
+	live.state[topreg].realind = thisind;
+    }
+    live.state[r].realreg = -1;
+    set_status (r, INMEM);
+}
+
+static __inline__ void free_nreg (int r)
+{
+    int i = live.nat[r].nholds;
+
+    while (i) {
+	int vr;
+
+	--i;
+	vr = live.nat[r].holds[i];
+	evict (vr);
+    }
+    Dif (live.nat[r].nholds != 0) {
+	printf ("Failed to free nreg %d, nholds is %d\n", r, live.nat[r].nholds);
+	abort ();
+    }
+}
+
+/* Use with care! */
+static __inline__ void isclean (int r)
+{
+    if (!isinreg (r))
+	return;
+    live.state[r].validsize = 4;
+    live.state[r].dirtysize = 0;
+    live.state[r].val = 0;
+    set_status (r, CLEAN);
+}
+
+static __inline__ void disassociate (int r)
+{
+    isclean (r);
+    evict (r);
+}
+
+static __inline__ void set_const (int r, uae_u32 val)
+{
+    disassociate (r);
+    live.state[r].val = val;
+    set_status (r, ISCONST);
+}
+
+static __inline__ uae_u32 get_offset (int r)
+{
+    return live.state[r].val;
+}
+
+static int alloc_reg_hinted (int r, int size, int willclobber, int hint)
+{
+    int bestreg;
+    uae_s32 when;
+    int i;
+    uae_s32 badness = 0;	/* to shut up gcc */
+    bestreg = -1;
+    when = 2000000000;
+
+    for (i = N_REGS; i--;) {
+	badness = live.nat[i].touched;
+	if (live.nat[i].nholds == 0)
+	    badness = 0;
+	if (i == hint)
+	    badness -= 200000000;
+	if (!live.nat[i].locked && badness < when) {
+	    if ((size == 1 && live.nat[i].canbyte) || (size == 2 && live.nat[i].canword) || (size == 4)) {
+		bestreg = i;
+		when = badness;
+		if (live.nat[i].nholds == 0 && hint < 0)
+		    break;
+		if (i == hint)
+		    break;
+	    }
+	}
+    }
+    Dif (bestreg == -1)
+	abort ();
+
+    if (live.nat[bestreg].nholds > 0) {
+	free_nreg (bestreg);
+    }
+    if (isinreg (r)) {
+	int rr = live.state[r].realreg;
+	/* This will happen if we read a partially dirty register at a
+	   bigger size */
+	Dif (willclobber || live.state[r].validsize >= size)
+	    abort ();
+	Dif (live.nat[rr].nholds != 1)
+	    abort ();
+	if (size == 4 && live.state[r].validsize == 2) {
+	    log_isused (bestreg);
+	    raw_mov_l_rm (bestreg, (uae_u32) live.state[r].mem);
+	    raw_bswap_32 (bestreg);
+	    raw_zero_extend_16_rr (rr, rr);
+	    raw_zero_extend_16_rr (bestreg, bestreg);
+	    raw_bswap_32 (bestreg);
+	    raw_lea_l_brr_indexed (rr, rr, bestreg, 1, 0);
+	    live.state[r].validsize = 4;
+	    live.nat[rr].touched = touchcnt++;
+	    return rr;
+	}
+	if (live.state[r].validsize == 1) {
+	    /* Nothing yet */
+	}
+	evict (r);
+    }
+
+    if (!willclobber) {
+	if (live.state[r].status != UNDEF) {
+	    if (isconst (r)) {
+		raw_mov_l_ri (bestreg, live.state[r].val);
+		live.state[r].val = 0;
+		live.state[r].dirtysize = 4;
+		set_status (r, DIRTY);
+		log_isused (bestreg);
+	    } else {
+		if (r == FLAGTMP)
+		    raw_load_flagreg (bestreg, r);
+		else if (r == FLAGX)
+		    raw_load_flagx (bestreg, r);
+		else {
+		    raw_mov_l_rm (bestreg, (uae_u32) live.state[r].mem);
+		}
+		live.state[r].dirtysize = 0;
+		set_status (r, CLEAN);
+		log_isreg (bestreg, r);
+	    }
+	} else {
+	    live.state[r].val = 0;
+	    live.state[r].dirtysize = 0;
+	    set_status (r, CLEAN);
+	    log_isused (bestreg);
+	}
+	live.state[r].validsize = 4;
+    } else {			/* this is the easiest way, but not optimal. FIXME! */
+	/* Now it's trickier, but hopefully still OK */
+	if (!isconst (r) || size == 4) {
+	    live.state[r].validsize = size;
+	    live.state[r].dirtysize = size;
+	    live.state[r].val = 0;
+	    set_status (r, DIRTY);
+	    if (size == 4)
+		log_isused (bestreg);
+	    else
+		log_isreg (bestreg, r);
+	} else {
+	    if (live.state[r].status != UNDEF)
+		raw_mov_l_ri (bestreg, live.state[r].val);
+	    live.state[r].val = 0;
+	    live.state[r].validsize = 4;
+	    live.state[r].dirtysize = 4;
+	    set_status (r, DIRTY);
+	    log_isused (bestreg);
+	}
+    }
+    live.state[r].realreg = bestreg;
+    live.state[r].realind = live.nat[bestreg].nholds;
+    live.nat[bestreg].touched = touchcnt++;
+    live.nat[bestreg].holds[live.nat[bestreg].nholds] = r;
+    live.nat[bestreg].nholds++;
+
+    return bestreg;
+}
+
+static int alloc_reg (int r, int size, int willclobber)
+{
+    return alloc_reg_hinted (r, size, willclobber, -1);
+}
+
+static void unlock (int r)
+{
+    Dif (!live.nat[r].locked)
+	abort ();
+    live.nat[r].locked--;
+}
+
+static void setlock (int r)
+{
+    live.nat[r].locked++;
+}
+
+
+static void mov_nregs (int d, int s)
+{
+    int ns = live.nat[s].nholds;
+    int nd = live.nat[d].nholds;
+    int i;
+
+    if (s == d)
+	return;
+
+    if (nd > 0)
+	free_nreg (d);
+
+    raw_mov_l_rr (d, s);
+    log_isused (d);
+
+    for (i = 0; i < live.nat[s].nholds; i++) {
+	int vs = live.nat[s].holds[i];
+
+	live.state[vs].realreg = d;
+	live.state[vs].realind = i;
+	live.nat[d].holds[i] = vs;
+    }
+    live.nat[d].nholds = live.nat[s].nholds;
+
+    live.nat[s].nholds = 0;
+}
+
+
+static __inline__ void make_exclusive (int r, int size, int spec)
+{
+    int clobber;
+    reg_status oldstate;
+    int rr = live.state[r].realreg;
+    int nr;
+    int nind;
+    int ndirt = 0;
+    int i;
+
+    if (!isinreg (r))
+	return;
+    if (live.nat[rr].nholds == 1)
+	return;
+    for (i = 0; i < live.nat[rr].nholds; i++) {
+	int vr = live.nat[rr].holds[i];
+	if (vr != r && (live.state[vr].status == DIRTY || live.state[vr].val))
+	    ndirt++;
+    }
+    if (!ndirt && size < live.state[r].validsize && !live.nat[rr].locked) {
+	/* Everything else is clean, so let's keep this register */
+	for (i = 0; i < live.nat[rr].nholds; i++) {
+	    int vr = live.nat[rr].holds[i];
+	    if (vr != r) {
+		evict (vr);
+		i--;		/* Try that index again! */
+	    }
+	}
+	Dif (live.nat[rr].nholds != 1) {
+	    printf ("natreg %d holds %d vregs, %d not exclusive\n", rr, live.nat[rr].nholds, r);
+	    abort ();
+	}
+	return;
+    }
+
+    /* We have to split the register */
+    oldstate = live.state[r];
+
+    setlock (rr);		/* Make sure this doesn't go away */
+    /* Forget about r being in the register rr */
+    disassociate (r);
+    /* Get a new register, that we will clobber completely */
+    if (oldstate.status == DIRTY) {
+	/* If dirtysize is <4, we need a register that can handle the
+	   eventual smaller memory store! Thanks to Quake68k for exposing
+	   this detail ;-) */
+	nr = alloc_reg_hinted (r, oldstate.dirtysize, 1, spec);
+    } else {
+	nr = alloc_reg_hinted (r, 4, 1, spec);
+    }
+    nind = live.state[r].realind;
+    live.state[r] = oldstate;	/* Keep all the old state info */
+    live.state[r].realreg = nr;
+    live.state[r].realind = nind;
+
+    if (size < live.state[r].validsize) {
+	if (live.state[r].val) {
+	    /* Might as well compensate for the offset now */
+	    raw_lea_l_brr (nr, rr, oldstate.val);
+	    live.state[r].val = 0;
+	    live.state[r].dirtysize = 4;
+	    set_status (r, DIRTY);
+	} else
+	    raw_mov_l_rr (nr, rr);	/* Make another copy */
+    }
+    unlock (rr);
+}
+
+static __inline__ void add_offset (int r, uae_u32 off)
+{
+    live.state[r].val += off;
+}
+
+static __inline__ void remove_offset (int r, int spec)
+{
+    reg_status oldstate;
+    int rr;
+
+    if (isconst (r))
+	return;
+    if (live.state[r].val == 0)
+	return;
+    if (isinreg (r) && live.state[r].validsize < 4)
+	evict (r);
+
+    if (!isinreg (r))
+	alloc_reg_hinted (r, 4, 0, spec);
+
+    Dif (live.state[r].validsize != 4) {
+	printf ("Validsize=%d in remove_offset\n", live.state[r].validsize);
+	abort ();
+    }
+    make_exclusive (r, 0, -1);
+    /* make_exclusive might have done the job already */
+    if (live.state[r].val == 0)
+	return;
+
+    rr = live.state[r].realreg;
+
+    if (live.nat[rr].nholds == 1) {
+	//printf("RemovingB offset %x from reg %d (%d) at %p\n",
+	//       live.state[r].val,r,rr,target); 
+	adjust_nreg (rr, live.state[r].val);
+	live.state[r].dirtysize = 4;
+	live.state[r].val = 0;
+	set_status (r, DIRTY);
+	return;
+    }
+    printf ("Failed in remove_offset\n");
+    abort ();
+}
+
+STATIC_INLINE void remove_all_offsets (void)
+{
+    int i;
+
+    for (i = 0; i < VREGS; i++)
+	remove_offset (i, -1);
+}
+
+static __inline__ int readreg_general (int r, int size, int spec, int can_offset)
+{
+    int n;
+    int answer = -1;
+
+    if (live.state[r].status == UNDEF) {
+	printf ("WARNING: Unexpected read of undefined register %d\n", r);
+    }
+    if (!can_offset)
+	remove_offset (r, spec);
+
+    if (isinreg (r) && live.state[r].validsize >= size) {
+	n = live.state[r].realreg;
+	switch (size) {
+	case 1:
+	    if (live.nat[n].canbyte || spec >= 0) {
+		answer = n;
+	    }
+	    break;
+	case 2:
+	    if (live.nat[n].canword || spec >= 0) {
+		answer = n;
+	    }
+	    break;
+	case 4:
+	    answer = n;
+	    break;
+	default:
+	    abort ();
+	}
+	if (answer < 0)
+	    evict (r);
+    }
+    /* either the value was in memory to start with, or it was evicted and 
+       is in memory now */
+    if (answer < 0) {
+	answer = alloc_reg_hinted (r, spec >= 0 ? 4 : size, 0, spec);
+    }
+
+    if (spec >= 0 && spec != answer) {
+	/* Too bad */
+	mov_nregs (spec, answer);
+	answer = spec;
+    }
+    live.nat[answer].locked++;
+    live.nat[answer].touched = touchcnt++;
+    return answer;
+}
+
+static int readreg (int r, int size)
+{
+    return readreg_general (r, size, -1, 0);
+}
+
+static int readreg_specific (int r, int size, int spec)
+{
+    return readreg_general (r, size, spec, 0);
+}
+
+static int readreg_offset (int r, int size)
+{
+    return readreg_general (r, size, -1, 1);
+}
+
+
+static __inline__ int writereg_general (int r, int size, int spec)
+{
+    int n;
+    int answer = -1;
+
+    if (size < 4) {
+	remove_offset (r, spec);
+    }
+
+    make_exclusive (r, size, spec);
+    if (isinreg (r)) {
+	int nvsize = size > live.state[r].validsize ? size : live.state[r].validsize;
+	int ndsize = size > live.state[r].dirtysize ? size : live.state[r].dirtysize;
+	n = live.state[r].realreg;
+
+	Dif (live.nat[n].nholds != 1)
+	    abort ();
+	switch (size) {
+	case 1:
+	    if (live.nat[n].canbyte || spec >= 0) {
+		live.state[r].dirtysize = ndsize;
+		live.state[r].validsize = nvsize;
+		answer = n;
+	    }
+	    break;
+	case 2:
+	    if (live.nat[n].canword || spec >= 0) {
+		live.state[r].dirtysize = ndsize;
+		live.state[r].validsize = nvsize;
+		answer = n;
+	    }
+	    break;
+	case 4:
+	    live.state[r].dirtysize = ndsize;
+	    live.state[r].validsize = nvsize;
+	    answer = n;
+	    break;
+	default:
+	    abort ();
+	}
+	if (answer < 0)
+	    evict (r);
+    }
+    /* either the value was in memory to start with, or it was evicted and 
+       is in memory now */
+    if (answer < 0) {
+	answer = alloc_reg_hinted (r, size, 1, spec);
+    }
+    if (spec >= 0 && spec != answer) {
+	mov_nregs (spec, answer);
+	answer = spec;
+    }
+    if (live.state[r].status == UNDEF)
+	live.state[r].validsize = 4;
+    live.state[r].dirtysize = size > live.state[r].dirtysize ? size : live.state[r].dirtysize;
+    live.state[r].validsize = size > live.state[r].validsize ? size : live.state[r].validsize;
+
+    live.nat[answer].locked++;
+    live.nat[answer].touched = touchcnt++;
+    if (size == 4) {
+	live.state[r].val = 0;
+    } else {
+	Dif (live.state[r].val) {
+	    printf ("Problem with val\n");
+	    abort ();
+	}
+    }
+    set_status (r, DIRTY);
+    return answer;
+}
+
+static int writereg (int r, int size)
+{
+    return writereg_general (r, size, -1);
+}
+
+static int writereg_specific (int r, int size, int spec)
+{
+    return writereg_general (r, size, spec);
+}
+
+static __inline__ int rmw_general (int r, int wsize, int rsize, int spec)
+{
+    int n;
+    int answer = -1;
+
+    if (live.state[r].status == UNDEF) {
+	printf ("WARNING: Unexpected read of undefined register %d\n", r);
+    }
+    remove_offset (r, spec);
+    make_exclusive (r, 0, spec);
+
+    Dif (wsize < rsize) {
+	printf ("Cannot handle wsize<rsize in rmw_general()\n");
+	abort ();
+    }
+    if (isinreg (r) && live.state[r].validsize >= rsize) {
+	n = live.state[r].realreg;
+	Dif (live.nat[n].nholds != 1)
+	    abort ();
+
+	switch (rsize) {
+	case 1:
+	    if (live.nat[n].canbyte || spec >= 0) {
+		answer = n;
+	    }
+	    break;
+	case 2:
+	    if (live.nat[n].canword || spec >= 0) {
+		answer = n;
+	    }
+	    break;
+	case 4:
+	    answer = n;
+	    break;
+	default:
+	    abort ();
+	}
+	if (answer < 0)
+	    evict (r);
+    }
+    /* either the value was in memory to start with, or it was evicted and 
+       is in memory now */
+    if (answer < 0) {
+	answer = alloc_reg_hinted (r, spec >= 0 ? 4 : rsize, 0, spec);
+    }
+
+    if (spec >= 0 && spec != answer) {
+	/* Too bad */
+	mov_nregs (spec, answer);
+	answer = spec;
+    }
+    if (wsize > live.state[r].dirtysize)
+	live.state[r].dirtysize = wsize;
+    if (wsize > live.state[r].validsize)
+	live.state[r].validsize = wsize;
+    set_status (r, DIRTY);
+
+    live.nat[answer].locked++;
+    live.nat[answer].touched = touchcnt++;
+
+    Dif (live.state[r].val) {
+	printf ("Problem with val(rmw)\n");
+	abort ();
+    }
+    return answer;
+}
+
+static int rmw (int r, int wsize, int rsize)
+{
+    return rmw_general (r, wsize, rsize, -1);
+}
+
+static int rmw_specific (int r, int wsize, int rsize, int spec)
+{
+    return rmw_general (r, wsize, rsize, spec);
+}
+
+
+/* needed for restoring the carry flag on non-P6 cores */
+static void bt_l_ri_noclobber (R4 r, IMM i)
+{
+    int size = 4;
+    if (i < 16)
+	size = 2;
+    r = readreg (r, size);
+    raw_bt_l_ri (r, i);
+    unlock (r);
+}
+
+/********************************************************************
+ * FPU register status handling. EMIT TIME!                         *
+ ********************************************************************/
+
+static void f_tomem (int r)
+{
+    if (live.fate[r].status == DIRTY) {
+#if USE_LONG_DOUBLE
+	raw_fmov_ext_mr ((uae_u32) live.fate[r].mem, live.fate[r].realreg);
+#else
+	raw_fmov_mr ((uae_u32) live.fate[r].mem, live.fate[r].realreg);
+#endif
+	live.fate[r].status = CLEAN;
+    }
+}
+
+static void f_tomem_drop (int r)
+{
+    if (live.fate[r].status == DIRTY) {
+#if USE_LONG_DOUBLE
+	raw_fmov_ext_mr_drop ((uae_u32) live.fate[r].mem, live.fate[r].realreg);
+#else
+	raw_fmov_mr_drop ((uae_u32) live.fate[r].mem, live.fate[r].realreg);
+#endif
+	live.fate[r].status = INMEM;
+    }
+}
+
+
+static __inline__ int f_isinreg (int r)
+{
+    return live.fate[r].status == CLEAN || live.fate[r].status == DIRTY;
+}
+
+static void f_evict (int r)
+{
+    int rr;
+
+    if (!f_isinreg (r))
+	return;
+    rr = live.fate[r].realreg;
+    if (live.fat[rr].nholds == 1)
+	f_tomem_drop (r);
+    else
+	f_tomem (r);
+
+    Dif (live.fat[rr].locked && live.fat[rr].nholds == 1) {
+	fprintf (stderr, "FPU register %d in nreg %d is locked!\n", r, live.fate[r].realreg);
+	abort ();
+    }
+
+    live.fat[rr].nholds--;
+    if (live.fat[rr].nholds != live.fate[r].realind) {	/* Was not last */
+	int topreg = live.fat[rr].holds[live.fat[rr].nholds];
+	int thisind = live.fate[r].realind;
+	live.fat[rr].holds[thisind] = topreg;
+	live.fate[topreg].realind = thisind;
+    }
+    live.fate[r].status = INMEM;
+    live.fate[r].realreg = -1;
+}
+
+static __inline__ void f_free_nreg (int r)
+{
+    int i = live.fat[r].nholds;
+
+    while (i) {
+	int vr;
+
+	--i;
+	vr = live.fat[r].holds[i];
+	f_evict (vr);
+    }
+    Dif (live.fat[r].nholds != 0) {
+	printf ("Failed to free nreg %d, nholds is %d\n", r, live.fat[r].nholds);
+	abort ();
+    }
+}
+
+
+/* Use with care! */
+static __inline__ void f_isclean (int r)
+{
+    if (!f_isinreg (r))
+	return;
+    live.fate[r].status = CLEAN;
+}
+
+static __inline__ void f_disassociate (int r)
+{
+    f_isclean (r);
+    f_evict (r);
+}
+
+
+
+static int f_alloc_reg (int r, int willclobber)
+{
+    int bestreg;
+    uae_s32 when;
+    int i;
+    uae_s32 badness;
+    bestreg = -1;
+    when = 2000000000;
+    for (i = N_FREGS; i--;) {
+	badness = live.fat[i].touched;
+	if (live.fat[i].nholds == 0)
+	    badness = 0;
+
+	if (!live.fat[i].locked && badness < when) {
+	    bestreg = i;
+	    when = badness;
+	    if (live.fat[i].nholds == 0)
+		break;
+	}
+    }
+    Dif (bestreg == -1)
+	abort ();
+
+    if (live.fat[bestreg].nholds > 0) {
+	f_free_nreg (bestreg);
+    }
+    if (f_isinreg (r)) {
+	f_evict (r);
+    }
+
+    if (!willclobber) {
+	if (live.fate[r].status != UNDEF) {
+#if USE_LONG_DOUBLE
+	    raw_fmov_ext_rm (bestreg, (uae_u32) live.fate[r].mem);
+#else
+	    raw_fmov_rm (bestreg, (uae_u32) live.fate[r].mem);
+#endif
+	}
+	live.fate[r].status = CLEAN;
+    } else {
+	live.fate[r].status = DIRTY;
+    }
+    live.fate[r].realreg = bestreg;
+    live.fate[r].realind = live.fat[bestreg].nholds;
+    live.fat[bestreg].touched = touchcnt++;
+    live.fat[bestreg].holds[live.fat[bestreg].nholds] = r;
+    live.fat[bestreg].nholds++;
+
+    return bestreg;
+}
+
+static void f_unlock (int r)
+{
+    Dif (!live.fat[r].locked)
+	abort ();
+    live.fat[r].locked--;
+}
+
+static void f_setlock (int r)
+{
+    live.fat[r].locked++;
+}
+
+static __inline__ int f_readreg (int r)
+{
+    int n;
+    int answer = -1;
+
+    if (f_isinreg (r)) {
+	n = live.fate[r].realreg;
+	answer = n;
+    }
+    /* either the value was in memory to start with, or it was evicted and 
+       is in memory now */
+    if (answer < 0)
+	answer = f_alloc_reg (r, 0);
+
+    live.fat[answer].locked++;
+    live.fat[answer].touched = touchcnt++;
+    return answer;
+}
+
+static __inline__ void f_make_exclusive (int r, int clobber)
+{
+    freg_status oldstate;
+    int rr = live.fate[r].realreg;
+    int nr;
+    int nind;
+    int ndirt = 0;
+    int i;
+
+    if (!f_isinreg (r))
+	return;
+    if (live.fat[rr].nholds == 1)
+	return;
+    for (i = 0; i < live.fat[rr].nholds; i++) {
+	int vr = live.fat[rr].holds[i];
+	if (vr != r && live.fate[vr].status == DIRTY)
+	    ndirt++;
+    }
+    if (!ndirt && !live.fat[rr].locked) {
+	/* Everything else is clean, so let's keep this register */
+	for (i = 0; i < live.fat[rr].nholds; i++) {
+	    int vr = live.fat[rr].holds[i];
+	    if (vr != r) {
+		f_evict (vr);
+		i--;		/* Try that index again! */
+	    }
+	}
+	Dif (live.fat[rr].nholds != 1) {
+	    printf ("realreg %d holds %d (", rr, live.fat[rr].nholds);
+	    for (i = 0; i < live.fat[rr].nholds; i++) {
+		printf (" %d(%d,%d)", live.fat[rr].holds[i],
+			live.fate[live.fat[rr].holds[i]].realreg, live.fate[live.fat[rr].holds[i]].realind);
+	    }
+	    printf ("\n");
+	    abort ();
+	}
+	return;
+    }
+
+    /* We have to split the register */
+    oldstate = live.fate[r];
+
+    f_setlock (rr);		/* Make sure this doesn't go away */
+    /* Forget about r being in the register rr */
+    f_disassociate (r);
+    /* Get a new register, that we will clobber completely */
+    nr = f_alloc_reg (r, 1);
+    nind = live.fate[r].realind;
+    if (!clobber)
+	raw_fmov_rr (nr, rr);	/* Make another copy */
+    live.fate[r] = oldstate;	/* Keep all the old state info */
+    live.fate[r].realreg = nr;
+    live.fate[r].realind = nind;
+    f_unlock (rr);
+}
+
+
+static __inline__ int f_writereg (int r)
+{
+    int n;
+    int answer = -1;
+
+    f_make_exclusive (r, 1);
+    if (f_isinreg (r)) {
+	n = live.fate[r].realreg;
+	answer = n;
+    }
+    if (answer < 0) {
+	answer = f_alloc_reg (r, 1);
+    }
+    live.fate[r].status = DIRTY;
+    live.fat[answer].locked++;
+    live.fat[answer].touched = touchcnt++;
+    return answer;
+}
+
+static int f_rmw (int r)
+{
+    int n;
+
+    f_make_exclusive (r, 0);
+    if (f_isinreg (r)) {
+	n = live.fate[r].realreg;
+    } else
+	n = f_alloc_reg (r, 0);
+    live.fate[r].status = DIRTY;
+    live.fat[n].locked++;
+    live.fat[n].touched = touchcnt++;
+    return n;
+}
+
+static void fflags_into_flags_internal (uae_u32 tmp)
+{
+    int r;
+
+    clobber_flags ();
+    r = f_readreg (FP_RESULT);
+    raw_fflags_into_flags (r);
+    f_unlock (r);
+}
+
+
+
+
+/********************************************************************
+ * CPU functions exposed to gencomp. Both CREATE and EMIT time      *
+ ********************************************************************/
+
+/* 
+ *  RULES FOR HANDLING REGISTERS:
+ *
+ *  * In the function headers, order the parameters 
+ *     - 1st registers written to
+ *     - 2nd read/modify/write registers
+ *     - 3rd registers read from
+ *  * Before calling raw_*, you must call readreg, writereg or rmw for
+ *    each register
+ *  * The order for this is
+ *     - 1st call remove_offset for all registers written to with size<4
+ *     - 2nd call readreg for all registers read without offset
+ *     - 3rd call rmw for all rmw registers
+ *     - 4th call readreg_offset for all registers that can handle offsets
+ *     - 5th call get_offset for all the registers from the previous step
+ *     - 6th call writereg for all written-to registers
+ *     - 7th call raw_*
+ *     - 8th unlock all registers that were locked
+ */
+
+MIDFUNC (0, live_flags, (void))
+{
+    live.flags_on_stack = TRASH;
+    live.flags_in_flags = VALID;
+    live.flags_are_important = 1;
+}
+MENDFUNC (0, live_flags, (void))
+
+MIDFUNC (0, dont_care_flags, (void))
+{
+    live.flags_are_important = 0;
+}
+MENDFUNC (0, dont_care_flags, (void))
+
+
+MIDFUNC (0, duplicate_carry, (void))
+{
+    evict (FLAGX);
+    make_flags_live_internal ();
+    COMPCALL (setcc_m) ((uae_u32) live.state[FLAGX].mem, 2);
+}
+MENDFUNC (0, duplicate_carry, (void))
+
+MIDFUNC (0, restore_carry, (void))
+{
+    if (!have_rat_stall) {	/* Not a P6 core, i.e. no partial stalls */
+	bt_l_ri_noclobber (FLAGX, 0);
+    } else {			/* Avoid the stall the above creates.
+				   This is slow on non-P6, though.
+				 */
+	COMPCALL (rol_b_ri (FLAGX, 8));
+	isclean (FLAGX);
+	/* Why is the above faster than the below? */
+	//raw_rol_b_mi((uae_u32)live.state[FLAGX].mem,8);
+    }
+}
+MENDFUNC (0, restore_carry, (void))
+
+MIDFUNC (0, start_needflags, (void))
+{
+    needflags = 1;
+}
+MENDFUNC (0, start_needflags, (void))
+
+MIDFUNC (0, end_needflags, (void))
+{
+    needflags = 0;
+}
+MENDFUNC (0, end_needflags, (void))
+
+MIDFUNC (0, make_flags_live, (void))
+{
+    make_flags_live_internal ();
+}
+MENDFUNC (0, make_flags_live, (void))
+
+MIDFUNC (1, fflags_into_flags, (W2 tmp))
+{
+    clobber_flags ();
+    fflags_into_flags_internal (tmp);
+}
+MENDFUNC (1, fflags_into_flags, (W2 tmp))
+
+
+MIDFUNC (2, bt_l_ri, (R4 r, IMM i))
+{				/* This is defined as only affecting C */
+    int size = 4;
+    if (i < 16)
+	size = 2;
+    CLOBBER_BT;
+    r = readreg (r, size);
+    raw_bt_l_ri (r, i);
+    unlock (r);
+}
+MENDFUNC (2, bt_l_ri, (R4 r, IMM i))
+    /* This is defined as only affecting C */
+MIDFUNC (2, bt_l_rr, (R4 r, R4 b))
+{				/* This is defined as only affecting C */
+    CLOBBER_BT;
+    r = readreg (r, 4);
+    b = readreg (b, 4);
+    raw_bt_l_rr (r, b);
+    unlock (r);
+    unlock (b);
+}
+MENDFUNC (2, bt_l_rr, (R4 r, R4 b))
+    /* This is defined as only affecting C */
+MIDFUNC (2, btc_l_ri, (RW4 r, IMM i))
+{
+    int size = 4;
+    if (i < 16)
+	size = 2;
+    CLOBBER_BT;
+    r = rmw (r, size, size);
+    raw_btc_l_ri (r, i);
+    unlock (r);
+}
+MENDFUNC (2, btc_l_ri, (RW4 r, IMM i))
+
+MIDFUNC (2, btc_l_rr, (RW4 r, R4 b))
+{
+    CLOBBER_BT;
+    b = readreg (b, 4);
+    r = rmw (r, 4, 4);
+    raw_btc_l_rr (r, b);
+    unlock (r);
+    unlock (b);
+}
+MENDFUNC (2, btc_l_rr, (RW4 r, R4 b))
+
+
+MIDFUNC (2, btr_l_ri, (RW4 r, IMM i))
+{
+    int size = 4;
+    if (i < 16)
+	size = 2;
+    CLOBBER_BT;
+    r = rmw (r, size, size);
+    raw_btr_l_ri (r, i);
+    unlock (r);
+}
+MENDFUNC (2, btr_l_ri, (RW4 r, IMM i))
+
+MIDFUNC (2, btr_l_rr, (RW4 r, R4 b))
+{
+    CLOBBER_BT;
+    b = readreg (b, 4);
+    r = rmw (r, 4, 4);
+    raw_btr_l_rr (r, b);
+    unlock (r);
+    unlock (b);
+}
+MENDFUNC (2, btr_l_rr, (RW4 r, R4 b))
+
+
+MIDFUNC (2, bts_l_ri, (RW4 r, IMM i))
+{
+    int size = 4;
+    if (i < 16)
+	size = 2;
+    CLOBBER_BT;
+    r = rmw (r, size, size);
+    raw_bts_l_ri (r, i);
+    unlock (r);
+}
+MENDFUNC (2, bts_l_ri, (RW4 r, IMM i))
+
+MIDFUNC (2, bts_l_rr, (RW4 r, R4 b))
+{
+    CLOBBER_BT;
+    b = readreg (b, 4);
+    r = rmw (r, 4, 4);
+    raw_bts_l_rr (r, b);
+    unlock (r);
+    unlock (b);
+}
+MENDFUNC (2, bts_l_rr, (RW4 r, R4 b))
+
+MIDFUNC (2, mov_l_rm, (W4 d, IMM s))
+{
+    CLOBBER_MOV;
+    d = writereg (d, 4);
+    raw_mov_l_rm (d, s);
+    unlock (d);
+}
+MENDFUNC (2, mov_l_rm, (W4 d, IMM s))
+
+
+MIDFUNC (1, call_r, (R4 r))
+{				/* Clobbering is implicit */
+    r = readreg (r, 4);
+    raw_call_r (r);
+    unlock (r);
+}
+MENDFUNC (1, call_r, (R4 r))
+    /* Clobbering is implicit */
+MIDFUNC (2, sub_l_mi, (IMM d, IMM s))
+{
+    CLOBBER_SUB;
+    raw_sub_l_mi (d, s);
+}
+MENDFUNC (2, sub_l_mi, (IMM d, IMM s))
+
+MIDFUNC (2, mov_l_mi, (IMM d, IMM s))
+{
+    CLOBBER_MOV;
+    raw_mov_l_mi (d, s);
+}
+MENDFUNC (2, mov_l_mi, (IMM d, IMM s))
+
+MIDFUNC (2, mov_w_mi, (IMM d, IMM s))
+{
+    CLOBBER_MOV;
+    raw_mov_w_mi (d, s);
+}
+MENDFUNC (2, mov_w_mi, (IMM d, IMM s))
+
+MIDFUNC (2, mov_b_mi, (IMM d, IMM s))
+{
+    CLOBBER_MOV;
+    raw_mov_b_mi (d, s);
+}
+MENDFUNC (2, mov_b_mi, (IMM d, IMM s))
+
+MIDFUNC (2, rol_b_ri, (RW1 r, IMM i))
+{
+    CLOBBER_ROL;
+    r = rmw (r, 1, 1);
+    raw_rol_b_ri (r, i);
+    unlock (r);
+}
+MENDFUNC (2, rol_b_ri, (RW1 r, IMM i))
+
+MIDFUNC (2, rol_w_ri, (RW2 r, IMM i))
+{
+    CLOBBER_ROL;
+    r = rmw (r, 2, 2);
+    raw_rol_w_ri (r, i);
+    unlock (r);
+}
+MENDFUNC (2, rol_w_ri, (RW2 r, IMM i))
+
+MIDFUNC (2, rol_l_ri, (RW4 r, IMM i))
+{
+    CLOBBER_ROL;
+    r = rmw (r, 4, 4);
+    raw_rol_l_ri (r, i);
+    unlock (r);
+}
+MENDFUNC (2, rol_l_ri, (RW4 r, IMM i))
+
+MIDFUNC (2, rol_l_rr, (RW4 d, R1 r))
+{
+    if (isconst (r)) {
+	COMPCALL (rol_l_ri) (d, (uae_u8) live.state[r].val);
+	return;
+    }
+    CLOBBER_ROL;
+    r = readreg_specific (r, 1, SHIFTCOUNT_NREG);
+    d = rmw (d, 4, 4);
+    Dif (r != 1) {
+	fprintf (stderr, "Illegal register %d in raw_rol_b\n", r);
+	abort ();
+    }
+    raw_rol_l_rr (d, r);
+    unlock (r);
+    unlock (d);
+}
+MENDFUNC (2, rol_l_rr, (RW4 d, R1 r))
+
+MIDFUNC (2, rol_w_rr, (RW2 d, R1 r))
+{				/* Can only do this with r==1, i.e. cl */
+
+    if (isconst (r)) {
+	COMPCALL (rol_w_ri) (d, (uae_u8) live.state[r].val);
+	return;
+    }
+    CLOBBER_ROL;
+    r = readreg_specific (r, 1, SHIFTCOUNT_NREG);
+    d = rmw (d, 2, 2);
+    Dif (r != 1) {
+	fprintf (stderr, "Illegal register %d in raw_rol_b\n", r);
+	abort ();
+    }
+    raw_rol_w_rr (d, r);
+    unlock (r);
+    unlock (d);
+}
+MENDFUNC (2, rol_w_rr, (RW2 d, R1 r))
+
+MIDFUNC (2, rol_b_rr, (RW1 d, R1 r))
+{				/* Can only do this with r==1, i.e. cl */
+
+    if (isconst (r)) {
+	COMPCALL (rol_b_ri) (d, (uae_u8) live.state[r].val);
+	return;
+    }
+
+    CLOBBER_ROL;
+    r = readreg_specific (r, 1, SHIFTCOUNT_NREG);
+    d = rmw (d, 1, 1);
+    Dif (r != 1) {
+	fprintf (stderr, "Illegal register %d in raw_rol_b\n", r);
+	abort ();
+    }
+    raw_rol_b_rr (d, r);
+    unlock (r);
+    unlock (d);
+}
+MENDFUNC (2, rol_b_rr, (RW1 d, R1 r))
+
+
+MIDFUNC (2, shll_l_rr, (RW4 d, R1 r))
+{
+    if (isconst (r)) {
+	COMPCALL (shll_l_ri) (d, (uae_u8) live.state[r].val);
+	return;
+    }
+    CLOBBER_SHLL;
+    r = readreg_specific (r, 1, SHIFTCOUNT_NREG);
+    d = rmw (d, 4, 4);
+    Dif (r != 1) {
+	fprintf (stderr, "Illegal register %d in raw_rol_b\n", r);
+	abort ();
+    }
+    raw_shll_l_rr (d, r);
+    unlock (r);
+    unlock (d);
+}
+MENDFUNC (2, shll_l_rr, (RW4 d, R1 r))
+
+MIDFUNC (2, shll_w_rr, (RW2 d, R1 r))
+{				/* Can only do this with r==1, i.e. cl */
+
+    if (isconst (r)) {
+	COMPCALL (shll_w_ri) (d, (uae_u8) live.state[r].val);
+	return;
+    }
+    CLOBBER_SHLL;
+    r = readreg_specific (r, 1, SHIFTCOUNT_NREG);
+    d = rmw (d, 2, 2);
+    Dif (r != 1) {
+	fprintf (stderr, "Illegal register %d in raw_shll_b\n", r);
+	abort ();
+    }
+    raw_shll_w_rr (d, r);
+    unlock (r);
+    unlock (d);
+}
+MENDFUNC (2, shll_w_rr, (RW2 d, R1 r))
+
+MIDFUNC (2, shll_b_rr, (RW1 d, R1 r))
+{				/* Can only do this with r==1, i.e. cl */
+
+    if (isconst (r)) {
+	COMPCALL (shll_b_ri) (d, (uae_u8) live.state[r].val);
+	return;
+    }
+
+    CLOBBER_SHLL;
+    r = readreg_specific (r, 1, SHIFTCOUNT_NREG);
+    d = rmw (d, 1, 1);
+    Dif (r != 1) {
+	fprintf (stderr, "Illegal register %d in raw_shll_b\n", r);
+	abort ();
+    }
+    raw_shll_b_rr (d, r);
+    unlock (r);
+    unlock (d);
+}
+MENDFUNC (2, shll_b_rr, (RW1 d, R1 r))
+
+
+MIDFUNC (2, ror_b_ri, (R1 r, IMM i))
+{
+    CLOBBER_ROR;
+    r = rmw (r, 1, 1);
+    raw_ror_b_ri (r, i);
+    unlock (r);
+}
+MENDFUNC (2, ror_b_ri, (R1 r, IMM i))
+
+MIDFUNC (2, ror_w_ri, (R2 r, IMM i))
+{
+    CLOBBER_ROR;
+    r = rmw (r, 2, 2);
+    raw_ror_w_ri (r, i);
+    unlock (r);
+}
+MENDFUNC (2, ror_w_ri, (R2 r, IMM i))
+
+MIDFUNC (2, ror_l_ri, (R4 r, IMM i))
+{
+    CLOBBER_ROR;
+    r = rmw (r, 4, 4);
+    raw_ror_l_ri (r, i);
+    unlock (r);
+}
+MENDFUNC (2, ror_l_ri, (R4 r, IMM i))
+
+MIDFUNC (2, ror_l_rr, (R4 d, R1 r))
+{
+    if (isconst (r)) {
+	COMPCALL (ror_l_ri) (d, (uae_u8) live.state[r].val);
+	return;
+    }
+    CLOBBER_ROR;
+    r = readreg_specific (r, 1, SHIFTCOUNT_NREG);
+    d = rmw (d, 4, 4);
+    raw_ror_l_rr (d, r);
+    unlock (r);
+    unlock (d);
+}
+MENDFUNC (2, ror_l_rr, (R4 d, R1 r))
+
+MIDFUNC (2, ror_w_rr, (R2 d, R1 r))
+{
+    if (isconst (r)) {
+	COMPCALL (ror_w_ri) (d, (uae_u8) live.state[r].val);
+	return;
+    }
+    CLOBBER_ROR;
+    r = readreg_specific (r, 1, SHIFTCOUNT_NREG);
+    d = rmw (d, 2, 2);
+    raw_ror_w_rr (d, r);
+    unlock (r);
+    unlock (d);
+}
+MENDFUNC (2, ror_w_rr, (R2 d, R1 r))
+
+MIDFUNC (2, ror_b_rr, (R1 d, R1 r))
+{
+    if (isconst (r)) {
+	COMPCALL (ror_b_ri) (d, (uae_u8) live.state[r].val);
+	return;
+    }
+
+    CLOBBER_ROR;
+    r = readreg_specific (r, 1, SHIFTCOUNT_NREG);
+    d = rmw (d, 1, 1);
+    raw_ror_b_rr (d, r);
+    unlock (r);
+    unlock (d);
+}
+MENDFUNC (2, ror_b_rr, (R1 d, R1 r))
+
+MIDFUNC (2, shrl_l_rr, (RW4 d, R1 r))
+{
+    if (isconst (r)) {
+	COMPCALL (shrl_l_ri) (d, (uae_u8) live.state[r].val);
+	return;
+    }
+    CLOBBER_SHRL;
+    r = readreg_specific (r, 1, SHIFTCOUNT_NREG);
+    d = rmw (d, 4, 4);
+    Dif (r != 1) {
+	fprintf (stderr, "Illegal register %d in raw_rol_b\n", r);
+	abort ();
+    }
+    raw_shrl_l_rr (d, r);
+    unlock (r);
+    unlock (d);
+}
+MENDFUNC (2, shrl_l_rr, (RW4 d, R1 r))
+
+MIDFUNC (2, shrl_w_rr, (RW2 d, R1 r))
+{				/* Can only do this with r==1, i.e. cl */
+
+    if (isconst (r)) {
+	COMPCALL (shrl_w_ri) (d, (uae_u8) live.state[r].val);
+	return;
+    }
+    CLOBBER_SHRL;
+    r = readreg_specific (r, 1, SHIFTCOUNT_NREG);
+    d = rmw (d, 2, 2);
+    Dif (r != 1) {
+	fprintf (stderr, "Illegal register %d in raw_shrl_b\n", r);
+	abort ();
+    }
+    raw_shrl_w_rr (d, r);
+    unlock (r);
+    unlock (d);
+}
+MENDFUNC (2, shrl_w_rr, (RW2 d, R1 r))
+
+MIDFUNC (2, shrl_b_rr, (RW1 d, R1 r))
+{				/* Can only do this with r==1, i.e. cl */
+
+    if (isconst (r)) {
+	COMPCALL (shrl_b_ri) (d, (uae_u8) live.state[r].val);
+	return;
+    }
+
+    CLOBBER_SHRL;
+    r = readreg_specific (r, 1, SHIFTCOUNT_NREG);
+    d = rmw (d, 1, 1);
+    Dif (r != 1) {
+	fprintf (stderr, "Illegal register %d in raw_shrl_b\n", r);
+	abort ();
+    }
+    raw_shrl_b_rr (d, r);
+    unlock (r);
+    unlock (d);
+}
+MENDFUNC (2, shrl_b_rr, (RW1 d, R1 r))
+
+
+
+MIDFUNC (2, shll_l_ri, (RW4 r, IMM i))
+{
+    if (!i && !needflags)
+	return;
+    if (isconst (r) && !needflags) {
+	live.state[r].val <<= i;
+	return;
+    }
+    CLOBBER_SHLL;
+    r = rmw (r, 4, 4);
+    raw_shll_l_ri (r, i);
+    unlock (r);
+}
+MENDFUNC (2, shll_l_ri, (RW4 r, IMM i))
+
+MIDFUNC (2, shll_w_ri, (RW2 r, IMM i))
+{
+    if (!i && !needflags)
+	return;
+    CLOBBER_SHLL;
+    r = rmw (r, 2, 2);
+    raw_shll_w_ri (r, i);
+    unlock (r);
+}
+MENDFUNC (2, shll_w_ri, (RW2 r, IMM i))
+
+MIDFUNC (2, shll_b_ri, (RW1 r, IMM i))
+{
+    if (!i && !needflags)
+	return;
+    CLOBBER_SHLL;
+    r = rmw (r, 1, 1);
+    raw_shll_b_ri (r, i);
+    unlock (r);
+}
+MENDFUNC (2, shll_b_ri, (RW1 r, IMM i))
+
+MIDFUNC (2, shrl_l_ri, (RW4 r, IMM i))
+{
+    if (!i && !needflags)
+	return;
+    if (isconst (r) && !needflags) {
+	live.state[r].val >>= i;
+	return;
+    }
+    CLOBBER_SHRL;
+    r = rmw (r, 4, 4);
+    raw_shrl_l_ri (r, i);
+    unlock (r);
+}
+MENDFUNC (2, shrl_l_ri, (RW4 r, IMM i))
+
+MIDFUNC (2, shrl_w_ri, (RW2 r, IMM i))
+{
+    if (!i && !needflags)
+	return;
+    CLOBBER_SHRL;
+    r = rmw (r, 2, 2);
+    raw_shrl_w_ri (r, i);
+    unlock (r);
+}
+MENDFUNC (2, shrl_w_ri, (RW2 r, IMM i))
+
+MIDFUNC (2, shrl_b_ri, (RW1 r, IMM i))
+{
+    if (!i && !needflags)
+	return;
+    CLOBBER_SHRL;
+    r = rmw (r, 1, 1);
+    raw_shrl_b_ri (r, i);
+    unlock (r);
+}
+MENDFUNC (2, shrl_b_ri, (RW1 r, IMM i))
+
+MIDFUNC (2, shra_l_ri, (RW4 r, IMM i))
+{
+    if (!i && !needflags)
+	return;
+    CLOBBER_SHRA;
+    r = rmw (r, 4, 4);
+    raw_shra_l_ri (r, i);
+    unlock (r);
+}
+MENDFUNC (2, shra_l_ri, (RW4 r, IMM i))
+
+MIDFUNC (2, shra_w_ri, (RW2 r, IMM i))
+{
+    if (!i && !needflags)
+	return;
+    CLOBBER_SHRA;
+    r = rmw (r, 2, 2);
+    raw_shra_w_ri (r, i);
+    unlock (r);
+}
+MENDFUNC (2, shra_w_ri, (RW2 r, IMM i))
+
+MIDFUNC (2, shra_b_ri, (RW1 r, IMM i))
+{
+    if (!i && !needflags)
+	return;
+    CLOBBER_SHRA;
+    r = rmw (r, 1, 1);
+    raw_shra_b_ri (r, i);
+    unlock (r);
+}
+MENDFUNC (2, shra_b_ri, (RW1 r, IMM i))
+
+MIDFUNC (2, shra_l_rr, (RW4 d, R1 r))
+{
+    if (isconst (r)) {
+	COMPCALL (shra_l_ri) (d, (uae_u8) live.state[r].val);
+	return;
+    }
+    CLOBBER_SHRA;
+    r = readreg_specific (r, 1, SHIFTCOUNT_NREG);
+    d = rmw (d, 4, 4);
+    Dif (r != 1) {
+	fprintf (stderr, "Illegal register %d in raw_rol_b\n", r);
+	abort ();
+    }
+    raw_shra_l_rr (d, r);
+    unlock (r);
+    unlock (d);
+}
+MENDFUNC (2, shra_l_rr, (RW4 d, R1 r))
+
+MIDFUNC (2, shra_w_rr, (RW2 d, R1 r))
+{				/* Can only do this with r==1, i.e. cl */
+
+    if (isconst (r)) {
+	COMPCALL (shra_w_ri) (d, (uae_u8) live.state[r].val);
+	return;
+    }
+    CLOBBER_SHRA;
+    r = readreg_specific (r, 1, SHIFTCOUNT_NREG);
+    d = rmw (d, 2, 2);
+    Dif (r != 1) {
+	fprintf (stderr, "Illegal register %d in raw_shra_b\n", r);
+	abort ();
+    }
+    raw_shra_w_rr (d, r);
+    unlock (r);
+    unlock (d);
+}
+MENDFUNC (2, shra_w_rr, (RW2 d, R1 r))
+
+MIDFUNC (2, shra_b_rr, (RW1 d, R1 r))
+{				/* Can only do this with r==1, i.e. cl */
+
+    if (isconst (r)) {
+	COMPCALL (shra_b_ri) (d, (uae_u8) live.state[r].val);
+	return;
+    }
+
+    CLOBBER_SHRA;
+    r = readreg_specific (r, 1, SHIFTCOUNT_NREG);
+    d = rmw (d, 1, 1);
+    Dif (r != 1) {
+	fprintf (stderr, "Illegal register %d in raw_shra_b\n", r);
+	abort ();
+    }
+    raw_shra_b_rr (d, r);
+    unlock (r);
+    unlock (d);
+}
+MENDFUNC (2, shra_b_rr, (RW1 d, R1 r))
+
+
+MIDFUNC (2, setcc, (W1 d, IMM cc))
+{
+    CLOBBER_SETCC;
+    d = writereg (d, 1);
+    raw_setcc (d, cc);
+    unlock (d);
+}
+MENDFUNC (2, setcc, (W1 d, IMM cc))
+
+MIDFUNC (2, setcc_m, (IMM d, IMM cc))
+{
+    CLOBBER_SETCC;
+    raw_setcc_m (d, cc);
+}
+MENDFUNC (2, setcc_m, (IMM d, IMM cc))
+
+MIDFUNC (3, cmov_l_rr, (RW4 d, R4 s, IMM cc))
+{
+    if (d == s)
+	return;
+    CLOBBER_CMOV;
+    s = readreg (s, 4);
+    d = rmw (d, 4, 4);
+    raw_cmov_l_rr (d, s, cc);
+    unlock (s);
+    unlock (d);
+}
+MENDFUNC (3, cmov_l_rr, (RW4 d, R4 s, IMM cc))
+
+MIDFUNC (3, cmov_l_rm, (RW4 d, IMM s, IMM cc))
+{
+    CLOBBER_CMOV;
+    d = rmw (d, 4, 4);
+    raw_cmov_l_rm (d, s, cc);
+    unlock (d);
+}
+MENDFUNC (3, cmov_l_rm, (RW4 d, IMM s, IMM cc))
+
+MIDFUNC (2, bsf_l_rr, (W4 d, R4 s))
+{
+    CLOBBER_BSF;
+    s = readreg (s, 4);
+    d = writereg (d, 4);
+    raw_bsf_l_rr (d, s);
+    unlock (s);
+    unlock (d);
+}
+MENDFUNC (2, bsf_l_rr, (W4 d, R4 s))
+
+MIDFUNC (2, imul_32_32, (RW4 d, R4 s))
+{
+    CLOBBER_MUL;
+    s = readreg (s, 4);
+    d = rmw (d, 4, 4);
+    raw_imul_32_32 (d, s);
+    unlock (s);
+    unlock (d);
+}
+MENDFUNC (2, imul_32_32, (RW4 d, R4 s))
+
+MIDFUNC (2, imul_64_32, (RW4 d, RW4 s))
+{
+    CLOBBER_MUL;
+    s = rmw_specific (s, 4, 4, MUL_NREG2);
+    d = rmw_specific (d, 4, 4, MUL_NREG1);
+    raw_imul_64_32 (d, s);
+    unlock (s);
+    unlock (d);
+}
+MENDFUNC (2, imul_64_32, (RW4 d, RW4 s))
+
+MIDFUNC (2, mul_64_32, (RW4 d, RW4 s))
+{
+    CLOBBER_MUL;
+    s = rmw_specific (s, 4, 4, MUL_NREG2);
+    d = rmw_specific (d, 4, 4, MUL_NREG1);
+    raw_mul_64_32 (d, s);
+    unlock (s);
+    unlock (d);
+}
+MENDFUNC (2, mul_64_32, (RW4 d, RW4 s))
+
+MIDFUNC (2, mul_32_32, (RW4 d, R4 s))
+{
+    CLOBBER_MUL;
+    s = readreg (s, 4);
+    d = rmw (d, 4, 4);
+    raw_mul_32_32 (d, s);
+    unlock (s);
+    unlock (d);
+}
+MENDFUNC (2, mul_32_32, (RW4 d, R4 s))
+
+MIDFUNC (2, sign_extend_16_rr, (W4 d, R2 s))
+{
+    int isrmw;
+
+    if (isconst (s)) {
+	set_const (d, (uae_s32) (uae_s16) live.state[s].val);
+	return;
+    }
+
+    CLOBBER_SE16;
+    isrmw = (s == d);
+    if (!isrmw) {
+	s = readreg (s, 2);
+	d = writereg (d, 4);
+    } else {			/* If we try to lock this twice, with different sizes, we
+				   are int trouble! */
+	s = d = rmw (s, 4, 2);
+    }
+    raw_sign_extend_16_rr (d, s);
+    if (!isrmw) {
+	unlock (d);
+	unlock (s);
+    } else {
+	unlock (s);
+    }
+}
+MENDFUNC (2, sign_extend_16_rr, (W4 d, R2 s))
+
+MIDFUNC (2, sign_extend_8_rr, (W4 d, R1 s))
+{
+    int isrmw;
+
+    if (isconst (s)) {
+	set_const (d, (uae_s32) (uae_s8) live.state[s].val);
+	return;
+    }
+
+    isrmw = (s == d);
+    CLOBBER_SE8;
+    if (!isrmw) {
+	s = readreg (s, 1);
+	d = writereg (d, 4);
+    } else {			/* If we try to lock this twice, with different sizes, we
+				   are int trouble! */
+	s = d = rmw (s, 4, 1);
+    }
+
+    raw_sign_extend_8_rr (d, s);
+
+    if (!isrmw) {
+	unlock (d);
+	unlock (s);
+    } else {
+	unlock (s);
+    }
+}
+MENDFUNC (2, sign_extend_8_rr, (W4 d, R1 s))
+
+
+MIDFUNC (2, zero_extend_16_rr, (W4 d, R2 s))
+{
+    int isrmw;
+
+    if (isconst (s)) {
+	set_const (d, (uae_u32) (uae_u16) live.state[s].val);
+	return;
+    }
+
+    isrmw = (s == d);
+    CLOBBER_ZE16;
+    if (!isrmw) {
+	s = readreg (s, 2);
+	d = writereg (d, 4);
+    } else {			/* If we try to lock this twice, with different sizes, we
+				   are int trouble! */
+	s = d = rmw (s, 4, 2);
+    }
+    raw_zero_extend_16_rr (d, s);
+    if (!isrmw) {
+	unlock (d);
+	unlock (s);
+    } else {
+	unlock (s);
+    }
+}
+MENDFUNC (2, zero_extend_16_rr, (W4 d, R2 s))
+
+MIDFUNC (2, zero_extend_8_rr, (W4 d, R1 s))
+{
+    int isrmw;
+    if (isconst (s)) {
+	set_const (d, (uae_u32) (uae_u8) live.state[s].val);
+	return;
+    }
+
+    isrmw = (s == d);
+    CLOBBER_ZE8;
+    if (!isrmw) {
+	s = readreg (s, 1);
+	d = writereg (d, 4);
+    } else {			/* If we try to lock this twice, with different sizes, we
+				   are int trouble! */
+	s = d = rmw (s, 4, 1);
+    }
+
+    raw_zero_extend_8_rr (d, s);
+
+    if (!isrmw) {
+	unlock (d);
+	unlock (s);
+    } else {
+	unlock (s);
+    }
+}
+MENDFUNC (2, zero_extend_8_rr, (W4 d, R1 s))
+
+MIDFUNC (2, mov_b_rr, (W1 d, R1 s))
+{
+    if (d == s)
+	return;
+    if (isconst (s)) {
+	COMPCALL (mov_b_ri) (d, (uae_u8) live.state[s].val);
+	return;
+    }
+
+    CLOBBER_MOV;
+    s = readreg (s, 1);
+    d = writereg (d, 1);
+    raw_mov_b_rr (d, s);
+    unlock (d);
+    unlock (s);
+}
+MENDFUNC (2, mov_b_rr, (W1 d, R1 s))
+
+MIDFUNC (2, mov_w_rr, (W2 d, R2 s))
+{
+    if (d == s)
+	return;
+    if (isconst (s)) {
+	COMPCALL (mov_w_ri) (d, (uae_u16) live.state[s].val);
+	return;
+    }
+
+    CLOBBER_MOV;
+    s = readreg (s, 2);
+    d = writereg (d, 2);
+    raw_mov_w_rr (d, s);
+    unlock (d);
+    unlock (s);
+}
+MENDFUNC (2, mov_w_rr, (W2 d, R2 s))
+
+
+MIDFUNC (4, mov_l_rrm_indexed, (W4 d, R4 baser, R4 index, IMM factor))
+{
+    CLOBBER_MOV;
+    baser = readreg (baser, 4);
+    index = readreg (index, 4);
+    d = writereg (d, 4);
+
+    raw_mov_l_rrm_indexed (d, baser, index, factor);
+    unlock (d);
+    unlock (baser);
+    unlock (index);
+}
+MENDFUNC (4, mov_l_rrm_indexed, (W4 d, R4 baser, R4 index, IMM factor))
+
+MIDFUNC (4, mov_w_rrm_indexed, (W2 d, R4 baser, R4 index, IMM factor))
+{
+    CLOBBER_MOV;
+    baser = readreg (baser, 4);
+    index = readreg (index, 4);
+    d = writereg (d, 2);
+
+    raw_mov_w_rrm_indexed (d, baser, index, factor);
+    unlock (d);
+    unlock (baser);
+    unlock (index);
+}
+MENDFUNC (4, mov_w_rrm_indexed, (W2 d, R4 baser, R4 index, IMM factor))
+
+MIDFUNC (4, mov_b_rrm_indexed, (W1 d, R4 baser, R4 index, IMM factor))
+{
+    CLOBBER_MOV;
+    baser = readreg (baser, 4);
+    index = readreg (index, 4);
+    d = writereg (d, 1);
+
+    raw_mov_b_rrm_indexed (d, baser, index, factor);
+
+    unlock (d);
+    unlock (baser);
+    unlock (index);
+}
+MENDFUNC (4, mov_b_rrm_indexed, (W1 d, R4 baser, R4 index, IMM factor))
+
+
+MIDFUNC (4, mov_l_mrr_indexed, (R4 baser, R4 index, IMM factor, R4 s))
+{
+    CLOBBER_MOV;
+    baser = readreg (baser, 4);
+    index = readreg (index, 4);
+    s = readreg (s, 4);
+
+    Dif (baser == s || index == s)
+	abort ();
+
+
+    raw_mov_l_mrr_indexed (baser, index, factor, s);
+    unlock (s);
+    unlock (baser);
+    unlock (index);
+}
+MENDFUNC (4, mov_l_mrr_indexed, (R4 baser, R4 index, IMM factor, R4 s))
+
+MIDFUNC (4, mov_w_mrr_indexed, (R4 baser, R4 index, IMM factor, R2 s))
+{
+    CLOBBER_MOV;
+    baser = readreg (baser, 4);
+    index = readreg (index, 4);
+    s = readreg (s, 2);
+
+    raw_mov_w_mrr_indexed (baser, index, factor, s);
+    unlock (s);
+    unlock (baser);
+    unlock (index);
+}
+MENDFUNC (4, mov_w_mrr_indexed, (R4 baser, R4 index, IMM factor, R2 s))
+
+MIDFUNC (4, mov_b_mrr_indexed, (R4 baser, R4 index, IMM factor, R1 s))
+{
+    CLOBBER_MOV;
+    s = readreg (s, 1);
+    baser = readreg (baser, 4);
+    index = readreg (index, 4);
+
+    raw_mov_b_mrr_indexed (baser, index, factor, s);
+    unlock (s);
+    unlock (baser);
+    unlock (index);
+}
+MENDFUNC (4, mov_b_mrr_indexed, (R4 baser, R4 index, IMM factor, R1 s))
+
+
+MIDFUNC (5, mov_l_bmrr_indexed, (IMM base, R4 baser, R4 index, IMM factor, R4 s))
+{
+    int basereg = baser;
+    int indexreg = index;
+
+    CLOBBER_MOV;
+    s = readreg (s, 4);
+    baser = readreg_offset (baser, 4);
+    index = readreg_offset (index, 4);
+
+    base += get_offset (basereg);
+    base += factor * get_offset (indexreg);
+
+    raw_mov_l_bmrr_indexed (base, baser, index, factor, s);
+    unlock (s);
+    unlock (baser);
+    unlock (index);
+}
+MENDFUNC (5, mov_l_bmrr_indexed, (IMM base, R4 baser, R4 index, IMM factor, R4 s))
+
+MIDFUNC (5, mov_w_bmrr_indexed, (IMM base, R4 baser, R4 index, IMM factor, R2 s))
+{
+    int basereg = baser;
+    int indexreg = index;
+
+    CLOBBER_MOV;
+    s = readreg (s, 2);
+    baser = readreg_offset (baser, 4);
+    index = readreg_offset (index, 4);
+
+    base += get_offset (basereg);
+    base += factor * get_offset (indexreg);
+
+    raw_mov_w_bmrr_indexed (base, baser, index, factor, s);
+    unlock (s);
+    unlock (baser);
+    unlock (index);
+}
+MENDFUNC (5, mov_w_bmrr_indexed, (IMM base, R4 baser, R4 index, IMM factor, R2 s))
+
+MIDFUNC (5, mov_b_bmrr_indexed, (IMM base, R4 baser, R4 index, IMM factor, R1 s))
+{
+    int basereg = baser;
+    int indexreg = index;
+
+    CLOBBER_MOV;
+    s = readreg (s, 1);
+    baser = readreg_offset (baser, 4);
+    index = readreg_offset (index, 4);
+
+    base += get_offset (basereg);
+    base += factor * get_offset (indexreg);
+
+    raw_mov_b_bmrr_indexed (base, baser, index, factor, s);
+    unlock (s);
+    unlock (baser);
+    unlock (index);
+}
+MENDFUNC (5, mov_b_bmrr_indexed, (IMM base, R4 baser, R4 index, IMM factor, R1 s))
+
+
+
+/* Read a long from base+baser+factor*index */
+MIDFUNC (5, mov_l_brrm_indexed, (W4 d, IMM base, R4 baser, R4 index, IMM factor))
+{
+    int basereg = baser;
+    int indexreg = index;
+
+    CLOBBER_MOV;
+    baser = readreg_offset (baser, 4);
+    index = readreg_offset (index, 4);
+    base += get_offset (basereg);
+    base += factor * get_offset (indexreg);
+    d = writereg (d, 4);
+    raw_mov_l_brrm_indexed (d, base, baser, index, factor);
+    unlock (d);
+    unlock (baser);
+    unlock (index);
+}
+MENDFUNC (5, mov_l_brrm_indexed, (W4 d, IMM base, R4 baser, R4 index, IMM factor))
+
+
+MIDFUNC (5, mov_w_brrm_indexed, (W2 d, IMM base, R4 baser, R4 index, IMM factor))
+{
+    int basereg = baser;
+    int indexreg = index;
+
+    CLOBBER_MOV;
+    remove_offset (d, -1);
+    baser = readreg_offset (baser, 4);
+    index = readreg_offset (index, 4);
+    base += get_offset (basereg);
+    base += factor * get_offset (indexreg);
+    d = writereg (d, 2);
+    raw_mov_w_brrm_indexed (d, base, baser, index, factor);
+    unlock (d);
+    unlock (baser);
+    unlock (index);
+}
+MENDFUNC (5, mov_w_brrm_indexed, (W2 d, IMM base, R4 baser, R4 index, IMM factor))
+
+
+MIDFUNC (5, mov_b_brrm_indexed, (W1 d, IMM base, R4 baser, R4 index, IMM factor))
+{
+    int basereg = baser;
+    int indexreg = index;
+
+    CLOBBER_MOV;
+    remove_offset (d, -1);
+    baser = readreg_offset (baser, 4);
+    index = readreg_offset (index, 4);
+    base += get_offset (basereg);
+    base += factor * get_offset (indexreg);
+    d = writereg (d, 1);
+    raw_mov_b_brrm_indexed (d, base, baser, index, factor);
+    unlock (d);
+    unlock (baser);
+    unlock (index);
+}
+MENDFUNC (5, mov_b_brrm_indexed, (W1 d, IMM base, R4 baser, R4 index, IMM factor))
+
+/* Read a long from base+factor*index */
+MIDFUNC (4, mov_l_rm_indexed, (W4 d, IMM base, R4 index, IMM factor))
+{
+    int indexreg = index;
+
+    if (isconst (index)) {
+	COMPCALL (mov_l_rm) (d, base + factor * live.state[index].val);
+	return;
+    }
+
+    CLOBBER_MOV;
+    index = readreg_offset (index, 4);
+    base += get_offset (indexreg) * factor;
+    d = writereg (d, 4);
+
+    raw_mov_l_rm_indexed (d, base, index, factor);
+    unlock (index);
+    unlock (d);
+}
+MENDFUNC (4, mov_l_rm_indexed, (W4 d, IMM base, R4 index, IMM factor))
+
+
+/* read the long at the address contained in s+offset and store in d */
+MIDFUNC (3, mov_l_rR, (W4 d, R4 s, IMM offset))
+{
+    if (isconst (s)) {
+	COMPCALL (mov_l_rm) (d, live.state[s].val + offset);
+	return;
+    }
+    CLOBBER_MOV;
+    s = readreg (s, 4);
+    d = writereg (d, 4);
+
+    raw_mov_l_rR (d, s, offset);
+    unlock (d);
+    unlock (s);
+}
+MENDFUNC (3, mov_l_rR, (W4 d, R4 s, IMM offset))
+
+/* read the word at the address contained in s+offset and store in d */
+MIDFUNC (3, mov_w_rR, (W2 d, R4 s, IMM offset))
+{
+    if (isconst (s)) {
+	COMPCALL (mov_w_rm) (d, live.state[s].val + offset);
+	return;
+    }
+    CLOBBER_MOV;
+    s = readreg (s, 4);
+    d = writereg (d, 2);
+
+    raw_mov_w_rR (d, s, offset);
+    unlock (d);
+    unlock (s);
+}
+MENDFUNC (3, mov_w_rR, (W2 d, R4 s, IMM offset))
+
+/* read the word at the address contained in s+offset and store in d */
+MIDFUNC (3, mov_b_rR, (W1 d, R4 s, IMM offset))
+{
+    if (isconst (s)) {
+	COMPCALL (mov_b_rm) (d, live.state[s].val + offset);
+	return;
+    }
+    CLOBBER_MOV;
+    s = readreg (s, 4);
+    d = writereg (d, 1);
+
+    raw_mov_b_rR (d, s, offset);
+    unlock (d);
+    unlock (s);
+}
+MENDFUNC (3, mov_b_rR, (W1 d, R4 s, IMM offset))
+
+/* read the long at the address contained in s+offset and store in d */
+MIDFUNC (3, mov_l_rR_gs, (W4 d, R4 s, IMM offset))
+{
+    CLOBBER_MOV;
+    s = readreg (s, 4);
+    d = writereg (d, 4);
+
+    raw_mov_l_rR_gs (d, s, offset);
+    unlock (d);
+    unlock (s);
+}
+MENDFUNC (3, mov_l_rR_gs, (W4 d, R4 s, IMM offset))
+
+/* read the word at the address contained in s+offset and store in d */
+MIDFUNC (3, mov_w_rR_gs, (W2 d, R4 s, IMM offset))
+{
+    CLOBBER_MOV;
+    s = readreg (s, 4);
+    d = writereg (d, 2);
+
+    raw_mov_w_rR_gs (d, s, offset);
+    unlock (d);
+    unlock (s);
+}
+MENDFUNC (3, mov_w_rR_gs, (W2 d, R4 s, IMM offset))
+
+/* read the word at the address contained in s+offset and store in d */
+MIDFUNC (3, mov_b_rR_gs, (W1 d, R4 s, IMM offset))
+{
+    CLOBBER_MOV;
+    s = readreg (s, 4);
+    d = writereg (d, 1);
+
+    raw_mov_b_rR_gs (d, s, offset);
+    unlock (d);
+    unlock (s);
+}
+MENDFUNC (3, mov_b_rR_gs, (W1 d, R4 s, IMM offset))
+
+/* read the long at the address contained in s+offset and store in d */
+MIDFUNC (3, mov_l_brR, (W4 d, R4 s, IMM offset))
+{
+    int sreg = s;
+    if (isconst (s) && ! use_gs_seg) {
+	COMPCALL (mov_l_rm) (d, live.state[s].val + offset);
+	return;
+    }
+    CLOBBER_MOV;
+    s = readreg_offset (s, 4);
+    offset += get_offset (sreg);
+    d = writereg (d, 4);
+
+    if (use_gs_seg)
+	raw_mov_l_brR_gs (d, s, offset);
+    else
+	raw_mov_l_brR (d, s, offset);
+    unlock (d);
+    unlock (s);
+}
+MENDFUNC (3, mov_l_brR, (W4 d, R4 s, IMM offset))
+
+/* read the word at the address contained in s+offset and store in d */
+MIDFUNC (3, mov_w_brR, (W2 d, R4 s, IMM offset))
+{
+    int sreg = s;
+    if (isconst (s) && ! use_gs_seg) {
+	COMPCALL (mov_w_rm) (d, live.state[s].val + offset);
+	return;
+    }
+    CLOBBER_MOV;
+    remove_offset (d, -1);
+    s = readreg_offset (s, 4);
+    offset += get_offset (sreg);
+    d = writereg (d, 2);
+
+    if (use_gs_seg)
+	raw_mov_w_brR_gs (d, s, offset);
+    else
+	raw_mov_w_brR (d, s, offset);
+    unlock (d);
+    unlock (s);
+}
+MENDFUNC (3, mov_w_brR, (W2 d, R4 s, IMM offset))
+
+/* read the word at the address contained in s+offset and store in d */
+MIDFUNC (3, mov_b_brR, (W1 d, R4 s, IMM offset))
+{
+    int sreg = s;
+    if (isconst (s) && ! use_gs_seg) {
+	COMPCALL (mov_b_rm) (d, live.state[s].val + offset);
+	return;
+    }
+    CLOBBER_MOV;
+    remove_offset (d, -1);
+    s = readreg_offset (s, 4);
+    offset += get_offset (sreg);
+    d = writereg (d, 1);
+
+    if (use_gs_seg)
+	raw_mov_b_brR_gs (d, s, offset);
+    else
+	raw_mov_b_brR (d, s, offset);
+    unlock (d);
+    unlock (s);
+}
+MENDFUNC (3, mov_b_brR, (W1 d, R4 s, IMM offset))
+
+/* Warning! OFFSET is byte sized only! */
+MIDFUNC (3, mov_l_Rr, (R4 d, R4 s, IMM offset))
+{
+    if (isconst (d)) {
+	COMPCALL (mov_l_mr) (live.state[d].val + offset, s);
+	return;
+    }
+
+    CLOBBER_MOV;
+    s = readreg (s, 4);
+    d = readreg (d, 4);
+
+    raw_mov_l_Rr (d, s, offset);
+    unlock (d);
+    unlock (s);
+}
+MENDFUNC (3, mov_l_Rr, (R4 d, R4 s, IMM offset))
+
+MIDFUNC (3, mov_w_Rr, (R4 d, R2 s, IMM offset))
+{
+    if (isconst (d)) {
+	COMPCALL (mov_w_mr) (live.state[d].val + offset, s);
+	return;
+    }
+
+    CLOBBER_MOV;
+    s = readreg (s, 2);
+    d = readreg (d, 4);
+    raw_mov_w_Rr (d, s, offset);
+    unlock (d);
+    unlock (s);
+}
+MENDFUNC (3, mov_w_Rr, (R4 d, R2 s, IMM offset))
+
+MIDFUNC (3, mov_b_Rr, (R4 d, R1 s, IMM offset))
+{
+    if (isconst (d)) {
+	COMPCALL (mov_b_mr) (live.state[d].val + offset, s);
+	return;
+    }
+
+    CLOBBER_MOV;
+    s = readreg (s, 1);
+    d = readreg (d, 4);
+    raw_mov_b_Rr (d, s, offset);
+    unlock (d);
+    unlock (s);
+}
+MENDFUNC (3, mov_b_Rr, (R4 d, R1 s, IMM offset))
+
+/* Warning! OFFSET is byte sized only! */
+MIDFUNC (3, mov_l_Rr_gs, (R4 d, R4 s, IMM offset))
+{
+    CLOBBER_MOV;
+    s = readreg (s, 4);
+    d = readreg (d, 4);
+
+    raw_mov_l_Rr_gs (d, s, offset);
+    unlock (d);
+    unlock (s);
+}
+MENDFUNC (3, mov_l_Rr_gs, (R4 d, R4 s, IMM offset))
+
+MIDFUNC (3, mov_w_Rr_gs, (R4 d, R2 s, IMM offset))
+{
+    CLOBBER_MOV;
+    s = readreg (s, 2);
+    d = readreg (d, 4);
+    raw_mov_w_Rr_gs (d, s, offset);
+    unlock (d);
+    unlock (s);
+}
+MENDFUNC (3, mov_w_Rr_gs, (R4 d, R2 s, IMM offset))
+
+MIDFUNC (3, mov_b_Rr_gs, (R4 d, R1 s, IMM offset))
+{
+    CLOBBER_MOV;
+    s = readreg (s, 1);
+    d = readreg (d, 4);
+    raw_mov_b_Rr_gs (d, s, offset);
+    unlock (d);
+    unlock (s);
+}
+MENDFUNC (3, mov_b_Rr_gs, (R4 d, R1 s, IMM offset))
+
+MIDFUNC (3, lea_l_brr, (W4 d, R4 s, IMM offset))
+{
+    if (isconst (s)) {
+	COMPCALL (mov_l_ri) (d, live.state[s].val + offset);
+	return;
+    }
+#if USE_OFFSET
+    if (d == s) {
+	add_offset (d, offset);
+	return;
+    }
+#endif
+    CLOBBER_LEA;
+    s = readreg (s, 4);
+    d = writereg (d, 4);
+    raw_lea_l_brr (d, s, offset);
+    unlock (d);
+    unlock (s);
+}
+MENDFUNC (3, lea_l_brr, (W4 d, R4 s, IMM offset))
+
+MIDFUNC (5, lea_l_brr_indexed, (W4 d, R4 s, R4 index, IMM factor, IMM offset))
+{
+    if (!offset) {
+	COMPCALL (lea_l_rr_indexed) (d, s, index, factor);
+	return;
+    }
+    CLOBBER_LEA;
+    s = readreg (s, 4);
+    index = readreg (index, 4);
+    d = writereg (d, 4);
+
+    raw_lea_l_brr_indexed (d, s, index, factor, offset);
+    unlock (d);
+    unlock (index);
+    unlock (s);
+}
+MENDFUNC (5, lea_l_brr_indexed, (W4 d, R4 s, R4 index, IMM factor, IMM offset))
+
+MIDFUNC (4, lea_l_rr_indexed, (W4 d, R4 s, R4 index, IMM factor))
+{
+    CLOBBER_LEA;
+    s = readreg (s, 4);
+    index = readreg (index, 4);
+    d = writereg (d, 4);
+
+    raw_lea_l_rr_indexed (d, s, index, factor);
+    unlock (d);
+    unlock (index);
+    unlock (s);
+}
+MENDFUNC (4, lea_l_rr_indexed, (W4 d, R4 s, R4 index, IMM factor))
+
+/* write d to the long at the address contained in s+offset */
+MIDFUNC (3, mov_l_bRr, (R4 d, R4 s, IMM offset))
+{
+    int dreg = d;
+    if (isconst (d) && ! use_gs_seg) {
+	COMPCALL (mov_l_mr) (live.state[d].val + offset, s);
+	return;
+    }
+
+    CLOBBER_MOV;
+    s = readreg (s, 4);
+    d = readreg_offset (d, 4);
+    offset += get_offset (dreg);
+
+    if (use_gs_seg)
+	raw_mov_l_bRr_gs (d, s, offset);
+    else
+	raw_mov_l_bRr (d, s, offset);
+    unlock (d);
+    unlock (s);
+}
+MENDFUNC (3, mov_l_bRr, (R4 d, R4 s, IMM offset))
+
+/* write the word at the address contained in s+offset and store in d */
+MIDFUNC (3, mov_w_bRr, (R4 d, R2 s, IMM offset))
+{
+    int dreg = d;
+
+    if (isconst (d) && ! use_gs_seg) {
+	COMPCALL (mov_w_mr) (live.state[d].val + offset, s);
+	return;
+    }
+
+    CLOBBER_MOV;
+    s = readreg (s, 2);
+    d = readreg_offset (d, 4);
+    offset += get_offset (dreg);
+    if (use_gs_seg)
+	raw_mov_w_bRr_gs (d, s, offset);
+    else
+	raw_mov_w_bRr (d, s, offset);
+    unlock (d);
+    unlock (s);
+}
+MENDFUNC (3, mov_w_bRr, (R4 d, R2 s, IMM offset))
+
+MIDFUNC (3, mov_b_bRr, (R4 d, R1 s, IMM offset))
+{
+    int dreg = d;
+    if (isconst (d) && ! use_gs_seg) {
+	COMPCALL (mov_b_mr) (live.state[d].val + offset, s);
+	return;
+    }
+
+    CLOBBER_MOV;
+    s = readreg (s, 1);
+    d = readreg_offset (d, 4);
+    offset += get_offset (dreg);
+    if (use_gs_seg)
+	raw_mov_b_bRr_gs (d, s, offset);
+    else
+	raw_mov_b_bRr (d, s, offset);
+    unlock (d);
+    unlock (s);
+}
+MENDFUNC (3, mov_b_bRr, (R4 d, R1 s, IMM offset))
+
+MIDFUNC (1, bswap_32, (RW4 r))
+{
+    int reg = r;
+
+    if (isconst (r)) {
+	uae_u32 oldv = live.state[r].val;
+	live.state[r].val = reverse32 (oldv);
+	return;
+    }
+
+    CLOBBER_SW32;
+    r = rmw (r, 4, 4);
+    raw_bswap_32 (r);
+    unlock (r);
+}
+MENDFUNC (1, bswap_32, (RW4 r))
+
+MIDFUNC (1, bswap_16, (RW2 r))
+{
+    if (isconst (r)) {
+	uae_u32 oldv = live.state[r].val;
+	live.state[r].val = ((oldv >> 8) & 0xff) | ((oldv << 8) & 0xff00) | (oldv & 0xffff0000);
+	return;
+    }
+
+    CLOBBER_SW16;
+    r = rmw (r, 2, 2);
+
+    raw_bswap_16 (r);
+    unlock (r);
+}
+MENDFUNC (1, bswap_16, (RW2 r))
+
+
+
+MIDFUNC (2, mov_l_rr, (W4 d, R4 s))
+{
+    int olds;
+
+    if (d == s) {		/* How pointless! */
+	return;
+    }
+    if (isconst (s)) {
+	COMPCALL (mov_l_ri) (d, live.state[s].val);
+	return;
+    }
+#if USE_ALIAS
+    olds = s;
+    disassociate (d);
+    s = readreg_offset (s, 4);
+    live.state[d].realreg = s;
+    live.state[d].realind = live.nat[s].nholds;
+    live.state[d].val = live.state[olds].val;
+    live.state[d].validsize = 4;
+    live.state[d].dirtysize = 4;
+    set_status (d, DIRTY);
+
+    live.nat[s].holds[live.nat[s].nholds] = d;
+    live.nat[s].nholds++;
+    log_clobberreg (d);
+
+    /* printf("Added %d to nreg %d(%d), now holds %d regs\n",
+       d,s,live.state[d].realind,live.nat[s].nholds); */
+    unlock (s);
+#else
+    CLOBBER_MOV;
+    s = readreg (s, 4);
+    d = writereg (d, 4);
+
+    raw_mov_l_rr (d, s);
+    unlock (d);
+    unlock (s);
+#endif
+}
+MENDFUNC (2, mov_l_rr, (W4 d, R4 s))
+
+MIDFUNC (2, mov_l_mr, (IMM d, R4 s))
+{
+    if (isconst (s)) {
+	COMPCALL (mov_l_mi) (d, live.state[s].val);
+	return;
+    }
+    CLOBBER_MOV;
+    s = readreg (s, 4);
+
+    raw_mov_l_mr (d, s);
+    unlock (s);
+}
+MENDFUNC (2, mov_l_mr, (IMM d, R4 s))
+
+
+MIDFUNC (2, mov_w_mr, (IMM d, R2 s))
+{
+    if (isconst (s)) {
+	COMPCALL (mov_w_mi) (d, (uae_u16) live.state[s].val);
+	return;
+    }
+    CLOBBER_MOV;
+    s = readreg (s, 2);
+
+    raw_mov_w_mr (d, s);
+    unlock (s);
+}
+MENDFUNC (2, mov_w_mr, (IMM d, R2 s))
+
+MIDFUNC (2, mov_w_rm, (W2 d, IMM s))
+{
+    CLOBBER_MOV;
+    d = writereg (d, 2);
+
+    raw_mov_w_rm (d, s);
+    unlock (d);
+}
+MENDFUNC (2, mov_w_rm, (W2 d, IMM s))
+
+MIDFUNC (2, mov_b_mr, (IMM d, R1 s))
+{
+    if (isconst (s)) {
+	COMPCALL (mov_b_mi) (d, (uae_u8) live.state[s].val);
+	return;
+    }
+
+    CLOBBER_MOV;
+    s = readreg (s, 1);
+
+    raw_mov_b_mr (d, s);
+    unlock (s);
+}
+MENDFUNC (2, mov_b_mr, (IMM d, R1 s))
+
+MIDFUNC (2, mov_b_rm, (W1 d, IMM s))
+{
+    CLOBBER_MOV;
+    d = writereg (d, 1);
+
+    raw_mov_b_rm (d, s);
+    unlock (d);
+}
+MENDFUNC (2, mov_b_rm, (W1 d, IMM s))
+
+MIDFUNC (2, mov_l_ri, (W4 d, IMM s))
+{
+    set_const (d, s);
+    return;
+}
+MENDFUNC (2, mov_l_ri, (W4 d, IMM s))
+
+MIDFUNC (2, mov_w_ri, (W2 d, IMM s))
+{
+    CLOBBER_MOV;
+    d = writereg (d, 2);
+
+    raw_mov_w_ri (d, s);
+    unlock (d);
+}
+MENDFUNC (2, mov_w_ri, (W2 d, IMM s))
+
+MIDFUNC (2, mov_b_ri, (W1 d, IMM s))
+{
+    CLOBBER_MOV;
+    d = writereg (d, 1);
+
+    raw_mov_b_ri (d, s);
+    unlock (d);
+}
+MENDFUNC (2, mov_b_ri, (W1 d, IMM s))
+
+
+MIDFUNC (2, add_l_mi, (IMM d, IMM s))
+{
+    CLOBBER_ADD;
+    raw_add_l_mi (d, s);
+}
+MENDFUNC (2, add_l_mi, (IMM d, IMM s))
+
+MIDFUNC (2, add_w_mi, (IMM d, IMM s))
+{
+    CLOBBER_ADD;
+    raw_add_w_mi (d, s);
+}
+MENDFUNC (2, add_w_mi, (IMM d, IMM s))
+
+MIDFUNC (2, add_b_mi, (IMM d, IMM s))
+{
+    CLOBBER_ADD;
+    raw_add_b_mi (d, s);
+}
+MENDFUNC (2, add_b_mi, (IMM d, IMM s))
+
+
+MIDFUNC (2, test_l_ri, (R4 d, IMM i))
+{
+    CLOBBER_TEST;
+    d = readreg (d, 4);
+
+    raw_test_l_ri (d, i);
+    unlock (d);
+}
+MENDFUNC (2, test_l_ri, (R4 d, IMM i))
+
+MIDFUNC (2, test_l_rr, (R4 d, R4 s))
+{
+    CLOBBER_TEST;
+    d = readreg (d, 4);
+    s = readreg (s, 4);
+
+    raw_test_l_rr (d, s);;
+    unlock (d);
+    unlock (s);
+}
+MENDFUNC (2, test_l_rr, (R4 d, R4 s))
+
+MIDFUNC (2, test_w_rr, (R2 d, R2 s))
+{
+    CLOBBER_TEST;
+    d = readreg (d, 2);
+    s = readreg (s, 2);
+
+    raw_test_w_rr (d, s);
+    unlock (d);
+    unlock (s);
+}
+MENDFUNC (2, test_w_rr, (R2 d, R2 s))
+
+MIDFUNC (2, test_b_rr, (R1 d, R1 s))
+{
+    CLOBBER_TEST;
+    d = readreg (d, 1);
+    s = readreg (s, 1);
+
+    raw_test_b_rr (d, s);
+    unlock (d);
+    unlock (s);
+}
+MENDFUNC (2, test_b_rr, (R1 d, R1 s))
+
+
+MIDFUNC (2, and_l_ri, (RW4 d, IMM i))
+{
+    if (isconst (d) && ! needflags) {
+	live.state[d].val &= i;
+	return;
+    }
+
+    CLOBBER_AND;
+    d = rmw (d, 4, 4);
+
+    raw_and_l_ri (d, i);
+    unlock (d);
+}
+MENDFUNC (2, and_l_ri, (RW4 d, IMM i))
+
+MIDFUNC (2, and_l, (RW4 d, R4 s))
+{
+    CLOBBER_AND;
+    s = readreg (s, 4);
+    d = rmw (d, 4, 4);
+
+    raw_and_l (d, s);
+    unlock (d);
+    unlock (s);
+}
+MENDFUNC (2, and_l, (RW4 d, R4 s))
+
+MIDFUNC (2, and_w, (RW2 d, R2 s))
+{
+    CLOBBER_AND;
+    s = readreg (s, 2);
+    d = rmw (d, 2, 2);
+
+    raw_and_w (d, s);
+    unlock (d);
+    unlock (s);
+}
+MENDFUNC (2, and_w, (RW2 d, R2 s))
+
+MIDFUNC (2, and_b, (RW1 d, R1 s))
+{
+    CLOBBER_AND;
+    s = readreg (s, 1);
+    d = rmw (d, 1, 1);
+
+    raw_and_b (d, s);
+    unlock (d);
+    unlock (s);
+}
+MENDFUNC (2, and_b, (RW1 d, R1 s))
+
+MIDFUNC (2, or_l_ri, (RW4 d, IMM i))
+{
+    if (isconst (d) && !needflags) {
+	live.state[d].val |= i;
+	return;
+    }
+    CLOBBER_OR;
+    d = rmw (d, 4, 4);
+
+    raw_or_l_ri (d, i);
+    unlock (d);
+}
+MENDFUNC (2, or_l_ri, (RW4 d, IMM i))
+
+MIDFUNC (2, or_l, (RW4 d, R4 s))
+{
+    if (isconst (d) && isconst (s) && !needflags) {
+	live.state[d].val |= live.state[s].val;
+	return;
+    }
+    CLOBBER_OR;
+    s = readreg (s, 4);
+    d = rmw (d, 4, 4);
+
+    raw_or_l (d, s);
+    unlock (d);
+    unlock (s);
+}
+MENDFUNC (2, or_l, (RW4 d, R4 s))
+
+MIDFUNC (2, or_w, (RW2 d, R2 s))
+{
+    CLOBBER_OR;
+    s = readreg (s, 2);
+    d = rmw (d, 2, 2);
+
+    raw_or_w (d, s);
+    unlock (d);
+    unlock (s);
+}
+MENDFUNC (2, or_w, (RW2 d, R2 s))
+
+MIDFUNC (2, or_b, (RW1 d, R1 s))
+{
+    CLOBBER_OR;
+    s = readreg (s, 1);
+    d = rmw (d, 1, 1);
+
+    raw_or_b (d, s);
+    unlock (d);
+    unlock (s);
+}
+MENDFUNC (2, or_b, (RW1 d, R1 s))
+
+MIDFUNC (2, adc_l, (RW4 d, R4 s))
+{
+    CLOBBER_ADC;
+    s = readreg (s, 4);
+    d = rmw (d, 4, 4);
+
+    raw_adc_l (d, s);
+
+    unlock (d);
+    unlock (s);
+}
+MENDFUNC (2, adc_l, (RW4 d, R4 s))
+
+MIDFUNC (2, adc_w, (RW2 d, R2 s))
+{
+    CLOBBER_ADC;
+    s = readreg (s, 2);
+    d = rmw (d, 2, 2);
+
+    raw_adc_w (d, s);
+    unlock (d);
+    unlock (s);
+}
+MENDFUNC (2, adc_w, (RW2 d, R2 s))
+
+MIDFUNC (2, adc_b, (RW1 d, R1 s))
+{
+    CLOBBER_ADC;
+    s = readreg (s, 1);
+    d = rmw (d, 1, 1);
+
+    raw_adc_b (d, s);
+    unlock (d);
+    unlock (s);
+}
+MENDFUNC (2, adc_b, (RW1 d, R1 s))
+
+MIDFUNC (2, add_l, (RW4 d, R4 s))
+{
+    if (isconst (s)) {
+	COMPCALL (add_l_ri) (d, live.state[s].val);
+	return;
+    }
+
+    CLOBBER_ADD;
+    s = readreg (s, 4);
+    d = rmw (d, 4, 4);
+
+    raw_add_l (d, s);
+
+    unlock (d);
+    unlock (s);
+}
+MENDFUNC (2, add_l, (RW4 d, R4 s))
+
+MIDFUNC (2, add_w, (RW2 d, R2 s))
+{
+    if (isconst (s)) {
+	COMPCALL (add_w_ri) (d, (uae_u16) live.state[s].val);
+	return;
+    }
+
+    CLOBBER_ADD;
+    s = readreg (s, 2);
+    d = rmw (d, 2, 2);
+
+    raw_add_w (d, s);
+    unlock (d);
+    unlock (s);
+}
+MENDFUNC (2, add_w, (RW2 d, R2 s))
+
+MIDFUNC (2, add_b, (RW1 d, R1 s))
+{
+    if (isconst (s)) {
+	COMPCALL (add_b_ri) (d, (uae_u8) live.state[s].val);
+	return;
+    }
+
+    CLOBBER_ADD;
+    s = readreg (s, 1);
+    d = rmw (d, 1, 1);
+
+    raw_add_b (d, s);
+    unlock (d);
+    unlock (s);
+}
+MENDFUNC (2, add_b, (RW1 d, R1 s))
+
+MIDFUNC (2, sub_l_ri, (RW4 d, IMM i))
+{
+    if (!i && !needflags)
+	return;
+    if (isconst (d) && !needflags) {
+	live.state[d].val -= i;
+	return;
+    }
+#if USE_OFFSET
+    if (!needflags) {
+	add_offset (d, -(signed) i);
+	return;
+    }
+#endif
+
+    CLOBBER_SUB;
+    d = rmw (d, 4, 4);
+
+    raw_sub_l_ri (d, i);
+    unlock (d);
+}
+MENDFUNC (2, sub_l_ri, (RW4 d, IMM i))
+
+MIDFUNC (2, sub_w_ri, (RW2 d, IMM i))
+{
+    if (!i && !needflags)
+	return;
+
+    CLOBBER_SUB;
+    d = rmw (d, 2, 2);
+
+    raw_sub_w_ri (d, i);
+    unlock (d);
+}
+MENDFUNC (2, sub_w_ri, (RW2 d, IMM i))
+
+MIDFUNC (2, sub_b_ri, (RW1 d, IMM i))
+{
+    if (!i && !needflags)
+	return;
+
+    CLOBBER_SUB;
+    d = rmw (d, 1, 1);
+
+    raw_sub_b_ri (d, i);
+
+    unlock (d);
+}
+MENDFUNC (2, sub_b_ri, (RW1 d, IMM i))
+
+MIDFUNC (2, add_l_ri, (RW4 d, IMM i))
+{
+    if (!i && !needflags)
+	return;
+    if (isconst (d) && !needflags) {
+	live.state[d].val += i;
+	return;
+    }
+#if USE_OFFSET
+    if (!needflags) {
+	add_offset (d, i);
+	return;
+    }
+#endif
+    CLOBBER_ADD;
+    d = rmw (d, 4, 4);
+    raw_add_l_ri (d, i);
+    unlock (d);
+}
+MENDFUNC (2, add_l_ri, (RW4 d, IMM i))
+
+MIDFUNC (2, add_w_ri, (RW2 d, IMM i))
+{
+    if (!i && !needflags)
+	return;
+
+    CLOBBER_ADD;
+    d = rmw (d, 2, 2);
+
+    raw_add_w_ri (d, i);
+    unlock (d);
+}
+MENDFUNC (2, add_w_ri, (RW2 d, IMM i))
+
+MIDFUNC (2, add_b_ri, (RW1 d, IMM i))
+{
+    if (!i && !needflags)
+	return;
+
+    CLOBBER_ADD;
+    d = rmw (d, 1, 1);
+
+    raw_add_b_ri (d, i);
+
+    unlock (d);
+}
+MENDFUNC (2, add_b_ri, (RW1 d, IMM i))
+
+MIDFUNC (2, sbb_l, (RW4 d, R4 s))
+{
+    CLOBBER_SBB;
+    s = readreg (s, 4);
+    d = rmw (d, 4, 4);
+
+    raw_sbb_l (d, s);
+    unlock (d);
+    unlock (s);
+}
+MENDFUNC (2, sbb_l, (RW4 d, R4 s))
+
+MIDFUNC (2, sbb_w, (RW2 d, R2 s))
+{
+    CLOBBER_SBB;
+    s = readreg (s, 2);
+    d = rmw (d, 2, 2);
+
+    raw_sbb_w (d, s);
+    unlock (d);
+    unlock (s);
+}
+MENDFUNC (2, sbb_w, (RW2 d, R2 s))
+
+MIDFUNC (2, sbb_b, (RW1 d, R1 s))
+{
+    CLOBBER_SBB;
+    s = readreg (s, 1);
+    d = rmw (d, 1, 1);
+
+    raw_sbb_b (d, s);
+    unlock (d);
+    unlock (s);
+}
+MENDFUNC (2, sbb_b, (RW1 d, R1 s))
+
+MIDFUNC (2, sub_l, (RW4 d, R4 s))
+{
+    if (isconst (s)) {
+	COMPCALL (sub_l_ri) (d, live.state[s].val);
+	return;
+    }
+
+    CLOBBER_SUB;
+    s = readreg (s, 4);
+    d = rmw (d, 4, 4);
+
+    raw_sub_l (d, s);
+    unlock (d);
+    unlock (s);
+}
+MENDFUNC (2, sub_l, (RW4 d, R4 s))
+
+MIDFUNC (2, sub_w, (RW2 d, R2 s))
+{
+    if (isconst (s)) {
+	COMPCALL (sub_w_ri) (d, (uae_u16) live.state[s].val);
+	return;
+    }
+
+    CLOBBER_SUB;
+    s = readreg (s, 2);
+    d = rmw (d, 2, 2);
+
+    raw_sub_w (d, s);
+    unlock (d);
+    unlock (s);
+}
+MENDFUNC (2, sub_w, (RW2 d, R2 s))
+
+MIDFUNC (2, sub_b, (RW1 d, R1 s))
+{
+    if (isconst (s)) {
+	COMPCALL (sub_b_ri) (d, (uae_u8) live.state[s].val);
+	return;
+    }
+
+    CLOBBER_SUB;
+    s = readreg (s, 1);
+    d = rmw (d, 1, 1);
+
+    raw_sub_b (d, s);
+    unlock (d);
+    unlock (s);
+}
+MENDFUNC (2, sub_b, (RW1 d, R1 s))
+
+MIDFUNC (2, cmp_l, (R4 d, R4 s))
+{
+    CLOBBER_CMP;
+    s = readreg (s, 4);
+    d = readreg (d, 4);
+
+    raw_cmp_l (d, s);
+    unlock (d);
+    unlock (s);
+}
+MENDFUNC (2, cmp_l, (R4 d, R4 s))
+
+MIDFUNC (2, cmp_l_ri, (R4 r, IMM i))
+{
+    CLOBBER_CMP;
+    r = readreg (r, 4);
+
+    raw_cmp_l_ri (r, i);
+    unlock (r);
+}
+MENDFUNC (2, cmp_l_ri, (R4 r, IMM i))
+
+MIDFUNC (2, cmp_w, (R2 d, R2 s))
+{
+    CLOBBER_CMP;
+    s = readreg (s, 2);
+    d = readreg (d, 2);
+
+    raw_cmp_w (d, s);
+    unlock (d);
+    unlock (s);
+}
+MENDFUNC (2, cmp_w, (R2 d, R2 s))
+
+MIDFUNC (2, cmp_b, (R1 d, R1 s))
+{
+    CLOBBER_CMP;
+    s = readreg (s, 1);
+    d = readreg (d, 1);
+
+    raw_cmp_b (d, s);
+    unlock (d);
+    unlock (s);
+}
+MENDFUNC (2, cmp_b, (R1 d, R1 s))
+
+
+MIDFUNC (2, xor_l, (RW4 d, R4 s))
+{
+    CLOBBER_XOR;
+    s = readreg (s, 4);
+    d = rmw (d, 4, 4);
+
+    raw_xor_l (d, s);
+    unlock (d);
+    unlock (s);
+}
+MENDFUNC (2, xor_l, (RW4 d, R4 s))
+
+MIDFUNC (2, xor_w, (RW2 d, R2 s))
+{
+    CLOBBER_XOR;
+    s = readreg (s, 2);
+    d = rmw (d, 2, 2);
+
+    raw_xor_w (d, s);
+    unlock (d);
+    unlock (s);
+}
+MENDFUNC (2, xor_w, (RW2 d, R2 s))
+
+MIDFUNC (2, xor_b, (RW1 d, R1 s))
+{
+    CLOBBER_XOR;
+    s = readreg (s, 1);
+    d = rmw (d, 1, 1);
+
+    raw_xor_b (d, s);
+    unlock (d);
+    unlock (s);
+}
+MENDFUNC (2, xor_b, (RW1 d, R1 s))
+
+MIDFUNC (5, call_r_11, (W4 out1, R4 r, R4 in1, IMM osize, IMM isize))
+{
+    clobber_flags ();
+    remove_all_offsets ();
+    if (osize == 4) {
+	if (out1 != in1 && out1 != r) {
+	    COMPCALL (forget_about) (out1);
+	}
+    } else {
+	tomem_c (out1);
+    }
+
+    in1 = readreg_specific (in1, isize, REG_PAR1);
+    r = readreg (r, 4);
+    prepare_for_call_1 ();	/* This should ensure that there won't be
+				   any need for swapping nregs in prepare_for_call_2
+				 */
+#if USE_NORMAL_CALLING_CONVENTION
+    raw_push_l_r (in1);
+#endif
+    unlock (in1);
+    unlock (r);
+
+    prepare_for_call_2 ();
+    raw_call_r (r);
+
+#if USE_NORMAL_CALLING_CONVENTION
+    raw_inc_sp (4);
+#endif
+
+
+    live.nat[REG_RESULT].holds[0] = out1;
+    live.nat[REG_RESULT].nholds = 1;
+    live.nat[REG_RESULT].touched = touchcnt++;
+
+    live.state[out1].realreg = REG_RESULT;
+    live.state[out1].realind = 0;
+    live.state[out1].val = 0;
+    live.state[out1].validsize = osize;
+    live.state[out1].dirtysize = osize;
+    set_status (out1, DIRTY);
+}
+MENDFUNC (5, call_r_11, (W4 out1, R4 r, R4 in1, IMM osize, IMM isize))
+
+MIDFUNC (5, call_r_02, (R4 r, R4 in1, R4 in2, IMM isize1, IMM isize2))
+{
+    clobber_flags ();
+    remove_all_offsets ();
+    in1 = readreg_specific (in1, isize1, REG_PAR1);
+    in2 = readreg_specific (in2, isize2, REG_PAR2);
+    r = readreg (r, 4);
+    prepare_for_call_1 ();	/* This should ensure that there won't be
+				   any need for swapping nregs in prepare_for_call_2
+				 */
+#if USE_NORMAL_CALLING_CONVENTION
+    raw_push_l_r (in2);
+    raw_push_l_r (in1);
+#endif
+    unlock (r);
+    unlock (in1);
+    unlock (in2);
+    prepare_for_call_2 ();
+    raw_call_r (r);
+#if USE_NORMAL_CALLING_CONVENTION
+    raw_inc_sp (8);
+#endif
+}
+MENDFUNC (5, call_r_02, (R4 r, R4 in1, R4 in2, IMM isize1, IMM isize2))
+
+
+MIDFUNC (1, forget_about, (W4 r))
+{
+    if (isinreg (r))
+	disassociate (r);
+    live.state[r].val = 0;
+    set_status (r, UNDEF);
+}
+MENDFUNC (1, forget_about, (W4 r))
+
+MIDFUNC (0, nop, (void))
+{
+    raw_nop ();
+}
+MENDFUNC (0, nop, (void))
+
+
+MIDFUNC (1, f_forget_about, (FW r))
+{
+    if (f_isinreg (r))
+	f_disassociate (r);
+    live.fate[r].status = UNDEF;
+}
+MENDFUNC (1, f_forget_about, (FW r))
+
+MIDFUNC (1, fmov_pi, (FW r))
+{
+    r = f_writereg (r);
+    raw_fmov_pi (r);
+    f_unlock (r);
+}
+MENDFUNC (1, fmov_pi, (FW r))
+
+MIDFUNC (1, fmov_log10_2, (FW r))
+{
+    r = f_writereg (r);
+    raw_fmov_log10_2 (r);
+    f_unlock (r);
+}
+MENDFUNC (1, fmov_log10_2, (FW r))
+
+MIDFUNC (1, fmov_log2_e, (FW r))
+{
+    r = f_writereg (r);
+    raw_fmov_log2_e (r);
+    f_unlock (r);
+}
+MENDFUNC (1, fmov_log2_e, (FW r))
+
+MIDFUNC (1, fmov_loge_2, (FW r))
+{
+    r = f_writereg (r);
+    raw_fmov_loge_2 (r);
+    f_unlock (r);
+}
+MENDFUNC (1, fmov_loge_2, (FW r))
+
+MIDFUNC (1, fmov_1, (FW r))
+{
+    r = f_writereg (r);
+    raw_fmov_1 (r);
+    f_unlock (r);
+}
+MENDFUNC (1, fmov_1, (FW r))
+
+MIDFUNC (1, fmov_0, (FW r))
+{
+    r = f_writereg (r);
+    raw_fmov_0 (r);
+    f_unlock (r);
+}
+MENDFUNC (1, fmov_0, (FW r))
+
+MIDFUNC (2, fmov_rm, (FW r, MEMR m))
+{
+    r = f_writereg (r);
+    raw_fmov_rm (r, m);
+    f_unlock (r);
+}
+MENDFUNC (2, fmov_rm, (FW r, MEMR m))
+
+MIDFUNC (2, fmovi_rm, (FW r, MEMR m))
+{
+    r = f_writereg (r);
+    raw_fmovi_rm (r, m);
+    f_unlock (r);
+}
+MENDFUNC (2, fmovi_rm, (FW r, MEMR m))
+
+MIDFUNC (2, fmovi_mr, (MEMW m, FR r))
+{
+    r = f_readreg (r);
+    raw_fmovi_mr (m, r);
+    f_unlock (r);
+}
+MENDFUNC (2, fmovi_mr, (MEMW m, FR r))
+
+MIDFUNC (2, fmovs_rm, (FW r, MEMR m))
+{
+    r = f_writereg (r);
+    raw_fmovs_rm (r, m);
+    f_unlock (r);
+}
+MENDFUNC (2, fmovs_rm, (FW r, MEMR m))
+
+MIDFUNC (2, fmovs_mr, (MEMW m, FR r))
+{
+    r = f_readreg (r);
+    raw_fmovs_mr (m, r);
+    f_unlock (r);
+}
+MENDFUNC (2, fmovs_mr, (MEMW m, FR r))
+
+MIDFUNC (2, fmov_ext_mr, (MEMW m, FR r))
+{
+    r = f_readreg (r);
+    raw_fmov_ext_mr (m, r);
+    f_unlock (r);
+}
+MENDFUNC (2, fmov_ext_mr, (MEMW m, FR r))
+
+MIDFUNC (2, fmov_mr, (MEMW m, FR r))
+{
+    r = f_readreg (r);
+    raw_fmov_mr (m, r);
+    f_unlock (r);
+}
+MENDFUNC (2, fmov_mr, (MEMW m, FR r))
+
+MIDFUNC (2, fmov_ext_rm, (FW r, MEMR m))
+{
+    r = f_writereg (r);
+    raw_fmov_ext_rm (r, m);
+    f_unlock (r);
+}
+MENDFUNC (2, fmov_ext_rm, (FW r, MEMR m))
+
+MIDFUNC (2, fmov_rr, (FW d, FR s))
+{
+    if (d == s) {		/* How pointless! */
+	return;
+    }
+#if USE_F_ALIAS
+    f_disassociate (d);
+    s = f_readreg (s);
+    live.fate[d].realreg = s;
+    live.fate[d].realind = live.fat[s].nholds;
+    live.fate[d].status = DIRTY;
+    live.fat[s].holds[live.fat[s].nholds] = d;
+    live.fat[s].nholds++;
+    f_unlock (s);
+#else
+    s = f_readreg (s);
+    d = f_writereg (d);
+    raw_fmov_rr (d, s);
+    f_unlock (s);
+    f_unlock (d);
+#endif
+}
+MENDFUNC (2, fmov_rr, (FW d, FR s))
+
+MIDFUNC (2, fldcw_m_indexed, (R4 index, IMM base))
+{
+    index = readreg (index, 4);
+
+    raw_fldcw_m_indexed (index, base);
+    unlock (index);
+}
+MENDFUNC (2, fldcw_m_indexed, (R4 index, IMM base))
+
+MIDFUNC (1, ftst_r, (FR r))
+{
+    r = f_readreg (r);
+    raw_ftst_r (r);
+    f_unlock (r);
+}
+MENDFUNC (1, ftst_r, (FR r))
+
+MIDFUNC (0, dont_care_fflags, (void))
+{
+    f_disassociate (FP_RESULT);
+}
+MENDFUNC (0, dont_care_fflags, (void))
+
+MIDFUNC (2, fsqrt_rr, (FW d, FR s))
+{
+    s = f_readreg (s);
+    d = f_writereg (d);
+    raw_fsqrt_rr (d, s);
+    f_unlock (s);
+    f_unlock (d);
+}
+MENDFUNC (2, fsqrt_rr, (FW d, FR s))
+
+MIDFUNC (2, fabs_rr, (FW d, FR s))
+{
+    s = f_readreg (s);
+    d = f_writereg (d);
+    raw_fabs_rr (d, s);
+    f_unlock (s);
+    f_unlock (d);
+}
+MENDFUNC (2, fabs_rr, (FW d, FR s))
+
+MIDFUNC (2, fsin_rr, (FW d, FR s))
+{
+    s = f_readreg (s);
+    d = f_writereg (d);
+    raw_fsin_rr (d, s);
+    f_unlock (s);
+    f_unlock (d);
+}
+MENDFUNC (2, fsin_rr, (FW d, FR s))
+
+MIDFUNC (2, fcos_rr, (FW d, FR s))
+{
+    s = f_readreg (s);
+    d = f_writereg (d);
+    raw_fcos_rr (d, s);
+    f_unlock (s);
+    f_unlock (d);
+}
+MENDFUNC (2, fcos_rr, (FW d, FR s))
+
+MIDFUNC (2, ftwotox_rr, (FW d, FR s))
+{
+    s = f_readreg (s);
+    d = f_writereg (d);
+    raw_ftwotox_rr (d, s);
+    f_unlock (s);
+    f_unlock (d);
+}
+MENDFUNC (2, ftwotox_rr, (FW d, FR s))
+
+MIDFUNC (2, fetox_rr, (FW d, FR s))
+{
+    s = f_readreg (s);
+    d = f_writereg (d);
+    raw_fetox_rr (d, s);
+    f_unlock (s);
+    f_unlock (d);
+}
+MENDFUNC (2, fetox_rr, (FW d, FR s))
+
+MIDFUNC (2, frndint_rr, (FW d, FR s))
+{
+    s = f_readreg (s);
+    d = f_writereg (d);
+    raw_frndint_rr (d, s);
+    f_unlock (s);
+    f_unlock (d);
+}
+MENDFUNC (2, frndint_rr, (FW d, FR s))
+
+MIDFUNC (2, flog2_rr, (FW d, FR s))
+{
+    s = f_readreg (s);
+    d = f_writereg (d);
+    raw_flog2_rr (d, s);
+    f_unlock (s);
+    f_unlock (d);
+}
+MENDFUNC (2, flog2_rr, (FW d, FR s))
+
+MIDFUNC (2, fneg_rr, (FW d, FR s))
+{
+    s = f_readreg (s);
+    d = f_writereg (d);
+    raw_fneg_rr (d, s);
+    f_unlock (s);
+    f_unlock (d);
+}
+MENDFUNC (2, fneg_rr, (FW d, FR s))
+
+MIDFUNC (2, fadd_rr, (FRW d, FR s))
+{
+    s = f_readreg (s);
+    d = f_rmw (d);
+    raw_fadd_rr (d, s);
+    f_unlock (s);
+    f_unlock (d);
+}
+MENDFUNC (2, fadd_rr, (FRW d, FR s))
+
+MIDFUNC (2, fsub_rr, (FRW d, FR s))
+{
+    s = f_readreg (s);
+    d = f_rmw (d);
+    raw_fsub_rr (d, s);
+    f_unlock (s);
+    f_unlock (d);
+}
+MENDFUNC (2, fsub_rr, (FRW d, FR s))
+
+MIDFUNC (2, fcmp_rr, (FR d, FR s))
+{
+    d = f_readreg (d);
+    s = f_readreg (s);
+    raw_fcmp_rr (d, s);
+    f_unlock (s);
+    f_unlock (d);
+}
+MENDFUNC (2, fcmp_rr, (FR d, FR s))
+
+MIDFUNC (2, fdiv_rr, (FRW d, FR s))
+{
+    s = f_readreg (s);
+    d = f_rmw (d);
+    raw_fdiv_rr (d, s);
+    f_unlock (s);
+    f_unlock (d);
+}
+MENDFUNC (2, fdiv_rr, (FRW d, FR s))
+
+MIDFUNC (2, frem_rr, (FRW d, FR s))
+{
+    s = f_readreg (s);
+    d = f_rmw (d);
+    raw_frem_rr (d, s);
+    f_unlock (s);
+    f_unlock (d);
+}
+MENDFUNC (2, frem_rr, (FRW d, FR s))
+
+MIDFUNC (2, frem1_rr, (FRW d, FR s))
+{
+    s = f_readreg (s);
+    d = f_rmw (d);
+    raw_frem1_rr (d, s);
+    f_unlock (s);
+    f_unlock (d);
+}
+MENDFUNC (2, frem1_rr, (FRW d, FR s))
+
+MIDFUNC (2, fmul_rr, (FRW d, FR s))
+{
+    s = f_readreg (s);
+    d = f_rmw (d);
+    raw_fmul_rr (d, s);
+    f_unlock (s);
+    f_unlock (d);
+}
+MENDFUNC (2, fmul_rr, (FRW d, FR s))
+
+
+/********************************************************************
+ * Support functions exposed to gencomp. CREATE time                *
+ ********************************************************************/
+int kill_rodent (int r)
+{
+    return KILLTHERAT &&
+	have_rat_stall &&
+	(live.state[r].status == INMEM ||
+	 live.state[r].status == CLEAN || live.state[r].status == ISCONST || live.state[r].dirtysize == 4);
+}
+
+uae_u32 get_const (int r)
+{
+#if USE_OPTIMIZER
+    if (!reg_alloc_run)
+#endif
+	Dif (!isconst (r)) {
+	printf ("Register %d should be constant, but isn't\n", r);
+	abort ();
+	}
+    return live.state[r].val;
+}
+
+void sync_m68k_pc (void)
+{
+    if (m68k_pc_offset) {
+	add_l_ri (PC_P, m68k_pc_offset);
+	comp_pc_p += m68k_pc_offset;
+	m68k_pc_offset = 0;
+    }
+}
+
+/********************************************************************
+ * Support functions exposed to newcpu                              *
+ ********************************************************************/
+
+uae_u32 scratch[VREGS];
+fptype fscratch[VFREGS];
+
+void init_comp (void)
+{
+    int i;
+    uae_u8 *cb = can_byte;
+    uae_u8 *cw = can_word;
+    uae_u8 *au = always_used;
+
+    for (i = 0; i < VREGS; i++) {
+	live.state[i].realreg = -1;
+	live.state[i].needflush = NF_SCRATCH;
+	live.state[i].val = 0;
+	set_status (i, UNDEF);
+    }
+
+    for (i = 0; i < VFREGS; i++) {
+	live.fate[i].status = UNDEF;
+	live.fate[i].realreg = -1;
+	live.fate[i].needflush = NF_SCRATCH;
+    }
+
+    for (i = 0; i < VREGS; i++) {
+	if (i < 16) {		/* First 16 registers map to 68k registers */
+	    live.state[i].mem = ((uae_u32 *) & regs) + i;
+	    live.state[i].needflush = NF_TOMEM;
+	    set_status (i, INMEM);
+	} else
+	    live.state[i].mem = scratch + i;
+    }
+    live.state[PC_P].mem = (uae_u32 *) & (regs.pc_p);
+    live.state[PC_P].needflush = NF_TOMEM;
+    set_const (PC_P, (uae_u32) comp_pc_p);
+
+    live.state[FLAGX].mem = &(regflags.x);
+    live.state[FLAGX].needflush = NF_TOMEM;
+    set_status (FLAGX, INMEM);
+
+    live.state[FLAGTMP].mem = &(regflags.cznv);
+    live.state[FLAGTMP].needflush = NF_TOMEM;
+    set_status (FLAGTMP, INMEM);
+
+    live.state[NEXT_HANDLER].needflush = NF_HANDLER;
+    set_status (NEXT_HANDLER, UNDEF);
+
+    for (i = 0; i < VFREGS; i++) {
+	if (i < 8) {		/* First 8 registers map to 68k FPU registers */
+	    live.fate[i].mem = (uae_u32 *) (((fptype *) regs.fp) + i);
+	    live.fate[i].needflush = NF_TOMEM;
+	    live.fate[i].status = INMEM;
+	} else if (i == FP_RESULT) {
+	    live.fate[i].mem = (uae_u32 *) (&regs.fp_result);
+	    live.fate[i].needflush = NF_TOMEM;
+	    live.fate[i].status = INMEM;
+	} else
+	    live.fate[i].mem = (uae_u32 *) (fscratch + i);
+    }
+
+
+    for (i = 0; i < N_REGS; i++) {
+	live.nat[i].touched = 0;
+	live.nat[i].nholds = 0;
+	live.nat[i].locked = 0;
+	if (*cb == i) {
+	    live.nat[i].canbyte = 1;
+	    cb++;
+	} else
+	    live.nat[i].canbyte = 0;
+	if (*cw == i) {
+	    live.nat[i].canword = 1;
+	    cw++;
+	} else
+	    live.nat[i].canword = 0;
+	if (*au == i) {
+	    live.nat[i].locked = 1;
+	    au++;
+	}
+    }
+
+    for (i = 0; i < N_FREGS; i++) {
+	live.fat[i].touched = 0;
+	live.fat[i].nholds = 0;
+	live.fat[i].locked = 0;
+    }
+
+    touchcnt = 1;
+    m68k_pc_offset = 0;
+    live.flags_in_flags = TRASH;
+    live.flags_on_stack = VALID;
+    live.flags_are_important = 1;
+
+    raw_fp_init ();
+}
+
+
+static void vinton (int i, uae_s8 * vton, int depth)
+{
+    int n;
+    int rr;
+
+    Dif (vton[i] == -1) {
+	printf ("Asked to load register %d, but nowhere to go\n", i);
+	abort ();
+    }
+    n = vton[i];
+    Dif (live.nat[n].nholds > 1)
+	abort ();
+    if (live.nat[n].nholds && depth < N_REGS) {
+	vinton (live.nat[n].holds[0], vton, depth + 1);
+    }
+    if (!isinreg (i))
+	return;			/* Oops --- got rid of that one in the recursive calls */
+    rr = live.state[i].realreg;
+    if (rr != n)
+	mov_nregs (n, rr);
+}
+
+#if USE_MATCHSTATE
+/* This is going to be, amongst other things, a more elaborate version of
+   flush() */
+static __inline__ void match_states (smallstate * s)
+{
+    uae_s8 vton[VREGS];
+    uae_s8 ndone[N_REGS];
+    int i;
+    int again = 0;
+
+    for (i = 0; i < VREGS; i++)
+	vton[i] = -1;
+
+    for (i = 0; i < N_REGS; i++)
+	if (s->nat[i].validsize)
+	    vton[s->nat[i].holds] = i;
+
+    flush_flags ();		/* low level */
+    sync_m68k_pc ();		/* mid level */
+
+    /* We don't do FREGS yet, so this is raw flush() code */
+    for (i = 0; i < VFREGS; i++) {
+	if (live.fate[i].needflush == NF_SCRATCH || live.fate[i].status == CLEAN) {
+	    f_disassociate (i);
+	}
+    }
+    for (i = 0; i < VFREGS; i++) {
+	if (live.fate[i].needflush == NF_TOMEM && live.fate[i].status == DIRTY) {
+	    f_evict (i);
+	}
+    }
+    raw_fp_cleanup_drop ();
+
+    /* Now comes the fun part. First, we need to remove all offsets */
+    for (i = 0; i < VREGS; i++)
+	if (!isconst (i) && live.state[i].val)
+	    remove_offset (i, -1);
+
+    /* Next, we evict everything that does not end up in registers,
+       write back overly dirty registers, and write back constants */
+    for (i = 0; i < VREGS; i++) {
+	switch (live.state[i].status) {
+	case ISCONST:
+	    if (i != PC_P)
+		writeback_const (i);
+	    break;
+	case DIRTY:
+	    if (vton[i] == -1) {
+		evict (i);
+		break;
+	    }
+	    if (live.state[i].dirtysize > s->nat[vton[i]].dirtysize)
+		tomem (i);
+	    /* Fall-through! */
+	case CLEAN:
+	    if (vton[i] == -1 || live.state[i].validsize < s->nat[vton[i]].validsize)
+		evict (i);
+	    else
+		make_exclusive (i, 0, -1);
+	    break;
+	case INMEM:
+	    break;
+	case UNDEF:
+	    break;
+	default:
+	    printf ("Weird status: %d\n", live.state[i].status);
+	    abort ();
+	}
+    }
+
+    /* Quick consistency check */
+    for (i = 0; i < VREGS; i++) {
+	if (isinreg (i)) {
+	    int n = live.state[i].realreg;
+
+	    if (live.nat[n].nholds != 1) {
+		printf ("Register %d isn't alone in nreg %d\n", i, n);
+		abort ();
+	    }
+	    if (vton[i] == -1) {
+		printf ("Register %d is still in register, shouldn't be\n", i);
+		abort ();
+	    }
+	}
+    }
+
+    /* Now we need to shuffle things around so the VREGs are in the
+       right N_REGs. */
+    for (i = 0; i < VREGS; i++) {
+	if (isinreg (i) && vton[i] != live.state[i].realreg)
+	    vinton (i, vton, 0);
+    }
+
+    /* And now we may need to load some registers from memory */
+    for (i = 0; i < VREGS; i++) {
+	int n = vton[i];
+	if (n == -1) {
+	    Dif (isinreg (i)) {
+		printf ("Register %d unexpectedly in nreg %d\n", i, live.state[i].realreg);
+		abort ();
+	    }
+	} else {
+	    switch (live.state[i].status) {
+	    case CLEAN:
+	    case DIRTY:
+		Dif (n != live.state[i].realreg)
+		    abort ();
+		break;
+	    case INMEM:
+		Dif (live.nat[n].nholds) {
+		    printf ("natreg %d holds %d vregs, should be empty\n", n, live.nat[n].nholds);
+		}
+		raw_mov_l_rm (n, (uae_u32) live.state[i].mem);
+		live.state[i].validsize = 4;
+		live.state[i].dirtysize = 0;
+		live.state[i].realreg = n;
+		live.state[i].realind = 0;
+		live.state[i].val = 0;
+		live.state[i].is_swapped = 0;
+		live.nat[n].nholds = 1;
+		live.nat[n].holds[0] = i;
+
+		set_status (i, CLEAN);
+		break;
+	    case ISCONST:
+		if (i != PC_P) {
+		    printf ("Got constant in matchstate for reg %d. Bad!\n", i);
+		    abort ();
+		}
+		break;
+	    case UNDEF:
+		break;
+	    }
+	}
+    }
+
+    /* One last consistency check, and adjusting the states in live
+       to those in s */
+    for (i = 0; i < VREGS; i++) {
+	int n = vton[i];
+	switch (live.state[i].status) {
+	case INMEM:
+	    if (n != -1)
+		abort ();
+	    break;
+	case ISCONST:
+	    if (i != PC_P)
+		abort ();
+	    break;
+	case CLEAN:
+	case DIRTY:
+	    if (n == -1)
+		abort ();
+	    if (live.state[i].dirtysize > s->nat[n].dirtysize)
+		abort;
+	    if (live.state[i].validsize < s->nat[n].validsize)
+		abort;
+	    live.state[i].dirtysize = s->nat[n].dirtysize;
+	    live.state[i].validsize = s->nat[n].validsize;
+	    if (live.state[i].dirtysize)
+		set_status (i, DIRTY);
+	    break;
+	case UNDEF:
+	    break;
+	}
+	if (n != -1)
+	    live.nat[n].touched = touchcnt++;
+    }
+}
+#else
+static __inline__ void match_states (smallstate * s)
+{
+    flush (1);
+}
+#endif
+
+/* Only do this if you really mean it! The next call should be to init!*/
+void flush (int save_regs)
+{
+    int fi, i;
+
+    log_flush ();
+    flush_flags ();		/* low level */
+    sync_m68k_pc ();		/* mid level */
+
+    if (save_regs) {
+	for (i = 0; i < VFREGS; i++) {
+	    if (live.fate[i].needflush == NF_SCRATCH || live.fate[i].status == CLEAN) {
+		f_disassociate (i);
+	    }
+	}
+	for (i = 0; i < VREGS; i++) {
+	    if (live.state[i].needflush == NF_TOMEM) {
+		switch (live.state[i].status) {
+		case INMEM:
+		    if (live.state[i].val) {
+			raw_add_l_mi ((uae_u32) live.state[i].mem, live.state[i].val);
+			live.state[i].val = 0;
+		    }
+		    break;
+		case CLEAN:
+		case DIRTY:
+		    remove_offset (i, -1);
+		    tomem (i);
+		    break;
+		case ISCONST:
+		    if (i != PC_P)
+			writeback_const (i);
+		    break;
+		default:
+		    break;
+		}
+		Dif (live.state[i].val && i != PC_P) {
+		    printf ("Register %d still has val %x\n", i, live.state[i].val);
+		}
+	    }
+	}
+	for (i = 0; i < VFREGS; i++) {
+	    if (live.fate[i].needflush == NF_TOMEM && live.fate[i].status == DIRTY) {
+		f_evict (i);
+	    }
+	}
+	raw_fp_cleanup_drop ();
+    }
+    if (needflags) {
+	printf ("Warning! flush with needflags=1!\n");
+    }
+
+    lopt_emit_all ();
+}
+
+static void flush_keepflags (void)
+{
+    int fi, i;
+
+    for (i = 0; i < VFREGS; i++) {
+	if (live.fate[i].needflush == NF_SCRATCH || live.fate[i].status == CLEAN) {
+	    f_disassociate (i);
+	}
+    }
+    for (i = 0; i < VREGS; i++) {
+	if (live.state[i].needflush == NF_TOMEM) {
+	    switch (live.state[i].status) {
+	    case INMEM:
+		/* Can't adjust the offset here --- that needs "add" */
+		break;
+	    case CLEAN:
+	    case DIRTY:
+		remove_offset (i, -1);
+		tomem (i);
+		break;
+	    case ISCONST:
+		if (i != PC_P)
+		    writeback_const (i);
+		break;
+	    default:
+		break;
+	    }
+	}
+    }
+    for (i = 0; i < VFREGS; i++) {
+	if (live.fate[i].needflush == NF_TOMEM && live.fate[i].status == DIRTY) {
+	    f_evict (i);
+	}
+    }
+    raw_fp_cleanup_drop ();
+    lopt_emit_all ();
+}
+
+void freescratch (void)
+{
+    int i;
+    for (i = 0; i < N_REGS; i++)
+	if (live.nat[i].locked && i != 4)
+	    printf ("Warning! %d is locked\n", i);
+
+    for (i = 0; i < VREGS; i++)
+	if (live.state[i].needflush == NF_SCRATCH) {
+	    forget_about (i);
+	}
+
+    for (i = 0; i < VFREGS; i++)
+	if (live.fate[i].needflush == NF_SCRATCH) {
+	    f_forget_about (i);
+	}
+}
+
+/********************************************************************
+ * Support functions, internal                                      *
+ ********************************************************************/
+
+
+static void align_target (uae_u32 a)
+{
+    lopt_emit_all ();
+    /* Fill with NOPs --- makes debugging with gdb easier */
+    while ((uae_u32) target & (a - 1))
+	*target++ = 0x90;
+}
+
+extern uae_u8 *kickmemory;
+static __inline__ int isinrom (uae_u32 addr)
+{
+    return (addr >= (uae_u32) kickmemory && addr < (uae_u32) kickmemory + 8 * 65536);
+}
+
+static void flush_all (void)
+{
+    int i;
+
+    log_flush ();
+    for (i = 0; i < VREGS; i++)
+	if (live.state[i].status == DIRTY) {
+	    if (!call_saved[live.state[i].realreg]) {
+		tomem (i);
+	    }
+	}
+    for (i = 0; i < VFREGS; i++)
+	if (f_isinreg (i))
+	    f_evict (i);
+    raw_fp_cleanup_drop ();
+}
+
+/* Make sure all registers that will get clobbered by a call are
+   save and sound in memory */
+static void prepare_for_call_1 (void)
+{
+    flush_all ();		/* If there are registers that don't get clobbered,
+				 * we should be a bit more selective here */
+}
+
+/* We will call a C routine in a moment. That will clobber all registers,
+   so we need to disassociate everything */
+static void prepare_for_call_2 (void)
+{
+    int i;
+    for (i = 0; i < N_REGS; i++)
+	if (!call_saved[i] && live.nat[i].nholds > 0)
+	    free_nreg (i);
+
+    for (i = 0; i < N_FREGS; i++)
+	if (live.fat[i].nholds > 0)
+	    f_free_nreg (i);
+
+    live.flags_in_flags = TRASH;	/* Note: We assume we already rescued the
+					   flags at the very start of the call_r
+					   functions! */
+}
+
+
+/********************************************************************
+ * Memory access and related functions, CREATE time                 *
+ ********************************************************************/
+
+void register_branch (uae_u32 not_taken, uae_u32 taken, uae_u8 cond)
+{
+    next_pc_p = not_taken;
+    taken_pc_p = taken;
+    branch_cc = cond;
+}
+
+
+static uae_u32 get_handler_address (uae_u32 addr)
+{
+    uae_u32 cl = cacheline (addr);
+    blockinfo *bi = get_blockinfo_addr_new ((void *) addr, 0);
+
+#if USE_OPTIMIZER
+    if (!bi && reg_alloc_run)
+	return 0;
+#endif
+    return (uae_u32) & (bi->direct_handler_to_use);
+}
+
+static uae_u32 get_handler (uae_u32 addr)
+{
+    uae_u32 cl = cacheline (addr);
+    blockinfo *bi = get_blockinfo_addr_new ((void *) addr, 0);
+
+#if USE_OPTIMIZER
+    if (!bi && reg_alloc_run)
+	return 0;
+#endif
+    return (uae_u32) bi->direct_handler_to_use;
+}
+
+static void load_handler (int reg, uae_u32 addr)
+{
+    mov_l_rm (reg, get_handler_address (addr));
+}
+
+/* This version assumes that it is writing *real* memory, and *will* fail
+ *  if that assumption is wrong! No branches, no second chances, just
+ *  straight go-for-it attitude */
+
+static void writemem_real (int address, int source, int offset, int size, int tmp, int clobber)
+{
+    int f = tmp;
+
+#ifdef NATMEM_OFFSET
+    if (canbang) {		/* Woohoo! go directly at the memory! */
+	if (clobber)
+	    f = source;
+	switch (size) {
+	case 1:
+	    use_gs_seg = 1;
+	    mov_b_bRr (address, source, GS_NATMEM_OFFSET);
+	    break;
+	case 2:
+	    mov_w_rr (f, source);
+	    bswap_16 (f);
+	    use_gs_seg = 1;
+	    mov_w_bRr (address, f, GS_NATMEM_OFFSET);
+	    break;
+	case 4:
+	    mov_l_rr (f, source);
+	    bswap_32 (f);
+	    use_gs_seg = 1;
+	    mov_l_bRr (address, f, GS_NATMEM_OFFSET);
+	    break;
+	}
+	use_gs_seg = 0;
+	forget_about (tmp);
+	forget_about (f);
+	return;
+    }
+#endif
+
+    mov_l_rr (f, address);
+    shrl_l_ri (f, 16);		/* The index into the baseaddr table */
+    mov_l_rm_indexed (f, (uae_u32) (baseaddr), f, 4);
+
+    if (address == source && size > 1) {	/* IBrowse does this! */
+	add_l (f, address);	/* f now has the final address */
+	switch (size) {
+	case 2:
+	    bswap_16 (source);
+	    mov_w_Rr (f, source, 0);
+	    bswap_16 (source);
+	    break;
+	case 4:
+	    bswap_32 (source);
+	    mov_l_Rr (f, source, 0);
+	    bswap_32 (source);
+	    break;
+	}
+    } else {
+	/* f now holds the offset */
+	switch (size) {
+	case 1:
+	    mov_b_mrr_indexed (address, f, 1, source);
+	    break;
+	case 2:
+	    bswap_16 (source);
+	    mov_w_mrr_indexed (address, f, 1, source);
+	    bswap_16 (source);
+	    break;
+	case 4:
+	    bswap_32 (source);
+	    mov_l_mrr_indexed (address, f, 1, source);
+	    bswap_32 (source);
+	    break;
+	}
+    }
+}
+
+static __inline__ void writemem (int address, int source, int offset, int size, int tmp)
+{
+    int f = tmp;
+
+    mov_l_rr (f, address);
+    shrl_l_ri (f, 16);		/* The index into the mem bank table */
+    mov_l_rm_indexed (f, (uae_u32) mem_banks, f, 4);
+    /* Now f holds a pointer to the actual membank */
+    mov_l_rR (f, f, offset);
+    /* Now f holds the address of the b/w/lput function */
+    call_r_02 (f, address, source, 4, size);
+    forget_about (tmp);
+}
+
+void writebyte (int address, int source, int tmp)
+{
+    int distrust;
+    switch (currprefs.comptrustbyte) {
+    case 0:
+	distrust = 0;
+	break;
+    case 1:
+	distrust = 1;
+	break;
+    case 2:
+	distrust = ((start_pc & 0xF80000) == 0xF80000);
+	break;
+    case 3:
+	distrust = !have_done_picasso;
+	break;
+    default:
+	abort ();
+    }
+
+    if ((special_mem & S_WRITE) || distrust)
+	writemem_special (address, source, 20, 1, tmp);
+    else
+	writemem_real (address, source, 20, 1, tmp, 0);
+}
+
+static __inline__ void writeword_general (int address, int source, int tmp, int clobber)
+{
+    int distrust;
+    switch (currprefs.comptrustword) {
+    case 0:
+	distrust = 0;
+	break;
+    case 1:
+	distrust = 1;
+	break;
+    case 2:
+	distrust = ((start_pc & 0xF80000) == 0xF80000);
+	break;
+    case 3:
+	distrust = !have_done_picasso;
+	break;
+    default:
+	abort ();
+    }
+
+    if ((special_mem & S_WRITE) || distrust)
+	writemem_special (address, source, 16, 2, tmp);
+    else
+	writemem_real (address, source, 16, 2, tmp, clobber);
+}
+
+void writeword_clobber (int address, int source, int tmp)
+{
+    writeword_general (address, source, tmp, 1);
+}
+
+void writeword (int address, int source, int tmp)
+{
+    writeword_general (address, source, tmp, 0);
+}
+
+static __inline__ void writelong_general (int address, int source, int tmp, int clobber)
+{
+    int distrust;
+    switch (currprefs.comptrustlong) {
+    case 0:
+	distrust = 0;
+	break;
+    case 1:
+	distrust = 1;
+	break;
+    case 2:
+	distrust = ((start_pc & 0xF80000) == 0xF80000);
+	break;
+    case 3:
+	distrust = !have_done_picasso;
+	break;
+    default:
+	abort ();
+    }
+
+    if ((special_mem & S_WRITE) || distrust)
+	writemem_special (address, source, 12, 4, tmp);
+    else
+	writemem_real (address, source, 12, 4, tmp, clobber);
+}
+
+void writelong_clobber (int address, int source, int tmp)
+{
+    writelong_general (address, source, tmp, 1);
+}
+
+void writelong (int address, int source, int tmp)
+{
+    writelong_general (address, source, tmp, 0);
+}
+
+/* This version assumes that it is reading *real* memory, and *will* fail
+ *  if that assumption is wrong! No branches, no second chances, just
+ *  straight go-for-it attitude */
+
+static void readmem_real (int address, int dest, int offset, int size, int tmp)
+{
+    int f = tmp;
+
+    if (size == 4 && address != dest)
+	f = dest;
+
+#ifdef NATMEM_OFFSET
+    if (canbang) {		/* Woohoo! go directly at the memory! */
+	switch (size) {
+	case 1:
+	    use_gs_seg = 1;
+	    mov_b_brR (dest, address, GS_NATMEM_OFFSET);
+	    break;
+	case 2:
+	    use_gs_seg = 1;
+	    mov_w_brR (dest, address, GS_NATMEM_OFFSET);
+	    bswap_16 (dest);
+	    break;
+	case 4:
+	    use_gs_seg = 1;
+	    mov_l_brR (dest, address, GS_NATMEM_OFFSET);
+	    bswap_32 (dest);
+	    break;
+	}
+	use_gs_seg = 0;
+
+	forget_about (tmp);
+	return;
+    }
+#endif
+
+    mov_l_rr (f, address);
+    shrl_l_ri (f, 16);		/* The index into the baseaddr table */
+    mov_l_rm_indexed (f, (uae_u32) baseaddr, f, 4);
+    /* f now holds the offset */
+
+    switch (size) {
+    case 1:
+	mov_b_rrm_indexed (dest, address, f, 1);
+	break;
+    case 2:
+	mov_w_rrm_indexed (dest, address, f, 1);
+	bswap_16 (dest);
+	break;
+    case 4:
+	mov_l_rrm_indexed (dest, address, f, 1);
+	bswap_32 (dest);
+	break;
+    }
+    forget_about (tmp);
+}
+
+static __inline__ void readmem (int address, int dest, int offset, int size, int tmp)
+{
+    int f = tmp;
+
+    mov_l_rr (f, address);
+    shrl_l_ri (f, 16);		/* The index into the mem bank table */
+    mov_l_rm_indexed (f, (uae_u32) mem_banks, f, 4);
+    /* Now f holds a pointer to the actual membank */
+    mov_l_rR (f, f, offset);
+    /* Now f holds the address of the b/w/lget function */
+    call_r_11 (dest, f, address, size, 4);
+    forget_about (tmp);
+}
+
+void readbyte (int address, int dest, int tmp)
+{
+    int distrust;
+    switch (currprefs.comptrustbyte) {
+    case 0:
+	distrust = 0;
+	break;
+    case 1:
+	distrust = 1;
+	break;
+    case 2:
+	distrust = ((start_pc & 0xF80000) == 0xF80000);
+	break;
+    case 3:
+	distrust = !have_done_picasso;
+	break;
+    default:
+	abort ();
+    }
+
+    if ((special_mem & S_READ) || distrust)
+	readmem_special (address, dest, 8, 1, tmp);
+    else
+	readmem_real (address, dest, 8, 1, tmp);
+}
+
+void readword (int address, int dest, int tmp)
+{
+    int distrust;
+    switch (currprefs.comptrustword) {
+    case 0:
+	distrust = 0;
+	break;
+    case 1:
+	distrust = 1;
+	break;
+    case 2:
+	distrust = ((start_pc & 0xF80000) == 0xF80000);
+	break;
+    case 3:
+	distrust = !have_done_picasso;
+	break;
+    default:
+	abort ();
+    }
+
+    if ((special_mem & S_READ) || distrust)
+	readmem_special (address, dest, 4, 2, tmp);
+    else
+	readmem_real (address, dest, 4, 2, tmp);
+}
+
+void readlong (int address, int dest, int tmp)
+{
+    int distrust;
+    switch (currprefs.comptrustlong) {
+    case 0:
+	distrust = 0;
+	break;
+    case 1:
+	distrust = 1;
+	break;
+    case 2:
+	distrust = ((start_pc & 0xF80000) == 0xF80000);
+	break;
+    case 3:
+	distrust = !have_done_picasso;
+	break;
+    default:
+	abort ();
+    }
+
+    if ((special_mem & S_READ) || distrust)
+	readmem_special (address, dest, 0, 4, tmp);
+    else
+	readmem_real (address, dest, 0, 4, tmp);
+}
+
+
+
+/* This one might appear a bit odd... */
+static __inline__ void get_n_addr_old (int address, int dest, int tmp)
+{
+    readmem (address, dest, 24, 4, tmp);
+}
+
+static __inline__ void get_n_addr_real (int address, int dest, int tmp)
+{
+    int f = tmp;
+    if (address != dest)
+	f = dest;
+
+#ifdef NATMEM_OFFSET
+    if (canbang) {
+	lea_l_brr (dest, address, GS_NATMEM_OFFSET);
+	forget_about (tmp);
+	return;
+    }
+#endif
+    mov_l_rr (f, address);
+    mov_l_rr (dest, address);	// gb-- nop if dest==address
+    shrl_l_ri (f, 16);
+    mov_l_rm_indexed (f, (uae_u32) baseaddr, f, 4);
+    add_l (dest, f);
+    forget_about (tmp);
+}
+
+void get_n_addr (int address, int dest, int tmp)
+{
+    int distrust;
+    switch (currprefs.comptrustnaddr) {
+    case 0:
+	distrust = 0;
+	break;
+    case 1:
+	distrust = 1;
+	break;
+    case 2:
+	distrust = ((start_pc & 0xF80000) == 0xF80000);
+	break;
+    case 3:
+	distrust = !have_done_picasso;
+	break;
+    default:
+	abort ();
+    }
+
+    if (special_mem || distrust)
+	get_n_addr_old (address, dest, tmp);
+    else
+	get_n_addr_real (address, dest, tmp);
+}
+
+void get_n_addr_jmp (int address, int dest, int tmp)
+{
+#if 0				/* For this, we need to get the same address as the rest of UAE
+				   would --- otherwise we end up translating everything twice */
+    get_n_addr (address, dest, tmp);
+#else
+    int f = tmp;
+    if (address != dest)
+	f = dest;
+    mov_l_rr (f, address);
+    shrl_l_ri (f, 16);		/* The index into the baseaddr bank table */
+    mov_l_rm_indexed (dest, (uae_u32) baseaddr, f, 4);
+    add_l (dest, address);
+    and_l_ri (dest, ~1);
+    forget_about (tmp);
+#endif
+}
+
+
+/* base is a register, but dp is an actual value. 
+   target is a register, as is tmp */
+void calc_disp_ea_020 (int base, uae_u32 dp, int target, int tmp)
+{
+    int reg = (dp >> 12) & 15;
+    int regd_shift = (dp >> 9) & 3;
+
+    if (dp & 0x100) {
+	int ignorebase = (dp & 0x80);
+	int ignorereg = (dp & 0x40);
+	int addbase = 0;
+	int outer = 0;
+
+	if ((dp & 0x30) == 0x20)
+	    addbase = (uae_s32) (uae_s16) comp_get_iword ((m68k_pc_offset += 2) - 2);
+	if ((dp & 0x30) == 0x30)
+	    addbase = comp_get_ilong ((m68k_pc_offset += 4) - 4);
+
+	if ((dp & 0x3) == 0x2)
+	    outer = (uae_s32) (uae_s16) comp_get_iword ((m68k_pc_offset += 2) - 2);
+	if ((dp & 0x3) == 0x3)
+	    outer = comp_get_ilong ((m68k_pc_offset += 4) - 4);
+
+	if ((dp & 0x4) == 0) {	/* add regd *before* the get_long */
+	    if (!ignorereg) {
+		if ((dp & 0x800) == 0)
+		    sign_extend_16_rr (target, reg);
+		else
+		    mov_l_rr (target, reg);
+		shll_l_ri (target, regd_shift);
+	    } else
+		mov_l_ri (target, 0);
+
+	    /* target is now regd */
+	    if (!ignorebase)
+		add_l (target, base);
+	    add_l_ri (target, addbase);
+	    if (dp & 0x03)
+		readlong (target, target, tmp);
+	} else {		/* do the getlong first, then add regd */
+	    if (!ignorebase) {
+		mov_l_rr (target, base);
+		add_l_ri (target, addbase);
+	    } else
+		mov_l_ri (target, addbase);
+	    if (dp & 0x03)
+		readlong (target, target, tmp);
+
+	    if (!ignorereg) {
+		if ((dp & 0x800) == 0)
+		    sign_extend_16_rr (tmp, reg);
+		else
+		    mov_l_rr (tmp, reg);
+		shll_l_ri (tmp, regd_shift);
+		/* tmp is now regd */
+		add_l (target, tmp);
+	    }
+	}
+	add_l_ri (target, outer);
+    } else {			/* 68000 version */
+	if ((dp & 0x800) == 0) {	/* Sign extend */
+	    sign_extend_16_rr (target, reg);
+	    lea_l_brr_indexed (target, base, target, 1 << regd_shift, (uae_s32) ((uae_s8) dp));
+	} else {
+	    lea_l_brr_indexed (target, base, reg, 1 << regd_shift, (uae_s32) ((uae_s8) dp));
+	}
+    }
+    forget_about (tmp);
+}
+
+static __inline__ unsigned int cft_map (unsigned int f)
+{
+    return ((f >> 8) & 255) | ((f & 255) << 8);
+}
+
+void set_cache_state (int enabled)
+{
+    if (enabled != letit)
+	flush_icache_hard (77);
+    letit = enabled;
+}
+
+int get_cache_state (void)
+{
+    return letit;
+}
+
+uae_u32 get_jitted_size (void)
+{
+    if (compiled_code)
+	return current_compile_p - compiled_code;
+    return 0;
+}
+
+void alloc_cache (void)
+{
+    if (compiled_code) {
+	flush_icache_hard (6);
+	free (compiled_code);
+    }
+    compiled_code = NULL;
+    if (currprefs.cachesize == 0)
+	return;
+
+    while (!compiled_code && currprefs.cachesize) {
+	compiled_code = malloc (currprefs.cachesize * 1024);
+	if (!compiled_code)
+	    currprefs.cachesize /= 2;
+    }
+    if (compiled_code) {
+	mprotect (compiled_code, currprefs.cachesize * 1024, PROT_READ | PROT_WRITE | PROT_EXEC);
+	max_compile_start = compiled_code + currprefs.cachesize * 1024 - BYTES_PER_INST;
+	current_compile_p = compiled_code;
+    }
+}
+
+extern unsigned long op_illg_1 (uae_u32 opcode) REGPARAM;
+
+static void calc_checksum (blockinfo * bi, uae_u32 * c1, uae_u32 * c2)
+{
+    uae_u32 k1 = 0;
+    uae_u32 k2 = 0;
+    uae_s32 len = bi->len;
+    uae_u32 tmp = bi->min_pcp;
+    uae_u32 *pos;
+
+    len += (tmp & 3);
+    tmp &= (~3);
+    pos = (uae_u32 *) tmp;
+
+    if (len < 0 || len > MAX_CHECKSUM_LEN) {
+	*c1 = 0;
+	*c2 = 0;
+    } else {
+	while (len > 0) {
+	    k1 += *pos;
+	    k2 ^= *pos;
+	    pos++;
+	    len -= 4;
+	}
+	*c1 = k1;
+	*c2 = k2;
+    }
+}
+
+static void show_checksum (blockinfo * bi)
+{
+    uae_u32 k1 = 0;
+    uae_u32 k2 = 0;
+    uae_s32 len = bi->len;
+    uae_u32 tmp = (uae_u32) bi->pc_p;
+    uae_u32 *pos;
+
+    len += (tmp & 3);
+    tmp &= (~3);
+    pos = (uae_u32 *) tmp;
+
+    if (len < 0 || len > MAX_CHECKSUM_LEN) {
+	return;
+    } else {
+	while (len > 0) {
+	    printf ("%08x ", *pos);
+	    pos++;
+	    len -= 4;
+	}
+	printf (" bla\n");
+    }
+}
+
+
+int check_for_cache_miss (void)
+{
+    blockinfo *bi = get_blockinfo_addr (regs.pc_p);
+
+    if (bi) {
+	int cl = cacheline (regs.pc_p);
+	if (bi != cache_tags[cl + 1].bi) {
+	    raise_in_cl_list (bi);
+	    return 1;
+	}
+    }
+    return 0;
+}
+
+
+static void recompile_block (void)
+{
+    /* An existing block's countdown code has expired. We need to make
+       sure that execute_normal doesn't refuse to recompile due to a
+       perceived cache miss... */
+    blockinfo *bi = get_blockinfo_addr (regs.pc_p);
+
+    Dif (!bi)
+	abort ();
+    raise_in_cl_list (bi);
+    execute_normal ();
+    return;
+}
+
+static void cache_miss (void)
+{
+    blockinfo *bi = get_blockinfo_addr (regs.pc_p);
+    uae_u32 cl = cacheline (regs.pc_p);
+    blockinfo *bi2 = get_blockinfo (cl);
+
+    if (!bi) {
+	execute_normal ();	/* Compile this block now */
+	return;
+    }
+    Dif (!bi2 || bi == bi2) {
+	fprintf (stderr, "Unexplained cache miss %p %p\n", bi, bi2);
+	abort ();
+    }
+    raise_in_cl_list (bi);
+    return;
+}
+
+static void check_checksum (void)
+{
+    blockinfo *bi = get_blockinfo_addr (regs.pc_p);
+    uae_u32 cl = cacheline (regs.pc_p);
+    blockinfo *bi2 = get_blockinfo (cl);
+
+    uae_u32 c1, c2;
+
+    checksum_count++;
+    /* These are not the droids you are looking for...  */
+    if (!bi) {
+	/* Whoever is the primary target is in a dormant state, but
+	   calling it was accidental, and we should just compile this
+	   new block */
+	execute_normal ();
+	return;
+    }
+    if (bi != bi2) {
+	/* The block was hit accidentally, but it does exist. Cache miss */
+	cache_miss ();
+	return;
+    }
+
+    if (bi->c1 || bi->c2)
+	calc_checksum (bi, &c1, &c2);
+    else {
+	c1 = c2 = 1;		/* Make sure it doesn't match */
+    }
+    if (c1 == bi->c1 && c2 == bi->c2) {
+	/* This block is still OK. So we reactivate. Of course, that
+	   means we have to move it into the needs-to-be-flushed list */
+	bi->handler_to_use = bi->handler;
+	set_dhtu (bi, bi->direct_handler);
+
+	/*      printf("reactivate %p/%p (%x %x/%x %x)\n",bi,bi->pc_p,
+	   c1,c2,bi->c1,bi->c2); */
+	remove_from_list (bi);
+	add_to_active (bi);
+	raise_in_cl_list (bi);
+    } else {
+	/* This block actually changed. We need to invalidate it,
+	   and set it up to be recompiled */
+	/* printf("discard %p/%p (%x %x/%x %x)\n",bi,bi->pc_p,
+	   c1,c2,bi->c1,bi->c2); */
+	invalidate_block (bi);
+	raise_in_cl_list (bi);
+	execute_normal ();
+    }
+}
+
+
+static uae_u8 popallspace[1024];	/* That should be enough space */
+
+static __inline__ void create_popalls (void)
+{
+    int i, r;
+
+    current_compile_p = popallspace;
+    set_target (current_compile_p);
+#if USE_PUSH_POP
+    /* If we can't use gcc inline assembly, we need to pop some
+       registers before jumping back to the various get-out routines.
+       This generates the code for it.
+     */
+    popall_do_nothing = current_compile_p;
+    for (i = 0; i < N_REGS; i++) {
+	if (need_to_preserve[i])
+	    raw_pop_l_r (i);
+    }
+    raw_jmp ((uae_u32) do_nothing);
+    align_target (32);
+
+    popall_execute_normal = get_target ();
+    for (i = 0; i < N_REGS; i++) {
+	if (need_to_preserve[i])
+	    raw_pop_l_r (i);
+    }
+    raw_jmp ((uae_u32) execute_normal);
+    align_target (32);
+
+    popall_cache_miss = get_target ();
+    for (i = 0; i < N_REGS; i++) {
+	if (need_to_preserve[i])
+	    raw_pop_l_r (i);
+    }
+    raw_jmp ((uae_u32) cache_miss);
+    align_target (32);
+
+    popall_recompile_block = get_target ();
+    for (i = 0; i < N_REGS; i++) {
+	if (need_to_preserve[i])
+	    raw_pop_l_r (i);
+    }
+    raw_jmp ((uae_u32) recompile_block);
+    align_target (32);
+
+    popall_exec_nostats = get_target ();
+    for (i = 0; i < N_REGS; i++) {
+	if (need_to_preserve[i])
+	    raw_pop_l_r (i);
+    }
+    raw_jmp ((uae_u32) exec_nostats);
+    align_target (32);
+
+    popall_check_checksum = get_target ();
+    for (i = 0; i < N_REGS; i++) {
+	if (need_to_preserve[i])
+	    raw_pop_l_r (i);
+    }
+    raw_jmp ((uae_u32) check_checksum);
+    align_target (32);
+
+    current_compile_p = get_target ();
+#else
+    popall_exec_nostats = exec_nostats;
+    popall_execute_normal = execute_normal;
+    popall_cache_miss = cache_miss;
+    popall_recompile_block = recompile_block;
+    popall_do_nothing = do_nothing;
+    popall_check_checksum = check_checksum;
+#endif
+
+    /* And now, the code to do the matching pushes and then jump
+       into a handler routine */
+    pushall_call_handler = get_target ();
+#if USE_PUSH_POP
+    for (i = N_REGS; i--;) {
+	if (need_to_preserve[i])
+	    raw_push_l_r (i);
+    }
+#endif
+    r = REG_PC_TMP;
+    raw_mov_l_rm (r, (uae_u32) & regs.pc_p);
+    raw_and_l_ri (r, TAGMASK);
+    raw_jmp_m_indexed ((uae_u32) cache_tags, r, 4);
+}
+
+static __inline__ void reset_lists (void)
+{
+    int i;
+
+    for (i = 0; i < MAX_HOLD_BI; i++)
+	hold_bi[i] = NULL;
+    active = NULL;
+    dormant = NULL;
+}
+
+static void prepare_block (blockinfo * bi)
+{
+    int i;
+
+    set_target (current_compile_p);
+    align_target (32);
+    bi->direct_pen = (void *) get_target ();
+    raw_mov_l_rm (0, (uae_u32) & (bi->pc_p));
+    raw_mov_l_mr ((uae_u32) & regs.pc_p, 0);
+    raw_jmp ((uae_u32) popall_execute_normal);
+
+    align_target (32);
+    bi->direct_pcc = (void *) get_target ();
+    raw_mov_l_rm (0, (uae_u32) & (bi->pc_p));
+    raw_mov_l_mr ((uae_u32) & regs.pc_p, 0);
+    raw_jmp ((uae_u32) popall_check_checksum);
+
+    align_target (32);
+    current_compile_p = get_target ();
+
+    bi->deplist = NULL;
+    for (i = 0; i < 2; i++) {
+	bi->dep[i].prev_p = NULL;
+	bi->dep[i].next = NULL;
+    }
+    bi->env = default_ss;
+    bi->status = BI_NEW;
+    bi->havestate = 0;
+    //bi->env=empty_ss;
+}
+
+void compemu_reset (void)
+{
+    int i;
+
+    set_cache_state (0);
+}
+
+void build_comp (void)
+{
+    int i;
+    int jumpcount = 0;
+    unsigned long opcode;
+    struct cputbl *tbl = op_smalltbl_0_comp_ff;
+    struct cputbl *nftbl = op_smalltbl_0_comp_nf;
+    int count;
+#ifdef NOFLAGS_SUPPORT
+    struct cputbl *nfctbl = (currprefs.cpu_level == 4 ? op_smalltbl_0_nf
+			     : currprefs.cpu_level == 3 ? op_smalltbl_1_nf
+			     : currprefs.cpu_level == 2 ? op_smalltbl_2_nf
+			     : currprefs.cpu_level == 1 ? op_smalltbl_3_nf
+			     : !currprefs.cpu_compatible ? op_smalltbl_4_nf : op_smalltbl_5_nf);
+#endif
+    raw_init_cpu ();
+#ifdef NATMEM_OFFSET
+    write_log ("Setting signal handler\n");
+#ifndef _WIN32
+    signal (SIGSEGV, segfault_vec);
+#endif
+#endif
+    write_log ("Building Compiler function table\n");
+    for (opcode = 0; opcode < 65536; opcode++) {
+#ifdef NOFLAGS_SUPPORT
+	nfcpufunctbl[opcode] = op_illg_1;
+#endif
+	compfunctbl[opcode] = NULL;
+	nfcompfunctbl[opcode] = NULL;
+	prop[opcode].use_flags = 0x1f;
+	prop[opcode].set_flags = 0x1f;
+	prop[opcode].is_jump = 1;
+    }
+
+    for (i = 0; tbl[i].opcode < 65536; i++) {
+	int isjmp = (tbl[i].specific & 1);
+	int isaddx = (tbl[i].specific & 8);
+	int iscjmp = (tbl[i].specific & 16);
+
+	prop[tbl[i].opcode].is_jump = isjmp;
+	prop[tbl[i].opcode].is_const_jump = iscjmp;
+	prop[tbl[i].opcode].is_addx = isaddx;
+	compfunctbl[tbl[i].opcode] = tbl[i].handler;
+    }
+    for (i = 0; nftbl[i].opcode < 65536; i++) {
+	nfcompfunctbl[nftbl[i].opcode] = nftbl[i].handler;
+#ifdef NOFLAGS_SUPPORT
+	nfcpufunctbl[nftbl[i].opcode] = nfctbl[i].handler;
+#endif
+    }
+
+#ifdef NOFLAGS_SUPPORT
+    for (i = 0; nfctbl[i].handler; i++) {
+	nfcpufunctbl[nfctbl[i].opcode] = nfctbl[i].handler;
+    }
+#endif
+
+    for (opcode = 0; opcode < 65536; opcode++) {
+	cpuop_func *f;
+	cpuop_func *nff;
+#ifdef NOFLAGS_SUPPORT
+	cpuop_func *nfcf;
+#endif
+	int isjmp, isaddx, iscjmp;
+
+	if (table68k[opcode].mnemo == i_ILLG || table68k[opcode].clev > currprefs.cpu_level)
+	    continue;
+
+	if (table68k[opcode].handler != -1) {
+	    f = compfunctbl[table68k[opcode].handler];
+	    nff = nfcompfunctbl[table68k[opcode].handler];
+#ifdef NOFLAGS_SUPPORT
+	    nfcf = nfcpufunctbl[table68k[opcode].handler];
+#endif
+	    isjmp = prop[table68k[opcode].handler].is_jump;
+	    iscjmp = prop[table68k[opcode].handler].is_const_jump;
+	    isaddx = prop[table68k[opcode].handler].is_addx;
+	    prop[opcode].is_jump = isjmp;
+	    prop[opcode].is_const_jump = iscjmp;
+	    prop[opcode].is_addx = isaddx;
+	    compfunctbl[opcode] = f;
+	    nfcompfunctbl[opcode] = nff;
+#ifdef NOFLAGS_SUPPORT
+	    Dif (nfcf == op_illg_1)
+		abort ();
+	    nfcpufunctbl[opcode] = nfcf;
+#endif
+	}
+	prop[opcode].set_flags = table68k[opcode].flagdead;
+	prop[opcode].use_flags = table68k[opcode].flaglive;
+	/* Unconditional jumps don't evaluate condition codes, so they
+	   don't actually use any flags themselves */
+	if (prop[opcode].is_const_jump)
+	    prop[opcode].use_flags = 0;
+    }
+#ifdef NOFLAGS_SUPPORT
+    for (i = 0; nfctbl[i].handler != NULL; i++) {
+	if (nfctbl[i].specific)
+	    nfcpufunctbl[tbl[i].opcode] = nfctbl[i].handler;
+    }
+#endif
+
+    count = 0;
+    for (opcode = 0; opcode < 65536; opcode++) {
+	if (compfunctbl[opcode])
+	    count++;
+    }
+    fprintf (stderr, "Supposedly %d compileable opcodes!\n", count);
+
+    /* Initialise state */
+    create_popalls ();
+    alloc_cache ();
+    reset_lists ();
+
+    for (i = 0; i < TAGSIZE; i += 2) {
+	cache_tags[i].handler = (void *) popall_execute_normal;
+	cache_tags[i + 1].bi = NULL;
+    }
+    compemu_reset ();
+
+    for (i = 0; i < N_REGS; i++) {
+	empty_ss.nat[i].holds = -1;
+	empty_ss.nat[i].validsize = 0;
+	empty_ss.nat[i].dirtysize = 0;
+    }
+    default_ss = empty_ss;
+#if 0
+    default_ss.nat[6].holds = 11;
+    default_ss.nat[6].validsize = 4;
+    default_ss.nat[5].holds = 12;
+    default_ss.nat[5].validsize = 4;
+#endif
+}
+
+
+static void flush_icache_hard (int n)
+{
+    uae_u32 i;
+    blockinfo *bi;
+
+    hard_flush_count++;
+#if 0
+    printf ("Flush Icache_hard(%d/%x/%p), %u instruction bytes\n", n, regs.pc, regs.pc_p, current_compile_p - compiled_code);
+#endif
+    bi = active;
+    while (bi) {
+	cache_tags[cacheline (bi->pc_p)].handler = (void *) popall_execute_normal;
+	cache_tags[cacheline (bi->pc_p) + 1].bi = NULL;
+	bi = bi->next;
+    }
+    bi = dormant;
+    while (bi) {
+	cache_tags[cacheline (bi->pc_p)].handler = (void *) popall_execute_normal;
+	cache_tags[cacheline (bi->pc_p) + 1].bi = NULL;
+	bi = bi->next;
+    }
+
+    reset_lists ();
+    if (!compiled_code)
+	return;
+    current_compile_p = compiled_code;
+    set_special (0);		/* To get out of compiled code */
+}
+
+
+/* "Soft flushing" --- instead of actually throwing everything away,
+   we simply mark everything as "needs to be checked". 
+*/
+
+void flush_icache (int n)
+{
+    uae_u32 i;
+    blockinfo *bi;
+    blockinfo *bi2;
+
+    if (currprefs.comp_hardflush) {
+	flush_icache_hard (n);
+	return;
+    }
+    soft_flush_count++;
+    if (!active)
+	return;
+
+    bi = active;
+    while (bi) {
+	uae_u32 cl = cacheline (bi->pc_p);
+	if (!bi->handler) {
+	    /* invalidated block */
+	    if (bi == cache_tags[cl + 1].bi)
+		cache_tags[cl].handler = popall_execute_normal;
+	    bi->handler_to_use = popall_execute_normal;
+	    set_dhtu (bi, bi->direct_pen);
+	} else {
+	    if (bi == cache_tags[cl + 1].bi)
+		cache_tags[cl].handler = popall_check_checksum;
+	    bi->handler_to_use = popall_check_checksum;
+	    set_dhtu (bi, bi->direct_pcc);
+	}
+	bi2 = bi;
+	bi = bi->next;
+    }
+    /* bi2 is now the last entry in the active list */
+    bi2->next = dormant;
+    if (dormant)
+	dormant->prev_p = &(bi2->next);
+
+    dormant = active;
+    active->prev_p = &dormant;
+    active = NULL;
+}
+
+
+static void catastrophe (void)
+{
+    abort ();
+}
+
+int failure;
+
+static int *pa, *pb;
+
+static void foobar (void *a, void *b)
+{
+    /* breakpoint me! */
+    pa = a; pb = b;
+}
+
+void compile_block (cpu_history * pc_hist, int blocklen, int totcycles)
+{
+    if (letit && compiled_code && currprefs.cpu_level >= 2) {
+
+	/* OK, here we need to 'compile' a block */
+	int i;
+	int r;
+	int was_comp = 0;
+	uae_u8 liveflags[MAXRUN + 1];
+	uae_u32 max_pcp = (uae_u32) pc_hist[0].location;
+	uae_u32 min_pcp = max_pcp;
+	uae_u32 cl = cacheline (pc_hist[0].location);
+	void *specflags = (void *) &regs.spcflags;
+	blockinfo *bi = NULL;
+	blockinfo *bi2;
+	int extra_len = 0;
+
+	compile_count++;
+	if (current_compile_p >= max_compile_start)
+	    flush_icache_hard (7);
+
+	alloc_blockinfos ();
+
+	bi = get_blockinfo_addr_new (pc_hist[0].location, 0);
+	bi2 = get_blockinfo (cl);
+
+	optlev = bi->optlevel;
+	if (bi->handler) {
+	    Dif (bi != bi2) {
+		/* I don't think it can happen anymore. Shouldn't, in 
+		   any case. So let's make sure... */
+		printf ("WOOOWOO count=%d, ol=%d %p %p\n", bi->count, bi->optlevel, bi->handler_to_use, cache_tags[cl].handler);
+		abort ();
+	    }
+
+	    Dif (bi->count != -1 && bi->status != BI_TARGETTED) {
+		/* What the heck? We are not supposed to be here! */
+		abort ();
+	    }
+	}
+	if (bi->count == -1) {
+	    optlev++;
+	    while (!currprefs.optcount[optlev])
+		optlev++;
+	    bi->count = currprefs.optcount[optlev] - 1;
+	}
+	current_block_pc_p = (uae_u32) pc_hist[0].location;
+
+	remove_deps (bi);	/* We are about to create new code */
+	bi->optlevel = optlev;
+	bi->pc_p = (uae_u8 *) pc_hist[0].location;
+
+	liveflags[blocklen] = 0x1f;	/* All flags needed afterwards */
+	i = blocklen;
+	while (i--) {
+	    uae_u16 *currpcp = pc_hist[i].location;
+	    int op = cft_map (*currpcp);
+
+	    if ((uae_u32) currpcp < min_pcp)
+		min_pcp = (uae_u32) currpcp;
+	    if ((uae_u32) currpcp > max_pcp)
+		max_pcp = (uae_u32) currpcp;
+
+	    if (currprefs.compnf) {
+		liveflags[i] = ((liveflags[i + 1] & (~prop[op].set_flags)) | prop[op].use_flags);
+		if (prop[op].is_addx && (liveflags[i + 1] & FLAG_Z) == 0)
+		    liveflags[i] &= ~FLAG_Z;
+	    } else {
+		liveflags[i] = 0x1f;
+	    }
+	}
+
+	bi->needed_flags = liveflags[0];
+
+	/* This is the non-direct handler */
+	align_target (32);
+	set_target (get_target () + 1);
+	align_target (16);
+	/* Now aligned at n*32+16 */
+
+	bi->handler = bi->handler_to_use = (void *) get_target ();
+	raw_cmp_l_mi ((uae_u32) & regs.pc_p, (uae_u32) pc_hist[0].location);
+	raw_jnz ((uae_u32) popall_cache_miss);
+	/* This was 16 bytes on the x86, so now aligned on (n+1)*32 */
+
+	was_comp = 0;
+
+#if USE_MATCHSTATE
+	comp_pc_p = (uae_u8 *) pc_hist[0].location;
+	init_comp ();
+	match_states (&(bi->env));
+	was_comp = 1;
+#endif
+
+	bi->direct_handler = (void *) get_target ();
+	set_dhtu (bi, bi->direct_handler);
+	current_block_start_target = (uae_u32) get_target ();
+
+	if (bi->count >= 0) {	/* Need to generate countdown code */
+	    raw_mov_l_mi ((uae_u32) & regs.pc_p, (uae_u32) pc_hist[0].location);
+	    raw_sub_l_mi ((uae_u32) & (bi->count), 1);
+	    raw_jl ((uae_u32) popall_recompile_block);
+	}
+	if (optlev == 0) {	/* No need to actually translate */
+	    /* Execute normally without keeping stats */
+	    raw_mov_l_mi ((uae_u32) & regs.pc_p, (uae_u32) pc_hist[0].location);
+	    raw_jmp ((uae_u32) popall_exec_nostats);
+	} else {
+	    reg_alloc_run = 0;
+	    next_pc_p = 0;
+	    taken_pc_p = 0;
+	    branch_cc = 0;
+
+	    log_startblock ();
+	    for (i = 0; i < blocklen && get_target_noopt () < max_compile_start; i++) {
+		cpuop_func **cputbl;
+		cpuop_func **comptbl;
+		uae_u16 opcode;
+
+		opcode = cft_map ((uae_u16) * pc_hist[i].location);
+		special_mem = pc_hist[i].specmem;
+		needed_flags = (liveflags[i + 1] & prop[opcode].set_flags);
+		if (!needed_flags && currprefs.compnf) {
+#ifdef NOFLAGS_SUPPORT
+		    cputbl = nfcpufunctbl;
+#else
+		    cputbl = cpufunctbl;
+#endif
+		    comptbl = nfcompfunctbl;
+		} else {
+		    cputbl = cpufunctbl;
+		    comptbl = compfunctbl;
+		}
+
+		if (comptbl[opcode] && optlev > 1) {
+		    failure = 0;
+		    if (!was_comp) {
+			comp_pc_p = (uae_u8 *) pc_hist[i].location;
+			init_comp ();
+		    }
+		    was_comp++;
+
+		    comptbl[opcode] (opcode);
+		    freescratch ();
+		    if (!(liveflags[i + 1] & FLAG_CZNV)) {
+			/* We can forget about flags */
+			dont_care_flags ();
+		    }
+#if INDIVIDUAL_INST
+		    flush (1);
+		    nop ();
+		    flush (1);
+		    was_comp = 0;
+#endif
+		} else
+		    failure = 1;
+		if (failure) {
+		    if (was_comp) {
+			flush (1);
+			was_comp = 0;
+		    }
+		    raw_mov_l_ri (REG_PAR1, (uae_u32) opcode);
+#if USE_NORMAL_CALLING_CONVENTION
+		    raw_push_l_r (REG_PAR1);
+#endif
+		    raw_mov_l_mi ((uae_u32) & regs.pc_p, (uae_u32) pc_hist[i].location);
+		    raw_call ((uae_u32) cputbl[opcode]);
+		    //raw_add_l_mi((uae_u32)&oink,1); // FIXME
+#if USE_NORMAL_CALLING_CONVENTION
+		    raw_inc_sp (4);
+#endif
+		    if (needed_flags) {
+			//raw_mov_l_mi((uae_u32)&foink3,(uae_u32)opcode+65536);
+		    } else {
+			//raw_mov_l_mi((uae_u32)&foink3,(uae_u32)opcode);
+		    }
+
+		    if (i < blocklen - 1) {
+			uae_s8 *branchadd;
+
+			raw_mov_l_rm (0, (uae_u32) specflags);
+			raw_test_l_rr (0, 0);
+			raw_jz_b_oponly ();
+			branchadd = get_target ();
+			emit_byte (0);
+			raw_sub_l_mi ((uae_u32) & countdown, scaled_cycles (totcycles));
+			raw_jmp ((uae_u32) popall_do_nothing);
+			*branchadd = (uae_u32) get_target () - (uae_u32) branchadd - 1;
+		    }
+		}
+	    }
+#if 0				/* This isn't completely kosher yet; It really needs to be
+				   be integrated into a general inter-block-dependency scheme */
+	    if (next_pc_p && taken_pc_p && was_comp && taken_pc_p == current_block_pc_p) {
+		blockinfo *bi1 = get_blockinfo_addr_new ((void *) next_pc_p, 0);
+		blockinfo *bi2 = get_blockinfo_addr_new ((void *) taken_pc_p, 0);
+		uae_u8 x = bi1->needed_flags;
+
+		if (x == 0xff || 1) {	/* To be on the safe side */
+		    uae_u16 *next = (uae_u16 *) next_pc_p;
+		    uae_u16 op = cft_map (*next);
+
+		    x = 0x1f;
+		    x &= (~prop[op].set_flags);
+		    x |= prop[op].use_flags;
+		}
+
+		x |= bi2->needed_flags;
+		if (!(x & FLAG_CZNV)) {
+		    /* We can forget about flags */
+		    dont_care_flags ();
+		    extra_len += 2;	/* The next instruction now is part of this
+					   block */
+		}
+
+	    }
+#endif
+
+	    if (next_pc_p) {	/* A branch was registered */
+		uae_u32 t1 = next_pc_p;
+		uae_u32 t2 = taken_pc_p;
+		int cc = branch_cc;
+
+		uae_u32 *branchadd;
+		uae_u32 *tba;
+		bigstate tmp;
+		blockinfo *tbi;
+
+		if (taken_pc_p < next_pc_p) {
+		    /* backward branch. Optimize for the "taken" case ---
+		       which means the raw_jcc should fall through when
+		       the 68k branch is taken. */
+		    t1 = taken_pc_p;
+		    t2 = next_pc_p;
+		    cc = branch_cc ^ 1;
+		}
+#if !USE_MATCHSTATE
+		flush_keepflags ();
+#endif
+		tmp = live;	/* ouch! This is big... */
+		raw_jcc_l_oponly (cc);
+		branchadd = (uae_u32 *) get_target ();
+		emit_long (0);
+		/* predicted outcome */
+		tbi = get_blockinfo_addr_new ((void *) t1, 1);
+		match_states (&(tbi->env));
+		//flush(1); /* Can only get here if was_comp==1 */
+		raw_sub_l_mi ((uae_u32) & countdown, scaled_cycles (totcycles));
+		raw_jcc_l_oponly (9);
+		tba = (uae_u32 *) get_target ();
+		emit_long (get_handler (t1) - ((uae_u32) tba + 4));
+		raw_mov_l_mi ((uae_u32) & regs.pc_p, t1);
+		raw_jmp ((uae_u32) popall_do_nothing);
+		create_jmpdep (bi, 0, tba, t1);
+
+		align_target (16);
+		/* not-predicted outcome */
+		*branchadd = (uae_u32) get_target () - ((uae_u32) branchadd + 4);
+		live = tmp;	/* Ouch again */
+		tbi = get_blockinfo_addr_new ((void *) t2, 1);
+		match_states (&(tbi->env));
+
+		//flush(1); /* Can only get here if was_comp==1 */
+		raw_sub_l_mi ((uae_u32) & countdown, scaled_cycles (totcycles));
+		raw_jcc_l_oponly (9);
+		tba = (uae_u32 *) get_target ();
+		emit_long (get_handler (t2) - ((uae_u32) tba + 4));
+		raw_mov_l_mi ((uae_u32) & regs.pc_p, t2);
+		raw_jmp ((uae_u32) popall_do_nothing);
+		create_jmpdep (bi, 1, tba, t2);
+	    } else {
+		if (was_comp) {
+		    flush (1);
+		}
+
+		/* Let's find out where next_handler is... */
+		if (was_comp && isinreg (PC_P)) {
+		    int r2;
+
+		    r = live.state[PC_P].realreg;
+
+		    if (r == 0)
+			r2 = 1;
+		    else
+			r2 = 0;
+
+		    raw_and_l_ri (r, TAGMASK);
+		    raw_mov_l_ri (r2, (uae_u32) popall_do_nothing);
+		    raw_sub_l_mi ((uae_u32) & countdown, scaled_cycles (totcycles));
+		    raw_cmov_l_rm_indexed (r2, (uae_u32) cache_tags, r, 4, 9);
+		    raw_jmp_r (r2);
+		} else if (was_comp && isconst (PC_P)) {
+		    uae_u32 v = live.state[PC_P].val;
+		    uae_u32 *tba;
+		    blockinfo *tbi;
+
+		    tbi = get_blockinfo_addr_new ((void *) v, 1);
+		    match_states (&(tbi->env));
+
+		    raw_sub_l_mi ((uae_u32) & countdown, scaled_cycles (totcycles));
+		    raw_jcc_l_oponly (9);
+		    tba = (uae_u32 *) get_target ();
+		    emit_long (get_handler (v) - ((uae_u32) tba + 4));
+		    raw_mov_l_mi ((uae_u32) & regs.pc_p, v);
+		    raw_jmp ((uae_u32) popall_do_nothing);
+		    create_jmpdep (bi, 0, tba, v);
+		} else {
+		    int r2;
+
+		    r = REG_PC_TMP;
+		    raw_mov_l_rm (r, (uae_u32) & regs.pc_p);
+		    if (r == 0)
+			r2 = 1;
+		    else
+			r2 = 0;
+
+		    raw_and_l_ri (r, TAGMASK);
+		    raw_mov_l_ri (r2, (uae_u32) popall_do_nothing);
+		    raw_sub_l_mi ((uae_u32) & countdown, scaled_cycles (totcycles));
+		    raw_cmov_l_rm_indexed (r2, (uae_u32) cache_tags, r, 4, 9);
+		    raw_jmp_r (r2);
+		}
+	    }
+	    if (bi->len > 80)
+		foobar (bi->direct_handler, get_target ());
+	}
+
+	if (next_pc_p + extra_len >= max_pcp && next_pc_p + extra_len < max_pcp + LONGEST_68K_INST)
+	    max_pcp = next_pc_p + extra_len;	/* extra_len covers flags magic */
+	else
+	    max_pcp += LONGEST_68K_INST;
+	bi->len = max_pcp - min_pcp;
+	bi->min_pcp = min_pcp;
+
+	remove_from_list (bi);
+	if (isinrom (min_pcp) && isinrom (max_pcp))
+	    add_to_dormant (bi);	/* No need to checksum it on cache flush.
+					   Please don't start changing ROMs in
+					   flight! */
+	else {
+	    calc_checksum (bi, &(bi->c1), &(bi->c2));
+	    add_to_active (bi);
+	}
+
+	log_dump ();
+	align_target (32);
+	current_compile_p = get_target ();
+
+	raise_in_cl_list (bi);
+	bi->nexthandler = current_compile_p;
+
+	/* We will flush soon, anyway, so let's do it now */
+	if (current_compile_p >= max_compile_start)
+	    flush_icache_hard (7);
+
+	do_extra_cycles (totcycles);	/* for the compilation time */
+    }
+}
Index: src/custom.c
===================================================================
RCS file: /usr/local/cvs/uae/src/custom.c,v
retrieving revision 1.154
retrieving revision 1.153.2.3
diff -c -p -d -u -p -r1.154 -r1.153.2.3
--- src/custom.c	2002/02/16 14:18:13	1.154
+++ src/custom.c	2002/02/16 20:06:59	1.153.2.3
@@ -20,9 +20,9 @@
 #include "uae.h"
 #include "gensound.h"
 #include "sounddep/sound.h"
-#include "events.h"
 #include "memory.h"
 #include "custom.h"
+#include "events.h"
 #include "newcpu.h"
 #include "cia.h"
 #include "disk.h"
@@ -54,10 +54,14 @@ unsigned int joy0dir, joy1dir;
 /* Events */
 
 unsigned long int currcycle, nextevent, is_lastline;
+long cycles_to_next_event;
+long max_cycles_to_next_event;
+long cycles_to_hsync_event;
+
 static int rpt_did_reset;
 struct ev eventtab[ev_max];
 
-frame_time_t vsynctime, vsyncmintime;
+volatile frame_time_t vsynctime, vsyncmintime;
 
 static int vpos;
 static uae_u16 lof;
@@ -3643,28 +3647,53 @@ void init_hardware_for_drawing_frame (vo
 
 static void do_savestate(void);
 
-static void vsync_handler (void)
+#define N_LINES 8
+
+STATIC_INLINE int trigger_frh (int v)
 {
-#if 0
-    static int old_clxdat;
-    if (clxdat != old_clxdat) {
-	printf ("CLXDAT %04x\n", clxdat);
-	old_clxdat = clxdat;
-    }
-#endif
-    n_frames++;
+    return (v & (N_LINES - 1)) == 0;
+}
+
+extern int gonebad;
 
+static void frh_handler(void)
+{
     if (currprefs.m68k_speed == -1) {
 	frame_time_t curr_time = read_processor_time ();
-	vsyncmintime += vsynctime;
+#if 0
+	printf("now=%lu, target=%lu, diff=%ld\n", curr_time, vsyncmintime,
+	       diff32 (curr_time, vsyncmintime));
+#endif
+
+	vsyncmintime += vsynctime*N_LINES/625*2;
 	/* @@@ Mathias? How do you think we should do this? */
 	/* If we are too far behind, or we just did a reset, adjust the
 	 * needed time. */
-	if ((long int)(curr_time - vsyncmintime) > 0 || rpt_did_reset)
+	if (rpt_did_reset) {
 	    vsyncmintime = curr_time + vsynctime;
-	rpt_did_reset = 0;
+	    rpt_did_reset = 0;
+	}
+
+	/* Allow this to be one frame's worth of cycles out */
+	while (diff32 (curr_time, vsyncmintime + vsynctime) > 0) {
+	    vsyncmintime += vsynctime*N_LINES/625*2;
+	    gonebad++;
+ 	}
+    }
+}
+
+static void vsync_handler (void)
+{
+    static int count=50;
+    
+    if (--count == 0) {
+	int i;
+	count=50;
+	newcpu_showstate();
     }
 
+    n_frames++;
+
     handle_events ();
 
     getjoystate (0, &joy0dir, &joy0button);
@@ -3811,7 +3840,17 @@ static void hsync_handler (void)
 
     DISK_update ();
 
-    is_lastline = vpos + 1 == maxvpos + (lof != 0) && currprefs.m68k_speed == -1 && ! rpt_did_reset;
+    if (currprefs.m68k_speed == -1) {
+	static int count=0;
+
+	count++;
+	if (trigger_frh(count)) {
+	    frh_handler();
+	}
+	is_lastline = trigger_frh(count+1) && ! rpt_did_reset;
+    }
+    else
+	is_lastline=0;
 
     if ((bplcon0 & 4) && currprefs.gfx_linedbl)
 	notice_interlace_seen ();
@@ -3898,7 +3937,8 @@ void init_eventtab (void)
 {
     int i;
 
-    currcycle = 0;
+    nextevent = 0;
+    set_cycles (0);
     for (i = 0; i < ev_max; i++) {
 	eventtab[i].active = 0;
 	eventtab[i].oldcycles = 0;
@@ -3968,6 +4008,9 @@ void customreset (void)
 
     DISK_reset ();
     CIA_reset ();
+#ifdef JIT
+    compemu_reset ();
+#endif
     unset_special (~(SPCFLAG_BRK | SPCFLAG_MODE_CHANGE));
 
     vpos = 0;
@@ -3998,7 +4041,7 @@ void customreset (void)
     cop_state.state = COP_stop;
     diwstate = DIW_waiting_start;
     hdiwstate = DIW_waiting_start;
-    currcycle = 0;
+    set_cycles (0);
 
     new_beamcon0 = currprefs.ntscmode ? 0x00 : 0x20;
     init_hz ();
@@ -4076,8 +4119,8 @@ void dumpcustom (void)
     write_log ("DIWSTRT: %04x DIWSTOP: %04x DDFSTRT: %04x DDFSTOP: %04x\n",
 	       (unsigned int)diwstrt, (unsigned int)diwstop, (unsigned int)ddfstrt, (unsigned int)ddfstop);
     if (timeframes) {
-	write_log ("Average frame time: %d ms [frames: %d time: %d]\n",
-		   frametime / timeframes, timeframes, frametime);
+	write_log ("Average frame time: %f ms [frames: %d time: %d]\n",
+		   (double)frametime / timeframes, timeframes, frametime);
 	if (total_skipped)
 	    write_log ("Skipped frames: %d\n", total_skipped);
     }
Index: src/debug.c
===================================================================
RCS file: /usr/local/cvs/uae/src/debug.c,v
retrieving revision 1.27
retrieving revision 1.27.2.1
diff -c -p -d -u -p -r1.27 -r1.27.2.1
--- src/debug.c	2001/10/24 10:59:20	1.27
+++ src/debug.c	2002/02/06 15:09:18	1.27.2.1
@@ -19,6 +19,7 @@
 #include "uae.h"
 #include "memory.h"
 #include "custom.h"
+#include "events.h"
 #include "newcpu.h"
 #include "debug.h"
 #include "cia.h"
Index: src/disk.c
===================================================================
RCS file: /usr/local/cvs/uae/src/disk.c,v
retrieving revision 1.55
retrieving revision 1.55.2.1
diff -c -p -d -u -p -r1.55 -r1.55.2.1
--- src/disk.c	2002/01/31 14:09:52	1.55
+++ src/disk.c	2002/02/06 15:09:19	1.55.2.1
@@ -1155,7 +1155,7 @@ void DSKLEN (uae_u16 v, int hpos)
     {
 	int dr;
 	uaecptr pc = m68k_getpc ();
-	if ((pc & 0xF80000) != 0xF80000)
+	if ((munge24(pc) & 0xFFF80000) != 0xF80000)
 	    return;
 	for (dr = 0; dr < 4; dr++) {
 	    drive *drv = &floppy[dr];
Index: src/drawing.c
===================================================================
RCS file: /usr/local/cvs/uae/src/drawing.c,v
retrieving revision 1.42
retrieving revision 1.42.2.1
diff -c -p -d -u -p -r1.42 -r1.42.2.1
--- src/drawing.c	2002/01/31 15:14:41	1.42
+++ src/drawing.c	2002/02/06 15:09:19	1.42.2.1
@@ -38,12 +38,14 @@
 #include "uae.h"
 #include "memory.h"
 #include "custom.h"
+#include "events.h"
 #include "newcpu.h"
 #include "xwin.h"
 #include "autoconf.h"
 #include "gui.h"
 #include "picasso96.h"
 #include "drawing.h"
+#include "compemu.h"
 #include "savestate.h"
 
 int lores_factor, lores_shift;
@@ -1725,6 +1727,7 @@ void vsync_handle_redraw (int long_frame
 	check_picasso ();
 
 	check_prefs_changed_audio ();
+	check_prefs_changed_comp ();
 	check_prefs_changed_custom ();
 	check_prefs_changed_cpu ();
 	if (check_prefs_changed_gfx ()) {
Index: src/ersatz.c
===================================================================
RCS file: /usr/local/cvs/uae/src/ersatz.c,v
retrieving revision 1.13
retrieving revision 1.13.2.1
diff -c -p -d -u -p -r1.13 -r1.13.2.1
--- src/ersatz.c	2001/12/17 18:38:37	1.13
+++ src/ersatz.c	2002/02/06 15:09:19	1.13.2.1
@@ -15,6 +15,7 @@
 #include "uae.h"
 #include "memory.h"
 #include "custom.h"
+#include "events.h"
 #include "newcpu.h"
 #include "cia.h"
 #include "disk.h"
Index: src/fpp.c
===================================================================
RCS file: /usr/local/cvs/uae/src/fpp.c,v
retrieving revision 1.17
retrieving revision 1.17.2.1
diff -c -p -d -u -p -r1.17 -r1.17.2.1
--- src/fpp.c	2001/11/19 17:53:29	1.17
+++ src/fpp.c	2002/02/06 15:09:19	1.17.2.1
@@ -54,7 +54,7 @@ static __inline__ uae_s32 toint(fptype s
     return src; /* Should never be reached */
 }
 
-static uae_u32 get_fpsr (void) 
+uae_u32 get_fpsr (void) 
 {
     uae_u32 answer = regs.fpsr & 0x00ffffff;
 #ifdef HAVE_ISNAN
Index: src/fsdb.c
===================================================================
RCS file: /usr/local/cvs/uae/src/fsdb.c,v
retrieving revision 1.6
retrieving revision 1.6.2.1
diff -c -p -d -u -p -r1.6 -r1.6.2.1
--- src/fsdb.c	2001/09/07 11:41:50	1.6
+++ src/fsdb.c	2002/02/06 15:09:19	1.6.2.1
@@ -16,6 +16,7 @@
 #include "uae.h"
 #include "memory.h"
 #include "custom.h"
+#include "events.h"
 #include "newcpu.h"
 #include "filesys.h"
 #include "autoconf.h"
Index: src/gencomp.c
===================================================================
RCS file: gencomp.c
diff -N gencomp.c
--- /dev/null	Tue Oct  2 20:51:52 2001
+++ src/gencomp.c	Sat Feb 16 20:08:35 2002
@@ -0,0 +1,2977 @@
+/*
+ * UAE - The Un*x Amiga Emulator
+ *
+ * MC68000 compilation generator
+ *
+ * Based on work Copyright 1995, 1996 Bernd Schmidt. Changes Copyright 2000
+ * Bernd Meyer
+ */
+
+#include "sysconfig.h"
+#include "sysdeps.h"
+#include <ctype.h>
+
+#include "readcpu.h"
+
+#include <stdio.h>
+#include <stdarg.h>
+
+#define BOOL_TYPE "int"
+#define failure global_failure=1
+#define FAILURE global_failure=1
+#define isjump  global_isjump=1
+#define is_const_jump global_iscjump=1;
+#define isaddx  global_isaddx=1
+#define uses_cmov global_cmov=1
+#define mayfail global_mayfail=1
+
+int hack_opcode;
+
+static int global_failure;
+static int global_isjump;
+static int global_iscjump;
+static int global_isaddx;
+static int global_cmov;
+static int long_opcode;
+static int global_mayfail;
+
+static char endstr[1000];
+static char lines[100000];
+static int comp_index=0;
+
+static int cond_codes_x86[]={-1,-1,7,6,3,2,5,4,-1,-1,9,8,13,12,15,14};
+
+static void comprintf(const char* format, ...)
+{
+    va_list args;
+
+    va_start(args,format);
+    comp_index+=vsprintf(lines+comp_index,format,args);
+}
+
+static void com_discard(void)
+{
+    comp_index=0;
+}
+
+static void com_flush(void)
+{
+    int i;
+    for (i=0;i<comp_index;i++)
+	putchar(lines[i]);
+    com_discard();
+}
+
+
+static FILE *headerfile;
+static FILE *stblfile;
+
+static int using_prefetch;
+static int using_exception_3;
+static int cpu_level;
+static int noflags;
+
+/* For the current opcode, the next lower level that will have different code.
+ * Initialized to -1 for each opcode. If it remains unchanged, indicates we
+ * are done with that opcode.  */
+static int next_cpu_level;
+
+void 
+write_log (const char *s,...)
+{
+    fprintf (stderr, "%s", s);
+}
+
+static int *opcode_map;
+static int *opcode_next_clev;
+static int *opcode_last_postfix;
+static unsigned long *counts;
+
+static void 
+read_counts (void)
+{
+    FILE *file;
+    unsigned long opcode, count, total;
+    char name[20];
+    int nr = 0;
+    memset (counts, 0, 65536 * sizeof *counts);
+
+    file = fopen ("frequent.68k", "r");
+    if (file)
+    {
+	fscanf (file, "Total: %lu\n", &total);
+	while (fscanf (file, "%lx: %lu %s\n", &opcode, &count, name) == 3)
+	{
+	    opcode_next_clev[nr] = 4;
+	    opcode_last_postfix[nr] = -1;
+	    opcode_map[nr++] = opcode;
+	    counts[opcode] = count;
+	}
+	fclose (file);
+    }
+    if (nr == nr_cpuop_funcs)
+	return;
+    for (opcode = 0; opcode < 0x10000; opcode++)
+    {
+	if (table68k[opcode].handler == -1 && table68k[opcode].mnemo != i_ILLG
+	    && counts[opcode] == 0)
+	{
+	    opcode_next_clev[nr] = 4;
+	    opcode_last_postfix[nr] = -1;
+	    opcode_map[nr++] = opcode;
+	    counts[opcode] = count;
+	}
+    }
+    if (nr != nr_cpuop_funcs)
+	abort ();
+}
+
+static int n_braces = 0;
+static int insn_n_cycles;
+
+static void 
+start_brace (void)
+{
+    n_braces++;
+    comprintf ("{");
+}
+
+static void 
+close_brace (void)
+{
+    assert (n_braces > 0);
+    n_braces--;
+    comprintf ("}");
+}
+
+static void 
+finish_braces (void)
+{
+    while (n_braces > 0)
+	close_brace ();
+}
+
+static void 
+pop_braces (int to)
+{
+    while (n_braces > to)
+	close_brace ();
+}
+
+static int 
+bit_size (int size)
+{
+    switch (size)
+    {
+     case sz_byte:
+	return 8;
+     case sz_word:
+	return 16;
+     case sz_long:
+	return 32;
+     default:
+	abort ();
+    }
+    return 0;
+}
+
+static const char *
+bit_mask (int size)
+{
+    switch (size)
+    {
+     case sz_byte:
+	return "0xff";
+     case sz_word:
+	return "0xffff";
+     case sz_long:
+	return "0xffffffff";
+     default:
+	abort ();
+    }
+    return 0;
+}
+
+static __inline__ void gen_update_next_handler(void)
+{
+    return; /* Can anything clever be done here? */
+}
+
+static void gen_writebyte(char* address, char* source)
+{
+    comprintf("\twritebyte(%s,%s,scratchie);\n",address,source);
+}
+
+static void gen_writeword(char* address, char* source)
+{
+    comprintf("\twriteword(%s,%s,scratchie);\n",address,source);
+}
+
+static void gen_writelong(char* address, char* source)
+{
+    comprintf("\twritelong(%s,%s,scratchie);\n",address,source);
+}
+
+static void gen_readbyte(char* address, char* dest)
+{
+    comprintf("\treadbyte(%s,%s,scratchie);\n",address,dest);
+}
+
+static void gen_readword(char* address, char* dest)
+{
+    comprintf("\treadword(%s,%s,scratchie);\n",address,dest);
+}
+
+static void gen_readlong(char* address, char* dest)
+{
+    comprintf("\treadlong(%s,%s,scratchie);\n",address,dest);
+}
+
+
+
+static const char *
+gen_nextilong (void)
+{
+    static char buffer[80];
+
+    sprintf (buffer, "comp_get_ilong((m68k_pc_offset+=4)-4)");
+    insn_n_cycles += 4;
+  
+    long_opcode=1;
+    return buffer;
+}
+
+static const char *
+gen_nextiword (void)
+{
+    static char buffer[80];
+
+    sprintf (buffer, "comp_get_iword((m68k_pc_offset+=2)-2)");
+    insn_n_cycles+=2;
+
+    long_opcode=1;
+    return buffer;
+}
+
+static const char *
+gen_nextibyte (void)
+{
+    static char buffer[80];
+
+    sprintf (buffer, "comp_get_ibyte((m68k_pc_offset+=2)-2)");
+    insn_n_cycles += 2;
+
+    long_opcode=1;
+    return buffer;
+}
+
+static void 
+sync_m68k_pc (void)
+{
+    comprintf("\t if (m68k_pc_offset>100) sync_m68k_pc();\n"); 
+}
+
+
+/* getv == 1: fetch data; getv != 0: check for odd address. If movem != 0,
+ * the calling routine handles Apdi and Aipi modes. */
+static void 
+genamode (amodes mode, char *reg, wordsizes size, char *name, int getv, int movem)
+{
+    start_brace ();
+    switch (mode)
+    {
+     case Dreg: /* Do we need to check dodgy here? */
+	if (movem)
+	    abort ();
+	if (getv == 1 || getv==2) { 
+	    /* We generate the variable even for getv==2, so we can use
+	       it as a destination for MOVE */
+	    comprintf ("\tint %s=%s;\n",name,reg);
+	}
+	return;
+
+     case Areg:
+	if (movem)
+	    abort ();
+	if (getv == 1 || getv==2) {
+	    /* see above */
+	    comprintf ("\tint %s=dodgy?scratchie++:%s+8;\n",name,reg);
+	    if (getv==1) {
+		comprintf ("\tif (dodgy) \n");
+		comprintf ("\t\tmov_l_rr(%s,%s+8);\n",name, reg);
+	    }
+	}
+	return;
+
+     case Aind:
+	comprintf ("\tint %sa=dodgy?scratchie++:%s+8;\n",name,reg);
+	comprintf ("\tif (dodgy) \n");
+	comprintf ("\t\tmov_l_rr(%sa,%s+8);\n",name, reg);
+	break;
+     case Aipi:
+	comprintf ("\tint %sa=scratchie++;\n",name,reg);
+	comprintf ("\tmov_l_rr(%sa,%s+8);\n",name, reg);
+	break;
+     case Apdi: 
+	switch (size)   
+	{
+	 case sz_byte:
+	    if (movem) {
+		comprintf ("\tint %sa=dodgy?scratchie++:%s+8;\n",name,reg);
+		comprintf ("\tif (dodgy) \n");
+		comprintf("\tmov_l_rr(%sa,8+%s);\n",name,reg);
+	    }
+	    else {
+		start_brace();
+		comprintf ("\tint %sa=dodgy?scratchie++:%s+8;\n",name,reg);
+		comprintf("\tlea_l_brr(%s+8,%s+8,(uae_s32)-areg_byteinc[%s]);\n",reg,reg,reg);
+		comprintf ("\tif (dodgy) \n");
+		comprintf("\tmov_l_rr(%sa,8+%s);\n",name,reg);
+	    }
+	    break;
+	 case sz_word:
+	    if (movem) {
+		comprintf ("\tint %sa=dodgy?scratchie++:%s+8;\n",name,reg);
+		comprintf ("\tif (dodgy) \n");
+		comprintf("\tmov_l_rr(%sa,8+%s);\n",name,reg);
+	    }
+	    else {
+		start_brace();
+		comprintf ("\tint %sa=dodgy?scratchie++:%s+8;\n",name,reg);
+		comprintf("\tlea_l_brr(%s+8,%s+8,-2);\n",reg,reg);
+		comprintf ("\tif (dodgy) \n");
+		comprintf("\tmov_l_rr(%sa,8+%s);\n",name,reg);
+	    }
+	    break;
+	 case sz_long:
+	    if (movem) {
+		comprintf ("\tint %sa=dodgy?scratchie++:%s+8;\n",name,reg);
+		comprintf ("\tif (dodgy) \n");
+		comprintf("\tmov_l_rr(%sa,8+%s);\n",name,reg);
+	    }
+	    else {
+		start_brace();
+		comprintf ("\tint %sa=dodgy?scratchie++:%s+8;\n",name,reg);
+		comprintf("\tlea_l_brr(%s+8,%s+8,-4);\n",reg,reg);
+		comprintf ("\tif (dodgy) \n");
+		comprintf("\tmov_l_rr(%sa,8+%s);\n",name,reg);
+	    }
+	    break;
+	 default:
+	    abort ();
+	}
+	break;
+     case Ad16:
+	comprintf("\tint %sa=scratchie++;\n",name);
+	comprintf("\tmov_l_rr(%sa,8+%s);\n",name,reg);
+	comprintf("\tlea_l_brr(%sa,%sa,(uae_s32)(uae_s16)%s);\n",name,name,gen_nextiword());
+	break;
+     case Ad8r:
+	comprintf("\tint %sa=scratchie++;\n",name);
+	comprintf("\tcalc_disp_ea_020(%s+8,%s,%sa,scratchie);\n",
+		  reg,gen_nextiword(),name);
+	break;
+
+     case PC16:
+	comprintf("\tint %sa=scratchie++;\n",name);
+	comprintf("\tuae_u32 address=start_pc+((char *)comp_pc_p-(char *)start_pc_p)+m68k_pc_offset;\n");
+	comprintf ("\tuae_s32 PC16off = (uae_s32)(uae_s16)%s;\n", gen_nextiword ());
+	comprintf("\tmov_l_ri(%sa,address+PC16off);\n",name);
+	break;
+
+     case PC8r:
+	comprintf("\tint pctmp=scratchie++;\n");
+	comprintf("\tint %sa=scratchie++;\n",name);
+	comprintf("\tuae_u32 address=start_pc+((char *)comp_pc_p-(char *)start_pc_p)+m68k_pc_offset;\n");
+	start_brace();
+	comprintf("\tmov_l_ri(pctmp,address);\n");
+
+	comprintf("\tcalc_disp_ea_020(pctmp,%s,%sa,scratchie);\n",
+		  gen_nextiword(),name);
+	break;
+     case absw:
+	comprintf ("\tint %sa = scratchie++;\n",name);
+	comprintf ("\tmov_l_ri(%sa,(uae_s32)(uae_s16)%s);\n", name, gen_nextiword ());
+	break;
+     case absl:
+	comprintf ("\tint %sa = scratchie++;\n",name);
+	comprintf ("\tmov_l_ri(%sa,%s); /* absl */\n", name, gen_nextilong ());
+	break;
+     case imm:
+	if (getv != 1)
+	    abort ();
+	switch (size)
+	{
+	 case sz_byte:
+	    comprintf ("\tint %s = scratchie++;\n",name);
+	    comprintf ("\tmov_l_ri(%s,(uae_s32)(uae_s8)%s);\n", name, gen_nextibyte ());
+	    break;
+	 case sz_word:
+	    comprintf ("\tint %s = scratchie++;\n",name);
+	    comprintf ("\tmov_l_ri(%s,(uae_s32)(uae_s16)%s);\n", name, gen_nextiword ());
+	    break;
+	 case sz_long:
+	    comprintf ("\tint %s = scratchie++;\n",name);
+	    comprintf ("\tmov_l_ri(%s,%s);\n", name, gen_nextilong ());
+	    break;
+	 default:
+	    abort ();
+	}
+	return;
+     case imm0:
+	if (getv != 1)
+	    abort ();
+	comprintf ("\tint %s = scratchie++;\n",name);
+	comprintf ("\tmov_l_ri(%s,(uae_s32)(uae_s8)%s);\n", name, gen_nextibyte ());
+	return;
+     case imm1:
+	if (getv != 1)
+	    abort ();
+	comprintf ("\tint %s = scratchie++;\n",name);
+	comprintf ("\tmov_l_ri(%s,(uae_s32)(uae_s16)%s);\n", name, gen_nextiword ());
+	return;
+     case imm2:
+	if (getv != 1)
+	    abort ();
+	comprintf ("\tint %s = scratchie++;\n",name);
+	comprintf ("\tmov_l_ri(%s,%s);\n", name, gen_nextilong ());
+	return;
+     case immi:
+	if (getv != 1)
+	    abort ();
+	comprintf ("\tint %s = scratchie++;\n",name);
+	comprintf ("\tmov_l_ri(%s,%s);\n", name, reg);
+	return;
+     default:
+	abort ();
+    }
+
+    /* We get here for all non-reg non-immediate addressing modes to
+     * actually fetch the value. */
+    if (getv == 1)
+    {
+	char astring[80];
+	sprintf(astring,"%sa",name);
+	switch (size)
+	{
+	 case sz_byte:
+	    insn_n_cycles += 2;
+	    break;
+	 case sz_word:
+	    insn_n_cycles += 2;
+	    break;
+	 case sz_long:
+	    insn_n_cycles += 4;
+	    break;
+	 default:
+	    abort ();
+	}
+	start_brace ();
+	comprintf("\tint %s=scratchie++;\n",name);
+	switch (size)
+	{
+	 case sz_byte:
+	    gen_readbyte(astring,name);
+	    break;
+	 case sz_word:
+	    gen_readword(astring,name);
+	    break;
+	 case sz_long:
+	    gen_readlong(astring,name);
+	    break;
+	 default:
+	    abort ();
+	}
+    }
+
+    /* We now might have to fix up the register for pre-dec or post-inc
+     * addressing modes. */
+    if (!movem) {
+	char x[160];
+	switch (mode)
+	{
+	 case Aipi:
+	    switch (size)
+	    {
+	     case sz_byte:
+		comprintf("\tlea_l_brr(%s+8,%s+8,areg_byteinc[%s]);\n",reg,reg,reg);
+		break;
+	     case sz_word:
+		comprintf("\tlea_l_brr(%s+8,%s+8,2);\n",reg,reg,reg);
+		break;
+	     case sz_long:
+		comprintf("\tlea_l_brr(%s+8,%s+8,4);\n",reg,reg);
+		break;
+	     default:
+		abort ();
+	    }
+	    break;
+	 case Apdi:
+	    break;
+	 default:
+	    break;
+	}
+    }
+}
+
+static void 
+genastore (char *from, amodes mode, char *reg, wordsizes size, char *to)
+{
+    switch (mode)
+    {
+     case Dreg:
+	switch (size)
+	{
+	 case sz_byte:
+	    comprintf("\tif(%s!=%s)\n",reg,from);
+	    comprintf ("\t\tmov_b_rr(%s,%s);\n", reg, from);
+	    break;
+	 case sz_word:
+	    comprintf("\tif(%s!=%s)\n",reg,from);
+	    comprintf ("\t\tmov_w_rr(%s,%s);\n", reg, from);
+	    break;
+	 case sz_long:
+	    comprintf("\tif(%s!=%s)\n",reg,from);
+	    comprintf ("\t\tmov_l_rr(%s,%s);\n", reg, from);
+	    break;
+	 default:
+	    abort ();
+	}
+	break;
+     case Areg:
+	switch (size)
+	{
+	 case sz_word:
+	    comprintf("\tif(%s+8!=%s)\n",reg,from);
+	    comprintf ("\t\tmov_w_rr(%s+8,%s);\n", reg, from);
+	    break;
+	 case sz_long:
+	    comprintf("\tif(%s+8!=%s)\n",reg,from);
+	    comprintf ("\t\tmov_l_rr(%s+8,%s);\n", reg, from);
+	    break;
+	 default:
+	    abort ();
+	}
+	break;
+
+     case Apdi:
+     case absw:
+     case PC16:
+     case PC8r:
+     case Ad16:
+     case Ad8r:
+     case Aipi:
+     case Aind:
+     case absl:
+     {
+	 char astring[80];
+	 sprintf(astring,"%sa",to);
+	
+	 switch (size)
+	 {
+	  case sz_byte:
+	     insn_n_cycles += 2;
+	     gen_writebyte(astring,from);
+	     break;
+	  case sz_word:
+	     insn_n_cycles += 2;
+	     gen_writeword(astring,from);
+	     break;
+	  case sz_long:
+	     insn_n_cycles += 4;
+	     gen_writelong(astring,from);
+	     break;
+	  default:
+	     abort ();
+	 }
+     }
+     break;
+     case imm:
+     case imm0:
+     case imm1:
+     case imm2:
+     case immi:
+	abort ();
+	break;
+     default:
+	abort ();
+    }
+}
+
+static void genmov16(void)
+{
+    comprintf("\tint src=scratchie++;\n"
+	      "\tuae_u16 dstreg=((%s)>>12)&0x07;\n",gen_nextiword());
+    comprintf("\tint dst=scratchie++;\n"
+	      "\tint tmp=scratchie;\n"
+	      "\tscratchie+=4;\n"
+	      "\tmov_l_rr(src,8+srcreg);\n"
+	      "\tand_l_ri(src,~15);\n"
+	      "\tmov_l_rr(dst,8+dstreg);\n"
+	      "\tand_l_ri(dst,~15);\n"
+	      "\tadd_l_ri(srcreg+8,16);\n"
+	      "\tadd_l_ri(dstreg+8,16);\n");
+
+    comprintf("\tif (special_mem) {\n"
+	      "\treadlong(src,tmp,scratchie);\n"
+	      "\twritelong_clobber(dst,tmp,scratchie);\n"
+	      "\tadd_l_ri(src,4);\n"
+	      "\tadd_l_ri(dst,4);\n"
+	      "\treadlong(src,tmp,scratchie);\n"
+	      "\twritelong_clobber(dst,tmp,scratchie);\n"
+	      "\tadd_l_ri(src,4);\n"
+	      "\tadd_l_ri(dst,4);\n"
+	      "\treadlong(src,tmp,scratchie);\n"
+	      "\twritelong_clobber(dst,tmp,scratchie);\n"
+	      "\tadd_l_ri(src,4);\n"
+	      "\tadd_l_ri(dst,4);\n"
+	      "\treadlong(src,tmp,scratchie);\n"
+	      "\twritelong_clobber(dst,tmp,scratchie);\n");
+    comprintf("\t} else {\n");
+    comprintf("\tget_n_addr(src,src,scratchie);\n"
+	      "\tget_n_addr(dst,dst,scratchie);\n"
+	      "\tmov_l_rR_gs(tmp+0,src,0);\n"
+	      "\tmov_l_rR_gs(tmp+1,src,4);\n"
+	      "\tmov_l_rR_gs(tmp+2,src,8);\n"
+	      "\tmov_l_rR_gs(tmp+3,src,12);\n"
+	      "\tmov_l_Rr_gs(dst,tmp+0,0);\n"
+	      "\tforget_about(tmp+0);\n"
+	      "\tmov_l_Rr_gs(dst,tmp+1,4);\n"
+	      "\tforget_about(tmp+1);\n"
+	      "\tmov_l_Rr_gs(dst,tmp+2,8);\n"
+	      "\tforget_about(tmp+2);\n"
+	      "\tmov_l_Rr_gs(dst,tmp+3,12);\n"
+	      "\t}\n");
+}
+
+static void 
+genmovemel (uae_u16 opcode)
+{
+    comprintf ("\tuae_u16 mask = %s;\n", gen_nextiword ());
+    comprintf ("\tint native=scratchie++;\n");
+    comprintf ("\tint i;\n");
+    comprintf ("\tint offset=0;\n");
+    genamode (table68k[opcode].dmode, "dstreg", table68k[opcode].size, "src", 2, 1);
+
+    comprintf("\tif (1 && !special_mem) {\n");
+
+    /* Fast but unsafe...  */
+    comprintf("\tget_n_addr(srca,native,scratchie);\n");
+    comprintf("\tfor (i=0;i<16;i++) {\n"
+	      "\t\tif ((mask>>i)&1) {\n");
+    switch (table68k[opcode].size) {
+     case sz_long: 
+	comprintf("\t\t\tmov_l_rR_gs(i,native,offset);\n"
+		  "\t\t\tbswap_32(i);\n"
+		  "\t\t\toffset+=4;\n");
+	break;
+     case sz_word: 
+	comprintf("\t\t\tmov_w_rR_gs(i,native,offset);\n"
+		  "\t\t\tbswap_16(i);\n"
+		  "\t\t\tsign_extend_16_rr(i,i);\n"
+		  "\t\t\toffset+=2;\n");
+	break;
+     default: abort();
+    }
+    comprintf("\t\t}\n"
+	      "\t}");
+    if (table68k[opcode].dmode == Aipi) {
+	comprintf("\t\t\tlea_l_brr(8+dstreg,srca,offset);\n"); 
+    }
+    /* End fast but unsafe.   */
+
+    comprintf("\t} else {\n");
+
+    comprintf ("\tint tmp=scratchie++;\n");
+
+    comprintf("\tmov_l_rr(tmp,srca);\n");
+    comprintf("\tfor (i=0;i<16;i++) {\n"
+	      "\t\tif ((mask>>i)&1) {\n");
+    switch(table68k[opcode].size) {
+    case sz_long: 
+	comprintf("\t\t\treadlong(tmp,i,scratchie);\n"
+		  "\t\t\tadd_l_ri(tmp,4);\n");
+	break;
+    case sz_word:
+	comprintf("\t\t\treadword(tmp,i,scratchie);\n"
+		  "\t\t\tadd_l_ri(tmp,2);\n");
+	break;
+    default: abort();
+    }
+
+    comprintf("\t\t}\n"
+	      "\t}");
+    if (table68k[opcode].dmode == Aipi) {
+	comprintf("\t\t\tmov_l_rr(8+dstreg,tmp);\n");
+    }
+    comprintf("\t}\n");
+
+}
+
+
+static void 
+genmovemle (uae_u16 opcode)
+{
+    comprintf ("\tuae_u16 mask = %s;\n", gen_nextiword ());
+    comprintf ("\tint native=scratchie++;\n");
+    comprintf ("\tint i;\n");
+    comprintf ("\tint tmp=scratchie++;\n");
+    comprintf ("\tsigned char offset=0;\n");
+    genamode (table68k[opcode].dmode, "dstreg", table68k[opcode].size, "src", 2, 1);
+
+    /* *Sigh* Some clever geek realized that the fastest way to copy a
+       buffer from main memory to the gfx card is by using movmle. Good
+       on her, but unfortunately, gfx mem isn't "real" mem, and thus that
+       act of cleverness means that movmle must pay attention to special_mem,
+       or Genetic Species is a rather boring-looking game ;-) */
+    comprintf("\tif (1 && !special_mem) {\n");
+    comprintf("\tget_n_addr(srca,native,scratchie);\n");
+
+    if (table68k[opcode].dmode!=Apdi) {
+	comprintf("\tfor (i=0;i<16;i++) {\n"
+		  "\t\tif ((mask>>i)&1) {\n");
+	switch(table68k[opcode].size) {
+	 case sz_long: 
+	    comprintf("\t\t\tmov_l_rr(tmp,i);\n"
+		      "\t\t\tbswap_32(tmp);\n"
+		      "\t\t\tmov_l_Rr_gs(native,tmp,offset);\n"
+		      "\t\t\toffset+=4;\n");
+	    break;
+	 case sz_word: 
+	    comprintf("\t\t\tmov_l_rr(tmp,i);\n"
+		      "\t\t\tbswap_16(tmp);\n"
+		      "\t\t\tmov_w_Rr_gs(native,tmp,offset);\n"
+		      "\t\t\toffset+=2;\n");
+	    break;
+	 default: abort();
+	}
+    }
+    else {  /* Pre-decrement */
+	comprintf("\tfor (i=0;i<16;i++) {\n"
+		  "\t\tif ((mask>>i)&1) {\n");
+	switch(table68k[opcode].size) {
+	 case sz_long: 
+	    comprintf("\t\t\toffset-=4;\n"
+		      "\t\t\tmov_l_rr(tmp,15-i);\n"
+		      "\t\t\tbswap_32(tmp);\n"
+		      "\t\t\tmov_l_Rr_gs(native,tmp,offset);\n"
+		      );
+	    break;
+	 case sz_word: 
+	    comprintf("\t\t\toffset-=2;\n"
+		      "\t\t\tmov_l_rr(tmp,15-i);\n"
+		      "\t\t\tbswap_16(tmp);\n"
+		      "\t\t\tmov_w_Rr_gs(native,tmp,offset);\n"
+		      );
+	    break;
+	 default: abort();
+	}
+    }
+  
+
+    comprintf("\t\t}\n"
+	      "\t}");
+    if (table68k[opcode].dmode == Apdi) {
+	comprintf("\t\t\tlea_l_brr(8+dstreg,srca,(uae_s32)offset);\n");
+    }
+    comprintf("\t} else {\n");
+
+    if (table68k[opcode].dmode!=Apdi) {
+	comprintf("\tmov_l_rr(tmp,srca);\n");
+	comprintf("\tfor (i=0;i<16;i++) {\n"
+		  "\t\tif ((mask>>i)&1) {\n");
+	switch(table68k[opcode].size) {
+	 case sz_long: 
+	    comprintf("\t\t\twritelong(tmp,i,scratchie);\n"
+		      "\t\t\tadd_l_ri(tmp,4);\n");
+	    break;
+	 case sz_word: 
+	    comprintf("\t\t\twriteword(tmp,i,scratchie);\n"
+		      "\t\t\tadd_l_ri(tmp,2);\n");
+	    break;
+	 default: abort();
+	}
+    } else {  /* Pre-decrement */
+	comprintf("\tfor (i=0;i<16;i++) {\n"
+		  "\t\tif ((mask>>i)&1) {\n");
+	switch(table68k[opcode].size) {
+	 case sz_long: 
+	    comprintf("\t\t\tsub_l_ri(srca,4);\n"
+		      "\t\t\twritelong(srca,15-i,scratchie);\n");
+	    break;
+	 case sz_word: 
+	    comprintf("\t\t\tsub_l_ri(srca,2);\n"
+		      "\t\t\twriteword(srca,15-i,scratchie);\n");
+	    break;
+	 default: abort();
+	}
+    }
+
+    comprintf("\t\t}\n"
+	      "\t}");
+    if (table68k[opcode].dmode == Apdi) {
+	comprintf("\t\t\tmov_l_rr(8+dstreg,srca);\n");
+    }
+    comprintf("\t}\n");
+}
+
+
+static void 
+duplicate_carry (void)
+{
+    comprintf ("\tif (needed_flags&FLAG_X) duplicate_carry();\n");
+}
+
+typedef enum
+{
+    flag_logical_noclobber, flag_logical, flag_add, flag_sub, flag_cmp, 
+    flag_addx, flag_subx, flag_zn, flag_av, flag_sv, flag_and, flag_or,
+    flag_eor, flag_mov
+}
+flagtypes;
+
+
+static void 
+genflags (flagtypes type, wordsizes size, char *value, char *src, char *dst)
+{
+    if (noflags) {
+	switch(type) {
+	 case flag_cmp:
+	    comprintf("\tdont_care_flags();\n");
+	    comprintf("/* Weird --- CMP with noflags ;-) */\n");
+	    return;
+	 case flag_add:
+	 case flag_sub:
+	    comprintf("\tdont_care_flags();\n");
+	    {
+		char* op;
+		switch(type) {
+		 case flag_add: op="add"; break;
+		 case flag_sub: op="sub"; break;
+		 default: abort();
+		}
+		switch (size)
+		{
+		 case sz_byte:
+		    comprintf("\t%s_b(%s,%s);\n",op,dst,src);
+		    break;
+		 case sz_word:
+		    comprintf("\t%s_w(%s,%s);\n",op,dst,src);
+		    break;
+		 case sz_long:
+		    comprintf("\t%s_l(%s,%s);\n",op,dst,src);
+		    break;
+		}
+		return;
+	    }
+	    break;
+
+	 case flag_and:
+	    comprintf("\tdont_care_flags();\n");
+	    switch (size)
+	    {
+	     case sz_byte:
+		comprintf("if (kill_rodent(dst)) {\n");
+		comprintf("\tzero_extend_8_rr(scratchie,%s);\n",src);
+		comprintf("\tor_l_ri(scratchie,0xffffff00);\n");
+		comprintf("\tand_l(%s,scratchie);\n",dst);
+		comprintf("\tforget_about(scratchie);\n");
+		comprintf("\t} else \n"
+			  "\tand_b(%s,%s);\n",dst,src);
+		break;
+	     case sz_word:
+		comprintf("if (kill_rodent(dst)) {\n");
+		comprintf("\tzero_extend_16_rr(scratchie,%s);\n",src);
+		comprintf("\tor_l_ri(scratchie,0xffff0000);\n");
+		comprintf("\tand_l(%s,scratchie);\n",dst);
+		comprintf("\tforget_about(scratchie);\n");
+		comprintf("\t} else \n"
+			  "\tand_w(%s,%s);\n",dst,src);
+		break;
+	     case sz_long:
+		comprintf("\tand_l(%s,%s);\n",dst,src);
+		break;
+	    }
+	    return;
+
+	 case flag_mov:
+	    comprintf("\tdont_care_flags();\n");
+	    switch (size)
+	    {
+	     case sz_byte:
+		comprintf("if (kill_rodent(dst)) {\n");
+		comprintf("\tzero_extend_8_rr(scratchie,%s);\n",src);
+		comprintf("\tand_l_ri(%s,0xffffff00);\n",dst);
+		comprintf("\tor_l(%s,scratchie);\n",dst);
+		comprintf("\tforget_about(scratchie);\n");
+		comprintf("\t} else \n"
+			  "\tmov_b_rr(%s,%s);\n",dst,src);
+		break;
+	     case sz_word:
+		comprintf("if (kill_rodent(dst)) {\n");
+		comprintf("\tzero_extend_16_rr(scratchie,%s);\n",src);
+		comprintf("\tand_l_ri(%s,0xffff0000);\n",dst);
+		comprintf("\tor_l(%s,scratchie);\n",dst);
+		comprintf("\tforget_about(scratchie);\n");
+		comprintf("\t} else \n"
+			  "\tmov_w_rr(%s,%s);\n",dst,src);
+		break;
+	     case sz_long:
+		comprintf("\tmov_l_rr(%s,%s);\n",dst,src);
+		break;
+	    }
+	    return;
+
+	 case flag_or:
+	 case flag_eor:
+	    comprintf("\tdont_care_flags();\n");
+	    start_brace();
+	    {
+		char* op;
+		switch(type) {
+		 case flag_or:  op="or"; break;
+		 case flag_eor: op="xor"; break;
+		 default: abort();
+		}
+		switch (size)
+		{
+		 case sz_byte:
+		    comprintf("if (kill_rodent(dst)) {\n");
+		    comprintf("\tzero_extend_8_rr(scratchie,%s);\n",src);
+		    comprintf("\t%s_l(%s,scratchie);\n",op,dst);
+		    comprintf("\tforget_about(scratchie);\n");
+		    comprintf("\t} else \n"
+			      "\t%s_b(%s,%s);\n",op,dst,src);
+		    break;
+		 case sz_word:
+		    comprintf("if (kill_rodent(dst)) {\n");
+		    comprintf("\tzero_extend_16_rr(scratchie,%s);\n",src);
+		    comprintf("\t%s_l(%s,scratchie);\n",op,dst);
+		    comprintf("\tforget_about(scratchie);\n");
+		    comprintf("\t} else \n"
+			      "\t%s_w(%s,%s);\n",op,dst,src);
+		    break;
+		 case sz_long:
+		    comprintf("\t%s_l(%s,%s);\n",op,dst,src);
+		    break;
+		}
+		close_brace();
+		return;
+	    }
+      
+
+	 case flag_addx:
+	 case flag_subx:
+	    comprintf("\tdont_care_flags();\n");
+	    {
+		char* op;
+		switch(type) {
+		 case flag_addx: op="adc"; break;
+		 case flag_subx: op="sbb"; break;
+		 default: abort();
+		}
+		comprintf("\trestore_carry();\n"); /* Reload the X flag into C */
+		switch (size)
+		{
+		 case sz_byte:
+		    comprintf("\t%s_b(%s,%s);\n",op,dst,src);
+		    break;
+		 case sz_word:
+		    comprintf("\t%s_w(%s,%s);\n",op,dst,src);
+		    break;
+		 case sz_long:
+		    comprintf("\t%s_l(%s,%s);\n",op,dst,src);
+		    break;
+		}
+		return;
+	    }
+	    break;
+	 default: return;
+	}
+    }
+  
+    /* Need the flags, but possibly not all of them */
+    switch (type)
+    {
+     case flag_logical_noclobber:
+	failure;
+
+     case flag_and:
+     case flag_or:
+     case flag_eor:
+	comprintf("\tdont_care_flags();\n");
+	start_brace();
+	{
+	    char* op;
+	    switch(type) {
+	     case flag_and: op="and"; break;
+	     case flag_or:  op="or"; break;
+	     case flag_eor: op="xor"; break;
+	     default: abort();
+	    }
+	    switch (size)
+	    {
+	     case sz_byte:
+		comprintf("\tstart_needflags();\n"
+			  "\t%s_b(%s,%s);\n",op,dst,src);
+		break;
+	     case sz_word:
+		comprintf("\tstart_needflags();\n"
+			  "\t%s_w(%s,%s);\n",op,dst,src);
+		break;
+	     case sz_long:
+		comprintf("\tstart_needflags();\n"
+			  "\t%s_l(%s,%s);\n",op,dst,src);
+		break;
+	    }
+	    comprintf("\tlive_flags();\n");
+	    comprintf("\tend_needflags();\n");
+	    close_brace();
+	    return;
+	}
+
+     case flag_mov:
+	comprintf("\tdont_care_flags();\n");
+	start_brace();
+	{
+	    switch (size)
+	    {
+	     case sz_byte:
+		comprintf("\tif (%s!=%s) {\n",src,dst);
+		comprintf("\tmov_b_ri(%s,0);\n"
+			  "\tstart_needflags();\n",dst);
+		comprintf("\tor_b(%s,%s);\n",dst,src);
+		comprintf("\t} else {\n");
+		comprintf("\tmov_b_rr(%s,%s);\n",dst,src);
+		comprintf("\ttest_b_rr(%s,%s);\n",dst,dst);
+		comprintf("\t}\n");
+		break;
+	     case sz_word:
+		comprintf("\tif (%s!=%s) {\n",src,dst);
+		comprintf("\tmov_w_ri(%s,0);\n"
+			  "\tstart_needflags();\n",dst);
+		comprintf("\tor_w(%s,%s);\n",dst,src);
+		comprintf("\t} else {\n");
+		comprintf("\tmov_w_rr(%s,%s);\n",dst,src);
+		comprintf("\ttest_w_rr(%s,%s);\n",dst,dst);
+		comprintf("\t}\n");
+		break;
+	     case sz_long:
+		comprintf("\tif (%s!=%s) {\n",src,dst);
+		comprintf("\tmov_l_ri(%s,0);\n"
+			  "\tstart_needflags();\n",dst);
+		comprintf("\tor_l(%s,%s);\n",dst,src);
+		comprintf("\t} else {\n");
+		comprintf("\tmov_l_rr(%s,%s);\n",dst,src);
+		comprintf("\ttest_l_rr(%s,%s);\n",dst,dst);
+		comprintf("\t}\n");
+		break;
+	    }
+	    comprintf("\tlive_flags();\n");
+	    comprintf("\tend_needflags();\n");
+	    close_brace();
+	    return;
+	}
+
+     case flag_logical:
+	comprintf("\tdont_care_flags();\n");
+	start_brace();
+	switch (size)
+	{
+	 case sz_byte:
+	    comprintf("\tstart_needflags();\n"
+		      "\ttest_b_rr(%s,%s);\n",value,value);
+	    break;
+	 case sz_word:
+	    comprintf("\tstart_needflags();\n"
+		      "\ttest_w_rr(%s,%s);\n",value,value);
+	    break;
+	 case sz_long:
+	    comprintf("\tstart_needflags();\n"
+		      "\ttest_l_rr(%s,%s);\n",value,value);
+	    break;
+	}
+	comprintf("\tlive_flags();\n");
+	comprintf("\tend_needflags();\n");
+	close_brace();
+	return;
+
+
+     case flag_add:
+     case flag_sub:
+     case flag_cmp:
+	comprintf("\tdont_care_flags();\n");
+	{
+	    char* op;
+	    switch(type) {
+	     case flag_add: op="add"; break;
+	     case flag_sub: op="sub"; break;
+	     case flag_cmp: op="cmp"; break;
+	     default: abort();
+	    }
+	    switch (size)
+	    {
+	     case sz_byte:
+		comprintf("\tstart_needflags();\n"
+			  "\t%s_b(%s,%s);\n",op,dst,src);
+		break;
+	     case sz_word:
+		comprintf("\tstart_needflags();\n"
+			  "\t%s_w(%s,%s);\n",op,dst,src);
+		break;
+	     case sz_long:
+		comprintf("\tstart_needflags();\n"
+			  "\t%s_l(%s,%s);\n",op,dst,src);
+		break;
+	    }
+	    comprintf("\tlive_flags();\n");
+	    comprintf("\tend_needflags();\n");
+	    if (type!=flag_cmp) {
+		duplicate_carry();
+	    }
+	    comprintf("if (!(needed_flags & FLAG_CZNV)) dont_care_flags();\n");
+	    
+	    return;
+	}
+      
+     case flag_addx:
+     case flag_subx:
+	uses_cmov;
+	comprintf("\tdont_care_flags();\n");
+	{
+	    char* op;
+	    switch(type) {
+	     case flag_addx: op="adc"; break;
+	     case flag_subx: op="sbb"; break;
+	     default: abort();
+	    }
+	    start_brace();
+	    comprintf("\tint zero=scratchie++;\n"
+		      "\tint one=scratchie++;\n"
+		      "\tif (needed_flags&FLAG_Z) {\n"
+		      "\tmov_l_ri(zero,0);\n"
+		      "\tmov_l_ri(one,1);\n"
+		      "\tmake_flags_live();\n"
+		      "\tcmov_l_rr(zero,one,5);\n"
+		      "\t}\n");
+	    comprintf("\trestore_carry();\n"); /* Reload the X flag into C */
+	    switch (size)
+	    {
+	     case sz_byte:
+		comprintf("\tstart_needflags();\n"
+			  "\t%s_b(%s,%s);\n",op,dst,src);
+		break;
+	     case sz_word:
+		comprintf("\tstart_needflags();\n"
+			  "\t%s_w(%s,%s);\n",op,dst,src);
+		break;
+	     case sz_long:
+		comprintf("\tstart_needflags();\n"
+			  "\t%s_l(%s,%s);\n",op,dst,src);
+		break;
+	    }
+	    comprintf("\tif (needed_flags&FLAG_Z) {\n"
+		      "\tcmov_l_rr(zero,one,5);\n"
+		      "\tbsf_l_rr(zero,zero);\n"
+		      "\t}\n");
+	    comprintf("\tlive_flags();\n");
+	    comprintf("\tend_needflags();\n");
+	    duplicate_carry();
+	    comprintf("if (!(needed_flags & FLAG_CZNV)) dont_care_flags();\n");
+	    return;
+	}
+     default:
+	failure;
+	break;
+    }
+}
+
+static void 
+force_range_for_rox (const char *var, wordsizes size)
+{
+    /* Could do a modulo operation here... which one is faster? */
+    switch (size)
+    {
+     case sz_long:
+	comprintf ("\tif (%s >= 33) %s -= 33;\n", var, var);
+	break;
+     case sz_word:
+	comprintf ("\tif (%s >= 34) %s -= 34;\n", var, var);
+	comprintf ("\tif (%s >= 17) %s -= 17;\n", var, var);
+	break;
+     case sz_byte:
+	comprintf ("\tif (%s >= 36) %s -= 36;\n", var, var);
+	comprintf ("\tif (%s >= 18) %s -= 18;\n", var, var);
+	comprintf ("\tif (%s >= 9) %s -= 9;\n", var, var);
+	break;
+    }
+}
+
+static const char *
+cmask (wordsizes size)
+{
+    switch (size)
+    {
+     case sz_byte:
+	return "0x80";
+     case sz_word:
+	return "0x8000";
+     case sz_long:
+	return "0x80000000";
+     default:
+	abort ();
+    }
+}
+
+static int 
+source_is_imm1_8 (struct instr *i)
+{
+    return i->stype == 3;
+}
+
+static int  /* returns zero for success, non-zero for failure */
+gen_opcode (unsigned long int opcode)
+{
+    struct instr *curi = table68k + opcode;
+    char* ssize=NULL;
+
+    insn_n_cycles = 2;
+    global_failure=0;
+    long_opcode=0;
+    global_isjump=0;
+    global_iscjump=0;
+    global_isaddx=0;
+    global_cmov=0;
+    global_mayfail=0;
+    hack_opcode=opcode;
+    endstr[0]=0;
+
+    start_brace ();
+    comprintf("\tuae_u8 scratchie=S1;\n");
+    switch (curi->plev)
+    {
+     case 0:			/* not privileged */
+	break;
+     case 1:			/* unprivileged only on 68000 */
+	if (cpu_level == 0)
+	    break;
+	if (next_cpu_level < 0)
+	    next_cpu_level = 0;
+
+	/* fall through */
+     case 2:			/* priviledged */
+	failure;   /* Easy ones first */
+	break;
+     case 3:			/* privileged if size == word */
+	if (curi->size == sz_byte)
+	    break;
+	failure;
+	break;
+    }
+    switch (curi->size) {
+     case sz_byte: ssize="b"; break;
+     case sz_word: ssize="w"; break;
+     case sz_long: ssize="l"; break;
+     default: abort();
+    }
+
+    switch (curi->mnemo)
+    {
+     case i_OR:
+     case i_AND:
+     case i_EOR:
+	genamode (curi->smode, "srcreg", curi->size, "src", 1, 0);
+	genamode (curi->dmode, "dstreg", curi->size, "dst", 1, 0);
+	switch(curi->mnemo) {
+	 case i_OR: genflags (flag_or, curi->size, "", "src", "dst"); break;
+	 case i_AND: genflags (flag_and, curi->size, "", "src", "dst"); break;
+	 case i_EOR: genflags (flag_eor, curi->size, "", "src", "dst"); break;
+	}
+	genastore ("dst", curi->dmode, "dstreg", curi->size, "dst");
+	break;
+
+     case i_ORSR:
+     case i_EORSR:
+	failure;
+	isjump; 
+	break;
+     case i_ANDSR:
+	failure;
+	isjump; 
+	break;
+     case i_SUB:
+	genamode (curi->smode, "srcreg", curi->size, "src", 1, 0);
+	genamode (curi->dmode, "dstreg", curi->size, "dst", 1, 0);
+	genflags (flag_sub, curi->size, "", "src", "dst");
+	genastore ("dst", curi->dmode, "dstreg", curi->size, "dst");
+	break;
+     case i_SUBA:
+	genamode (curi->smode, "srcreg", curi->size, "src", 1, 0);
+	genamode (curi->dmode, "dstreg", sz_long, "dst", 1, 0);
+	start_brace();
+	comprintf("\tint tmp=scratchie++;\n");
+	switch(curi->size) {
+	 case sz_byte: comprintf("\tsign_extend_8_rr(tmp,src);\n"); break;
+	 case sz_word: comprintf("\tsign_extend_16_rr(tmp,src);\n"); break;
+	 case sz_long: comprintf("\ttmp=src;\n"); break;
+	 default: abort();
+	}
+	comprintf("\tsub_l(dst,tmp);\n");
+	genastore ("dst", curi->dmode, "dstreg", sz_long, "dst");
+	break;
+     case i_SUBX:
+	isaddx;
+	genamode (curi->smode, "srcreg", curi->size, "src", 1, 0);
+	genamode (curi->dmode, "dstreg", curi->size, "dst", 1, 0);
+	genflags (flag_subx, curi->size, "", "src", "dst");
+	genastore ("dst", curi->dmode, "dstreg", curi->size, "dst");
+	break;
+     case i_SBCD:
+	failure;
+	/* I don't think so! */
+	break;
+     case i_ADD:
+	genamode (curi->smode, "srcreg", curi->size, "src", 1, 0);
+	genamode (curi->dmode, "dstreg", curi->size, "dst", 1, 0);
+	genflags (flag_add, curi->size, "", "src", "dst");
+	genastore ("dst", curi->dmode, "dstreg", curi->size, "dst");
+	break;
+     case i_ADDA:
+	genamode (curi->smode, "srcreg", curi->size, "src", 1, 0);
+	genamode (curi->dmode, "dstreg", sz_long, "dst", 1, 0);
+	start_brace();
+	comprintf("\tint tmp=scratchie++;\n");
+	switch(curi->size) {
+	 case sz_byte: comprintf("\tsign_extend_8_rr(tmp,src);\n"); break;
+	 case sz_word: comprintf("\tsign_extend_16_rr(tmp,src);\n"); break;
+	 case sz_long: comprintf("\ttmp=src;\n"); break;
+	 default: abort();
+	}
+	comprintf("\tadd_l(dst,tmp);\n");
+	genastore ("dst", curi->dmode, "dstreg", sz_long, "dst");
+	break;
+     case i_ADDX:
+	isaddx;
+	genamode (curi->smode, "srcreg", curi->size, "src", 1, 0);
+	genamode (curi->dmode, "dstreg", curi->size, "dst", 1, 0);
+	start_brace();
+	genflags (flag_addx, curi->size, "", "src", "dst");
+	genastore ("dst", curi->dmode, "dstreg", curi->size, "dst");
+	break;
+     case i_ABCD:
+	failure;
+	/* No BCD maths for me.... */
+	break;
+     case i_NEG:
+	genamode (curi->smode, "srcreg", curi->size, "src", 1, 0);
+	start_brace ();
+	comprintf("\tint dst=scratchie++;\n");
+	comprintf("\tmov_l_ri(dst,0);\n");
+	genflags (flag_sub, curi->size, "", "src", "dst");
+	genastore ("dst", curi->smode, "srcreg", curi->size, "src");
+	break;
+     case i_NEGX:
+	genamode (curi->smode, "srcreg", curi->size, "src", 1, 0);
+	start_brace ();
+	comprintf("\tint dst=scratchie++;\n");
+	comprintf("\tmov_l_ri(dst,0);\n");
+	genflags (flag_subx, curi->size, "", "src", "dst");
+	genastore ("dst", curi->smode, "srcreg", curi->size, "src");
+	break;
+
+     case i_NBCD:
+	failure;
+	/* Nope! */
+	break;
+     case i_CLR:
+	genamode (curi->smode, "srcreg", curi->size, "src", 2, 0);
+	start_brace();
+	comprintf("\tint dst=scratchie++;\n");
+	comprintf("\tmov_l_ri(dst,0);\n");
+	genflags (flag_logical, curi->size, "dst", "", "");
+	genastore ("dst", curi->smode, "srcreg", curi->size, "src");
+	break;
+     case i_NOT:
+	genamode (curi->smode, "srcreg", curi->size, "src", 1, 0);
+	start_brace ();
+	comprintf("\tint dst=scratchie++;\n");
+	comprintf("\tmov_l_ri(dst,0xffffffff);\n");
+	genflags (flag_eor, curi->size, "", "src", "dst");
+	genastore ("dst", curi->smode, "srcreg", curi->size, "src");
+	break;
+     case i_TST:
+	genamode (curi->smode, "srcreg", curi->size, "src", 1, 0);
+	genflags (flag_logical, curi->size, "src", "", "");
+	break;
+     case i_BCHG:
+     case i_BCLR:
+     case i_BSET:
+     case i_BTST:
+	genamode (curi->smode, "srcreg", curi->size, "src", 1, 0);
+	genamode (curi->dmode, "dstreg", curi->size, "dst", 1, 0);
+	start_brace();
+	comprintf("\tint s=scratchie++;\n"
+		  "\tmov_l_rr(s,src);\n");
+	if (curi->size == sz_byte)
+	    comprintf("\tand_l_ri(s,7);\n");
+	else
+	    comprintf("\tand_l_ri(s,31);\n");
+
+	{
+	    char* op;
+	    int need_write=1;
+
+	    switch(curi->mnemo) {
+	     case i_BCHG: op="btc"; break;
+	     case i_BCLR: op="btr"; break;
+	     case i_BSET: op="bts"; break;
+	     case i_BTST: op="bt"; need_write=0; break;
+	    }
+	    comprintf("\t%s_l_rr(dst,s);\n"  /* Answer now in C */
+		      "\tsbb_l(s,s);\n" /* s is 0 if bit was 0, 
+					   -1 otherwise */
+		      "\tmake_flags_live();\n" /* Get the flags back */
+		      "\tdont_care_flags();\n" 
+		      "\tstart_needflags();\n"
+		      "\tbsf_l_rr(s,s);\n"
+		      "\tlive_flags();\n"
+		      "\tend_needflags();\n",op);
+	    if (need_write) 
+		genastore ("dst", curi->dmode, "dstreg", curi->size, "dst");
+	}
+	break;
+
+     case i_CMPM:
+     case i_CMP:
+	genamode (curi->smode, "srcreg", curi->size, "src", 1, 0);
+	genamode (curi->dmode, "dstreg", curi->size, "dst", 1, 0);
+	start_brace ();
+	genflags (flag_cmp, curi->size, "", "src", "dst");
+	break;
+     case i_CMPA:
+	genamode (curi->smode, "srcreg", curi->size, "src", 1, 0);
+	genamode (curi->dmode, "dstreg", sz_long, "dst", 1, 0);
+	start_brace();
+	comprintf("\tint tmps=scratchie++;\n");
+	switch(curi->size) {
+	 case sz_byte: comprintf("\tsign_extend_8_rr(tmps,src);\n"); break;
+	 case sz_word: comprintf("\tsign_extend_16_rr(tmps,src);\n"); break;
+	 case sz_long: comprintf("tmps=src;\n"); break;
+	 default: abort();
+	}
+	genflags (flag_cmp, sz_long, "", "tmps", "dst");
+	break;
+	/* The next two are coded a little unconventional, but they are doing
+	 * weird things... */
+     case i_MVPRM:
+	isjump; 
+	failure;
+	break;
+     case i_MVPMR:
+	isjump; 
+	failure;
+	break;
+     case i_MOVE:
+	switch(curi->dmode) {
+	 case Dreg:
+	 case Areg:
+	    genamode (curi->smode, "srcreg", curi->size, "src", 1, 0);
+	    genamode (curi->dmode, "dstreg", curi->size, "dst", 2, 0);
+	    genflags (flag_mov, curi->size, "", "src", "dst");
+	    genastore ("dst", curi->dmode, "dstreg", curi->size, "dst");
+	    break;
+	 default: /* It goes to memory, not a register */
+	    genamode (curi->smode, "srcreg", curi->size, "src", 1, 0);
+	    genamode (curi->dmode, "dstreg", curi->size, "dst", 2, 0);
+	    genflags (flag_logical, curi->size, "src", "", "");
+	    genastore ("src", curi->dmode, "dstreg", curi->size, "dst");
+	    break;
+	}
+	break;
+     case i_MOVEA:
+	genamode (curi->smode, "srcreg", curi->size, "src", 1, 0);
+	genamode (curi->dmode, "dstreg", curi->size, "dst", 2, 0);
+
+	start_brace();
+	comprintf("\tint tmps=scratchie++;\n");
+	switch(curi->size) {
+	 case sz_word: comprintf("\tsign_extend_16_rr(dst,src);\n"); break;
+	 case sz_long: comprintf("\tmov_l_rr(dst,src);\n"); break;
+	 default: abort();
+	}
+	genastore ("dst", curi->dmode, "dstreg", sz_long, "dst");
+	break;
+
+     case i_MVSR2:
+	isjump; 
+	failure;
+	break;
+     case i_MV2SR:
+	isjump; 
+	failure;
+	break;
+     case i_SWAP:
+	genamode (curi->smode, "srcreg", sz_long, "src", 1, 0);
+	comprintf("\tdont_care_flags();\n");
+	comprintf("\trol_l_ri(src,16);\n");
+	genflags (flag_logical, sz_long, "src", "", "");
+	genastore ("src", curi->smode, "srcreg", sz_long, "src");
+	break;
+     case i_EXG:
+	genamode (curi->smode, "srcreg", curi->size, "src", 1, 0);
+	genamode (curi->dmode, "dstreg", curi->size, "dst", 1, 0);
+	start_brace();
+	comprintf("\tint tmp=scratchie++;\n"
+		  "\tmov_l_rr(tmp,src);\n");
+	genastore ("dst", curi->smode, "srcreg", curi->size, "src");
+	genastore ("tmp", curi->dmode, "dstreg", curi->size, "dst");
+	break;
+     case i_EXT:
+	genamode (curi->smode, "srcreg", sz_long, "src", 1, 0);
+	comprintf("\tdont_care_flags();\n");
+	start_brace ();
+	switch (curi->size)
+	{
+	 case sz_byte:
+	    comprintf ("\tint dst = src;\n"
+		       "\tsign_extend_8_rr(src,src);\n");
+	    break;
+	 case sz_word:
+	    comprintf ("\tint dst = scratchie++;\n"
+		       "\tsign_extend_8_rr(dst,src);\n");
+	    break;
+	 case sz_long:
+	    comprintf ("\tint dst = src;\n"
+		       "\tsign_extend_16_rr(src,src);\n");
+	    break;
+	 default:
+	    abort ();
+	}
+	genflags (flag_logical,
+		  curi->size == sz_word ? sz_word : sz_long, "dst", "", "");
+	genastore ("dst", curi->smode, "srcreg",
+		   curi->size == sz_word ? sz_word : sz_long, "src");
+	break;
+     case i_MVMEL:
+	genmovemel (opcode);
+	break;
+     case i_MVMLE:
+	genmovemle (opcode);
+	break;
+     case i_TRAP:
+	isjump; 
+	failure;
+	break;
+     case i_MVR2USP:
+	isjump; 
+	failure;
+	break;
+     case i_MVUSP2R:
+	isjump; 
+	failure;
+	break;
+     case i_RESET:
+	isjump; 
+	failure;
+	break;
+     case i_NOP:
+	break;
+     case i_STOP:
+	isjump; 
+	failure;
+	break;
+     case i_RTE:
+	isjump; 
+	failure;
+	break;
+     case i_RTD:
+	genamode (curi->smode, "srcreg", curi->size, "offs", 1, 0);
+	/* offs is constant */
+	comprintf("\tadd_l_ri(offs,4);\n");
+	start_brace();
+	comprintf("\tint newad=scratchie++;\n"
+		  "\treadlong(15,newad,scratchie);\n"
+		  "\tand_l_ri(newad,~1);\n"
+		  "\tmov_l_mr((uae_u32)&regs.pc,newad);\n"
+		  "\tget_n_addr_jmp(newad,PC_P,scratchie);\n"
+		  "\tmov_l_mr((uae_u32)&regs.pc_oldp,PC_P);\n"
+		  "\tm68k_pc_offset=0;\n"
+		  "\tadd_l(15,offs);\n");
+	gen_update_next_handler();
+	isjump; 
+	break;
+     case i_LINK:
+	genamode (curi->smode, "srcreg", sz_long, "src", 1, 0);
+	genamode (curi->dmode, "dstreg", curi->size, "offs", 1, 0);
+	comprintf("\tsub_l_ri(15,4);\n"
+		  "\twritelong_clobber(15,src,scratchie);\n"
+		  "\tmov_l_rr(src,15);\n");
+	if (curi->size==sz_word)
+	    comprintf("\tsign_extend_16_rr(offs,offs);\n");
+	comprintf("\tadd_l(15,offs);\n");
+	genastore ("src", curi->smode, "srcreg", sz_long, "src");
+	break;
+     case i_UNLK:
+	genamode (curi->smode, "srcreg", curi->size, "src", 1, 0);
+	comprintf("\tmov_l_rr(15,src);\n"
+		  "\treadlong(15,src,scratchie);\n"
+		  "\tadd_l_ri(15,4);\n");
+	genastore ("src", curi->smode, "srcreg", curi->size, "src");
+	break;
+     case i_RTS:
+	comprintf("\tint newad=scratchie++;\n"
+		  "\treadlong(15,newad,scratchie);\n"
+		  "\tand_l_ri(newad,~1);\n"
+		  "\tmov_l_mr((uae_u32)&regs.pc,newad);\n"
+		  "\tget_n_addr_jmp(newad,PC_P,scratchie);\n"
+		  "\tmov_l_mr((uae_u32)&regs.pc_oldp,PC_P);\n"
+		  "\tm68k_pc_offset=0;\n"
+		  "\tlea_l_brr(15,15,4);\n");
+	gen_update_next_handler();
+	isjump; 
+	break;
+     case i_TRAPV:
+	isjump; 
+	failure;
+	break;
+     case i_RTR:
+	isjump; 
+	failure;
+	break;
+     case i_JSR:
+	isjump; 
+	genamode (curi->smode, "srcreg", curi->size, "src", 0, 0);
+	start_brace();
+	comprintf("\tuae_u32 retadd=start_pc+((char *)comp_pc_p-(char *)start_pc_p)+m68k_pc_offset;\n");
+	comprintf("\tint ret=scratchie++;\n"
+		  "\tmov_l_ri(ret,retadd);\n"
+		  "\tsub_l_ri(15,4);\n"
+		  "\twritelong_clobber(15,ret,scratchie);\n");
+	comprintf("\tand_l_ri(srca,~1);\n"
+		  "\tmov_l_mr((uae_u32)&regs.pc,srca);\n"
+		  "\tget_n_addr_jmp(srca,PC_P,scratchie);\n"
+		  "\tmov_l_mr((uae_u32)&regs.pc_oldp,PC_P);\n"
+		  "\tm68k_pc_offset=0;\n");
+	gen_update_next_handler();
+	break;
+     case i_JMP:
+	isjump;
+	genamode (curi->smode, "srcreg", curi->size, "src", 0, 0);
+	comprintf("\tand_l_ri(srca,~1);\n"
+		  "\tmov_l_mr((uae_u32)&regs.pc,srca);\n"
+		  "\tget_n_addr_jmp(srca,PC_P,scratchie);\n"
+		  "\tmov_l_mr((uae_u32)&regs.pc_oldp,PC_P);\n"
+		  "\tm68k_pc_offset=0;\n");
+	gen_update_next_handler();
+	break;
+     case i_BSR:
+	if (curi->size==sz_long)
+	    failure;
+	is_const_jump;
+	genamode (curi->smode, "srcreg", curi->size, "src", 1, 0);
+	comprintf("\tand_l_ri(src,~1);\n");
+	start_brace();
+	comprintf("\tuae_u32 retadd=start_pc+((char *)comp_pc_p-(char *)start_pc_p)+m68k_pc_offset;\n");
+	comprintf("\tint ret=scratchie++;\n"
+		  "\tmov_l_ri(ret,retadd);\n"
+		  "\tsub_l_ri(15,4);\n"
+		  "\twritelong_clobber(15,ret,scratchie);\n");
+	comprintf("\tadd_l_ri(src,m68k_pc_offset_thisinst+2);\n");
+	comprintf("\tm68k_pc_offset=0;\n");
+	comprintf("\tadd_l(PC_P,src);\n");
+
+	comprintf("\tcomp_pc_p=(void*)get_const(PC_P);\n");
+	break;
+     case i_Bcc:
+	comprintf("\tuae_u32 v,v1,v2;\n");
+	genamode (curi->smode, "srcreg", curi->size, "src", 1, 0);
+	/* That source is an immediate, so we can clobber it with abandon */
+	switch(curi->size) {
+	 case sz_byte: comprintf("\tsign_extend_8_rr(src,src);\n"); break;
+	 case sz_word: comprintf("\tsign_extend_16_rr(src,src);\n"); break;
+	 case sz_long: break;
+	}
+	comprintf("\tand_l_ri(src,~1);\n");
+	comprintf("\tsub_l_ri(src,m68k_pc_offset-m68k_pc_offset_thisinst-2);\n");
+	/* Leave the following as "add" --- it will allow it to be optimized
+	   away due to src being a constant ;-) */
+	comprintf("\tadd_l_ri(src,(uae_u32)comp_pc_p);\n");  
+	comprintf("\tmov_l_ri(PC_P,(uae_u32)comp_pc_p);\n");
+	/* Now they are both constant. Might as well fold in m68k_pc_offset */
+	comprintf("\tadd_l_ri(src,m68k_pc_offset);\n");
+	comprintf("\tadd_l_ri(PC_P,m68k_pc_offset);\n");
+	comprintf("\tm68k_pc_offset=0;\n");
+
+	if (curi->cc>=2) {
+	    comprintf("\tv1=get_const(PC_P);\n"
+		      "\tv2=get_const(src);\n"
+		      "\tregister_branch(v1,v2,%d);\n",
+		      cond_codes_x86[curi->cc]);
+	    comprintf("\tmake_flags_live();\n"); /* Load the flags */
+	    isjump; 
+	}
+	else {
+	    is_const_jump; 
+	}
+
+	switch(curi->cc) {
+	 case 0:  /* Unconditional jump */
+	    comprintf("\tmov_l_rr(PC_P,src);\n"); 
+	    comprintf("\tcomp_pc_p=(void*)get_const(PC_P);\n");
+	    break;
+	 case 1: break; /* This is silly! */
+	 case 8: failure; break;  /* Work out details! FIXME */
+	 case 9: failure; break;  /* Not critical, though! */
+
+	 case 2:
+	 case 3:
+	 case 4:
+	 case 5:
+	 case 6:
+	 case 7:
+	 case 10:
+	 case 11:
+	 case 12:
+	 case 13:
+	 case 14:
+	 case 15: 
+	    break;
+	 default: abort();
+	}
+	break;
+     case i_LEA:
+	genamode (curi->smode, "srcreg", curi->size, "src", 0, 0);
+	genamode (curi->dmode, "dstreg", curi->size, "dst", 2, 0);
+	genastore ("srca", curi->dmode, "dstreg", curi->size, "dst");
+	break;
+     case i_PEA:
+	if (table68k[opcode].smode==Areg || 
+	    table68k[opcode].smode==Aind || 
+	    table68k[opcode].smode==Aipi || 
+	    table68k[opcode].smode==Apdi || 
+	    table68k[opcode].smode==Ad16 || 
+	    table68k[opcode].smode==Ad8r) 
+	    comprintf("if (srcreg==7) dodgy=1;\n");
+
+	genamode (curi->smode, "srcreg", curi->size, "src", 0, 0);
+	genamode (Apdi, "7", sz_long, "dst", 2, 0);
+	genastore ("srca", Apdi, "7", sz_long, "dst");
+	break;
+     case i_DBcc:
+	isjump; 
+	uses_cmov;
+	genamode (curi->smode, "srcreg", curi->size, "src", 1, 0);
+	genamode (curi->dmode, "dstreg", curi->size, "offs", 1, 0);
+
+	/* That offs is an immediate, so we can clobber it with abandon */
+	switch(curi->size) {
+	 case sz_word: comprintf("\tsign_extend_16_rr(offs,offs);\n"); break;
+	 default: abort();  /* Seems this only comes in word flavour */
+	}
+	comprintf("\tsub_l_ri(offs,m68k_pc_offset-m68k_pc_offset_thisinst-2);\n"); 
+	comprintf("\tadd_l_ri(offs,(uae_u32)comp_pc_p);\n"); /* New PC, 
+								once the 
+								offset_68k is
+								* also added */
+	/* Let's fold in the m68k_pc_offset at this point */
+	comprintf("\tadd_l_ri(offs,m68k_pc_offset);\n");
+	comprintf("\tadd_l_ri(PC_P,m68k_pc_offset);\n");
+	comprintf("\tm68k_pc_offset=0;\n");
+
+	start_brace();
+	comprintf("\tint nsrc=scratchie++;\n");
+
+	if (curi->cc>=2) {
+	    comprintf("\tmake_flags_live();\n"); /* Load the flags */
+	}
+
+	if (curi->size!=sz_word) 
+	    abort();
+
+
+	switch(curi->cc) {
+	 case 0: /* This is an elaborate nop? */
+	    break;
+	 case 1: 
+	    comprintf("\tstart_needflags();\n");
+	    comprintf("\tsub_w_ri(src,1);\n");
+	    comprintf("\t end_needflags();\n");
+	    start_brace();
+	    comprintf("\tuae_u32 v2,v;\n"
+		      "\tuae_u32 v1=get_const(PC_P);\n");
+	    comprintf("\tv2=get_const(offs);\n"
+		      "\tregister_branch(v1,v2,3);\n");
+	    break;
+
+	 case 8: failure; break;  /* Work out details! FIXME */
+	 case 9: failure; break;  /* Not critical, though! */
+
+	 case 2:
+	 case 3:
+	 case 4:
+	 case 5:
+	 case 6:
+	 case 7:
+	 case 10:
+	 case 11:
+	 case 12:
+	 case 13:
+	 case 14:
+	 case 15:
+	    comprintf("\tmov_l_rr(nsrc,src);\n");
+	    comprintf("\tlea_l_brr(scratchie,src,(uae_s32)-1);\n"
+		      "\tmov_w_rr(src,scratchie);\n");
+	    comprintf("\tcmov_l_rr(offs,PC_P,%d);\n",
+		      cond_codes_x86[curi->cc]);
+	    comprintf("\tcmov_l_rr(src,nsrc,%d);\n",
+		      cond_codes_x86[curi->cc]);
+	    /* OK, now for cc=true, we have src==nsrc and offs==PC_P, 
+	       so whether we move them around doesn't matter. However,
+	       if cc=false, we have offs==jump_pc, and src==nsrc-1 */
+
+	    comprintf("\t start_needflags();\n");
+	    comprintf("\ttest_w_rr(nsrc,nsrc);\n"); 
+	    comprintf("\t end_needflags();\n");
+	    comprintf("\tcmov_l_rr(PC_P,offs,5);\n"); 
+	    break;
+	 default: abort();
+	}
+	genastore ("src", curi->smode, "srcreg", curi->size, "src");
+	gen_update_next_handler();
+	break;
+
+     case i_Scc:
+	genamode (curi->smode, "srcreg", curi->size, "src", 2, 0);
+	start_brace ();
+	comprintf ("\tint val = scratchie++;\n");
+
+	/* We set val to 0 if we really should use 255, and to 1 for real 0 */
+	switch(curi->cc) {
+	 case 0:  /* Unconditional set */
+	    comprintf("\tmov_l_ri(val,0);\n"); 
+	    break;
+	 case 1: 
+	    /* Unconditional not-set */
+	    comprintf("\tmov_l_ri(val,1);\n"); 
+	    break;
+	 case 8: failure; break;  /* Work out details! FIXME */
+	 case 9: failure; break;  /* Not critical, though! */
+
+	 case 2:
+	 case 3:
+	 case 4:
+	 case 5:
+	 case 6:
+	 case 7:
+	 case 10:
+	 case 11:
+	 case 12:
+	 case 13:
+	 case 14:
+	 case 15:
+	    comprintf("\tmake_flags_live();\n"); /* Load the flags */
+	    /* All condition codes can be inverted by changing the LSB */
+	    comprintf("\tsetcc(val,%d);\n",
+		      cond_codes_x86[curi->cc]^1); break;
+	 default: abort();
+	}
+	comprintf("\tsub_b_ri(val,1);\n");
+	genastore ("val", curi->smode, "srcreg", curi->size, "src");
+	break;
+     case i_DIVU:
+	isjump; 
+	failure;
+	break;
+     case i_DIVS:
+	isjump; 
+	failure;
+	break;
+     case i_MULU:
+	comprintf("\tdont_care_flags();\n");
+	genamode (curi->smode, "srcreg", sz_word, "src", 1, 0);
+	genamode (curi->dmode, "dstreg", sz_word, "dst", 1, 0);
+	/* To do 16x16 unsigned multiplication, we actually use 
+	   32x32 signed, and zero-extend the registers first.
+	   That solves the problem of MUL needing dedicated registers
+	   on the x86 */
+	comprintf("\tzero_extend_16_rr(scratchie,src);\n"
+		  "\tzero_extend_16_rr(dst,dst);\n"
+		  "\timul_32_32(dst,scratchie);\n");
+	genflags (flag_logical, sz_long, "dst", "", "");
+	genastore ("dst", curi->dmode, "dstreg", sz_long, "dst");
+	break;
+     case i_MULS:
+	comprintf("\tdont_care_flags();\n");
+	genamode (curi->smode, "srcreg", sz_word, "src", 1, 0);
+	genamode (curi->dmode, "dstreg", sz_word, "dst", 1, 0);
+	comprintf("\tsign_extend_16_rr(scratchie,src);\n"
+		  "\tsign_extend_16_rr(dst,dst);\n"
+		  "\timul_32_32(dst,scratchie);\n");
+	genflags (flag_logical, sz_long, "dst", "", "");
+	genastore ("dst", curi->dmode, "dstreg", sz_long, "dst");
+	break;
+     case i_CHK:
+	isjump; 
+	failure;
+	break;
+
+     case i_CHK2:
+	isjump; 
+	failure;
+	break;
+
+     case i_ASR:
+	comprintf("\tdont_care_flags();\n");
+
+	genamode (curi->smode, "srcreg", curi->size, "cnt", 1, 0);
+	genamode (curi->dmode, "dstreg", curi->size, "data", 1, 0);
+	if (curi->smode!=immi) {
+	    if (!noflags) {
+		uses_cmov;
+		start_brace();
+		comprintf("\tint highmask;\n"
+			  "\tint width;\n"
+			  "\tint cdata=scratchie++;\n"
+			  "\tint tmpcnt=scratchie++;\n"
+			  "\tint highshift=scratchie++;\n");
+		comprintf("\tmov_l_rr(tmpcnt,cnt);\n"
+			  "\tand_l_ri(tmpcnt,63);\n"
+			  "\tmov_l_ri(cdata,0);\n"
+			  "\tcmov_l_rr(cdata,data,5);\n");
+		/* cdata is now either data (for shift count!=0) or
+		   0 (for shift count==0) */
+		switch(curi->size) {
+		 case sz_byte: comprintf("\tshra_b_rr(data,cnt);\n"
+					 "\thighmask=0x38;\n"
+					 "\twidth=8;\n"); 
+		 break;
+		 case sz_word: comprintf("\tshra_w_rr(data,cnt);\n"
+					 "\thighmask=0x30;\n"
+					 "\twidth=16;\n"); 
+		 break;
+		 case sz_long: comprintf("\tshra_l_rr(data,cnt);\n"
+					 "\thighmask=0x20;\n"
+					 "\twidth=32;\n"); 
+		 break;
+		 default: abort();
+		}
+		comprintf("test_l_ri(cnt,highmask);\n"
+			  "mov_l_ri(highshift,0);\n"
+			  "mov_l_ri(scratchie,width/2);\n"
+			  "cmov_l_rr(highshift,scratchie,5);\n");
+		/* The x86 masks out bits, so we now make sure that things
+		   really get shifted as much as planned */
+		switch(curi->size) {
+		 case sz_byte: comprintf("\tshra_b_rr(data,highshift);\n");break;
+		 case sz_word: comprintf("\tshra_w_rr(data,highshift);\n");break;
+		 case sz_long: comprintf("\tshra_l_rr(data,highshift);\n");break;
+		 default: abort();
+		}
+		/* And again */
+		switch(curi->size) {
+		 case sz_byte: comprintf("\tshra_b_rr(data,highshift);\n");break;
+		 case sz_word: comprintf("\tshra_w_rr(data,highshift);\n");break;
+		 case sz_long: comprintf("\tshra_l_rr(data,highshift);\n");break;
+		 default: abort();
+		}
+		
+		/* Result of shift is now in data. Now we need to determine
+		   the carry by shifting cdata one less */
+		comprintf("\tsub_l_ri(tmpcnt,1);\n");
+		switch(curi->size) {
+		 case sz_byte: comprintf("\tshra_b_rr(cdata,tmpcnt);\n");break;
+		 case sz_word: comprintf("\tshra_w_rr(cdata,tmpcnt);\n");break;
+		 case sz_long: comprintf("\tshra_l_rr(cdata,tmpcnt);\n");break;
+		 default: abort();
+		}
+		/* If the shift count was higher than the width, we need
+		   to pick up the sign from data */
+		comprintf("test_l_ri(tmpcnt,highmask);\n"
+			  "cmov_l_rr(cdata,data,5);\n");
+		/* And create the flags */
+		comprintf("\tstart_needflags();\n");
+		comprintf("\tif (needed_flags & FLAG_ZNV)\n");
+		switch(curi->size) {
+		 case sz_byte: comprintf("\t  test_b_rr(data,data);\n"); break;
+		 case sz_word: comprintf("\t  test_w_rr(data,data);\n"); break;
+		 case sz_long: comprintf("\t  test_l_rr(data,data);\n"); break;
+		}
+		comprintf("\t bt_l_ri(cdata,0);\n"); /* Set C */
+		comprintf("\t live_flags();\n");
+		comprintf("\t end_needflags();\n");
+		comprintf("\t duplicate_carry();\n");
+		comprintf("if (!(needed_flags & FLAG_CZNV)) dont_care_flags();\n");
+		genastore ("data", curi->dmode, "dstreg", curi->size, "data");
+	    }
+	    else {
+		uses_cmov;
+		start_brace();
+		comprintf("\tint highmask;\n"
+			  "\tint width;\n"
+			  "\tint highshift=scratchie++;\n");
+		switch(curi->size) {
+		 case sz_byte: comprintf("\tshra_b_rr(data,cnt);\n"
+					 "\thighmask=0x38;\n"
+					 "\twidth=8;\n"); 
+		 break;
+		 case sz_word: comprintf("\tshra_w_rr(data,cnt);\n"
+					 "\thighmask=0x30;\n"
+					 "\twidth=16;\n"); 
+		 break;
+		 case sz_long: comprintf("\tshra_l_rr(data,cnt);\n"
+					 "\thighmask=0x20;\n"
+					 "\twidth=32;\n"); 
+		 break;
+		 default: abort();
+		}
+		comprintf("test_l_ri(cnt,highmask);\n"
+			  "mov_l_ri(highshift,0);\n"
+			  "mov_l_ri(scratchie,width/2);\n"
+			  "cmov_l_rr(highshift,scratchie,5);\n");
+		/* The x86 masks out bits, so we now make sure that things
+		   really get shifted as much as planned */
+		switch(curi->size) {
+		 case sz_byte: comprintf("\tshra_b_rr(data,highshift);\n");break;
+		 case sz_word: comprintf("\tshra_w_rr(data,highshift);\n");break;
+		 case sz_long: comprintf("\tshra_l_rr(data,highshift);\n");break;
+		 default: abort();
+		}
+		/* And again */
+		switch(curi->size) {
+		 case sz_byte: comprintf("\tshra_b_rr(data,highshift);\n");break;
+		 case sz_word: comprintf("\tshra_w_rr(data,highshift);\n");break;
+		 case sz_long: comprintf("\tshra_l_rr(data,highshift);\n");break;
+		 default: abort();
+		}
+		genastore ("data", curi->dmode, "dstreg", curi->size, "data");
+	    }
+	}
+	else {
+	    start_brace();
+	    comprintf("\tint tmp=scratchie++;\n"
+		      "\tint bp;\n"
+		      "\tmov_l_rr(tmp,data);\n");
+	    switch(curi->size) {
+	     case sz_byte: comprintf("\tshra_b_ri(data,srcreg);\n"
+				     "\tbp=srcreg-1;\n"); break;
+	     case sz_word: comprintf("\tshra_w_ri(data,srcreg);\n"
+				     "\tbp=srcreg-1;\n"); break;
+	     case sz_long: comprintf("\tshra_l_ri(data,srcreg);\n"
+				     "\tbp=srcreg-1;\n"); break;
+	     default: abort();
+	    }
+
+	    if (!noflags) {
+		comprintf("\tstart_needflags();\n");
+		comprintf("\tif (needed_flags & FLAG_ZNV)\n");
+		switch(curi->size) {
+		 case sz_byte: comprintf("\t  test_b_rr(data,data);\n"); break;
+		 case sz_word: comprintf("\t  test_w_rr(data,data);\n"); break;
+		 case sz_long: comprintf("\t  test_l_rr(data,data);\n"); break;
+		}
+		comprintf("\t bt_l_ri(tmp,bp);\n"); /* Set C */
+		comprintf("\t live_flags();\n");
+		comprintf("\t end_needflags();\n");
+		comprintf("\t duplicate_carry();\n");
+		comprintf("if (!(needed_flags & FLAG_CZNV)) dont_care_flags();\n");
+	    }
+	    genastore ("data", curi->dmode, "dstreg", curi->size, "data");
+	}
+	break;
+
+     case i_ASL:
+	comprintf("\tdont_care_flags();\n");
+	mayfail;
+	/* Except for the handling of the V flag, this is identical to
+	   LSL. The handling of V is, uhm, unpleasant, so if it's needed,
+	   let the normal emulation handle it. Shoulders of giants kinda
+	   thing ;-) */
+	comprintf("if (needed_flags & FLAG_V) {\n"
+		  "  FAIL(1);\n"
+		  "  return 0;\n"
+		  "} \n");
+	
+	genamode (curi->smode, "srcreg", curi->size, "cnt", 1, 0);
+	genamode (curi->dmode, "dstreg", curi->size, "data", 1, 0);
+	if (curi->smode!=immi) {
+	    if (!noflags) {
+		uses_cmov;
+		start_brace();
+		comprintf("\tint highmask;\n"
+			  "\tint cdata=scratchie++;\n"
+			  "\tint tmpcnt=scratchie++;\n");
+		comprintf("\tmov_l_rr(tmpcnt,cnt);\n"
+			  "\tand_l_ri(tmpcnt,63);\n"
+			  "\tmov_l_ri(cdata,0);\n"
+			  "\tcmov_l_rr(cdata,data,5);\n");
+		/* cdata is now either data (for shift count!=0) or
+		   0 (for shift count==0) */
+		switch(curi->size) {
+		 case sz_byte: comprintf("\tshll_b_rr(data,cnt);\n"
+					 "\thighmask=0x38;\n"); 
+		 break;
+		 case sz_word: comprintf("\tshll_w_rr(data,cnt);\n"
+					 "\thighmask=0x30;\n"); 
+		 break;
+		 case sz_long: comprintf("\tshll_l_rr(data,cnt);\n"
+					 "\thighmask=0x20;\n"); 
+		 break;
+		 default: abort();
+		}
+		comprintf("test_l_ri(cnt,highmask);\n"
+			  "mov_l_ri(scratchie,0);\n"
+			  "cmov_l_rr(scratchie,data,4);\n");
+		switch(curi->size) {
+		 case sz_byte: comprintf("\tmov_b_rr(data,scratchie);\n");break;
+		 case sz_word: comprintf("\tmov_w_rr(data,scratchie);\n");break;
+		 case sz_long: comprintf("\tmov_l_rr(data,scratchie);\n");break;
+		 default: abort();
+		}
+		/* Result of shift is now in data. Now we need to determine
+		   the carry by shifting cdata one less */
+		comprintf("\tsub_l_ri(tmpcnt,1);\n");
+		switch(curi->size) {
+		 case sz_byte: comprintf("\tshll_b_rr(cdata,tmpcnt);\n");break;
+		 case sz_word: comprintf("\tshll_w_rr(cdata,tmpcnt);\n");break;
+		 case sz_long: comprintf("\tshll_l_rr(cdata,tmpcnt);\n");break;
+		 default: abort();
+		}
+		comprintf("test_l_ri(tmpcnt,highmask);\n"
+			  "mov_l_ri(scratchie,0);\n"
+			  "cmov_l_rr(cdata,scratchie,5);\n");
+		/* And create the flags */
+		comprintf("\tstart_needflags();\n");
+
+		comprintf("\tif (needed_flags & FLAG_ZNV)\n");
+		switch(curi->size) {
+		 case sz_byte: comprintf("\t  test_b_rr(data,data);\n"); 
+		    comprintf("\t bt_l_ri(cdata,7);\n"); break;
+		 case sz_word: comprintf("\t  test_w_rr(data,data);\n"); 
+		    comprintf("\t bt_l_ri(cdata,15);\n"); break;
+		 case sz_long: comprintf("\t  test_l_rr(data,data);\n"); 
+		    comprintf("\t bt_l_ri(cdata,31);\n"); break;
+		}
+		comprintf("\t live_flags();\n");
+		comprintf("\t end_needflags();\n");
+		comprintf("\t duplicate_carry();\n");
+		comprintf("if (!(needed_flags & FLAG_CZNV)) dont_care_flags();\n");
+		genastore ("data", curi->dmode, "dstreg", curi->size, "data");
+	    }
+	    else {
+		uses_cmov;
+		start_brace();
+		comprintf("\tint highmask;\n");
+		switch(curi->size) {
+		 case sz_byte: comprintf("\tshll_b_rr(data,cnt);\n"
+					 "\thighmask=0x38;\n"); 
+		    break;
+		 case sz_word: comprintf("\tshll_w_rr(data,cnt);\n"
+					 "\thighmask=0x30;\n"); 
+		    break;
+		 case sz_long: comprintf("\tshll_l_rr(data,cnt);\n"
+					 "\thighmask=0x20;\n"); 
+		    break;
+		 default: abort();
+		}
+		comprintf("test_l_ri(cnt,highmask);\n"
+			  "mov_l_ri(scratchie,0);\n"
+			  "cmov_l_rr(scratchie,data,4);\n");
+		switch(curi->size) {
+		 case sz_byte: comprintf("\tmov_b_rr(data,scratchie);\n");break;
+		 case sz_word: comprintf("\tmov_w_rr(data,scratchie);\n");break;
+		 case sz_long: comprintf("\tmov_l_rr(data,scratchie);\n");break;
+		 default: abort();
+		}
+		genastore ("data", curi->dmode, "dstreg", curi->size, "data");
+	    }
+	}
+	else {
+	    start_brace();
+	    comprintf("\tint tmp=scratchie++;\n"
+		      "\tint bp;\n"
+		      "\tmov_l_rr(tmp,data);\n");
+	    switch(curi->size) {
+	     case sz_byte: comprintf("\tshll_b_ri(data,srcreg);\n"
+				     "\tbp=8-srcreg;\n"); break;
+	     case sz_word: comprintf("\tshll_w_ri(data,srcreg);\n"
+				     "\tbp=16-srcreg;\n"); break;
+	     case sz_long: comprintf("\tshll_l_ri(data,srcreg);\n"
+				     "\tbp=32-srcreg;\n"); break;
+	     default: abort();
+	    }
+
+	    if (!noflags) {
+		comprintf("\tstart_needflags();\n");
+		comprintf("\tif (needed_flags & FLAG_ZNV)\n");
+		switch(curi->size) {
+		 case sz_byte: comprintf("\t  test_b_rr(data,data);\n"); break;
+		 case sz_word: comprintf("\t  test_w_rr(data,data);\n"); break;
+		 case sz_long: comprintf("\t  test_l_rr(data,data);\n"); break;
+		}
+		comprintf("\t bt_l_ri(tmp,bp);\n"); /* Set C */
+		comprintf("\t live_flags();\n");
+		comprintf("\t end_needflags();\n");
+		comprintf("\t duplicate_carry();\n");
+		comprintf("if (!(needed_flags & FLAG_CZNV)) dont_care_flags();\n");
+	    }
+	    genastore ("data", curi->dmode, "dstreg", curi->size, "data");
+	}
+	break;
+    
+     case i_LSR:
+	comprintf("\tdont_care_flags();\n");
+
+	genamode (curi->smode, "srcreg", curi->size, "cnt", 1, 0);
+	genamode (curi->dmode, "dstreg", curi->size, "data", 1, 0);
+	if (curi->smode!=immi) {
+	    if (!noflags) {
+		uses_cmov;
+		start_brace();
+		comprintf("\tint highmask;\n"
+			  "\tint cdata=scratchie++;\n"
+			  "\tint tmpcnt=scratchie++;\n");
+		comprintf("\tmov_l_rr(tmpcnt,cnt);\n"
+			  "\tand_l_ri(tmpcnt,63);\n"
+			  "\tmov_l_ri(cdata,0);\n"
+			  "\tcmov_l_rr(cdata,data,5);\n");
+		/* cdata is now either data (for shift count!=0) or
+		   0 (for shift count==0) */
+		switch(curi->size) {
+		 case sz_byte: comprintf("\tshrl_b_rr(data,cnt);\n"
+					 "\thighmask=0x38;\n"); 
+		 break;
+		 case sz_word: comprintf("\tshrl_w_rr(data,cnt);\n"
+					 "\thighmask=0x30;\n"); 
+		 break;
+		 case sz_long: comprintf("\tshrl_l_rr(data,cnt);\n"
+					 "\thighmask=0x20;\n"); 
+		 break;
+		 default: abort();
+		}
+		comprintf("test_l_ri(cnt,highmask);\n"
+			  "mov_l_ri(scratchie,0);\n"
+			  "cmov_l_rr(scratchie,data,4);\n");
+		switch(curi->size) {
+		 case sz_byte: comprintf("\tmov_b_rr(data,scratchie);\n");break;
+		 case sz_word: comprintf("\tmov_w_rr(data,scratchie);\n");break;
+		 case sz_long: comprintf("\tmov_l_rr(data,scratchie);\n");break;
+		 default: abort();
+		}
+		/* Result of shift is now in data. Now we need to determine
+		   the carry by shifting cdata one less */
+		comprintf("\tsub_l_ri(tmpcnt,1);\n");
+		switch(curi->size) {
+		 case sz_byte: comprintf("\tshrl_b_rr(cdata,tmpcnt);\n");break;
+		 case sz_word: comprintf("\tshrl_w_rr(cdata,tmpcnt);\n");break;
+		 case sz_long: comprintf("\tshrl_l_rr(cdata,tmpcnt);\n");break;
+		 default: abort();
+		}
+		comprintf("test_l_ri(tmpcnt,highmask);\n"
+			  "mov_l_ri(scratchie,0);\n"
+			  "cmov_l_rr(cdata,scratchie,5);\n");
+		/* And create the flags */
+		comprintf("\tstart_needflags();\n");
+		comprintf("\tif (needed_flags & FLAG_ZNV)\n");
+		switch(curi->size) {
+		 case sz_byte: comprintf("\t  test_b_rr(data,data);\n"); break;
+		 case sz_word: comprintf("\t  test_w_rr(data,data);\n"); break;
+		 case sz_long: comprintf("\t  test_l_rr(data,data);\n"); break;
+		}
+		comprintf("\t bt_l_ri(cdata,0);\n"); /* Set C */
+		comprintf("\t live_flags();\n");
+		comprintf("\t end_needflags();\n");
+		comprintf("\t duplicate_carry();\n");
+		comprintf("if (!(needed_flags & FLAG_CZNV)) dont_care_flags();\n");
+		genastore ("data", curi->dmode, "dstreg", curi->size, "data");
+	    }
+	    else {
+		uses_cmov;
+		start_brace();
+		comprintf("\tint highmask;\n");
+		switch(curi->size) {
+		 case sz_byte: comprintf("\tshrl_b_rr(data,cnt);\n"
+					 "\thighmask=0x38;\n"); 
+		    break;
+		 case sz_word: comprintf("\tshrl_w_rr(data,cnt);\n"
+					 "\thighmask=0x30;\n"); 
+		    break;
+		 case sz_long: comprintf("\tshrl_l_rr(data,cnt);\n"
+					 "\thighmask=0x20;\n"); 
+		    break;
+		 default: abort();
+		}
+		comprintf("test_l_ri(cnt,highmask);\n"
+			  "mov_l_ri(scratchie,0);\n"
+			  "cmov_l_rr(scratchie,data,4);\n");
+		switch(curi->size) {
+		 case sz_byte: comprintf("\tmov_b_rr(data,scratchie);\n");break;
+		 case sz_word: comprintf("\tmov_w_rr(data,scratchie);\n");break;
+		 case sz_long: comprintf("\tmov_l_rr(data,scratchie);\n");break;
+		 default: abort();
+		}
+		genastore ("data", curi->dmode, "dstreg", curi->size, "data");
+	    }
+	}
+	else {
+	    start_brace();
+	    comprintf("\tint tmp=scratchie++;\n"
+		      "\tint bp;\n"
+		      "\tmov_l_rr(tmp,data);\n");
+	    switch(curi->size) {
+	     case sz_byte: comprintf("\tshrl_b_ri(data,srcreg);\n"
+				     "\tbp=srcreg-1;\n"); break;
+	     case sz_word: comprintf("\tshrl_w_ri(data,srcreg);\n"
+				     "\tbp=srcreg-1;\n"); break;
+	     case sz_long: comprintf("\tshrl_l_ri(data,srcreg);\n"
+				     "\tbp=srcreg-1;\n"); break;
+	     default: abort();
+	    }
+
+	    if (!noflags) {
+		comprintf("\tstart_needflags();\n");
+		comprintf("\tif (needed_flags & FLAG_ZNV)\n");
+		switch(curi->size) {
+		 case sz_byte: comprintf("\t  test_b_rr(data,data);\n"); break;
+		 case sz_word: comprintf("\t  test_w_rr(data,data);\n"); break;
+		 case sz_long: comprintf("\t  test_l_rr(data,data);\n"); break;
+		}
+		comprintf("\t bt_l_ri(tmp,bp);\n"); /* Set C */
+		comprintf("\t live_flags();\n");
+		comprintf("\t end_needflags();\n");
+		comprintf("\t duplicate_carry();\n");
+		comprintf("if (!(needed_flags & FLAG_CZNV)) dont_care_flags();\n");
+	    }
+	    genastore ("data", curi->dmode, "dstreg", curi->size, "data");
+	}
+	break;
+
+     case i_LSL:
+	comprintf("\tdont_care_flags();\n");
+
+	genamode (curi->smode, "srcreg", curi->size, "cnt", 1, 0);
+	genamode (curi->dmode, "dstreg", curi->size, "data", 1, 0);
+	if (curi->smode!=immi) {
+	    if (!noflags) {
+		uses_cmov;
+		start_brace();
+		comprintf("\tint highmask;\n"
+			  "\tint cdata=scratchie++;\n"
+			  "\tint tmpcnt=scratchie++;\n");
+		comprintf("\tmov_l_rr(tmpcnt,cnt);\n"
+			  "\tand_l_ri(tmpcnt,63);\n"
+			  "\tmov_l_ri(cdata,0);\n"
+			  "\tcmov_l_rr(cdata,data,5);\n");
+		/* cdata is now either data (for shift count!=0) or
+		   0 (for shift count==0) */
+		switch(curi->size) {
+		 case sz_byte: comprintf("\tshll_b_rr(data,cnt);\n"
+					 "\thighmask=0x38;\n"); 
+		 break;
+		 case sz_word: comprintf("\tshll_w_rr(data,cnt);\n"
+					 "\thighmask=0x30;\n"); 
+		 break;
+		 case sz_long: comprintf("\tshll_l_rr(data,cnt);\n"
+					 "\thighmask=0x20;\n"); 
+		 break;
+		 default: abort();
+		}
+		comprintf("test_l_ri(cnt,highmask);\n"
+			  "mov_l_ri(scratchie,0);\n"
+			  "cmov_l_rr(scratchie,data,4);\n");
+		switch(curi->size) {
+		 case sz_byte: comprintf("\tmov_b_rr(data,scratchie);\n");break;
+		 case sz_word: comprintf("\tmov_w_rr(data,scratchie);\n");break;
+		 case sz_long: comprintf("\tmov_l_rr(data,scratchie);\n");break;
+		 default: abort();
+		}
+		/* Result of shift is now in data. Now we need to determine
+		   the carry by shifting cdata one less */
+		comprintf("\tsub_l_ri(tmpcnt,1);\n");
+		switch(curi->size) {
+		 case sz_byte: comprintf("\tshll_b_rr(cdata,tmpcnt);\n");break;
+		 case sz_word: comprintf("\tshll_w_rr(cdata,tmpcnt);\n");break;
+		 case sz_long: comprintf("\tshll_l_rr(cdata,tmpcnt);\n");break;
+		 default: abort();
+		}
+		comprintf("test_l_ri(tmpcnt,highmask);\n"
+			  "mov_l_ri(scratchie,0);\n"
+			  "cmov_l_rr(cdata,scratchie,5);\n");
+		/* And create the flags */
+		comprintf("\tstart_needflags();\n");
+		comprintf("\tif (needed_flags & FLAG_ZNV)\n");
+		switch(curi->size) {
+		 case sz_byte: comprintf("\t  test_b_rr(data,data);\n"); 
+		    comprintf("\t bt_l_ri(cdata,7);\n"); break;
+		 case sz_word: comprintf("\t  test_w_rr(data,data);\n"); 
+		    comprintf("\t bt_l_ri(cdata,15);\n"); break;
+		 case sz_long: comprintf("\t  test_l_rr(data,data);\n"); 
+		    comprintf("\t bt_l_ri(cdata,31);\n"); break;
+		}
+		comprintf("\t live_flags();\n");
+		comprintf("\t end_needflags();\n");
+		comprintf("\t duplicate_carry();\n");
+		comprintf("if (!(needed_flags & FLAG_CZNV)) dont_care_flags();\n");
+		genastore ("data", curi->dmode, "dstreg", curi->size, "data");
+	    }
+	    else {
+		uses_cmov;
+		start_brace();
+		comprintf("\tint highmask;\n");
+		switch(curi->size) {
+		 case sz_byte: comprintf("\tshll_b_rr(data,cnt);\n"
+					 "\thighmask=0x38;\n"); 
+		    break;
+		 case sz_word: comprintf("\tshll_w_rr(data,cnt);\n"
+					 "\thighmask=0x30;\n"); 
+		    break;
+		 case sz_long: comprintf("\tshll_l_rr(data,cnt);\n"
+					 "\thighmask=0x20;\n"); 
+		    break;
+		 default: abort();
+		}
+		comprintf("test_l_ri(cnt,highmask);\n"
+			  "mov_l_ri(scratchie,0);\n"
+			  "cmov_l_rr(scratchie,data,4);\n");
+		switch(curi->size) {
+		 case sz_byte: comprintf("\tmov_b_rr(data,scratchie);\n");break;
+		 case sz_word: comprintf("\tmov_w_rr(data,scratchie);\n");break;
+		 case sz_long: comprintf("\tmov_l_rr(data,scratchie);\n");break;
+		 default: abort();
+		}
+		genastore ("data", curi->dmode, "dstreg", curi->size, "data");
+	    }
+	}
+	else {
+	    start_brace();
+	    comprintf("\tint tmp=scratchie++;\n"
+		      "\tint bp;\n"
+		      "\tmov_l_rr(tmp,data);\n");
+	    switch(curi->size) {
+	     case sz_byte: comprintf("\tshll_b_ri(data,srcreg);\n"
+				     "\tbp=8-srcreg;\n"); break;
+	     case sz_word: comprintf("\tshll_w_ri(data,srcreg);\n"
+				     "\tbp=16-srcreg;\n"); break;
+	     case sz_long: comprintf("\tshll_l_ri(data,srcreg);\n"
+				     "\tbp=32-srcreg;\n"); break;
+	     default: abort();
+	    }
+
+	    if (!noflags) {
+		comprintf("\tstart_needflags();\n");
+		comprintf("\tif (needed_flags & FLAG_ZNV)\n");
+		switch(curi->size) {
+		 case sz_byte: comprintf("\t  test_b_rr(data,data);\n"); break;
+		 case sz_word: comprintf("\t  test_w_rr(data,data);\n"); break;
+		 case sz_long: comprintf("\t  test_l_rr(data,data);\n"); break;
+		}
+		comprintf("\t bt_l_ri(tmp,bp);\n"); /* Set C */
+		comprintf("\t live_flags();\n");
+		comprintf("\t end_needflags();\n");
+		comprintf("\t duplicate_carry();\n");
+		comprintf("if (!(needed_flags & FLAG_CZNV)) dont_care_flags();\n");
+	    }
+	    genastore ("data", curi->dmode, "dstreg", curi->size, "data");
+	}
+	break;
+
+     case i_ROL:
+	comprintf("\tdont_care_flags();\n");
+	genamode (curi->smode, "srcreg", curi->size, "cnt", 1, 0);
+	genamode (curi->dmode, "dstreg", curi->size, "data", 1, 0);
+	start_brace ();
+
+	switch(curi->size) {
+	 case sz_long: comprintf("\t rol_l_rr(data,cnt);\n"); break;
+	 case sz_word: comprintf("\t rol_w_rr(data,cnt);\n"); break;
+	 case sz_byte: comprintf("\t rol_b_rr(data,cnt);\n"); break;
+	}
+      
+	if (!noflags) {
+	    comprintf("\tstart_needflags();\n");
+	    comprintf("\tif (needed_flags & FLAG_ZNV)\n");
+	    switch(curi->size) {
+	     case sz_byte: comprintf("\t  test_b_rr(data,data);\n"); break;
+	     case sz_word: comprintf("\t  test_w_rr(data,data);\n"); break;
+	     case sz_long: comprintf("\t  test_l_rr(data,data);\n"); break;
+	    }
+	    comprintf("\t bt_l_ri(data,0x00);\n"); /* Set C */
+	    comprintf("\t live_flags();\n");
+	    comprintf("\t end_needflags();\n");
+	}
+	genastore ("data", curi->dmode, "dstreg", curi->size, "data");
+	break;
+
+     case i_ROR:
+	comprintf("\tdont_care_flags();\n");
+	genamode (curi->smode, "srcreg", curi->size, "cnt", 1, 0);
+	genamode (curi->dmode, "dstreg", curi->size, "data", 1, 0);
+	start_brace ();
+
+	switch(curi->size) {
+	 case sz_long: comprintf("\t ror_l_rr(data,cnt);\n"); break;
+	 case sz_word: comprintf("\t ror_w_rr(data,cnt);\n"); break;
+	 case sz_byte: comprintf("\t ror_b_rr(data,cnt);\n"); break;
+	}
+      
+	if (!noflags) {
+	    comprintf("\tstart_needflags();\n");
+	    comprintf("\tif (needed_flags & FLAG_ZNV)\n");
+	    switch(curi->size) {
+	     case sz_byte: comprintf("\t  test_b_rr(data,data);\n"); break;
+	     case sz_word: comprintf("\t  test_w_rr(data,data);\n"); break;
+	     case sz_long: comprintf("\t  test_l_rr(data,data);\n"); break;
+	    }
+	    switch(curi->size) {
+	     case sz_byte: comprintf("\t bt_l_ri(data,0x07);\n"); break;
+	     case sz_word: comprintf("\t bt_l_ri(data,0x0f);\n"); break;
+	     case sz_long: comprintf("\t bt_l_ri(data,0x1f);\n"); break;
+	    }
+	    comprintf("\t live_flags();\n");
+	    comprintf("\t end_needflags();\n");
+	}
+	genastore ("data", curi->dmode, "dstreg", curi->size, "data");
+	break;
+
+     case i_ROXL:
+	failure;
+	break;
+     case i_ROXR:
+	failure;
+	break;
+     case i_ASRW:
+	failure;
+	break;
+     case i_ASLW:
+	failure;
+	break;
+     case i_LSRW:
+	failure;
+	break;
+     case i_LSLW:
+	failure;
+	break;
+     case i_ROLW:
+	failure;
+	break;
+     case i_RORW:
+	failure;
+	break;
+     case i_ROXLW:
+	failure;
+	break;
+     case i_ROXRW:
+	failure;
+	break;
+     case i_MOVEC2:
+	isjump; 
+	failure;
+	break;
+     case i_MOVE2C:
+	isjump; 
+	failure;
+	break;
+     case i_CAS:
+	failure;
+	break;
+     case i_CAS2:
+	failure;
+	break;
+     case i_MOVES:		/* ignore DFC and SFC because we have no MMU */
+	isjump; 
+	failure;
+	break;
+     case i_BKPT:		/* only needed for hardware emulators */
+	isjump; 
+	failure;
+	break;
+     case i_CALLM:		/* not present in 68030 */
+	isjump; 
+	failure;
+	break;
+     case i_RTM:		/* not present in 68030 */
+	isjump; 
+	failure;
+	break;
+     case i_TRAPcc:
+	isjump; 
+	failure;
+	break;
+     case i_DIVL:
+	isjump; 
+	failure;
+	break;
+     case i_MULL:
+	if (!noflags) {
+	    failure;
+	    break;
+	}
+	comprintf("\tuae_u16 extra=%s;\n",gen_nextiword());
+	comprintf("\tint r2=(extra>>12)&7;\n"
+		  "\tint tmp=scratchie++;\n");
+       
+	genamode (curi->dmode, "dstreg", curi->size, "dst", 1, 0);
+	/* The two operands are in dst and r2 */
+	comprintf("\tif (extra&0x0400) {\n" /* Need full 64 bit result */
+		  "\tint r3=(extra&7);\n"
+		  "\tmov_l_rr(r3,dst);\n"); /* operands now in r3 and r2 */
+	comprintf("\tif (extra&0x0800) { \n" /* signed */
+		  "\t\timul_64_32(r2,r3);\n"
+		  "\t} else { \n"
+		  "\t\tmul_64_32(r2,r3);\n"
+		  "\t} \n");
+	/* The result is in r2/tmp, with r2 holding the lower 32 bits */
+	comprintf("\t} else {\n");  /* Only want 32 bit result */
+	/* operands in dst and r2, result foes into r2 */
+	/* shouldn't matter whether it's signed or unsigned?!? */
+	comprintf("\timul_32_32(r2,dst);\n"
+		  "\t}\n");
+	break;
+
+     case i_BFTST:
+     case i_BFEXTU:
+     case i_BFCHG:
+     case i_BFEXTS:
+     case i_BFCLR:
+     case i_BFFFO:
+     case i_BFSET:
+     case i_BFINS:
+	failure;
+	break;
+     case i_PACK:
+	failure;
+	break;
+     case i_UNPK:
+	failure;
+	break;
+     case i_TAS:
+	failure;
+	break;
+     case i_FPP:
+	mayfail;
+	comprintf("\tuae_u16 extra=%s;\n",gen_nextiword());
+	comprintf("\tcomp_fpp_opp(opcode,extra);\n");
+	break;
+     case i_FBcc:
+	isjump;
+	uses_cmov;
+	mayfail;
+	comprintf("\tcomp_fbcc_opp(opcode);\n");
+	break;
+     case i_FDBcc:
+	isjump; 
+	failure;
+	break;
+     case i_FScc:
+	mayfail;
+	uses_cmov;
+	comprintf("\tuae_u16 extra=%s;\n",gen_nextiword());
+	comprintf("\tcomp_fscc_opp(opcode,extra);\n");
+	break;
+     case i_FTRAPcc:
+	isjump; 
+	failure;
+	break;
+     case i_FSAVE:
+	failure;
+	break;
+     case i_FRESTORE:
+	failure;
+	break;
+
+     case i_CINVL:
+     case i_CINVP:
+     case i_CINVA:
+	isjump;  /* Not really, but it's probably a good idea to stop 
+		    translating at this point */
+	failure;
+	comprintf ("\tflush_icache();\n");  /* Differentiate a bit more? */
+	break;
+     case i_CPUSHL:
+     case i_CPUSHP:
+     case i_CPUSHA:
+	isjump;  /* Not really, but it's probably a good idea to stop 
+		    translating at this point */
+	failure;
+	break;
+     case i_MOVE16:
+	if ((opcode & 0xfff8) == 0xf620) {
+	    genmov16();
+	} else {
+	    isjump;
+	    failure;
+	}
+	break;
+
+     case i_MMUOP:
+	isjump; 
+	failure;
+	break;
+     default:
+	abort ();
+	break;
+    }
+    comprintf("%s",endstr);
+    finish_braces ();
+    sync_m68k_pc ();
+    if (global_mayfail)
+	comprintf("\tif (failure)  m68k_pc_offset=m68k_pc_offset_thisinst;\n");
+    return global_failure;
+}
+
+static void 
+generate_includes (FILE * f)
+{
+    fprintf (f, "#include \"sysconfig.h\"\n");
+    fprintf (f, "#include \"sysdeps.h\"\n");
+    fprintf (f, "#include \"config.h\"\n");
+    fprintf (f, "#include \"options.h\"\n");
+    fprintf (f, "#include \"memory.h\"\n");
+    fprintf (f, "#include \"custom.h\"\n");
+    fprintf (f, "#include \"events.h\"\n");
+    fprintf (f, "#include \"newcpu.h\"\n");
+    fprintf (f, "#include \"compiler.h\"\n");
+    fprintf (f, "#include \"comptbl.h\"\n");
+}
+
+static int postfix;
+
+static void 
+generate_one_opcode (int rp, int noflags)
+{
+    int i;
+    uae_u16 smsk, dmsk;
+    long int opcode = opcode_map[rp];
+    int aborted=0;
+    int have_srcreg=0;
+    int have_dstreg=0;
+
+    if (table68k[opcode].mnemo == i_ILLG
+	|| table68k[opcode].clev > cpu_level)
+	return;
+
+    for (i = 0; lookuptab[i].name[0]; i++)
+    {
+	if (table68k[opcode].mnemo == lookuptab[i].mnemo)
+	    break;
+    }
+
+    if (table68k[opcode].handler != -1)
+	return;
+
+    switch (table68k[opcode].stype)
+    {
+    case 0: smsk = 7; break;
+    case 1: smsk = 255; break;
+    case 2: smsk = 15;	break;
+    case 3: smsk = 7; break;
+    case 4: smsk = 7; break;
+    case 5: smsk = 63; break;
+    case 7: smsk = 3; break;
+    default: abort ();
+    }
+    dmsk = 7;
+
+    next_cpu_level = -1;
+    if (table68k[opcode].suse
+	&& table68k[opcode].smode != imm && table68k[opcode].smode != imm0
+	&& table68k[opcode].smode != imm1 && table68k[opcode].smode != imm2
+	&& table68k[opcode].smode != absw && table68k[opcode].smode != absl
+	&& table68k[opcode].smode != PC8r && table68k[opcode].smode != PC16)
+    {
+	have_srcreg=1;
+	if (table68k[opcode].spos == -1)
+	{
+	    if (((int) table68k[opcode].sreg) >= 128)
+		comprintf ("\tuae_s32 srcreg = (uae_s32)(uae_s8)%d;\n", (int) table68k[opcode].sreg);
+	    else
+		comprintf ("\tuae_s32 srcreg = %d;\n", (int) table68k[opcode].sreg);
+	}
+	else
+	{
+	    char source[100];
+	    int pos = table68k[opcode].spos;
+	  
+	    if (pos)
+		sprintf (source, "((opcode >> %d) & %d)", pos, smsk);
+	    else
+		sprintf (source, "(opcode & %d)", smsk);
+
+	    if (table68k[opcode].stype == 3)
+		comprintf ("\tuae_s32 srcreg = imm8_table[%s];\n", source);
+	    else if (table68k[opcode].stype == 1)
+		comprintf ("\tuae_s32 srcreg = (uae_s32)(uae_s8)%s;\n", source);
+	    else
+		comprintf ("\tuae_s32 srcreg = %s;\n", source);
+	}
+    }
+    if (table68k[opcode].duse
+	/* Yes, the dmode can be imm, in case of LINK or DBcc */
+	&& table68k[opcode].dmode != imm && table68k[opcode].dmode != imm0
+	&& table68k[opcode].dmode != imm1 && table68k[opcode].dmode != imm2
+	&& table68k[opcode].dmode != absw && table68k[opcode].dmode != absl)
+    {
+	have_dstreg=1;
+	if (table68k[opcode].dpos == -1)
+	{
+	    if (((int) table68k[opcode].dreg) >= 128)
+		comprintf ("\tuae_s32 dstreg = (uae_s32)(uae_s8)%d;\n", (int) table68k[opcode].dreg);
+	    else
+		comprintf ("\tuae_s32 dstreg = %d;\n", (int) table68k[opcode].dreg);
+	}
+	else
+	{
+	    int pos = table68k[opcode].dpos;
+	  
+	    if (pos)
+		comprintf ("\tuae_u32 dstreg = (opcode >> %d) & %d;\n",
+			   pos, dmsk);
+	    else
+		comprintf ("\tuae_u32 dstreg = opcode & %d;\n", dmsk);
+	}
+    }
+
+    if (have_srcreg && have_dstreg &&
+	(table68k[opcode].dmode==Areg || 
+	 table68k[opcode].dmode==Aind || 
+	 table68k[opcode].dmode==Aipi || 
+	 table68k[opcode].dmode==Apdi || 
+	 table68k[opcode].dmode==Ad16 || 
+	 table68k[opcode].dmode==Ad8r) &&
+	(table68k[opcode].smode==Areg || 
+	 table68k[opcode].smode==Aind || 
+	 table68k[opcode].smode==Aipi || 
+	 table68k[opcode].smode==Apdi || 
+	 table68k[opcode].smode==Ad16 || 
+	 table68k[opcode].smode==Ad8r) 
+	) {
+	comprintf("\tuae_u32 dodgy=(srcreg==(uae_s32)dstreg);\n");
+    }
+    else {
+	comprintf("\tuae_u32 dodgy=0;\n");
+    }
+    comprintf("\tuae_u32 m68k_pc_offset_thisinst=m68k_pc_offset;\n");
+    comprintf("\tm68k_pc_offset+=2;\n");
+
+    aborted=gen_opcode (opcode);
+    {
+	int flags=0;
+	if (global_isjump) flags|=1;
+	if (long_opcode)   flags|=2;
+	if (global_cmov)   flags|=4;
+	if (global_isaddx) flags|=8;
+	if (global_iscjump) flags|=16;
+	comprintf ("return 0;\n");
+	comprintf ("}\n");
+    
+	if (aborted) {
+	    fprintf (stblfile, "{ NULL, 0x%08x, %ld }, /* %s */\n", flags, opcode, lookuptab[i].name);
+	    com_discard();
+	}
+	else {
+	    if (noflags) {
+		fprintf (stblfile, "{ op_%lx_%d_comp_nf, 0x%08x, %ld }, /* %s */\n", opcode, postfix, flags, opcode, lookuptab[i].name);
+		fprintf (headerfile, "extern cpuop_func op_%lx_%d_comp_nf;\n", opcode, postfix);
+		printf ("unsigned long REGPARAM2 op_%lx_%d_comp_nf(uae_u32 opcode) /* %s */\n{\n", opcode, postfix, lookuptab[i].name);
+	    }
+	    else {
+		fprintf (stblfile, "{ op_%lx_%d_comp_ff, 0x%08x, %ld }, /* %s */\n", opcode, postfix, flags, opcode, lookuptab[i].name);
+		fprintf (headerfile, "extern cpuop_func op_%lx_%d_comp_ff;\n", opcode, postfix);
+		printf ("unsigned long REGPARAM2 op_%lx_%d_comp_ff(uae_u32 opcode) /* %s */\n{\n", opcode, postfix, lookuptab[i].name);
+	    }
+	    com_flush();
+	}
+    }
+    opcode_next_clev[rp] = next_cpu_level;
+    opcode_last_postfix[rp] = postfix;
+}
+
+static void 
+generate_func (int noflags)
+{
+    int i, j, rp;
+
+    using_prefetch = 0;
+    using_exception_3 = 0;
+    for (i = 0; i < 1; i++) /* We only do one level! */
+    {
+	cpu_level = 4 - i;
+	postfix = i;
+
+	if (noflags)
+	    fprintf (stblfile, "struct cputbl op_smalltbl_%d_comp_nf[] = {\n", postfix);
+	else
+	    fprintf (stblfile, "struct cputbl op_smalltbl_%d_comp_ff[] = {\n", postfix);
+
+
+	/* sam: this is for people with low memory (eg. me :)) */
+	!printf ("\n"
+		 "#if !defined(PART_1) && !defined(PART_2) && "
+		 "!defined(PART_3) && !defined(PART_4) && "
+		 "!defined(PART_5) && !defined(PART_6) && "
+		 "!defined(PART_7) && !defined(PART_8)"
+		 "\n"
+		 "#define PART_1 1\n"
+		 "#define PART_2 1\n"
+		 "#define PART_3 1\n"
+		 "#define PART_4 1\n"
+		 "#define PART_5 1\n"
+		 "#define PART_6 1\n"
+		 "#define PART_7 1\n"
+		 "#define PART_8 1\n"
+		 "#endif\n\n");
+
+	rp = 0;
+	for (j = 1; j <= 8; ++j)
+	{
+	    int k = (j * nr_cpuop_funcs) / 8;
+	    printf ("#ifdef PART_%d\n", j);
+	    for (; rp < k; rp++)
+		generate_one_opcode (rp,noflags);
+	    printf ("#endif\n\n");
+	}
+
+	fprintf (stblfile, "{ 0, 0,65536 }};\n");
+    }
+
+}
+
+int 
+main (int argc, char **argv)
+{
+    read_table68k ();
+    do_merges ();
+
+    opcode_map = (int *) xmalloc (sizeof (int) * nr_cpuop_funcs);
+    opcode_last_postfix = (int *) xmalloc (sizeof (int) * nr_cpuop_funcs);
+    opcode_next_clev = (int *) xmalloc (sizeof (int) * nr_cpuop_funcs);
+    counts = (unsigned long *) xmalloc (65536 * sizeof (unsigned long));
+    read_counts ();
+
+    /* It would be a lot nicer to put all in one file (we'd also get rid of
+     * cputbl.h that way), but cpuopti can't cope.  That could be fixed, but
+     * I don't dare to touch the 68k version.  */
+
+    headerfile = fopen ("comptbl.h", "wb");
+    stblfile = fopen ("compstbl.c", "wb");
+    freopen ("compemu.c", "wb", stdout);
+
+    generate_includes (stdout);
+    generate_includes (stblfile);
+
+    printf("#include \"compemu.h\"\n");
+
+    noflags=0;
+    generate_func (noflags);
+
+
+    opcode_map = (int *) xmalloc (sizeof (int) * nr_cpuop_funcs);
+    opcode_last_postfix = (int *) xmalloc (sizeof (int) * nr_cpuop_funcs);
+    opcode_next_clev = (int *) xmalloc (sizeof (int) * nr_cpuop_funcs);
+    counts = (unsigned long *) xmalloc (65536 * sizeof (unsigned long));
+    read_counts ();
+    noflags=1;
+    generate_func (noflags);
+
+    free (table68k);
+    return 0;
+}
Index: src/gencpu.c
===================================================================
RCS file: /usr/local/cvs/uae/src/gencpu.c,v
retrieving revision 1.53
diff -c -p -d -u -p -r1.53 gencpu.c
--- src/gencpu.c	2001/12/17 18:38:37	1.53
+++ src/gencpu.c	2002/02/09 18:48:43
@@ -1454,7 +1454,7 @@ static void gen_opcode (unsigned long in
 	    abort ();
 	}
 	printf ("\tSET_ZFLG (upper == reg || lower == reg);\n");
-	printf ("\tSET_CFLG (lower <= upper ? reg < lower || reg > upper : reg > upper || reg < lower);\n");
+	printf ("\tSET_CFLG_ALWAYS (lower <= upper ? reg < lower || reg > upper : reg > upper || reg < lower);\n");
 	printf ("\tif ((extra & 0x800) && GET_CFLG) { Exception(6,oldpc); goto %s; }\n}\n", endlabelstr);
 	need_endlabel = 1;
 	break;
@@ -1991,7 +1991,7 @@ static void gen_opcode (unsigned long in
 	    printf ("\ttmp = (bf0 << (offset & 7)) | (bf1 >> (8 - (offset & 7)));\n");
 	}
 	printf ("\ttmp >>= (32 - width);\n");
-	printf ("\tSET_NFLG (tmp & (1 << (width-1)) ? 1 : 0);\n");
+	printf ("\tSET_NFLG_ALWAYS (tmp & (1 << (width-1)) ? 1 : 0);\n");
 	printf ("\tSET_ZFLG (tmp == 0); SET_VFLG (0); SET_CFLG (0);\n");
 	switch (curi->mnemo) {
 	case i_BFTST:
@@ -2129,11 +2129,28 @@ static void gen_opcode (unsigned long in
 	break;
 
      case i_CINVL:
+	printf ("\tif (opcode&0x80)\n"
+		"\t\tflush_icache(31);\n"); 
+	break;
      case i_CINVP:
+	printf ("\tif (opcode&0x80)\n"
+		"\t\tflush_icache(32);\n"); 
+	break;
      case i_CINVA:
+	printf ("\tif (opcode&0x80)\n"
+		"\t\tflush_icache(33);\n"); 
+	break;
      case i_CPUSHL:
+	printf ("\tif (opcode&0x80)\n"
+		"\t\tflush_icache(41);\n"); 
+	break;
      case i_CPUSHP:
+	printf ("\tif (opcode&0x80)\n"
+		"\t\tflush_icache(42);\n"); 
+	break;
      case i_CPUSHA:
+	printf ("\tif (opcode&0x80)\n"
+		"\t\tflush_icache(43);\n"); 
 	break;
      case i_MOVE16:
 	 if ((opcode & 0xfff8) == 0xf620) {
@@ -2186,11 +2203,14 @@ static void generate_includes (FILE * f)
     fprintf (f, "#include \"options.h\"\n");
     fprintf (f, "#include \"memory.h\"\n");
     fprintf (f, "#include \"custom.h\"\n");
+    fprintf (f, "#include \"events.h\"\n");
     fprintf (f, "#include \"newcpu.h\"\n");
     fprintf (f, "#include \"compiler.h\"\n");
     fprintf (f, "#include \"cputbl.h\"\n");
     
     fprintf (f, "#define CPUFUNC(x) x##_ff\n"
+	     "#define SET_CFLG_ALWAYS(x) SET_CFLG(x)\n"
+	     "#define SET_NFLG_ALWAYS(x) SET_NFLG(x)\n"
 	     "#ifdef NOFLAGS\n"
 	     "#include \"noflags.h\"\n"
 	     "#endif\n");
Index: src/gtkui.c
===================================================================
RCS file: /usr/local/cvs/uae/src/gtkui.c,v
retrieving revision 1.36
retrieving revision 1.33.2.2
diff -c -p -d -u -p -r1.36 -r1.33.2.2
--- src/gtkui.c	2002/02/16 19:26:25	1.36
+++ src/gtkui.c	2002/02/16 20:06:59	1.33.2.2
@@ -18,6 +18,7 @@
 
 #include "config.h"
 #include "options.h"
+#include "events.h"
 #include "uae.h"
 #include "memory.h"
 #include "custom.h"
@@ -27,6 +28,7 @@
 #include "threaddep/thread.h"
 #include "sounddep/sound.h"
 #include "savestate.h"
+#include "compemu.h"
 #include "debug.h"
 
 #include <gtk/gtk.h>
@@ -73,6 +75,12 @@ static GtkWidget *fcop_widget;
 static GtkAdjustment *framerate_adj;
 static GtkWidget *bimm_widget, *b32_widget, *afscr_widget, *pfscr_widget;
 
+static GtkWidget *compbyte_widget[4], *compword_widget[4], *complong_widget[4];
+static GtkWidget *compaddr_widget[4], *compnf_widget[2], *comp_midopt_widget[2];
+static GtkWidget *comp_lowopt_widget[2], *compfpu_widget[2], *comp_hardflush_widget[2];
+static GtkWidget *comp_constjump_widget[2];
+static GtkAdjustment *cachesize_adj;
+
 static GtkWidget *joy_widget[2][6];
 
 static GtkWidget *led_widgets[5];
@@ -230,6 +238,25 @@ static void set_mem_state (void)
     gtk_label_set_text (GTK_LABEL (key_text_widget), currprefs.keyfile);
 }
 
+static void set_comp_state (void)
+{
+    gtk_toggle_button_set_active (GTK_TOGGLE_BUTTON (compbyte_widget[currprefs.comptrustbyte]), 1);
+    gtk_toggle_button_set_active (GTK_TOGGLE_BUTTON (compword_widget[currprefs.comptrustword]), 1);
+    gtk_toggle_button_set_active (GTK_TOGGLE_BUTTON (complong_widget[currprefs.comptrustlong]), 1);
+    gtk_toggle_button_set_active (GTK_TOGGLE_BUTTON (compaddr_widget[currprefs.comptrustnaddr]), 1);
+    gtk_toggle_button_set_active (GTK_TOGGLE_BUTTON (compnf_widget[currprefs.compnf]), 1);
+    gtk_toggle_button_set_active (GTK_TOGGLE_BUTTON (comp_hardflush_widget[currprefs.comp_hardflush]), 1);
+    gtk_toggle_button_set_active (GTK_TOGGLE_BUTTON (comp_constjump_widget[currprefs.comp_constjump]), 1);
+
+    gtk_toggle_button_set_active (GTK_TOGGLE_BUTTON (compfpu_widget[currprefs.compfpu]), 1);
+#if USE_OPTIMIZER
+    gtk_toggle_button_set_active (GTK_TOGGLE_BUTTON (comp_midopt_widget[currprefs.comp_midopt]), 1);
+#endif
+#if USE_LOW_OPTIMIZER
+    gtk_toggle_button_set_active (GTK_TOGGLE_BUTTON (comp_lowopt_widget[currprefs.comp_lowopt]), 1);
+#endif
+}
+
 static void set_joy_state (void)
 {
     int j0t = changed_prefs.jport0;
@@ -337,6 +364,7 @@ static int my_idle (void)
 	    set_gfx_state ();
 	    set_joy_state ();
 	    set_sound_state ();
+	    set_comp_state ();
 	    set_mem_state ();
 	    set_hd_state ();
 	    set_chipset_state ();
@@ -500,6 +528,25 @@ static void sound_changed (void)
     changed_prefs.sound_bits = (find_current_toggle (sound_bits_widget, 2) + 1) * 8;
 }
 
+static void comp_changed (void)
+{
+  changed_prefs.cachesize=cachesize_adj->value;
+  changed_prefs.comptrustbyte = find_current_toggle (compbyte_widget, 4);
+  changed_prefs.comptrustword = find_current_toggle (compword_widget, 4);
+  changed_prefs.comptrustlong = find_current_toggle (complong_widget, 4);
+  changed_prefs.comptrustnaddr = find_current_toggle (compaddr_widget, 4);
+  changed_prefs.compnf = find_current_toggle (compnf_widget, 2);
+  changed_prefs.comp_hardflush = find_current_toggle (comp_hardflush_widget, 2);
+  changed_prefs.comp_constjump = find_current_toggle (comp_constjump_widget, 2);
+  changed_prefs.compfpu= find_current_toggle (compfpu_widget, 2);
+#if USE_OPTIMIZER
+  changed_prefs.comp_midopt = find_current_toggle (comp_midopt_widget, 2);
+#endif
+#if USE_LOW_OPTIMIZER
+  changed_prefs.comp_lowopt = find_current_toggle (comp_lowopt_widget, 2);
+#endif
+}
+
 static void did_reset (void)
 {
     if (quit_gui)
@@ -1271,6 +1318,101 @@ static void make_mem_widgets (GtkWidget 
     gtk_box_pack_start (GTK_BOX (hbox), frame, FALSE, TRUE, 0);
 }
 
+static void make_comp_widgets (GtkWidget *vbox)
+{
+    GtkWidget *frame, *newbox;
+    int i;
+    GtkWidget *hbox;
+    static const char *complabels1[] = {
+	"Direct", "Indirect", "Indirect for KS", "Direct after Picasso",
+	NULL
+    },*complabels2[] = {
+	"Direct", "Indirect", "Indirect for KS", "Direct after Picasso", 
+	NULL
+    },*complabels3[] = {
+	"Direct", "Indirect", "Indirect for KS", "Direct after Picasso", 
+	NULL
+    },*complabels3a[] = {
+	"Direct", "Indirect", "Indirect for KS", "Direct after Picasso", 
+	NULL
+    }, *complabels4[] = {
+      "Always generate", "Only generate when needed",
+	NULL
+    }, *complabels5[] = {
+      "Disable", "Enable",
+	NULL
+    }, *complabels6[] = {
+      "Disable", "Enable",
+	NULL
+    }, *complabels7[] = {
+      "Disable", "Enable",
+	NULL
+    }, *complabels8[] = {
+      "Soft", "Hard",
+	NULL
+    }, *complabels9[] = {
+      "Disable", "Enable", 
+	NULL
+    };
+    GtkWidget *thing;
+
+    add_empty_vbox (vbox);
+
+    newbox = make_radio_group_box ("Byte access", complabels1, compbyte_widget, 1, comp_changed);
+    gtk_widget_show (newbox);
+    add_centered_to_vbox (vbox, newbox);
+    newbox = make_radio_group_box ("Word access", complabels2, compword_widget, 1, comp_changed);
+    gtk_widget_show (newbox);
+    add_centered_to_vbox (vbox, newbox);
+    newbox = make_radio_group_box ("Long access", complabels3, complong_widget, 1, comp_changed);
+    gtk_widget_show (newbox);
+    add_centered_to_vbox (vbox, newbox);
+    newbox = make_radio_group_box ("Address lookup", complabels3a, compaddr_widget, 1, comp_changed);
+    gtk_widget_show (newbox);
+    add_centered_to_vbox (vbox, newbox);
+
+    newbox = make_radio_group_box ("Flags", complabels4, compnf_widget, 1, comp_changed);
+    gtk_widget_show (newbox);
+    add_centered_to_vbox (vbox, newbox);
+
+    newbox = make_radio_group_box ("Icache flushes", complabels8, comp_hardflush_widget, 1, comp_changed);
+    gtk_widget_show (newbox);
+    add_centered_to_vbox (vbox, newbox);
+
+    newbox = make_radio_group_box ("Compile through uncond branch", complabels9, comp_constjump_widget, 1, comp_changed);
+    gtk_widget_show (newbox);
+    add_centered_to_vbox (vbox, newbox);
+
+    newbox = make_radio_group_box ("JIT FPU compiler", complabels7, compfpu_widget, 1, comp_changed);
+    gtk_widget_show (newbox);
+    add_centered_to_vbox (vbox, newbox);
+
+#if USE_OPTIMIZER
+    newbox = make_radio_group_box ("Mid Level Optimizer", complabels5, comp_midopt_widget, 1, comp_changed);
+    gtk_widget_show (newbox);
+    add_centered_to_vbox (vbox, newbox);
+#endif
+
+#if USE_LOW_OPTIMIZER
+    newbox = make_radio_group_box ("Low Level Optimizer", complabels6, comp_lowopt_widget, 1, comp_changed);
+    gtk_widget_show (newbox);
+    add_centered_to_vbox (vbox, newbox);
+#endif
+
+    cachesize_adj = GTK_ADJUSTMENT (gtk_adjustment_new (currprefs.cachesize, 0.0, 16384.0, 1.0, 1.0, 1.0));
+    gtk_signal_connect (GTK_OBJECT (cachesize_adj), "value_changed",
+			GTK_SIGNAL_FUNC (comp_changed), NULL);
+
+    thing = gtk_hscale_new (cachesize_adj);
+    gtk_range_set_update_policy (GTK_RANGE (thing), GTK_UPDATE_DELAYED);
+    gtk_scale_set_digits (GTK_SCALE (thing), 0);
+    gtk_scale_set_value_pos (GTK_SCALE (thing), GTK_POS_RIGHT);
+    add_labelled_widget_centered ("Translation buffer(kB):", thing, vbox);
+
+    add_empty_vbox (vbox);
+}
+
+
 static void make_joy_widgets (GtkWidget *dvbox)
 {
     int i;
@@ -1535,6 +1677,7 @@ static void create_guidlg (void)
 	{ "Graphics", make_gfx_widgets },
 	{ "Chipset", make_chipset_widgets },
 	{ "Sound", make_sound_widgets },
+ 	{ "JIT", make_comp_widgets },
 	{ "Game ports", make_joy_widgets },
 	{ "Harddisks", make_hd_widgets },
 	{ "About", make_about_widgets }
Index: src/hardfile.c
===================================================================
RCS file: /usr/local/cvs/uae/src/hardfile.c,v
retrieving revision 1.23
retrieving revision 1.23.2.1
diff -c -p -d -u -p -r1.23 -r1.23.2.1
--- src/hardfile.c	2000/08/25 21:29:41	1.23
+++ src/hardfile.c	2002/02/06 15:09:19	1.23.2.1
@@ -13,6 +13,7 @@
 #include "options.h"
 #include "memory.h"
 #include "custom.h"
+#include "events.h"
 #include "newcpu.h"
 #include "disk.h"
 #include "autoconf.h"
Index: src/main.c
===================================================================
RCS file: /usr/local/cvs/uae/src/main.c,v
retrieving revision 1.91
diff -c -p -d -u -p -r1.91 main.c
--- src/main.c	2001/12/17 18:38:38	1.91
+++ src/main.c	2002/02/10 11:39:58
@@ -17,10 +17,10 @@
 #include "gensound.h"
 #include "audio.h"
 #include "sounddep/sound.h"
-#include "events.h"
 #include "memory.h"
 #include "custom.h"
 #include "serial.h"
+#include "events.h"
 #include "newcpu.h"
 #include "disk.h"
 #include "debug.h"
@@ -119,6 +119,35 @@ void default_prefs (struct uae_prefs *p)
     p->sound_maxbsiz = DEFAULT_SOUND_MAXB;
     p->sound_interpol = 0;
 
+    p->comptrustbyte = 0;
+    p->comptrustword = 0;
+    p->comptrustlong = 0;
+    p->comptrustnaddr= 0;
+    p->compnf=1;
+    p->comp_hardflush=0;
+    p->comp_constjump=1;
+    p->comp_oldsegv=0;
+    p->compfpu=1;
+    p->compforcesettings=0;
+    p->cachesize=4096;
+    p->avoid_cmov=0;
+    p->avoid_dga=0;
+    p->avoid_vid=0;
+    p->comp_midopt=0;
+    p->comp_lowopt=0;
+    p->override_dga_address=0;
+    {
+	int i;
+	for (i=0;i<10;i++)
+	    p->optcount[i]=-1;
+	p->optcount[0]=4; /* How often a block has to be executed before it
+			     is translated */
+	p->optcount[1]=0; /* How often to use the naive translation */
+	p->optcount[2]=0; 
+	p->optcount[3]=0;
+	p->optcount[4]=0;
+	p->optcount[5]=0;
+    }
     p->gfx_framerate = 1;
     p->gfx_width = 800;
     p->gfx_height = 600;
@@ -261,6 +290,52 @@ static void fix_options (void)
 	currprefs.produce_sound = 0;
 	err = 1;
     }
+    if (currprefs.comptrustbyte < 0 || currprefs.comptrustbyte > 3) {
+	fprintf (stderr, "Bad value for comptrustbyte parameter: value must be within 0..2\n");
+	currprefs.comptrustbyte = 1;
+	err = 1;
+    }
+    if (currprefs.comptrustword < 0 || currprefs.comptrustword > 3) {
+	fprintf (stderr, "Bad value for comptrustword parameter: value must be within 0..2\n");
+	currprefs.comptrustword = 1;
+	err = 1;
+    }
+    if (currprefs.comptrustlong < 0 || currprefs.comptrustlong > 3) {
+	fprintf (stderr, "Bad value for comptrustlong parameter: value must be within 0..2\n");
+	currprefs.comptrustlong = 1;
+	err = 1;
+    }
+    if (currprefs.comptrustnaddr < 0 || currprefs.comptrustnaddr > 3) {
+	fprintf (stderr, "Bad value for comptrustnaddr parameter: value must be within 0..2\n");
+	currprefs.comptrustnaddr = 1;
+	err = 1;
+    }
+    if (currprefs.compnf < 0 || currprefs.compnf > 1) {
+	fprintf (stderr, "Bad value for compnf parameter: value must be within 0..1\n");
+	currprefs.compnf = 1;
+	err = 1;
+    }
+    if (currprefs.comp_hardflush < 0 || currprefs.comp_hardflush > 1) {
+	fprintf (stderr, "Bad value for comp_hardflush parameter: value must be within 0..1\n");
+	currprefs.comp_hardflush = 1;
+	err = 1;
+    }
+    if (currprefs.comp_constjump < 0 || currprefs.comp_constjump > 1) {
+	fprintf (stderr, "Bad value for comp_constjump parameter: value must be within 0..1\n");
+	currprefs.comp_constjump = 1;
+	err = 1;
+    }
+    if (currprefs.comp_oldsegv < 0 || currprefs.comp_oldsegv > 1) {
+	fprintf (stderr, "Bad value for comp_oldsegv parameter: value must be within 0..1\n");
+	currprefs.comp_oldsegv = 1;
+	err = 1;
+    }
+    if (currprefs.cachesize < 0 || currprefs.cachesize > 16384) {
+	fprintf (stderr, "Bad value for cachesize parameter: value must be within 0..16384\n");
+	currprefs.cachesize = 2048;
+	err = 1;
+    }
+
     if (currprefs.cpu_level < 2 && currprefs.z3fastmem_size > 0) {
 	write_log ("Z3 fast memory can't be used with a 68000/68010 emulation. It\n"
 		 "requires a 68020 emulation. Turning off Z3 fast memory.\n");
Index: src/memory.c
===================================================================
RCS file: /usr/local/cvs/uae/src/memory.c,v
retrieving revision 1.56
retrieving revision 1.55.2.3
diff -c -p -d -u -p -r1.56 -r1.55.2.3
--- src/memory.c	2002/02/16 14:29:42	1.56
+++ src/memory.c	2002/02/16 20:06:59	1.55.2.3
@@ -1032,7 +1032,7 @@ uae_u8 *mapped_malloc (size_t s, char *f
     if (!canbang)
 	return malloc (s);
 
-    id = shmget (IPC_PRIVATE, s, 0x1ff, file);
+    id = shmget (IPC_PRIVATE, s, 0x1ff);
     if (id == 1) {
 	canbang = 0;
 	return mapped_malloc (s, file);
@@ -1187,7 +1187,8 @@ void memory_reset (void)
 	map_banks (&bogomem_bank, 0xC0, t, allocated_bogomem);
     }
     if (a3000memory != 0)
-	map_banks (&a3000mem_bank, a3000mem_start >> 16, allocated_a3000mem >> 16, allocated_a3000mem);
+	map_banks (&a3000mem_bank, a3000mem_start >> 16, allocated_a3000mem >> 16,
+		   allocated_a3000mem);
 
     map_banks (&rtarea_bank, RTAREA_BASE >> 16, 1, 0);
 
@@ -1207,8 +1208,63 @@ void memory_reset (void)
 	if (cloanto_rom)
 	    map_banks (&kickmem_bank, 0xE0, 8, 0);
     }
+
+    {
+	int dummy;
+	__asm__ __volatile__ ("mov %%gs:0,%0" : "=r" (dummy));
+    }
+}
+
+#if defined __i386__ && defined __linux__
+
+#include <sys/syscall.h>
+
+struct modify_ldt_ldt_s {
+    unsigned int  entry_number;
+    unsigned long base_addr;
+    unsigned int  limit;
+    unsigned int  seg_32bit:1;
+    unsigned int  contents:2;
+    unsigned int  read_exec_only:1;
+    unsigned int  limit_in_pages:1;
+    unsigned int  seg_not_present:1;
+    unsigned int  useable:1;
+};
+
+static inline int modify_ldt( int func, struct modify_ldt_ldt_s *ptr,
+                                  unsigned long count )
+{
+    int res;
+    __asm__ __volatile__("int $0x80"
+                         : "=a" (res)
+                         : "0" (SYS_modify_ldt),
+                           "b" (func),
+                           "c" (ptr),
+                           "d" (count) );
+    return res;
 }
 
+#define MODIFY_LDT_CONTENTS_DATA        0
+#define MODIFY_LDT_CONTENTS_STACK       1
+#define MODIFY_LDT_CONTENTS_CODE        2
+
+static void setup_ldt (void)
+{
+    struct modify_ldt_ldt_s entry;
+    entry.entry_number = 1;
+    entry.base_addr = NATMEM_OFFSET;
+    entry.limit = 0x80000000 >> 12;
+    entry.contents = MODIFY_LDT_CONTENTS_DATA;
+    entry.read_exec_only = 0;
+    entry.limit_in_pages = 1;
+    entry.seg_not_present = 0;
+    entry.useable = 1;
+    modify_ldt (1, &entry, sizeof entry);
+    __asm__ __volatile__ ("mov %0,%%gs" : : "r" (15));
+}
+
+#endif
+
 void memory_init (void)
 {
     allocated_chipmem = 0;
@@ -1228,6 +1284,8 @@ void memory_init (void)
 	init_ersatz_rom (kickmemory);
 	ersatzkickfile = 1;
     }
+
+    setup_ldt ();
 
     init_mem_banks ();
     memory_reset ();
Index: src/native2amiga.c
===================================================================
RCS file: /usr/local/cvs/uae/src/native2amiga.c,v
retrieving revision 1.5
retrieving revision 1.5.2.1
diff -c -p -d -u -p -r1.5 -r1.5.2.1
--- src/native2amiga.c	2001/11/19 17:58:46	1.5
+++ src/native2amiga.c	2002/02/06 15:09:19	1.5.2.1
@@ -17,6 +17,7 @@
 #include "options.h"
 #include "memory.h"
 #include "custom.h"
+#include "events.h"
 #include "newcpu.h"
 #include "disk.h"
 #include "autoconf.h"
Index: src/newcpu.c
===================================================================
RCS file: /usr/local/cvs/uae/src/newcpu.c,v
retrieving revision 1.67
retrieving revision 1.66.2.3
diff -c -p -d -u -p -r1.67 -r1.66.2.3
--- src/newcpu.c	2002/02/16 14:18:13	1.67
+++ src/newcpu.c	2002/02/16 20:06:59	1.66.2.3
@@ -6,6 +6,13 @@
   * (c) 1995 Bernd Schmidt
   */
 
+/* Lots of workarounds for gcc 2.95.* compiler problems tagged as "FIXME".
+   The compiler should be fixed, not the app! */
+
+extern unsigned long foink;
+extern unsigned long foink2;
+extern unsigned long foink3;
+
 #include "sysconfig.h"
 #include "sysdeps.h"
 
@@ -24,6 +31,23 @@
 #include "savestate.h"
 #include "blitter.h"
 
+#ifdef JIT
+#include "compemu.h"
+#include <signal.h>
+extern void vec(int x, struct siginfo* si, struct sigcontext* sc);
+#else
+/* Need to have these somewhere */
+static void build_comp(void) {}
+void check_prefs_changed_comp (void) {}
+#endif
+
+static int stop_compile;
+int oink=0;
+/* For faster cycles handling */
+signed long pissoff=0;
+/* Counter for missed vsyncmintime deadlines */
+int gonebad=0;
+
 /* Opcode of faulting instruction */
 uae_u16 last_op_for_exception_3;
 /* PC at fault time */
@@ -44,6 +68,8 @@ int fpp_movem_next[256];
 
 cpuop_func *cpufunctbl[65536];
 
+extern uae_u32 get_fpsr(void);
+
 #define COUNT_INSTRS 0
 
 #if COUNT_INSTRS
@@ -96,11 +122,12 @@ void dump_counts (void)
 }
 #endif
 
+
 int broken_in;
 
-static unsigned long op_illg_1 (uae_u32 opcode) REGPARAM;
+unsigned long op_illg_1 (uae_u32 opcode) REGPARAM;
 
-static unsigned long REGPARAM2 op_illg_1 (uae_u32 opcode)
+unsigned long REGPARAM2 op_illg_1 (uae_u32 opcode)
 {
     op_illg (opcode);
     return 4;
@@ -143,6 +170,7 @@ static void build_cpufunctbl (void)
 	if (tbl[i].specific)
 	    cpufunctbl[tbl[i].opcode] = tbl[i].handler;
     }
+    build_comp();
 }
 
 unsigned long cycles_mask, cycles_val;
@@ -681,12 +709,13 @@ void MakeFromSR (void)
 	unset_special (SPCFLAG_TRACE);
 }
 
-void Exception(int nr, uaecptr oldpc)
+void Exception (int nr, uaecptr oldpc)
 {
     uae_u32 currpc = m68k_getpc ();
 
-    compiler_flush_jsr_stack();
-    MakeSR();
+    stop_compile = 1;
+    compiler_flush_jsr_stack ();
+    MakeSR ();
 
     if (!regs.s) {
 	regs.usp = m68k_areg(regs, 7);
@@ -746,6 +775,7 @@ kludge_me_do:
     m68k_areg(regs, 7) -= 2;
     put_word (m68k_areg(regs, 7), regs.sr);
     m68k_setpc (get_long (regs.vbr + 4*nr));
+    set_special(SPCFLAG_END_COMPILE);
     fill_prefetch_0 ();
     regs.t1 = regs.t0 = regs.m = 0;
     unset_special (SPCFLAG_TRACE | SPCFLAG_DOTRACE);
@@ -776,7 +806,23 @@ int m68k_move2c (int regno, uae_u32 *reg
 	switch (regno) {
 	case 0: regs.sfc = *regp & 7; break;
 	case 1: regs.dfc = *regp & 7; break;
-	case 2: cacr = *regp & (currprefs.cpu_level < 4 ? 0x3 : 0x80008000); break;
+	 case 2: 
+	    cacr = *regp & (currprefs.cpu_level < 4 ? 0x3 : 0x80008000);
+#ifdef JIT
+	    if (currprefs.cpu_level<4) {
+		set_cache_state(cacr&1);
+		if (*regp&0x08) {
+		    flush_icache(1);
+		}
+	    }
+	    else {
+		set_cache_state((cacr&0x8000)||0);
+		if (*regp&0x08) {   /* Just to be on the safe side */
+		    flush_icache(2);
+		}
+	    }
+#endif
+	    break;
 	case 3: tc = *regp & 0xc000; break;
 	    /* Mask out fields that should be zero.  */
 	case 4: itt0 = *regp & 0xffffe364; break;
@@ -1123,6 +1169,17 @@ void m68k_reset (void)
     regs.intmask = 7;
     regs.vbr = regs.sfc = regs.dfc = 0;
     regs.fpcr = regs.fpsr = regs.fpiar = 0;
+    regs.fp_result=1;
+}
+
+STATIC_INLINE int in_rom (uaecptr pc)
+{
+    return (munge24 (pc) & 0xFFF80000) == 0xF80000;
+}
+
+STATIC_INLINE int in_rtarea (uaecptr pc)
+{
+    return (munge24 (pc) & 0xFFFF0000) == RTAREA_BASE;
 }
 
 unsigned long REGPARAM2 op_illg (uae_u32 opcode)
@@ -1137,28 +1194,28 @@ unsigned long REGPARAM2 op_illg (uae_u32
     }
 
     compiler_flush_jsr_stack ();
-    if (opcode == 0x4E7B && get_long (0x10) == 0 && (pc & 0xF80000) == 0xF80000) {
+    if (opcode == 0x4E7B && get_long (0x10) == 0 && in_rom (pc)) {
 	write_log ("Your Kickstart requires a 68020 CPU. Giving up.\n");
 	broken_in = 1;
 	set_special (SPCFLAG_BRK);
 	quit_program = 1;
     }
     if (opcode == 0xFF0D) {
-	if ((pc & 0xF80000) == 0xF80000) {
+	if (in_rom (pc)) {
 	    /* This is from the dummy Kickstart replacement */
 	    uae_u16 arg = get_iword (2);
 	    m68k_incpc (4);
 	    ersatz_perform (arg);
 	    fill_prefetch_0 ();
 	    return 4;
-	} else if ((pc & 0xFFFF0000) == RTAREA_BASE) {
+	} else if (in_rtarea (pc)) {
 	    /* User-mode STOP replacement */
 	    m68k_setstopped (1);
 	    return 4;
 	}
     }
 
-    if ((opcode & 0xF000) == 0xA000 && (pc & 0xFFFF0000) == RTAREA_BASE) {
+    if ((opcode & 0xF000) == 0xA000 && in_rtarea (pc)) {
 	/* Calltrap. */
 	m68k_incpc(2);
 	call_calltrap (opcode & 0xFFF);
@@ -1167,11 +1224,12 @@ unsigned long REGPARAM2 op_illg (uae_u32
     }
 
     if ((opcode & 0xF000) == 0xF000) {
+ 	write_log ("B-Trap %x at %x (%p)\n", opcode, m68k_getpc () + m68kpc_offset, regs.pc_p);
 	Exception(0xB,0);
 	return 4;
     }
     if ((opcode & 0xF000) == 0xA000) {
-	if ((pc & 0xFFFF0000) == RTAREA_BASE) {
+	if (in_rtarea (pc)) {
 	    /* Calltrap. */
 	    call_calltrap (opcode & 0xFFF);
 	}
@@ -1243,6 +1301,7 @@ static int do_specialties (void)
 	do_copper ();
 
     /*n_spcinsns++;*/
+    unset_special(SPCFLAG_END_COMPILE);   /* has done its job */
     while (regs.spcflags & SPCFLAG_BLTNASTY) {
 	int c = blitnasty();
 	if (!c)
@@ -1301,7 +1360,7 @@ static void m68k_run_1 (void)
     uae_u16 *oldpcp;
 #endif
     for (;;) {
-	int cycles;
+	int local_cycles;
 	uae_u32 opcode = get_iword_prefetch (0);
 #ifdef DEBUG_PREFETCH
 	if (get_ilong (0) != do_get_mem_long (&regs.prefetch)) {
@@ -1321,12 +1380,13 @@ static void m68k_run_1 (void)
 	instrcount[opcode]++;
 #endif
 #if defined X86_ASSEMBLY
-	__asm__ __volatile__("\tcall *%%ebx"
-			     : "=&a" (cycles) : "b" (cpufunctbl[opcode]), "0" (opcode)
+	__asm__ __volatile__("\tpush %%ebp\n\tcall *%%ebx\n\tpop %%ebp" /* FIXME */
+			     : "=&a" (local_cycles) 
+			     : "b" (cpufunctbl[opcode]), "0" (opcode)
 			     : "%edx", "%ecx",
 			     "%esi", "%edi", "%ebp", "memory", "cc");
 #else
-	cycles = (*cpufunctbl[opcode])(opcode);
+	local_cycles = (*cpufunctbl[opcode])(opcode);
 #endif
 #ifdef DEBUG_PREFETCH
 	if (memcmp (saved_bytes, oldpcp, 20) != 0) {
@@ -1335,10 +1395,11 @@ static void m68k_run_1 (void)
 	    debugging = 1;
 	}
 #endif
+
 	/*n_insns++;*/
-	cycles &= cycles_mask;
-	cycles |= cycles_val;
-	do_cycles (cycles);
+	local_cycles &= cycles_mask;
+	local_cycles |= cycles_val;
+	do_cycles (local_cycles);
 	if (regs.spcflags) {
 	    if (do_specialties ())
 		return;
@@ -1348,6 +1409,113 @@ static void m68k_run_1 (void)
 
 #define DEBUG_PREFETCH
 
+#ifdef JIT  /* Completely different run_2 replacement */
+
+void do_nothing(void)
+{
+    /* What did you expect this to do? */
+    do_cycles(0);
+    /* I bet you didn't expect *that* ;-) */
+}
+
+void exec_nostats(void)
+{
+    int new_cycles;
+
+    for (;;) 
+    { 
+	/* gcc bug! */
+	__volatile__ uae_u16 opcode=get_iword(0);
+#if defined X86_ASSEMBLY
+	__asm__ __volatile__("\tpush %%ebp\n\tcall *%%ebx\n\tpop %%ebp" /* FIXME */
+			     : "=&a" (new_cycles) 
+			     : "b" (cpufunctbl[opcode]), "0" (opcode)
+			     : "%edx", "%ecx", "%esi", "%edi", 
+			     "%ebp", "memory", "cc");
+#else
+	new_cycles = (*cpufunctbl[opcode])(opcode);
+#endif
+
+	new_cycles &= cycles_mask;
+	new_cycles |= cycles_val;
+	do_cycles (new_cycles);
+	
+	if (end_block(opcode) ||
+	    regs.spcflags) {
+	    return; /* We will deal with the spcflags in the caller */
+	}
+    }
+}
+
+
+void execute_normal (void)
+{
+    int blocklen;
+    cpu_history pc_hist[MAXRUN];
+    int new_cycles;
+    int total_cycles;
+
+    if (check_for_cache_miss())
+	return;
+    total_cycles=0;
+    blocklen=0;
+    start_pc_p=regs.pc_oldp;  
+    start_pc=regs.pc; 
+    for (;;) 
+    {    /* Take note: This is the do-it-normal loop */
+	uae_u16 opcode=get_iword(0);
+
+	special_mem = DISTRUST_CONSISTENT_MEM;
+	pc_hist[blocklen].location = (uae_u16*)regs.pc_p;
+	stop_compile = 0;
+#if defined X86_ASSEMBLY
+	__asm__ __volatile__("\tpush %%ebp\n\tcall *%%ebx\n\tpop %%ebp" /* FIXME */
+			     : "=&a" (new_cycles) 
+			     : "b" (cpufunctbl[opcode]), "0" (opcode)
+			     : "%edx", "%ecx", "%esi", "%edi", 
+			     "%ebp", "memory", "cc");
+#else
+	new_cycles = (*cpufunctbl[opcode])(opcode);
+#endif
+	new_cycles &= cycles_mask;
+	new_cycles |= cycles_val;
+	do_cycles (new_cycles);
+	total_cycles+=new_cycles;
+	pc_hist[blocklen].specmem=special_mem;
+	blocklen++;
+	if (stop_compile || end_block(opcode) || blocklen >= MAXRUN || regs.spcflags) {
+	    compile_block(pc_hist,blocklen,total_cycles);
+	    return; /* We will deal with the spcflags in the caller */
+	}
+	/* No need to check regs.spcflags, because if they were set,
+	   we'd have ended up inside that "if" */
+    }
+}
+
+typedef void compiled_handler(void);
+
+static void m68k_run_2a (void)
+{
+    for (;;) {  
+#if defined X86_ASSEMBLY 
+	__asm__ __volatile__(
+	    "\tpush %%ebp\n\tcall *%0\n\tpop %%ebp"  /* FIXME */
+	    :: "m" (cache_tags[cacheline(regs.pc_p)].handler) 
+	    : "%edx", "%ecx", "%eax",
+	    "%esi", "%ebx", "%edi", "%ebp", "memory", "cc");
+#else
+	((compiled_handler*)(pushall_call_handler))();
+#endif
+	/* Whenever we return from that, we should check spcflags */
+	if (regs.spcflags) {
+	    if (do_specialties ()) {
+		return;
+	    }
+	}
+    }
+}
+#endif
+
 /* Same thing, but don't use prefetch to get opcode.  */
 static void m68k_run_2 (void)
 {
@@ -1364,7 +1532,7 @@ static void m68k_run_2 (void)
 	instrcount[opcode]++;
 #endif
 #if defined X86_ASSEMBLY
-	__asm__ __volatile__("\tcall *%%ebx"
+	__asm__ __volatile__("\tpush %%ebp\n\tcall *%%ebx\n\tpop %%ebp" /* FIXME */
 			     : "=&a" (cycles) : "b" (cpufunctbl[opcode]), "0" (opcode)
 			     : "%edx", "%ecx",
 			     "%esi", "%edi", "%ebp", "memory", "cc");
@@ -1430,7 +1598,12 @@ void m68k_go (int may_quit)
 
 	if (debugging)
 	    debug ();
+#ifndef JIT
 	m68k_run1 (currprefs.cpu_compatible ? m68k_run_1 : m68k_run_2);
+#else
+	m68k_run1 (currprefs.cpu_compatible ? m68k_run_1 : 
+		   currprefs.cpu_level>=2 ? m68k_run_2a : m68k_run_2);
+#endif
     }
     in_m68k_go--;
 }
@@ -1525,6 +1698,8 @@ void m68k_disasm (FILE *f, uaecptr addr,
 void m68k_dumpstate (FILE *f, uaecptr *nextpc)
 {
     int i;
+    uae_u32 fpsr;
+
     for (i = 0; i < 8; i++){
 	fprintf (f, "D%d: %08lx ", i, m68k_dreg(regs, i));
 	if ((i & 3) == 3) fprintf (f, "\n");
@@ -1545,11 +1720,12 @@ void m68k_dumpstate (FILE *f, uaecptr *n
 	fprintf (f, "FP%d: %g ", i, regs.fp[i]);
 	if ((i & 3) == 3) fprintf (f, "\n");
     }
+    fpsr=get_fpsr();
     fprintf (f, "N=%d Z=%d I=%d NAN=%d\n",
-	     (regs.fpsr & 0x8000000) != 0,
-	     (regs.fpsr & 0x4000000) != 0,
-	     (regs.fpsr & 0x2000000) != 0,
-	     (regs.fpsr & 0x1000000) != 0);
+	     (fpsr & 0x8000000) != 0,
+	     (fpsr & 0x4000000) != 0,
+	     (fpsr & 0x2000000) != 0,
+	     (fpsr & 0x1000000) != 0);
     if (currprefs.cpu_compatible)
 	fprintf (f, "prefetch %08lx\n", (unsigned long)do_get_mem_long(&regs.prefetch));
 
@@ -1654,3 +1830,55 @@ uae_u8 *save_cpu (int *len)
     *len = dst - dstbak;
     return dstbak;
 }
+
+extern int segvcount;
+extern int soft_flush_count;
+extern int hard_flush_count;
+extern int compile_count;
+extern int checksum_count;
+extern int inhibit_frame;
+
+void newcpu_showstate(void)
+{
+    static time_t oldtime=0;
+    static int line=0;
+    time_t newtime=time(NULL);
+    
+    /* return; */
+#if defined JIT 
+
+    if (!line) {
+	fprintf(stderr,"compiled segv soft hard trans check  lost   debug1   debug2   debug3   debug4\n");
+	line++;
+    }
+    if (oldtime && newtime!=oldtime+1) {
+	printf("Time difference was %d seconds, should be 1\n",(int)(newtime-oldtime));
+	line++;
+    }
+    oldtime=newtime;
+
+    fprintf(stderr,"%8lu %4d %4d %4d %5d %5d %5.3f",get_jitted_size(),segvcount,soft_flush_count,hard_flush_count,compile_count,checksum_count,(double)gonebad/15625*8);
+    /*    fprintf(stderr," %8d %8lu %8lu %8lu",oink,foink3,foink2,foink);*/
+    if (!inhibit_frame) {
+	fprintf(stderr," NAT");
+    }
+    fprintf(stderr,"\n");
+    oink=0; 
+    /*    foink3=foink2=foink=0;*/
+    checksum_count=soft_flush_count=hard_flush_count=compile_count=0;
+    gonebad=0;
+    line++;
+    if (line==25)
+	line=0;
+#endif
+}
+
+/* Putting this here should stop the compiler from trying to work out
+   (wrongly!) what we *really* mean ;-) 
+*/
+
+long int diff32(frame_time_t x, frame_time_t y)
+{
+    return (long int)(x-y);
+}
+
Index: src/picasso96.c
===================================================================
RCS file: /usr/local/cvs/uae/src/picasso96.c,v
retrieving revision 1.29
retrieving revision 1.29.2.1
diff -c -p -d -u -p -r1.29 -r1.29.2.1
--- src/picasso96.c	2002/01/31 14:09:52	1.29
+++ src/picasso96.c	2002/02/06 15:09:19	1.29.2.1
@@ -39,10 +39,15 @@
 #include "uae.h"
 #include "memory.h"
 #include "custom.h"
+#include "events.h"
 #include "newcpu.h"
 #include "xwin.h"
 #include "picasso96.h"
 
+int have_done_picasso=0; /* For the JIT compiler */
+int picasso_is_special=PIC_WRITE; /* ditto */
+int picasso_is_special_read=PIC_READ; /* ditto */
+
 #ifdef PICASSO96
 
 /* #define P96TRACING_ENABLED */
@@ -248,6 +253,7 @@ static int CopyRenderInfoStructureA2U (u
     uaecptr memp = get_long (amigamemptr + PSSO_RenderInfo_Memory);
 
     if (valid_address (memp, PSSO_RenderInfo_sizeof)) {
+	ri->AMemory=memp;
 	ri->Memory = get_real_address (memp);
 	ri->BytesPerRow = get_word (amigamemptr + PSSO_RenderInfo_BytesPerRow);
 	ri->RGBFormat = get_long (amigamemptr + PSSO_RenderInfo_RGBFormat);
@@ -696,6 +702,8 @@ void picasso_refresh (void)
     if (!picasso_on)
 	return;
 
+    have_done_picasso=1;
+    
     /* Make sure that the first time we show a Picasso video mode, we don't blit any crap.
      * We can do this by checking if we have an Address yet.  */
     if (picasso96_state.Address) {
@@ -923,6 +931,10 @@ uae_u32 picasso_SetSwitch (void)
 #if 0
     write_log ("SetSwitch() - trying to show %s screen\n", flag ? "picasso96" : "amiga");
 #endif
+
+    flush_icache(5);  /* Changing the screen mode might make gfx memory
+			 directly accessible, or no longer thus accessible */
+
     /* Put old switch-state in D0 */
     return !flag;
 }
@@ -2239,6 +2251,8 @@ static void write_gfx_long (uaecptr addr
 
     addr += gfxmem_start;
     /* Check to see if this needs to be written through to the display, or was it an "offscreen" area? */
+    /* Shouldn't the "+4" be on the *first* addr, rather than the second?
+       and be a "+3" at  that? */
     if (addr < picasso96_state.Address || addr + 4 > picasso96_state.Extent)
 	return;
 
@@ -2335,6 +2349,8 @@ static void write_gfx_byte (uaecptr addr
 static uae_u32 REGPARAM2 gfxmem_lget (uaecptr addr)
 {
     uae_u32 *m;
+
+    special_mem|=picasso_is_special_read;  
     addr -= gfxmem_start & gfxmem_mask;
     addr &= gfxmem_mask;
     m = (uae_u32 *) (gfxmemory + addr);
@@ -2344,6 +2360,8 @@ static uae_u32 REGPARAM2 gfxmem_lget (ua
 static uae_u32 REGPARAM2 gfxmem_wget (uaecptr addr)
 {
     uae_u16 *m;
+
+    special_mem|=picasso_is_special_read;  
     addr -= gfxmem_start & gfxmem_mask;
     addr &= gfxmem_mask;
     m = (uae_u16 *) (gfxmemory + addr);
@@ -2352,6 +2370,7 @@ static uae_u32 REGPARAM2 gfxmem_wget (ua
 
 static uae_u32 REGPARAM2 gfxmem_bget (uaecptr addr)
 {
+    special_mem|=picasso_is_special_read;  
     addr -= gfxmem_start & gfxmem_mask;
     addr &= gfxmem_mask;
     return gfxmemory[addr];
@@ -2360,6 +2379,8 @@ static uae_u32 REGPARAM2 gfxmem_bget (ua
 static void REGPARAM2 gfxmem_lput (uaecptr addr, uae_u32 l)
 {
     uae_u32 *m;
+
+    special_mem|=picasso_is_special; 
     addr -= gfxmem_start & gfxmem_mask;
     addr &= gfxmem_mask;
     m = (uae_u32 *) (gfxmemory + addr);
@@ -2372,6 +2393,7 @@ static void REGPARAM2 gfxmem_lput (uaecp
 static void REGPARAM2 gfxmem_wput (uaecptr addr, uae_u32 w)
 {
     uae_u16 *m;
+    special_mem|=picasso_is_special; 
     addr -= gfxmem_start & gfxmem_mask;
     addr &= gfxmem_mask;
     m = (uae_u16 *) (gfxmemory + addr);
@@ -2383,6 +2405,7 @@ static void REGPARAM2 gfxmem_wput (uaecp
 
 static void REGPARAM2 gfxmem_bput (uaecptr addr, uae_u32 b)
 {
+    special_mem|=picasso_is_special; 
     addr -= gfxmem_start & gfxmem_mask;
     addr &= gfxmem_mask;
     gfxmemory[addr] = b;
Index: src/uaeexe.c
===================================================================
RCS file: /usr/local/cvs/uae/src/uaeexe.c,v
retrieving revision 1.3
retrieving revision 1.3.2.1
diff -c -p -d -u -p -r1.3 -r1.3.2.1
--- src/uaeexe.c	2000/08/25 21:29:42	1.3
+++ src/uaeexe.c	2002/02/06 15:09:19	1.3.2.1
@@ -12,6 +12,7 @@
 #include "uae.h"
 #include "memory.h"
 #include "custom.h"
+#include "events.h"
 #include "newcpu.h"
 #include "autoconf.h"
 #include "uaeexe.h"
Index: src/uaelib.c
===================================================================
RCS file: /usr/local/cvs/uae/src/uaelib.c,v
retrieving revision 1.27
retrieving revision 1.27.2.1
diff -c -p -d -u -p -r1.27 -r1.27.2.1
--- src/uaelib.c	2001/12/30 15:15:56	1.27
+++ src/uaelib.c	2002/02/06 15:09:19	1.27.2.1
@@ -20,6 +20,7 @@
 #include "uae.h"
 #include "include/memory.h"
 #include "custom.h"
+#include "events.h"
 #include "newcpu.h"
 #include "xwin.h"
 #include "autoconf.h"
Index: src/include/autoconf.h
===================================================================
RCS file: /usr/local/cvs/uae/src/include/autoconf.h,v
retrieving revision 1.25
retrieving revision 1.25.2.1
diff -c -p -d -u -p -r1.25 -r1.25.2.1
--- src/include/autoconf.h	2001/12/30 15:15:57	1.25
+++ src/include/autoconf.h	2002/02/06 15:09:19	1.25.2.1
@@ -77,6 +77,8 @@ extern void emulib_install (void);
 extern void expansion_init (void);
 extern void expansion_cleanup (void);
 
+extern uae_u8* rtarea;
+
 #define TRAPFLAG_NO_REGSAVE 1
 #define TRAPFLAG_NO_RETVAL 2
 #define TRAPFLAG_EXTRA_STACK 4
Index: src/include/compemu.h
===================================================================
RCS file: compemu.h
diff -N compemu.h
--- /dev/null	Tue Oct  2 20:51:52 2001
+++ src/include/compemu.h	Sat Feb 16 20:08:35 2002
@@ -0,0 +1,530 @@
+#define USE_OPTIMIZER 0
+#define USE_LOW_OPTIMIZER 0
+#define USE_ALIAS 1
+#define USE_F_ALIAS 1
+#define USE_SOFT_FLUSH 1
+#define USE_OFFSET 1
+#define COMP_DEBUG 1
+
+#if COMP_DEBUG
+#define Dif(x) if (x)
+#else
+#define Dif(x) if (0)
+#endif
+
+#define SCALE 2
+#define MAXCYCLES (1000 * CYCLE_UNIT)
+#define MAXREGOPT 65536
+
+#define BYTES_PER_INST 10240  /* paranoid ;-) */
+#define LONGEST_68K_INST 16 /* The number of bytes the longest possible
+			       68k instruction takes */
+#define MAX_CHECKSUM_LEN 2048 /* The maximum size we calculate checksums
+				 for. Anything larger will be flushed
+				 unconditionally even with SOFT_FLUSH */
+#define MAX_HOLD_BI 3  /* One for the current block, and up to two
+			  for jump targets */
+
+#define INDIVIDUAL_INST 0
+#define FLAG_C    0x0010
+#define FLAG_V    0x0008
+#define FLAG_Z    0x0004
+#define FLAG_N    0x0002
+#define FLAG_X    0x0001
+#define FLAG_CZNV (FLAG_C | FLAG_Z | FLAG_N | FLAG_V)
+#define FLAG_ZNV  (FLAG_Z | FLAG_N | FLAG_V)
+
+#define KILLTHERAT 1  /* Set to 1 to avoid some partial_rat_stalls */
+
+/* Whether to preserve registers across calls to JIT compiled routines */
+#if defined X86_ASSEMBLY
+#define USE_PUSH_POP 0
+#else
+#define USE_PUSH_POP 1
+#endif
+
+#define N_REGS 8  /* really only 7, but they are numbered 0,1,2,3,5,6,7 */
+#define N_FREGS 6 /* That leaves us two positions on the stack to play with */
+
+/* Functions exposed to newcpu, or to what was moved from newcpu.c to
+ * compemu_support.c */
+extern void init_comp(void);
+extern void flush(int save_regs);
+extern void small_flush(int save_regs);
+extern void set_target(uae_u8* t);
+extern uae_u8* get_target(void);
+extern void freescratch(void);
+extern void build_comp(void);
+extern void set_cache_state(int enabled);
+extern int get_cache_state(void);
+extern uae_u32 get_jitted_size(void);
+#ifdef JIT
+extern void flush_icache(int n);
+#endif
+extern void alloc_cache(void);
+extern void compile_block(cpu_history* pc_hist, int blocklen, int totcyles);
+extern void lopt_emit_all(void);
+extern int check_for_cache_miss(void);
+
+
+#define scaled_cycles(x) (currprefs.m68k_speed==-1?(((x)/SCALE)?(((x)/SCALE<MAXCYCLES?((x)/SCALE):MAXCYCLES)):1):(x))
+
+
+extern uae_u32 needed_flags;
+extern cacheline cache_tags[];
+extern uae_u8* comp_pc_p;
+extern void* pushall_call_handler;
+
+#define VREGS 32
+#define VFREGS 16
+
+#define INMEM 1
+#define CLEAN 2
+#define DIRTY 3
+#define UNDEF 4
+#define ISCONST 5
+
+typedef struct {
+  uae_u32* mem;
+  uae_u32 val;
+  uae_u8 is_swapped;
+  uae_u8 status;
+  uae_u8 realreg;
+  uae_u8 realind; /* The index in the holds[] array */
+  uae_u8 needflush;
+  uae_u8 validsize;
+  uae_u8 dirtysize;
+  uae_u8 dummy;
+} reg_status;
+
+typedef struct {
+  uae_u32* mem;
+  double val;
+  uae_u8 status;
+  uae_u8 realreg;
+  uae_u8 realind;  
+  uae_u8 needflush;
+} freg_status;
+
+typedef struct {
+    uae_u8 use_flags;
+    uae_u8 set_flags;
+    uae_u8 is_jump;
+    uae_u8 is_addx;
+    uae_u8 is_const_jump;
+} op_properties;
+extern op_properties prop[65536];
+
+static __inline__ int end_block(uae_u16 opcode)
+{
+    return prop[opcode].is_jump ||
+	(prop[opcode].is_const_jump && !currprefs.comp_constjump);
+}
+
+#define PC_P 16
+#define FLAGX 17
+#define FLAGTMP 18
+#define NEXT_HANDLER 19
+#define S1 20
+#define S2 21
+#define S3 22
+#define S4 23
+#define S5 24
+#define S6 25
+#define S7 26
+#define S8 27
+#define S9 28
+#define S10 29
+#define S11 30
+#define S12 31
+
+#define FP_RESULT 8
+#define FS1 9
+#define FS2 10
+#define FS3 11
+
+typedef struct {
+  uae_u32 touched;
+  uae_s8 holds[VREGS];
+  uae_u8 nholds;
+  uae_u8 canbyte;
+  uae_u8 canword;
+  uae_u8 locked;
+} n_status;
+
+typedef struct {
+    uae_s8 holds;
+    uae_u8 validsize;
+    uae_u8 dirtysize;
+} n_smallstatus;
+
+typedef struct {
+  uae_u32 touched;
+  uae_s8 holds[VFREGS];
+  uae_u8 nholds;
+  uae_u8 locked;
+} fn_status;
+
+/* For flag handling */
+#define NADA 1
+#define TRASH 2
+#define VALID 3
+
+/* needflush values */
+#define NF_SCRATCH   0
+#define NF_TOMEM     1
+#define NF_HANDLER   2
+
+typedef struct {
+    /* Integer part */
+    reg_status state[VREGS];
+    n_status   nat[N_REGS];
+    uae_u32 flags_on_stack;
+    uae_u32 flags_in_flags;
+    uae_u32 flags_are_important;
+    /* FPU part */
+    freg_status fate[VFREGS];
+    fn_status   fat[N_FREGS];
+
+    /* x86 FPU part */
+    uae_s8 spos[N_FREGS];
+    uae_s8 onstack[6];
+    uae_s8 tos;
+} bigstate;
+
+typedef struct {
+    /* Integer part */
+    n_smallstatus  nat[N_REGS];
+} smallstate;
+
+extern bigstate live;
+extern int touchcnt;
+
+
+#define IMM uae_u32
+#define R1  uae_u32
+#define R2  uae_u32
+#define R4  uae_u32
+#define W1  uae_u32
+#define W2  uae_u32
+#define W4  uae_u32
+#define RW1 uae_u32
+#define RW2 uae_u32
+#define RW4 uae_u32
+#define MEMR uae_u32
+#define MEMW uae_u32
+#define MEMRW uae_u32
+
+#define FW   uae_u32
+#define FR   uae_u32
+#define FRW  uae_u32
+
+#define MIDFUNC(nargs,func,args) void func args
+#define MENDFUNC(nargs,func,args) 
+#define COMPCALL(func) func
+
+#define LOWFUNC(flags,mem,nargs,func,args) static __inline__ void func args
+#define LENDFUNC(flags,mem,nargs,func,args) 
+
+#if USE_OPTIMIZER
+#define REGALLOC_O 2
+#define PEEPHOLE_O 3 /* Has to be >= REGALLOC */
+#define DECLARE(func) extern void func; extern void do_##func
+#else
+#define REGALLOC_O 2000000
+#define PEEPHOLE_O 2000000
+#define DECLARE(func) extern void func
+#endif
+
+
+/* What we expose to the outside */
+DECLARE(bt_l_ri(R4 r, IMM i));
+DECLARE(bt_l_rr(R4 r, R4 b));
+DECLARE(btc_l_ri(RW4 r, IMM i));
+DECLARE(btc_l_rr(RW4 r, R4 b));
+DECLARE(bts_l_ri(RW4 r, IMM i));
+DECLARE(bts_l_rr(RW4 r, R4 b));
+DECLARE(btr_l_ri(RW4 r, IMM i));
+DECLARE(btr_l_rr(RW4 r, R4 b));
+DECLARE(mov_l_rm(W4 d, IMM s));
+DECLARE(call_r(R4 r));
+DECLARE(sub_l_mi(IMM d, IMM s));
+DECLARE(mov_l_mi(IMM d, IMM s));
+DECLARE(mov_w_mi(IMM d, IMM s));
+DECLARE(mov_b_mi(IMM d, IMM s));
+DECLARE(rol_b_ri(RW1 r, IMM i));
+DECLARE(rol_w_ri(RW2 r, IMM i));
+DECLARE(rol_l_ri(RW4 r, IMM i));
+DECLARE(rol_l_rr(RW4 d, R1 r));
+DECLARE(rol_w_rr(RW2 d, R1 r));
+DECLARE(rol_b_rr(RW1 d, R1 r));
+DECLARE(shll_l_rr(RW4 d, R1 r));
+DECLARE(shll_w_rr(RW2 d, R1 r));
+DECLARE(shll_b_rr(RW1 d, R1 r));
+DECLARE(ror_b_ri(R1 r, IMM i));
+DECLARE(ror_w_ri(R2 r, IMM i));
+DECLARE(ror_l_ri(R4 r, IMM i));
+DECLARE(ror_l_rr(R4 d, R1 r));
+DECLARE(ror_w_rr(R2 d, R1 r));
+DECLARE(ror_b_rr(R1 d, R1 r));
+DECLARE(shrl_l_rr(RW4 d, R1 r));
+DECLARE(shrl_w_rr(RW2 d, R1 r));
+DECLARE(shrl_b_rr(RW1 d, R1 r));
+DECLARE(shra_l_rr(RW4 d, R1 r));
+DECLARE(shra_w_rr(RW2 d, R1 r));
+DECLARE(shra_b_rr(RW1 d, R1 r));
+DECLARE(shll_l_ri(RW4 r, IMM i));
+DECLARE(shll_w_ri(RW2 r, IMM i));
+DECLARE(shll_b_ri(RW1 r, IMM i));
+DECLARE(shrl_l_ri(RW4 r, IMM i));
+DECLARE(shrl_w_ri(RW2 r, IMM i));
+DECLARE(shrl_b_ri(RW1 r, IMM i));
+DECLARE(shra_l_ri(RW4 r, IMM i));
+DECLARE(shra_w_ri(RW2 r, IMM i));
+DECLARE(shra_b_ri(RW1 r, IMM i));
+DECLARE(setcc(W1 d, IMM cc));
+DECLARE(setcc_m(IMM d, IMM cc));
+DECLARE(cmov_l_rr(RW4 d, R4 s, IMM cc));
+DECLARE(cmov_l_rm(RW4 d, IMM s, IMM cc));
+DECLARE(bsf_l_rr(W4 d, R4 s));
+DECLARE(pop_m(IMM d));
+DECLARE(push_m(IMM d));
+DECLARE(pop_l(W4 d));
+DECLARE(push_l_i(IMM i));
+DECLARE(push_l(R4 s));
+DECLARE(clear_16(RW4 r));
+DECLARE(clear_8(RW4 r));
+DECLARE(sign_extend_16_rr(W4 d, R2 s));
+DECLARE(sign_extend_8_rr(W4 d, R1 s));
+DECLARE(zero_extend_16_rr(W4 d, R2 s));
+DECLARE(zero_extend_8_rr(W4 d, R1 s));
+DECLARE(imul_64_32(RW4 d, RW4 s));
+DECLARE(mul_64_32(RW4 d, RW4 s));
+DECLARE(imul_32_32(RW4 d, R4 s));
+DECLARE(mul_32_32(RW4 d, R4 s));
+DECLARE(mov_b_rr(W1 d, R1 s));
+DECLARE(mov_w_rr(W2 d, R2 s));
+DECLARE(mov_l_rrm_indexed(W4 d,R4 baser, R4 index, IMM factor));
+DECLARE(mov_w_rrm_indexed(W2 d, R4 baser, R4 index, IMM factor));
+DECLARE(mov_b_rrm_indexed(W1 d, R4 baser, R4 index, IMM factor));
+DECLARE(mov_l_mrr_indexed(R4 baser, R4 index, IMM factor, R4 s));
+DECLARE(mov_w_mrr_indexed(R4 baser, R4 index, IMM factor, R2 s));
+DECLARE(mov_b_mrr_indexed(R4 baser, R4 index, IMM factor, R1 s));
+DECLARE(mov_l_bmrr_indexed(IMM base, R4 baser, R4 index, IMM factor, R4 s));
+DECLARE(mov_w_bmrr_indexed(IMM base, R4 baser, R4 index, IMM factor, R2 s));
+DECLARE(mov_b_bmrr_indexed(IMM base, R4 baser, R4 index, IMM factor, R1 s));
+DECLARE(mov_l_brrm_indexed(W4 d, IMM base, R4 baser, R4 index, IMM factor));
+DECLARE(mov_w_brrm_indexed(W2 d, IMM base, R4 baser, R4 index, IMM factor));
+DECLARE(mov_b_brrm_indexed(W1 d, IMM base, R4 baser, R4 index, IMM factor));
+DECLARE(mov_l_rm_indexed(W4 d, IMM base, R4 index, IMM factor));
+DECLARE(mov_l_rR(W4 d, R4 s, IMM offset));
+DECLARE(mov_w_rR(W2 d, R4 s, IMM offset));
+DECLARE(mov_b_rR(W1 d, R4 s, IMM offset));
+DECLARE(mov_l_rR_gs(W4 d, R4 s, IMM offset));
+DECLARE(mov_w_rR_gs(W2 d, R4 s, IMM offset));
+DECLARE(mov_b_rR_gs(W1 d, R4 s, IMM offset));
+DECLARE(mov_l_brR(W4 d, R4 s, IMM offset));
+DECLARE(mov_w_brR(W2 d, R4 s, IMM offset));
+DECLARE(mov_b_brR(W1 d, R4 s, IMM offset));
+DECLARE(mov_l_Rr_gs(R4 d, R4 s, IMM offset));
+DECLARE(mov_w_Rr_gs(R4 d, R2 s, IMM offset));
+DECLARE(mov_b_Rr_gs(R4 d, R1 s, IMM offset));
+DECLARE(mov_l_Rr(R4 d, R4 s, IMM offset));
+DECLARE(mov_w_Rr(R4 d, R2 s, IMM offset));
+DECLARE(mov_b_Rr(R4 d, R1 s, IMM offset));
+DECLARE(lea_l_brr(W4 d, R4 s, IMM offset));
+DECLARE(lea_l_brr_indexed(W4 d, R4 s, R4 index, IMM factor, IMM offset));
+DECLARE(lea_l_rr_indexed(W4 d, R4 s, R4 index, IMM factor));
+DECLARE(mov_l_bRr(R4 d, R4 s, IMM offset));
+DECLARE(mov_w_bRr(R4 d, R2 s, IMM offset));
+DECLARE(mov_b_bRr(R4 d, R1 s, IMM offset));
+DECLARE(bswap_32(RW4 r));
+DECLARE(bswap_16(RW2 r));
+DECLARE(mov_l_rr(W4 d, R4 s));
+DECLARE(mov_l_mr(IMM d, R4 s));
+DECLARE(mov_w_mr(IMM d, R2 s));
+DECLARE(mov_w_rm(W2 d, IMM s));
+DECLARE(mov_b_mr(IMM d, R1 s));
+DECLARE(mov_b_rm(W1 d, IMM s));
+DECLARE(mov_l_ri(W4 d, IMM s));
+DECLARE(mov_w_ri(W2 d, IMM s));
+DECLARE(mov_b_ri(W1 d, IMM s));
+DECLARE(add_l_mi(IMM d, IMM s) );
+DECLARE(add_w_mi(IMM d, IMM s) );
+DECLARE(add_b_mi(IMM d, IMM s) );
+DECLARE(test_l_ri(R4 d, IMM i));
+DECLARE(test_l_rr(R4 d, R4 s));
+DECLARE(test_w_rr(R2 d, R2 s));
+DECLARE(test_b_rr(R1 d, R1 s));
+DECLARE(and_l_ri(RW4 d, IMM i));
+DECLARE(and_l(RW4 d, R4 s));
+DECLARE(and_w(RW2 d, R2 s));
+DECLARE(and_b(RW1 d, R1 s));
+DECLARE(or_l_ri(RW4 d, IMM i));
+DECLARE(or_l(RW4 d, R4 s));
+DECLARE(or_w(RW2 d, R2 s));
+DECLARE(or_b(RW1 d, R1 s));
+DECLARE(adc_l(RW4 d, R4 s));
+DECLARE(adc_w(RW2 d, R2 s));
+DECLARE(adc_b(RW1 d, R1 s));
+DECLARE(add_l(RW4 d, R4 s));
+DECLARE(add_w(RW2 d, R2 s));
+DECLARE(add_b(RW1 d, R1 s));
+DECLARE(sub_l_ri(RW4 d, IMM i));
+DECLARE(sub_w_ri(RW2 d, IMM i));
+DECLARE(sub_b_ri(RW1 d, IMM i));
+DECLARE(add_l_ri(RW4 d, IMM i));
+DECLARE(add_w_ri(RW2 d, IMM i));
+DECLARE(add_b_ri(RW1 d, IMM i));
+DECLARE(sbb_l(RW4 d, R4 s));
+DECLARE(sbb_w(RW2 d, R2 s));
+DECLARE(sbb_b(RW1 d, R1 s));
+DECLARE(sub_l(RW4 d, R4 s));
+DECLARE(sub_w(RW2 d, R2 s));
+DECLARE(sub_b(RW1 d, R1 s));
+DECLARE(cmp_l(R4 d, R4 s));
+DECLARE(cmp_l_ri(R4 r, IMM i));
+DECLARE(cmp_w(R2 d, R2 s));
+DECLARE(cmp_b(R1 d, R1 s));
+DECLARE(xor_l(RW4 d, R4 s));
+DECLARE(xor_w(RW2 d, R2 s));
+DECLARE(xor_b(RW1 d, R1 s));
+DECLARE(live_flags(void));
+DECLARE(dont_care_flags(void));
+DECLARE(duplicate_carry(void));
+DECLARE(restore_carry(void));
+DECLARE(start_needflags(void));
+DECLARE(end_needflags(void));
+DECLARE(make_flags_live(void));
+DECLARE(call_r_11(R4 r, W4 out1, R4 in1, IMM osize, IMM isize));
+DECLARE(call_r_02(R4 r, R4 in1, R4 in2, IMM isize1, IMM isize2));
+DECLARE(readmem_new(R4 address, W4 dest, IMM offset, IMM size, W4 tmp));
+DECLARE(writemem_new(R4 address, R4 source, IMM offset, IMM size, W4 tmp));
+DECLARE(forget_about(W4 r));
+DECLARE(nop(void));
+
+DECLARE(f_forget_about(FW r));
+DECLARE(fmov_pi(FW r));
+DECLARE(fmov_log10_2(FW r));
+DECLARE(fmov_log2_e(FW r));
+DECLARE(fmov_loge_2(FW r));
+DECLARE(fmov_1(FW r));
+DECLARE(fmov_0(FW r));
+DECLARE(fmov_rm(FW r, MEMR m));
+DECLARE(fmovi_rm(FW r, MEMR m));
+DECLARE(fmovi_mr(MEMW m, FR r));
+DECLARE(fmovs_rm(FW r, MEMR m));
+DECLARE(fmovs_mr(MEMW m, FR r));
+DECLARE(fmov_mr(MEMW m, FR r));
+DECLARE(fmov_ext_mr(MEMW m, FR r));
+DECLARE(fmov_ext_rm(FW r, MEMR m));
+DECLARE(fmov_rr(FW d, FR s));
+DECLARE(fldcw_m_indexed(R4 index, IMM base));
+DECLARE(ftst_r(FR r));
+DECLARE(dont_care_fflags(void));
+DECLARE(fsqrt_rr(FW d, FR s));
+DECLARE(fabs_rr(FW d, FR s));
+DECLARE(frndint_rr(FW d, FR s));
+DECLARE(fsin_rr(FW d, FR s));
+DECLARE(fcos_rr(FW d, FR s));
+DECLARE(ftwotox_rr(FW d, FR s));
+DECLARE(fetox_rr(FW d, FR s));
+DECLARE(flog2_rr(FW d, FR s));
+DECLARE(fneg_rr(FW d, FR s));
+DECLARE(fadd_rr(FRW d, FR s));
+DECLARE(fsub_rr(FRW d, FR s));
+DECLARE(fmul_rr(FRW d, FR s));
+DECLARE(frem_rr(FRW d, FR s));
+DECLARE(frem1_rr(FRW d, FR s));
+DECLARE(fdiv_rr(FRW d, FR s));
+DECLARE(fcmp_rr(FR d, FR s));
+DECLARE(fflags_into_flags(W2 tmp));
+
+extern int failure;
+#define FAIL(x) do { failure|=x; } while (0)
+
+/* Convenience functions exposed to gencomp */
+extern uae_u32 m68k_pc_offset;
+extern void readbyte(int address, int dest, int tmp);
+extern void readword(int address, int dest, int tmp);
+extern void readlong(int address, int dest, int tmp);
+extern void writebyte(int address, int source, int tmp);
+extern void writeword(int address, int source, int tmp);
+extern void writelong(int address, int source, int tmp);
+extern void writeword_clobber(int address, int source, int tmp);
+extern void writelong_clobber(int address, int source, int tmp);
+extern void get_n_addr(int address, int dest, int tmp);
+extern void get_n_addr_jmp(int address, int dest, int tmp);
+extern void calc_disp_ea_020(int base, uae_u32 dp, int target, int tmp);
+extern int kill_rodent(int r);
+extern void sync_m68k_pc(void);
+extern uae_u32 get_const(int r);
+extern int  is_const(int r);
+extern void register_branch(uae_u32 not_taken, uae_u32 taken, uae_u8 cond);
+extern void empty_optimizer(void);
+
+#define comp_get_ibyte(o) do_get_mem_byte((uae_u8 *)(comp_pc_p + (o) + 1))
+#define comp_get_iword(o) do_get_mem_word((uae_u16 *)(comp_pc_p + (o)))
+#define comp_get_ilong(o) do_get_mem_long((uae_u32 *)(comp_pc_p + (o)))
+
+/* Preferences handling */
+void check_prefs_changed_comp (void);
+
+struct blockinfo_t;
+
+typedef struct dep_t {
+  uae_u32*            jmp_off;
+  struct blockinfo_t* target;
+  struct dep_t**      prev_p;
+  struct dep_t*       next;
+} dependency;
+
+typedef struct blockinfo_t {
+    uae_s32 count;
+    cpuop_func* direct_handler_to_use;
+    cpuop_func* handler_to_use;
+    /* The direct handler does not check for the correct address */
+
+    cpuop_func* handler; 
+    cpuop_func* direct_handler;
+
+    cpuop_func* direct_pen;
+    cpuop_func* direct_pcc;
+
+    uae_u8* nexthandler;
+    uae_u8* pc_p;
+    
+    uae_u32 c1;     
+    uae_u32 c2;
+    uae_u32 len;
+
+    struct blockinfo_t* next_same_cl;
+    struct blockinfo_t** prev_same_cl_p;  
+    struct blockinfo_t* next;
+    struct blockinfo_t** prev_p; 
+
+    uae_u32 min_pcp; 
+    uae_u8 optlevel;  
+    uae_u8 needed_flags;  
+    uae_u8 status;  
+    uae_u8 havestate;
+    
+    dependency  dep[2];  /* Holds things we depend on */
+    dependency* deplist; /* List of things that depend on this */
+    smallstate  env;
+} blockinfo;
+
+#define BI_NEW 0
+#define BI_COUNTING 1
+#define BI_TARGETTED 2
+
+typedef struct {
+    uae_u8 type;
+    uae_u8 reg;
+    uae_u32 next;
+} regacc;
+
+void execute_normal(void);
+void exec_nostats(void);
+void do_nothing(void);
+
Index: src/include/custom.h
===================================================================
RCS file: /usr/local/cvs/uae/src/include/custom.h,v
retrieving revision 1.39
retrieving revision 1.39.2.1
diff -c -p -d -u -p -r1.39 -r1.39.2.1
--- src/include/custom.h	2001/10/24 10:59:20	1.39
+++ src/include/custom.h	2002/02/06 15:09:19	1.39.2.1
@@ -61,6 +61,7 @@ STATIC_INLINE int dmaen (unsigned int dm
 #define SPCFLAG_BLTNASTY 512
 #define SPCFLAG_EXEC 1024
 #define SPCFLAG_MODE_CHANGE 8192
+#define SPCFLAG_END_COMPILE 16384
 
 extern uae_u16 adkcon;
 
Index: src/include/events.h
===================================================================
RCS file: /usr/local/cvs/uae/src/include/events.h,v
retrieving revision 1.23
retrieving revision 1.23.2.2
diff -c -p -d -u -p -r1.23 -r1.23.2.2
--- src/include/events.h	2001/07/29 09:47:03	1.23
+++ src/include/events.h	2002/02/16 19:53:29	1.23.2.2
@@ -1,3 +1,5 @@
+#ifndef EVENTS_H
+#define EVENTS_H
  /*
   * UAE - The Un*x Amiga Emulator
   *
@@ -11,12 +13,13 @@
 
 #include "machdep/rpt.h"
 
-extern frame_time_t vsynctime, vsyncmintime;
+extern unsigned long currcycle, nextevent, is_lastline;
+extern unsigned long sample_evtime;
+
+extern volatile frame_time_t vsynctime, vsyncmintime;
 extern void reset_frame_rate_hack (void);
 extern int rpt_available;
 
-extern unsigned long currcycle, nextevent, is_lastline;
-extern unsigned long sample_evtime;
 typedef void (*evfunc)(void);
 
 struct ev
@@ -33,12 +36,19 @@ enum {
 
 extern struct ev eventtab[ev_max];
 
+extern void init_eventtab (void);
+
+#if 1
+
+/* Let's see whether hiding this away somewhere where the compiler can't
+   see it will cure it of its silly urge to mis-optimize the comparison */ extern long int diff32(frame_time_t x, frame_time_t y);
+
 STATIC_INLINE void events_schedule (void)
 {
     int i;
 
     unsigned long int mintime = ~0L;
-    for (i = 0; i < ev_max; i++) {
+    for(i = 0; i < ev_max; i++) {
 	if (eventtab[i].active) {
 	    unsigned long int eventtime = eventtab[i].evtime - currcycle;
 	    if (eventtime < mintime)
@@ -48,12 +58,42 @@ STATIC_INLINE void events_schedule (void
     nextevent = currcycle + mintime;
 }
 
-STATIC_INLINE void do_cycles_slow (unsigned long cycles_to_add)
+extern signed long pissoff;
+
+STATIC_INLINE void cycles_do_special (void)
 {
-    if (is_lastline && eventtab[ev_hsync].evtime - currcycle <= cycles_to_add
-	&& (long int)(read_processor_time () - vsyncmintime) < 0)
+    if (pissoff >= 0)
+	pissoff = -1;
+}
+
+STATIC_INLINE void do_extra_cycles (unsigned long cycles_to_add) {
+    pissoff -= cycles_to_add;
+}
+
+STATIC_INLINE unsigned long int get_cycles (void)
+{
+    return currcycle;
+}
+
+STATIC_INLINE void set_cycles (unsigned long int x)
+{
+    currcycle = x;
+}
+
+STATIC_INLINE void do_cycles_slow (unsigned long cycles_to_add) {
+    if ((pissoff -= cycles_to_add) >= 0)
 	return;
 
+    cycles_to_add = -pissoff;
+    pissoff = 0;
+
+    if (is_lastline && eventtab[ev_hsync].evtime-currcycle <= cycles_to_add) {
+	frame_time_t now=read_processor_time ();
+	if (diff32(now, vsyncmintime) < 0) {
+	    pissoff = 3000 * CYCLE_UNIT;
+	    return;
+	}
+    }
     while ((nextevent - currcycle) <= cycles_to_add) {
         int i;
         cycles_to_add -= (nextevent - currcycle);
@@ -66,35 +106,118 @@ STATIC_INLINE void do_cycles_slow (unsig
 	}
         events_schedule();
     }
+
     currcycle += cycles_to_add;
 }
 
-STATIC_INLINE void do_cycles_fast (void)
+#define do_cycles do_cycles_slow
+#define countdown pissoff
+
+#else
+
+/* Let's see whether hiding this away somewhere where the compiler can't
+   see it will cure it of its silly urge to mis-optimize the comparison */ extern long int diff32(frame_time_t x, frame_time_t y);
+
+extern long cycles_to_next_event;
+extern long max_cycles_to_next_event;
+extern long cycles_to_hsync_event;
+extern long pissoff;
+
+STATIC_INLINE void cycles_do_special(void)
 {
-    if (is_lastline && eventtab[ev_hsync].evtime - currcycle <= 1
-	&& (long int)(read_processor_time () - vsyncmintime) < 0)
+    if (cycles_to_next_event >= 0) {
+	pissoff += cycles_to_next_event;
+	cycles_to_next_event = 0;
+    }
+}
+
+
+STATIC_INLINE void do_extra_cycles (unsigned long cycles_to_add) {
+    pissoff -= cycles_to_add;
+}
+
+STATIC_INLINE unsigned long int get_cycles (void)
+{
+    if (cycles_to_next_event <= max_cycles_to_next_event) {
+	max_cycles_to_next_event = cycles_to_next_event;
+	return nextevent - cycles_to_next_event;
+    } else {
+	return nextevent - max_cycles_to_next_event;
+    }
+}
+
+STATIC_INLINE void events_schedule (void)
+{
+    int i;
+
+    unsigned long int curcycles = get_cycles();
+    unsigned long int mintime = ~0L;
+
+    cycles_to_hsync_event=eventtab[ev_hsync].evtime - curcycles;
+    for (i = 0; i < ev_max; i++) {
+	if (eventtab[i].active) {
+	    unsigned long int eventtime = eventtab[i].evtime - curcycles;
+	    if (eventtime < mintime) 
+		mintime = eventtime;
+	}
+    }
+    nextevent = curcycles + mintime;
+    max_cycles_to_next_event = mintime;
+    cycles_to_next_event = mintime;
+    cycles_to_hsync_event = mintime - cycles_to_hsync_event;
+}
+
+STATIC_INLINE void set_cycles (unsigned long int x)
+{
+    cycles_to_next_event = nextevent - x;
+    events_schedule ();
+}
+
+STATIC_INLINE void do_cycles_slow (long cycles_to_add)
+{
+    cycles_to_next_event -= cycles_to_add;
+    if (cycles_to_next_event > 0)
 	return;
 
-    currcycle++;
-    if (nextevent == currcycle) {
+    cycles_to_next_event += pissoff;
+    pissoff=0;
+
+    if (is_lastline
+	&& /*cycles_to_next_event <= cycles_to_hsync_event*/
+	eventtab[ev_hsync].evtime == nextevent) 
+    {
+	frame_time_t now=read_processor_time();
+	if (diff32(now, vsyncmintime)<0)
+	{
+	    cycles_to_next_event += 3000 * CYCLE_UNIT;
+	    return;
+	}
+    }
+    cycles_to_add=0;
+    while (cycles_to_next_event <= cycles_to_add) {
 	int i;
 
+	cycles_to_add-=cycles_to_next_event;
+	cycles_to_next_event=0;
 	for (i = 0; i < ev_max; i++) {
-	    if (eventtab[i].active && eventtab[i].evtime == currcycle) {
+	    if (eventtab[i].active && eventtab[i].evtime == nextevent) {
 		(*eventtab[i].handler) ();
 	    }
 	}
 	events_schedule();
     }
-
+    cycles_to_next_event -= cycles_to_add;
 }
 
+#define do_cycles do_cycles_slow
+#define countdown cycles_to_next_event
+
+#endif
+
 /* This is a special-case function.  Normally, all events should lie in the
    future; they should only ever be active at the current cycle during
    do_cycles.  However, a snapshot is saved during do_cycles, and so when
-   restoring it, we may have other events pending.  */
-STATIC_INLINE void handle_active_events (void)
-{
+   restoring it, we may have other events pending.  */ STATIC_INLINE void handle_active_events (void) {
     int i;
     for (i = 0; i < ev_max; i++) {
 	if (eventtab[i].active && eventtab[i].evtime == currcycle) {
@@ -103,15 +226,4 @@ STATIC_INLINE void handle_active_events 
     }
 }
 
-STATIC_INLINE unsigned long get_cycles (void)
-{
-    return currcycle;
-}
-
-extern void init_eventtab (void);
-
-#if /* M68K_SPEED == 1 */  0
-#define do_cycles do_cycles_fast
-#else
-#define do_cycles do_cycles_slow
 #endif
Index: src/include/newcpu.h
===================================================================
RCS file: /usr/local/cvs/uae/src/include/newcpu.h,v
retrieving revision 1.36
retrieving revision 1.36.2.2
diff -c -p -d -u -p -r1.36 -r1.36.2.2
--- src/include/newcpu.h	2001/12/17 18:38:38	1.36
+++ src/include/newcpu.h	2002/02/10 11:32:24	1.36.2.2
@@ -51,7 +51,7 @@ typedef unsigned long cpuop_func (uae_u3
 struct cputbl {
     cpuop_func *handler;
     int specific;
-    uae_u16 opcode;
+    uae_u32 opcode;
 };
 
 extern unsigned long op_illg (uae_u32) REGPARAM;
@@ -101,9 +101,32 @@ extern struct regstruct
     uae_u32 prefetch;
 } regs, lastint_regs;
 
+typedef struct {
+  uae_u16* location;
+  uae_u8  cycles;
+  uae_u8  specmem;
+  uae_u8  dummy2;
+  uae_u8  dummy3;
+} cpu_history;
+
+struct blockinfo_t;
+
+typedef union {
+    cpuop_func* handler;
+    struct blockinfo_t* bi;
+} cacheline;
+
+extern signed long pissoff;
+
+STATIC_INLINE uae_u32 munge24(uae_u32 x)
+{
+    return currprefs.address_space_24?(x&0x00ffffff):x;
+}
+
 STATIC_INLINE void set_special (uae_u32 x)
 {
     regs.spcflags |= x;
+    cycles_do_special();
 }
 
 STATIC_INLINE void unset_special (uae_u32 x)
@@ -117,6 +140,7 @@ STATIC_INLINE void unset_special (uae_u3
 #if !defined USE_COMPILER
 STATIC_INLINE void m68k_setpc (uaecptr newpc)
 {
+    newpc &= ~1;
     regs.pc_p = regs.pc_oldp = get_real_address (newpc);
     regs.pc = newpc;
 }
@@ -242,7 +266,7 @@ STATIC_INLINE void m68k_setstopped (int 
     /* A traced STOP instruction drops through immediately without
        actually stopping.  */
     if (stop && (regs.spcflags & SPCFLAG_DOTRACE) == 0)
-	regs.spcflags |= SPCFLAG_STOP;
+	set_special (SPCFLAG_STOP);
 }
 
 extern uae_u32 get_disp_ea_020 (uae_u32 base, uae_u32 dp);
@@ -297,6 +321,20 @@ extern struct cputbl op_smalltbl_4_ff[];
 extern struct cputbl op_smalltbl_5_ff[];
 
 extern cpuop_func *cpufunctbl[65536] ASM_SYM_FOR_FUNC ("cpufunctbl");
+
+  
+/* Flags for Bernie during development/debugging. Should go away eventually */
+#define DISTRUST_CONSISTENT_MEM 0
+#define TAGMASK 0x000fffff
+#define TAGSIZE (TAGMASK+1)
+#define MAXRUN 1024
+
+extern uae_u8* start_pc_p;
+extern uae_u32 start_pc;
+
+#define cacheline(x) (((uae_u32)x)&TAGMASK)
+
+void newcpu_showstate(void);
 
 #ifdef JIT
 #else
Index: src/include/noflags.h
===================================================================
RCS file: noflags.h
diff -N noflags.h
--- /dev/null	Tue Oct  2 20:51:52 2001
+++ src/include/noflags.h	Sat Feb 16 20:08:35 2002
@@ -0,0 +1,177 @@
+#ifndef NOFLAGS_H
+#define NOFLAGS_H
+
+/* Undefine everything that will *set* flags. Note: Leave *reading*
+   flags alone ;-). We assume that nobody does something like 
+   SET_ZFLG(a=b+c), i.e. expect side effects of the macros. That would 
+   be a stupid thing to do when using macros.
+*/
+
+/* Gwenole Beauchesne pointed out that CAS and CAS2 use flag_cmp to set
+   flags that are then used internally, and that thus the noflags versions
+   of those instructions were broken. Oops! 
+   Easy fix: Leave flag_cmp alone. It is only used by CMP* and CAS* 
+   instructions. For CAS*, noflags is a bad idea. For CMP*, which has
+   setting flags as its only function, the noflags version is kinda pointless,
+   anyway. 
+   Note that this will only work while using the optflag_* routines ---
+   as we do on all (one ;-) platforms that will ever use the noflags
+   versions, anyway.
+   However, if you try to compile without optimized flags, the "SET_ZFLAG"
+   macro will be left unchanged, to make CAS and CAS2 work right. Of course,
+   this is contrary to the whole idea of noflags, but better be right than
+   be fast.
+
+   Another problem exists with one of the bitfield operations. Once again,
+   one of the operations sets a flag, and looks at it later. And the CHK2
+   instruction does so as well. For those, a different solution is possible.
+   the *_ALWAYS versions of the SET_?FLG macros shall remain untouched by 
+   the redefinitions in this file.
+   Unfortunately, they are defined in terms of the macros we *do* redefine.
+   So here comes a bit of trickery....
+*/
+#define NOFLAGS_CMP 0
+
+#undef SET_NFLG_ALWAYS
+static __inline__ void SET_NFLG_ALWAYS(uae_u32 x)
+{
+    SET_NFLG(x);  /* This has not yet been redefined */
+}
+
+#undef SET_CFLG_ALWAYS
+static __inline__ void SET_CFLG_ALWAYS(uae_u32 x)
+{
+    SET_CFLG(x);  /* This has not yet been redefined */
+}
+
+#undef CPUFUNC
+#define CPUFUNC(x) x##_nf
+
+#ifndef OPTIMIZED_FLAGS
+#undef SET_ZFLG
+#define SET_ZFLG(y) do {uae_u32 dummy=(y); } while (0)
+#endif
+
+#undef SET_CFLG
+#define SET_CFLG(y) do {uae_u32 dummy=(y); } while (0)
+#undef SET_VFLG
+#define SET_VFLG(y) do {uae_u32 dummy=(y); } while (0)
+#undef SET_NFLG
+#define SET_NFLG(y) do {uae_u32 dummy=(y); } while (0)
+#undef SET_XFLG
+#define SET_XFLG(y) do {uae_u32 dummy=(y); } while (0)
+
+#undef CLEAR_CZNV
+#define CLEAR_CZNV
+#undef IOR_CZNV
+#define IOR_CZNV(y) do {uae_u32 dummy=(y); } while (0)
+#undef SET_CZNV
+#define SET_CZNV(y) do {uae_u32 dummy=(y); } while (0)
+#undef COPY_CARRY
+#define COPY_CARRY 
+
+#ifdef  optflag_testl
+#undef  optflag_testl
+#endif
+
+#ifdef  optflag_testw
+#undef  optflag_testw
+#endif
+
+#ifdef  optflag_testb
+#undef  optflag_testb
+#endif
+
+#ifdef  optflag_addl
+#undef  optflag_addl
+#endif
+
+#ifdef  optflag_addw
+#undef  optflag_addw
+#endif
+
+#ifdef  optflag_addb
+#undef  optflag_addb
+#endif
+
+#ifdef  optflag_subl
+#undef  optflag_subl
+#endif
+
+#ifdef  optflag_subw
+#undef  optflag_subw
+#endif
+
+#ifdef  optflag_subb
+#undef  optflag_subb
+#endif
+
+#if NOFLAGS_CMP
+#ifdef  optflag_cmpl
+#undef  optflag_cmpl
+#endif
+
+#ifdef  optflag_cmpw
+#undef  optflag_cmpw
+#endif
+
+#ifdef  optflag_cmpb
+#undef  optflag_cmpb
+#endif
+#endif
+
+
+#define optflag_testl(v) \
+do { } while(0)
+
+#define optflag_testw(v) \
+do { } while(0)
+
+#define optflag_testb(v) \
+do { } while(0)
+
+#define optflag_addl(v, s, d) do { \
+  __asm__ __volatile__ ("addl %k1,%k0\n\t" \
+			: "=r" (v) : "rmi" (s), "0" (d) : "cc"); \
+    } while (0)
+#define optflag_addw(v, s, d) do { \
+  __asm__ __volatile__ ("addw %w1,%w0\n\t" \
+			: "=r" (v) : "rmi" (s), "0" (d) : "cc"); \
+    } while (0)
+
+#define optflag_addb(v, s, d) do { \
+  __asm__ __volatile__ ("addb %b1,%b0\n\t" \
+			: "=q" (v) : "qmi" (s), "0" (d) : "cc"); \
+    } while (0)
+
+#define optflag_subl(v, s, d) do { \
+  __asm__ __volatile__ ("subl %k1,%k0\n\t" \
+			: "=r" (v) : "rmi" (s), "0" (d) : "cc"); \
+    } while (0)
+
+#define optflag_subw(v, s, d) do { \
+  __asm__ __volatile__ ("subw %w1,%w0\n\t" \
+			: "=r" (v) : "rmi" (s), "0" (d) : "cc"); \
+    } while (0)
+
+#define optflag_subb(v, s, d) do { \
+  __asm__ __volatile__ ("subb %b1,%b0\n\t" \
+			: "=q" (v) : "qmi" (s), "0" (d) : "cc"); \
+    } while (0)
+
+#if NOFLAGS_CMP
+/* These are just for completeness sake */
+#define optflag_cmpl(s, d) \
+do {  __asm__ __volatile__ ("cmpl %k0,%k1\n\t" \
+			:: "rmi" (s), "r" (d) : "cc"); } while(0)
+
+#define optflag_cmpw(s, d) \
+do {  __asm__ __volatile__ ("cmpw %w0,%w1\n\t" \
+			:: "rmi" (s), "r" (d) : "cc");  } while(0)
+
+#define optflag_cmpb(s, d) \
+do {  __asm__ __volatile__ ("cmpb %b0,%b1\n\t" \
+			:: "qmi" (s), "q" (d) : "cc"); } while(0)
+#endif
+
+#endif
Index: src/include/options.h
===================================================================
RCS file: /usr/local/cvs/uae/src/include/options.h,v
retrieving revision 1.89
retrieving revision 1.87.2.2
diff -c -p -d -u -p -r1.89 -r1.87.2.2
--- src/include/options.h	2002/02/16 19:27:08	1.89
+++ src/include/options.h	2002/02/16 20:06:59	1.87.2.2
@@ -57,6 +57,28 @@ struct uae_prefs {
     int sound_pri_cutoff;
     int sound_interpol;
 
+    int comptrustbyte;
+    int comptrustword;
+    int comptrustlong;
+    int comptrustnaddr;
+    int compnf;
+    int compforcesettings;
+    int compfpu;
+    int comp_midopt;
+    int comp_lowopt;
+
+    int comp_hardflush;
+    int comp_constjump;
+    int comp_oldsegv;
+
+    int cachesize;
+    int optcount[10];
+
+    int avoid_cmov;
+    int avoid_dga;
+    int avoid_vid;
+    uae_u32 override_dga_address;
+
     int gfx_framerate;
     int gfx_width;
     int gfx_height;
@@ -80,6 +102,7 @@ struct uae_prefs {
     char romfile[256];
     char romextfile[256];
     char keyfile[256];
+    char pci_devices[256];
     char prtname[256];
     char sername[256];
 
Index: src/include/picasso96.h
===================================================================
RCS file: /usr/local/cvs/uae/src/include/picasso96.h,v
retrieving revision 1.13
retrieving revision 1.13.2.1
diff -c -p -d -u -p -r1.13 -r1.13.2.1
--- src/include/picasso96.h	2001/11/25 12:41:51	1.13
+++ src/include/picasso96.h	2002/02/06 15:09:19	1.13.2.1
@@ -10,6 +10,11 @@
 
 #define PICASSO96
 
+
+/* Seems the same routines copy back and forth ;-) */
+#define PIC_READ (S_READ|S_WRITE)
+#define PIC_WRITE (S_READ|S_WRITE)
+
 #define JAM1 0
 #define JAM2 1
 #define COMP 2
@@ -282,6 +287,7 @@ struct RenderInfo {
     uae_s16 BytesPerRow;
     uae_s16 pad;
     RGBFTYPE RGBFormat;
+    uaecptr AMemory;
 };
 
 #define PSSO_Pattern_Memory 0
@@ -554,5 +560,17 @@ extern void gfx_unlock_picasso (void);
 extern int picasso_display_mode_index (uae_u32 x, uae_u32 y, uae_u32 d);
 extern int picasso_nr_resolutions (void);
 extern void picasso_clip_mouse (int *, int *);
+
+extern int NDX_InvertRect(struct RenderInfo* ri, unsigned long X, unsigned long Y, unsigned long Width, unsigned long Height, uae_u32 mask, int Bpp);
+extern int NDX_BlitPattern(struct RenderInfo* ri,struct Pattern* pat,unsigned long X, unsigned long Y, unsigned long W, unsigned long H, uae_u8 Mask, uae_u32 RGBFmt);
+extern int NDX_BlitTemplate(struct RenderInfo* ri, struct Template* tmp, unsigned long X, unsigned long Y, unsigned long W, unsigned long H, uae_u16 Mask);
+extern int NDX_BlitPlanar2Chunky(struct RenderInfo* ri, struct BitMap* bm, unsigned long srcx, unsigned long srcy, unsigned long dstx, unsigned long dsty, unsigned long width, unsigned long height, uae_u8 minterm, uae_u8 mask);
+extern int NDX_BlitPlanar2Direct(struct RenderInfo* ri, struct BitMap* bm, unsigned long srcx, unsigned long srcy, unsigned long dstx, unsigned long dsty, unsigned long width, unsigned long height, uae_u8 minterm, uae_u8 Mask);
+extern int NDX_FillRect(struct RenderInfo* ri, unsigned long X, unsigned long Y, unsigned long Width, unsigned long Height, uae_u32 Pen, uae_u8 Mask, uae_u32 RGBFormat);
+extern int NDX_BlitRect(struct RenderInfo* ri, unsigned long srcx, unsigned long srcy, unsigned long dstx, unsigned long dsty, unsigned long width, unsigned long height, uae_u8 Mask);
+extern int NDX_BlitRectNoMaskComplete(struct RenderInfo* sri,struct RenderInfo* dri, unsigned long srcx, unsigned long srcy, unsigned long dstx, unsigned long dsty, unsigned long width, unsigned long height, uae_u8 OpCode, uae_u32 RGBFmt);
+
+extern int picasso_is_special;
+extern int picasso_is_special_read;
 
 #endif
Index: src/include/sysdeps.h
===================================================================
RCS file: /usr/local/cvs/uae/src/include/sysdeps.h,v
retrieving revision 1.32
retrieving revision 1.32.2.1
diff -c -p -d -u -p -r1.32 -r1.32.2.1
--- src/include/sysdeps.h	2001/11/19 17:58:46	1.32
+++ src/include/sysdeps.h	2002/02/06 15:09:19	1.32.2.1
@@ -235,7 +235,7 @@ extern void *xcalloc(size_t, size_t);
 /* While we're here, make abort more useful.  */
 #define abort() \
   do { \
-    write_log ("Internal error; file %s, line %d\n", __FILE__, __LINE__); \
+    fprintf (stderr, "Internal error; file %s, line %d\n", __FILE__, __LINE__); \
     (abort) (); \
 } while (0)
 #else
Index: src/md-i386-gcc/m68k.h
===================================================================
RCS file: /usr/local/cvs/uae/src/md-i386-gcc/m68k.h,v
retrieving revision 1.6
retrieving revision 1.6.2.1
diff -c -p -d -u -p -r1.6 -r1.6.2.1
--- src/md-i386-gcc/m68k.h	2000/08/15 22:21:41	1.6
+++ src/md-i386-gcc/m68k.h	2002/02/06 15:09:19	1.6.2.1
@@ -1,3 +1,6 @@
+#ifndef M68K_H
+#define M68K_H
+
  /* 
   * UAE - The Un*x Amiga Emulator
   * 
@@ -32,19 +35,19 @@ struct flag_struct {
     unsigned int x;
 };
 
-#define FLAGVAL_Z 0x40
-#define FLAGVAL_N 0x80
+#define FLAGVAL_Z 0x4000
+#define FLAGVAL_N 0x8000
 
-#define SET_ZFLG(y) (regflags.cznv = (regflags.cznv & ~0x40) | (((y) & 1) << 6))
-#define SET_CFLG(y) (regflags.cznv = (regflags.cznv & ~1) | ((y) & 1))
-#define SET_VFLG(y) (regflags.cznv = (regflags.cznv & ~0x800) | (((y) & 1) << 11))
-#define SET_NFLG(y) (regflags.cznv = (regflags.cznv & ~0x80) | (((y) & 1) << 7))
+#define SET_ZFLG(y) (regflags.cznv = (regflags.cznv & ~0x4000) | (((y) & 1) << 14))
+#define SET_CFLG(y) (regflags.cznv = (regflags.cznv & ~0x100) | (((y) & 1) << 8))
+#define SET_VFLG(y) (regflags.cznv = (regflags.cznv & ~0x1) | (((y) & 1)))
+#define SET_NFLG(y) (regflags.cznv = (regflags.cznv & ~0x8000) | (((y) & 1) << 15))
 #define SET_XFLG(y) (regflags.x = (y))
 
-#define GET_ZFLG ((regflags.cznv >> 6) & 1)
-#define GET_CFLG (regflags.cznv & 1)
-#define GET_VFLG ((regflags.cznv >> 11) & 1)
-#define GET_NFLG ((regflags.cznv >> 7) & 1)
+#define GET_ZFLG ((regflags.cznv >> 14) & 1)
+#define GET_CFLG ((regflags.cznv >> 8) & 1)
+#define GET_VFLG ((regflags.cznv >> 0) & 1)
+#define GET_NFLG ((regflags.cznv >> 15) & 1)
 #define GET_XFLG (regflags.x & 1)
 
 #define CLEAR_CZNV (regflags.cznv = 0)
@@ -52,7 +55,7 @@ struct flag_struct {
 #define IOR_CZNV(X) (regflags.cznv |= (X))
 #define SET_CZNV(X) (regflags.cznv = (X))
 
-#define COPY_CARRY (regflags.x = regflags.cznv)
+#define COPY_CARRY (regflags.x = (regflags.cznv)>>8)
 
 
 #endif
@@ -65,109 +68,139 @@ static __inline__ int cctrue(int cc)
     switch(cc){
      case 0: return 1;                       /* T */
      case 1: return 0;                       /* F */
-     case 2: return (cznv & 0x41) == 0; /* !GET_CFLG && !GET_ZFLG;  HI */
-     case 3: return (cznv & 0x41) != 0; /* GET_CFLG || GET_ZFLG;    LS */
-     case 4: return (cznv & 1) == 0;        /* !GET_CFLG;               CC */
-     case 5: return (cznv & 1) != 0;           /* GET_CFLG;                CS */
-     case 6: return (cznv & 0x40) == 0; /* !GET_ZFLG;               NE */
-     case 7: return (cznv & 0x40) != 0; /* GET_ZFLG;                EQ */
-     case 8: return (cznv & 0x800) == 0;/* !GET_VFLG;               VC */
-     case 9: return (cznv & 0x800) != 0;/* GET_VFLG;                VS */
-     case 10:return (cznv & 0x80) == 0; /* !GET_NFLG;               PL */
-     case 11:return (cznv & 0x80) != 0; /* GET_NFLG;                MI */
-     case 12:return (((cznv << 4) ^ cznv) & 0x800) == 0; /* GET_NFLG == GET_VFLG;             GE */
-     case 13:return (((cznv << 4) ^ cznv) & 0x800) != 0;/* GET_NFLG != GET_VFLG;             LT */
+     case 2: return (cznv & 0x4100) == 0; /* !GET_CFLG && !GET_ZFLG;  HI */
+     case 3: return (cznv & 0x4100) != 0; /* GET_CFLG || GET_ZFLG;    LS */
+     case 4: return (cznv & 0x100) == 0;  /* !GET_CFLG;               CC */
+     case 5: return (cznv & 0x100) != 0;  /* GET_CFLG;                CS */
+     case 6: return (cznv & 0x4000) == 0; /* !GET_ZFLG;               NE */
+     case 7: return (cznv & 0x4000) != 0; /* GET_ZFLG;                EQ */
+     case 8: return (cznv & 0x01) == 0;   /* !GET_VFLG;               VC */
+     case 9: return (cznv & 0x01) != 0;   /* GET_VFLG;                VS */
+     case 10:return (cznv & 0x8000) == 0; /* !GET_NFLG;               PL */
+     case 11:return (cznv & 0x8000) != 0; /* GET_NFLG;                MI */
+     case 12:return (((cznv << 15) ^ cznv) & 0x8000) == 0; /* GET_NFLG == GET_VFLG;             GE */
+     case 13:return (((cznv << 15) ^ cznv) & 0x8000) != 0;/* GET_NFLG != GET_VFLG;             LT */
      case 14:
-	cznv &= 0x8c0;
-	return (((cznv << 4) ^ cznv) & 0x840) == 0; /* !GET_ZFLG && (GET_NFLG == GET_VFLG);  GT */
+	cznv &= 0xc001;
+	return (((cznv << 15) ^ cznv) & 0xc000) == 0; /* !GET_ZFLG && (GET_NFLG == GET_VFLG);  GT */
      case 15:
-	cznv &= 0x8c0;
-	return (((cznv << 4) ^ cznv) & 0x840) != 0; /* GET_ZFLG || (GET_NFLG != GET_VFLG);   LE */
+	cznv &= 0xc001;
+	return (((cznv << 15) ^ cznv) & 0xc000) != 0; /* GET_ZFLG || (GET_NFLG != GET_VFLG);   LE */
     }
     abort();
     return 0;
 }
 
+/* Is there any way to do this without declaring *all* memory clobbered?
+   I.e. any way to tell gcc that some byte-sized value is in %al? */
 #define optflag_testl(v) \
-  __asm__ __volatile__ ("testl %1,%1\n\t" \
-			"pushfl\n\t" \
-			"popl %0\n\t" \
-			: "=r" (regflags.cznv) : "r" (v) : "cc")
-
+  __asm__ __volatile__ ("andl %0,%0\n\t" \
+			"lahf\n\t" \
+			"seto %%al\n\t" \
+                        "movb %%al,regflags\n\t" \
+			"movb %%ah,regflags+1\n\t" \
+			:: "r" (v) : "%eax","cc","memory")
 #define optflag_testw(v) \
-  __asm__ __volatile__ ("testw %w1,%w1\n\t" \
-			"pushfl\n\t" \
-			"popl %0\n\t" \
-			: "=r" (regflags.cznv) : "r" (v) : "cc")
+  __asm__ __volatile__ ("andw %w0,%w0\n\t" \
+			"lahf\n\t" \
+			"seto %%al\n\t" \
+                        "movb %%al,regflags\n\t" \
+			"movb %%ah,regflags+1\n\t" \
+			:: "r" (v) : "%eax","cc","memory")
 
 #define optflag_testb(v) \
-  __asm__ __volatile__ ("testb %b1,%b1\n\t" \
-			"pushfl\n\t" \
-			"popl %0\n\t" \
-			: "=r" (regflags.cznv) : "q" (v) : "cc")
+  __asm__ __volatile__ ("andb %b0,%b0\n\t" \
+			"lahf\n\t" \
+			"seto %%al\n\t" \
+                        "movb %%al,regflags\n\t" \
+			"movb %%ah,regflags+1\n\t" \
+			:: "q" (v) : "%eax","cc","memory")
 
 #define optflag_addl(v, s, d) do { \
-  __asm__ __volatile__ ("addl %k2,%k1\n\t" \
-			"pushfl\n\t" \
-			"popl %0\n\t" \
-			: "=r" (regflags.cznv), "=r" (v) : "rmi" (s), "1" (d) : "cc"); \
+  __asm__ __volatile__ ("addl %k1,%k0\n\t" \
+			"lahf\n\t" \
+			"seto %%al\n\t" \
+                        "movb %%al,regflags\n\t" \
+			"movb %%ah,regflags+1\n\t" \
+			:"=r" (v) : "rmi" (s), "0" (d) : "%eax","cc","memory"); \
     COPY_CARRY; \
     } while (0)
 #define optflag_addw(v, s, d) do { \
-  __asm__ __volatile__ ("addw %w2,%w1\n\t" \
-			"pushfl\n\t" \
-			"popl %0\n\t" \
-			: "=r" (regflags.cznv), "=r" (v) : "rmi" (s), "1" (d) : "cc"); \
+  __asm__ __volatile__ ("addw %w1,%w0\n\t" \
+			"lahf\n\t" \
+			"seto %%al\n\t" \
+                        "movb %%al,regflags\n\t" \
+			"movb %%ah,regflags+1\n\t" \
+			: "=r" (v) : "rmi" (s), "0" (d) : "%eax","cc","memory"); \
     COPY_CARRY; \
     } while (0)
 
 #define optflag_addb(v, s, d) do { \
-  __asm__ __volatile__ ("addb %b2,%b1\n\t" \
-			"pushfl\n\t" \
-			"popl %0\n\t" \
-			: "=r" (regflags.cznv), "=q" (v) : "qmi" (s), "1" (d) : "cc"); \
+  __asm__ __volatile__ ("addb %b1,%b0\n\t" \
+			"lahf\n\t" \
+			"seto %%al\n\t" \
+                        "movb %%al,regflags\n\t" \
+			"movb %%ah,regflags+1\n\t" \
+			:"=q" (v) : "qmi" (s), "0" (d) : "%eax","cc","memory"); \
     COPY_CARRY; \
     } while (0)
 
 #define optflag_subl(v, s, d) do { \
-  __asm__ __volatile__ ("subl %k2,%k1\n\t" \
-			"pushfl\n\t" \
-			"popl %0\n\t" \
-			: "=r" (regflags.cznv), "=r" (v) : "rmi" (s), "1" (d) : "cc"); \
+  __asm__ __volatile__ ("subl %k1,%k0\n\t" \
+			"lahf\n\t" \
+			"seto %%al\n\t" \
+                        "movb %%al,regflags\n\t" \
+			"movb %%ah,regflags+1\n\t" \
+			: "=r" (v) : "rmi" (s), "0" (d) : "%eax","cc","memory"); \
     COPY_CARRY; \
     } while (0)
 
 #define optflag_subw(v, s, d) do { \
-  __asm__ __volatile__ ("subw %w2,%w1\n\t" \
-			"pushfl\n\t" \
-			"popl %0\n\t" \
-			: "=r" (regflags.cznv), "=r" (v) : "rmi" (s), "1" (d) : "cc"); \
+  __asm__ __volatile__ ("subw %w1,%w0\n\t" \
+			"lahf\n\t" \
+			"seto %%al\n\t" \
+                        "movb %%al,regflags\n\t" \
+			"movb %%ah,regflags+1\n\t" \
+			: "=r" (v) : "rmi" (s), "0" (d) : "%eax","cc","memory"); \
     COPY_CARRY; \
     } while (0)
 
 #define optflag_subb(v, s, d) do { \
-  __asm__ __volatile__ ("subb %b2,%b1\n\t" \
-			"pushfl\n\t" \
-			"popl %0\n\t" \
-			: "=r" (regflags.cznv), "=q" (v) : "qmi" (s), "1" (d) : "cc"); \
+   __asm__ __volatile__ ("subb %b1,%b0\n\t" \
+			"lahf\n\t" \
+			"seto %%al\n\t" \
+                        "movb %%al,regflags\n\t" \
+			"movb %%ah,regflags+1\n\t" \
+			: "=q" (v) : "qmi" (s), "0" (d) : "%eax","cc","memory"); \
     COPY_CARRY; \
     } while (0)
 
 #define optflag_cmpl(s, d) \
-  __asm__ __volatile__ ("cmpl %k1,%k2\n\t" \
-			"pushfl\n\t" \
-			"popl %0\n\t" \
-			: "=r" (regflags.cznv) : "rmi" (s), "r" (d) : "cc")
+  __asm__ __volatile__ ("cmpl %k0,%k1\n\t" \
+			"lahf\n\t" \
+			"seto %%al\n\t" \
+                        "movb %%al,regflags\n\t" \
+			"movb %%ah,regflags+1\n\t" \
+			:: "rmi" (s), "r" (d) : "%eax","cc","memory")
 
 #define optflag_cmpw(s, d) \
-  __asm__ __volatile__ ("cmpw %w1,%w2\n\t" \
-			"pushfl\n\t" \
-			"popl %0\n\t" \
-			: "=r" (regflags.cznv) : "rmi" (s), "r" (d) : "cc")
+  __asm__ __volatile__ ("cmpw %w0,%w1\n\t" \
+			"lahf\n\t" \
+			"seto %%al\n\t" \
+                        "movb %%al,regflags\n\t" \
+			"movb %%ah,regflags+1\n\t" \
+			:: "rmi" (s), "r" (d) : "%eax","cc","memory");
 
 #define optflag_cmpb(s, d) \
-  __asm__ __volatile__ ("cmpb %b1,%b2\n\t" \
-			"pushfl\n\t" \
-			"popl %0\n\t" \
-			: "=r" (regflags.cznv) : "qmi" (s), "q" (d) : "cc")
+  __asm__ __volatile__ ("cmpb %b0,%b1\n\t" \
+			"lahf\n\t" \
+			"seto %%al\n\t" \
+                        "movb %%al,regflags\n\t" \
+			"movb %%ah,regflags+1\n\t" \
+			:: "qmi" (s), "q" (d) : "%eax","cc","memory")
+
+
+#endif
+
+
 
Index: src/od-amiga/ami-rexx.c
===================================================================
RCS file: /usr/local/cvs/uae/src/od-amiga/ami-rexx.c,v
retrieving revision 1.7
retrieving revision 1.7.2.1
diff -c -p -d -u -p -r1.7 -r1.7.2.1
--- src/od-amiga/ami-rexx.c	2001/09/07 11:44:24	1.7
+++ src/od-amiga/ami-rexx.c	2002/02/06 15:09:19	1.7.2.1
@@ -34,6 +34,7 @@
 
 #include <rexx/storage.h>
 #include <rexx/errors.h>
+#include "events.h"
 
 /* this prevent a conflict between <rexx/rexxio.h> and <sys/dirent.h> */
 #undef DT_DIR 
@@ -210,7 +211,7 @@ static int INSERT(char *line)
 static void QUIT(void)
 {
     broken_in = 1;
-    regs.spcflags |= SPCFLAG_BRK;
+    set_special(SPCFLAG_BRK);
     quit_program = 1;
 }
 
Index: src/od-macos/mac.c
===================================================================
RCS file: /usr/local/cvs/uae/src/od-macos/mac.c,v
retrieving revision 1.3
retrieving revision 1.3.2.1
diff -c -p -d -u -p -r1.3 -r1.3.2.1
--- src/od-macos/mac.c	2001/09/07 11:44:25	1.3
+++ src/od-macos/mac.c	2002/02/06 15:09:19	1.3.2.1
@@ -936,7 +936,7 @@ static void HandleMenu (long mSelect)
 				
 				case 13:
 					broken_in = 1;
-					regs.spcflags |= SPCFLAG_BRK;
+					set_special(SPCFLAG_BRK);
 					quit_program=1;
 				break;
 			}
Index: src/od-pOS/pos-rexx.c
===================================================================
RCS file: /usr/local/cvs/uae/src/od-pOS/pos-rexx.c,v
retrieving revision 1.2
retrieving revision 1.2.6.1
diff -c -p -d -u -p -r1.2 -r1.2.6.1
--- src/od-pOS/pos-rexx.c	1997/11/01 14:07:58	1.2
+++ src/od-pOS/pos-rexx.c	2002/02/06 15:09:19	1.2.6.1
@@ -6,6 +6,8 @@
   * Copyright 1997 Samuel Devulder.
   */
 
+#include "events.h"
+
 int  rexx_init(void);
 void rexx_exit(void);
 void rexx_led(int led, int on);
@@ -189,7 +191,7 @@ static int INSERT(char *line)
 static void QUIT(void)
 {
     broken_in = 1;
-    regs.spcflags |= SPCFLAG_BRK;
+    set_special(SPCFLAG_BRK);
     quit_program = 1;
 }
 
Index: src/od-win32/win32gui.c
===================================================================
RCS file: /usr/local/cvs/uae/src/od-win32/win32gui.c,v
retrieving revision 1.16
retrieving revision 1.16.2.1
diff -c -p -d -u -p -r1.16 -r1.16.2.1
--- src/od-win32/win32gui.c	2001/12/17 16:37:43	1.16
+++ src/od-win32/win32gui.c	2002/02/06 15:09:19	1.16.2.1
@@ -3014,7 +3014,7 @@ static BOOL CALLBACK HarddiskDlgProc (HW
 	    case PSN_RESET:
 		if (allow_quit) {
 		    quit_program = 1;
-		    regs.spcflags |= SPCFLAG_BRK;
+		    set_special(SPCFLAG_BRK);
 		}
 		break;
 	    }
@@ -3233,7 +3233,7 @@ static BOOL CALLBACK FloppyDlgProc (HWND
 	case PSN_RESET:
 	    if (allow_quit) {
 		quit_program = 1;
-		regs.spcflags |= SPCFLAG_BRK;
+		set_special(SPCFLAG_BRK);
 	    }
 	    break;
 	}
@@ -3603,7 +3603,7 @@ static BOOL CALLBACK PortsDlgProc (HWND 
 	case PSN_RESET:
 	    if (allow_quit) {
 		quit_program = 1;
-		regs.spcflags |= SPCFLAG_BRK;
+		set_special(SPCFLAG_BRK);
 	    }
 	    break;
 	}
Index: src/sd-uss/sound.h
===================================================================
RCS file: /usr/local/cvs/uae/src/sd-uss/sound.h,v
retrieving revision 1.1
retrieving revision 1.1.6.1
diff -c -p -d -u -p -r1.1 -r1.1.6.1
--- src/sd-uss/sound.h	1997/11/25 16:27:52	1.1
+++ src/sd-uss/sound.h	2002/02/06 15:09:19	1.1.6.1
@@ -13,8 +13,29 @@ extern int sndbufsize;
 
 static __inline__ void check_sound_buffers (void)
 {
-    if ((char *)sndbufpt - (char *)sndbuffer >= sndbufsize) {
-	write (sound_fd, sndbuffer, sndbufsize);
+    int delay;
+    
+    int size=(char *)sndbufpt - (char *)sndbuffer;
+    if (size >= sndbufsize) {
+#if 0
+	ioctl(sound_fd,SNDCTL_DSP_GETODELAY,&delay);
+	if (delay<sndbufsize*1+size) {
+	    /* We are still OK */
+	}
+	else {
+	    unsigned long long x=sndbufsize;
+	    x*=syncbase;
+	    x/=currprefs.sound_freq;
+	    x/=(currprefs.sound_bits/8);
+	    x/=(currprefs.stereo+1);
+	    x/=16;  
+	    /* Skip one 1/16 buffer worth of time. That's 6% we can slow
+	       things down --- that should be enough! */
+	    vsyncmintime+=x;
+	    // fprintf(stderr,"Adding %llu ticks in sound\n",x);
+	}
+#endif
+	write (sound_fd, sndbuffer, size);
 	sndbufpt = sndbuffer;
     }
 }
Index: src/tools/Makefile.in
===================================================================
RCS file: /usr/local/cvs/uae/src/tools/Makefile.in,v
retrieving revision 1.2
retrieving revision 1.2.2.1
diff -c -p -d -u -p -r1.2 -r1.2.2.1
--- src/tools/Makefile.in	2001/11/22 00:03:30	1.2
+++ src/tools/Makefile.in	2002/02/06 15:09:19	1.2.2.1
@@ -23,14 +23,14 @@ VPATH = @top_srcdir@
 
 INCLUDES=-I. -I@top_srcdir@/../include/ -I@top_srcdir@
 
-all: gencpu build68k genblitter cpuopti
+all: gencpu gencomp build68k genblitter cpuopti
 
 install:
 
 
 clean:
 	-rm -f *.o
-	-rm -f gencpu genblitter cpuopti build68k
+	-rm -f gencpu gencomp genblitter cpuopti build68k
 
 
 streifenfrei: clean
@@ -43,6 +43,8 @@ cpuopti: cpuopti.o writelog.o
 	$(CC) $(LDFLAGS) -o cpuopti cpuopti.o writelog.o
 gencpu: gencpu.o readcpu.o cpudefs.o missing.o writelog.o
 	$(CC) $(LDFLAGS) -o gencpu gencpu.o readcpu.o cpudefs.o missing.o writelog.o
+gencomp: gencomp.o readcpu.o cpudefs.o missing.o
+	$(CC) $(LDFLAGS) -o gencomp gencomp.o readcpu.o missing.o cpudefs.o
 
 custom.o: blit.h
 drawing.o: linetoscr.c
@@ -62,6 +64,8 @@ genblitter.o: @top_srcdir@/../genblitter
 	$(CC) $(INCLUDES) -c $(INCDIRS) $(CFLAGS) $(DEBUGFLAGS) @top_srcdir@/../genblitter.c -o $@
 gencpu.o: @top_srcdir@/../gencpu.c
 	$(CC) $(INCLUDES) -c $(INCDIRS) $(CFLAGS) $(DEBUGFLAGS) @top_srcdir@/../gencpu.c -o $@
+gencomp.o: @top_srcdir@/../gencomp.c
+	$(CC) $(INCLUDES) -c $(INCDIRS) $(CFLAGS) $(DEBUGFLAGS) @top_srcdir@/../gencomp.c -o $@
 build68k.o: @top_srcdir@/../build68k.c
 	$(CC) $(INCLUDES) -c $(INCDIRS) $(CFLAGS) $(DEBUGFLAGS) @top_srcdir@/../build68k.c -o $@
 blitops.o: @top_srcdir@/../blitops.c
